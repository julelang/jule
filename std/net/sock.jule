// Copyright 2024 The Jule Project Contributors. All rights reserved.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/comptime"
use "std/internal/poll"
use "std/mem"
use "std/sys"
use "std/time"

// Listens the address on the named network.
// It will forward any exceptional from network connectors.
//
// For UDP network, the [ListenUDP] function should be used.
// If the network parameter is points UDP network, function will panic.
//
// See the [Dial] function for a description of the network and addr parameters.
async fn Listen(network: Network, addr: str)!: Listener {
	match network {
	| TCP | TCP4 | TCP6:
		ret tcpBind(network, addr).await?
	|:
		error(&AddrError{Err: "invalid network: " + str(network)})
	}
}

// Listens the address on the named network.
// It will forward any exceptional from network connectors.
// Just for UDP networks.
//
// See the [Dial] function for a description of the network and addr parameters.
async fn ListenUDP(network: Network, addr: str)!: &UDPConn {
	ret udpBind(network, addr).await?
}

// Connects to the address on the named network.
// Network should be one of the fields of the Network enum.
// The addr parameter is should represent valid address according to network.
//
// For TCP:
//	The address has the form "host:port".
//	The host must be a literal IP address, or a host name that can be
//	resolved to IP addresses such as "localhost".
//	The port must be a literal port number or a service name.
//	If the host is a literal IPv6 address it must be enclosed in brackets,
//	as in "[2001:db8::1]:80" or "[fe80::1%zone]:80".
//	The zone specifies the scope of the literal IPv6 address as defined
//	in RFC 4007. The functions [JoinHostPort] and [SplitHostPort] manipulate
//	a pair of host and port in this form.
//
//	If network is Tcp4, it will accept only IPv4 addresses and if address is IPv6,
//	will try to convert IPv4. If network is Tcp6, it will accept only IPv6 address and
//	address is IPv4, will not try to convert IPv6. If network is Tcp, it will use Tcp4
//	for empty addresses and try for IPv4 if possible. If address is IPv4 or IPv6 which
//	is converted to IPv4 successfully, will use Tcp4, otherwise IPv6 and Tcp6 preferred.
//
// For UDP:
//	The address has the form "host:port".
//	The host must be a literal IP address, or a host name that can be
//	resolved to IP addresses such as "localhost".
//	The port must be a literal port number or a service name.
//	If the host is a literal IPv6 address it must be enclosed in brackets,
//	as in "[2001:db8::1]:80" or "[fe80::1%zone]:80".
//	The zone specifies the scope of the literal IPv6 address as defined
//	in RFC 4007. The functions [JoinHostPort] and [SplitHostPort] manipulate
//	a pair of host and port in this form.
//
//	If network is Udp4, it will accept only IPv4 addresses and if address is IPv6,
//	will try to convert IPv4. If network is Udp6, it will accept only IPv6 address and
//	address is IPv4, will not try to convert IPv6. If network is Udp, it will use Udp4
//	for empty addresses and try for IPv4 if possible. If address is IPv4 or IPv6 which
//	is converted to IPv4 successfully, will use Udp4, otherwise IPv6 and Udp6 preferred.
//
// It will forward any exceptional from network connectors.
async fn Dial(network: Network, addr: str)!: Conn {
	ret DialTimeout(network, addr, 0).await?
}

// Same as Dial, but uses timeout.
// For UDP networks, timeout will be ignored.
// Timeout precision is microseconds.
// If the timeout is below one microsecond it will be ignored.
async fn DialTimeout(network: Network, addr: str, timeout: time::Duration)!: Conn {
	match network {
	| TCP | TCP4 | TCP6:
		ret tcpDial(network, addr, timeout).await?
	| UDP | UDP4 | UDP6:
		ret udpDial(network, addr).await?
	|:
		error(&AddrError{Err: "invalid network: " + str(network)})
	}
}

fn getSocketAddr(handle: poll::NetHandle, addr: uintptr, len: sys::Socklen)! {
	sys::Getsockname(handle, addr, len)?
}

async fn socketipv4(remote: bool, sockaddr: uintptr, mut addr: addr, typ: int, timeout: time::Duration)!: &netFD {
	ret socket(remote, sockaddr, addr, sys::AF_INET, typ, timeout).await?
}

async fn socketipv6(remote: bool, sockaddr: uintptr, mut addr: addr, typ: int, timeout: time::Duration)!: &netFD {
	ret socket(remote, sockaddr, addr, sys::AF_INET6, typ, timeout).await?
}

async fn socket(remote: bool, sockaddr: uintptr, mut addr: addr, domain: int, typ: int, timeout: time::Duration)!: (fd: &netFD) {
	let mut proto: int
	match typ {
	| sys::SOCK_STREAM:
		proto = sys::IPPROTO_TCP
	| sys::SOCK_DGRAM:
		proto = sys::IPPROTO_UDP
	|:
		panic("unreachable")
	}
	sock := syssocket(domain, typ, proto)?
	match typ {
	| sys::SOCK_STREAM:
		fd = newFD(sock, poll::Socket, typ)
	| sys::SOCK_DGRAM:
		fd = newFD(sock, poll::SocketNoConn, typ)
	|:
		panic("unreachable")
	}
	port := htons(addr.port())
	let mut sockaddrlen: sys::Socklen
	let mut sockv: int
	match domain {
	| sys::AF_INET:
		sockv = 4
		mut &addr4 := unsafe { &(*(*sys::RawSockaddrInet4)(sockaddr)) }
		sockaddrlen = sys::Socklen(mem::SizeOf(*addr4))
		comptime::TypeAlias(DomainType, comptime::TypeOf(addr4.Family)) // Hack for platform specific compatibility.
		addr4.Family = DomainType(domain)
		addr4.Port = port
		ip := addr.ip().To4()
		copy(addr4.Addr[:], ip)
	| sys::AF_INET6:
		sockv = 6
		mut &addr6 := unsafe { &(*(*sys::RawSockaddrInet6)(sockaddr)) }
		sockaddrlen = sys::Socklen(mem::SizeOf(*addr6))
		comptime::TypeAlias(DomainType, comptime::TypeOf(addr6.Family)) // Hack for platform specific compatibility.
		addr6.Family = DomainType(domain)
		addr6.Port = port
		ip := addr.ip().To16()
		copy(addr6.Addr[:], ip)
	}
	setDefaultSockopts(sock) else {
		fd.Close().await else {}
		error(error)
	}
	if remote {
		// Initialize fd here because connect needs eventpoll for timeout.
		// Timeout is actually implemented like deadline but temporary.
		// It will be cleared before conect return.
		fd.init() else {
			fd.Close().await else {}
			error(error)
		}
		fd.connect(sockv, sockaddr, sockaddrlen, timeout).await else {
			fd.Close().await else {}
			error(error)
		}
	} else {
		sys::Bind(sock, sockaddr, sockaddrlen) else {
			fd.Close().await else {}
			error(error)
		}
		match typ {
		| sys::SOCK_STREAM:
			setDefaultListenerSockopts(sock) else {
				fd.Close().await else {}
				error(error)
			}
			backlog := listenerBacklog().await
			sys::Listen(sock, backlog) else {
				fd.Close().await else {}
				error(error)
			}
		| sys::SOCK_DGRAM:
			// No-op.
		|:
			panic("unreachable")
		}
		fd.init() else {
			fd.Close().await else {}
			error(error)
		}
	}
	ret fd
}
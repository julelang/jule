// Copyright 2024 The Jule Project Contributors. All rights reserved.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/internal/poll"
use "std/io"
use "std/runtime"
use "std/sys"
use "std/time"

// TCP connection.
// In most cases, represents TCP client.
struct TCPConn {
	mut fd: &netFD
	v6:     bool
	Addr:   &TCPAddr
}

impl Conn for TCPConn {}
impl io::Reader for TCPConn {}
impl io::Writer for TCPConn {}
impl io::ReadWriteCloser for TCPConn {}
impl io::WriteCloser for TCPConn {}

impl TCPConn {
	// Read bytes to buffer from connection and returns read byte count.
	// The number of bytes read can never exceed the length of the buffer.
	// If the buffer is larger than the number of bytes that can be read,
	// the buffer will not cause an overflow.
	// It will panic if connection is closed.
	// If connection is closed by server, it returns zero and sets connection
	// state as closed. So if you try read again, function will panic because of
	// connection state is closed.
	async fn Read(mut *self, mut buf: []byte)!: int {
		if self.fd == nil {
			panic("net: TCPConn.Read: connection is closed")
		}
		if len(buf) == 0 {
			ret 0
		}
		n := self.fd.Read(buf).await?
		if n == io::EOF {
			self.Close().await!
		}
		ret n
	}

	// Writes bytes to connection and returns written byte count.
	// The number of bytes written can never exceed the length of the buffer.
	async fn Write(mut *self, buf: []byte)!: int {
		if self.fd == nil {
			panic("net: TCPConn.Write: connection is closed")
		}
		ret self.fd.Write(buf).await?
	}

	// Sets read timeout for connection.
	// Timeout precision is milliseconds.
	// If the timeout is below one millisecond it will be accepted as zero.
	// The maximum timeout is 40 days, if timeout is greater than 40 fays, it panics.
	// The zero timeout, clears current timeout if exist.
	fn SetReadTimeout(mut *self, timeout: time::Duration)! {
		if self.fd == nil {
			panic("net: TCPConn.SetReadTimeout: connection is closed")
		}
		self.fd.SetReadTimeout(timeout)?
	}

	// Sets write timeout for connection.
	// Timeout precision is milliseconds.
	// If the timeout is below one millisecond it will be accepted as zero.
	// The maximum timeout is 40 days, if timeout is greater than 40 fays, it panics.
	// The zero timeout, clears current timeout if exist.
	fn SetWriteTimeout(mut *self, timeout: time::Duration)! {
		if self.fd == nil {
			panic("net: TCPConn.SetWriteTimeout: connection is closed")
		}
		self.fd.SetWriteTimeout(timeout)?
	}

	// Returns network name which is connected.
	// If connection closed, returns Network.TCP as a general network.
	fn Network(*self): Network {
		match {
		| self.fd == nil:
			ret Network.TCP
		| self.v6:
			ret Network.TCP6
		|:
			ret Network.TCP4
		}
	}

	// Returns raw socket/file-descriptor of the connection.
	// Intended for low-level use. Just borrow, do not close or something else.
	fn RawFD(*self): u64 {
		ret self.fd.pfd.File
	}

	// Closes connection.
	async fn Close(mut *self)! {
		if self.fd == nil {
			ret
		}
		self.fd.Close().await?
		self.fd = nil
		self.v6 = false
	}
}
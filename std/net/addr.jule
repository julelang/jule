// Copyright 2024-2025 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/internal/byteslite"

// Represents a network end point address.
trait Addr {
	// Returns name of the network.
	fn Network(*self): str

	// String form of address.
	fn Str(*self): str
}

// Combines host and port into a network address of the
// form "host:port". If host contains a colon, as found in literal
// IPv6 addresses, then JoinHostPort returns "[host]:port".
//
// See the [Dial] function for a description of the host and port parameters.
fn JoinHostPort(host: str, port: str): str {
	// We assume that host is a literal IPv6 address if host has colons.
	if byteslite::IndexByteStr(host, ':') >= 0 {
		ret "[" + host + "]:" + port
	}
	ret host + ":" + port
}

// Splits a network address of the form "host:port",
// "host%zone:port", "[host]:port" or "[host%zone]:port" into host or
// host%zone and port.
//
// A literal IPv6 address in hostport must be enclosed in square
// brackets, as in "[::1]:80", "[::1%lo0]:80".
//
// See the [Dial] function for a description of the hostport parameter, and host
// and port results.
fn SplitHostPort(hostport: str)!: (host: str, port: str) {
	const (
		missingPort   = "missing port in address"
		tooManyColons = "too many colons in address"
	)

	mut j, mut k := 0, 0
	i := byteslite::LastIndexByteStr(hostport, ':')
	if i == -1 {
		error(&AddrError{Err: missingPort, Addr: hostport})
	}
	if hostport[0] == '[' {
		// Expect the first ']' just before the last ':'.
		end := byteslite::IndexByteStr(hostport, ']')
		if end == -1 {
			error(&AddrError{Err: "missing ']' in address", Addr: hostport})
		}
		match end + 1 {
		| len(hostport):
			error(&AddrError{Err: missingPort, Addr: hostport})
		| i:
			// Expected result, it's fine.
		|:
			// Either ']' isn't followed by a colon, or it is
			// followed by a colon that is not the last one.
			if hostport[end+1] == ':' {
				error(&AddrError{Err: tooManyColons, Addr: hostport})
			}
			error(&AddrError{Err: missingPort, Addr: hostport})
		}
		host = hostport[1:end]
		j, k = 1, end+1 // There can't be a '[' resp. ']' before these positions.
	} else {
		host = hostport[:i]
		if byteslite::IndexByteStr(host, ':') != -1 {
			error(&AddrError{Err: tooManyColons, Addr: hostport})
		}
	}
	if byteslite::IndexByteStr(hostport[j:], '[') != -1 {
		error(&AddrError{Err: "unexpected '[' in address", Addr: hostport})
	}
	if byteslite::IndexByteStr(hostport[k:], ']') != -1 {
		error(&AddrError{Err: "unexpected ']' in address", Addr: hostport})
	}
	port = hostport[i+1:]
	ret
}

fn splitHostZone(s: str): (host: str, zone: str) {
	// The IPv6 scoped addressing zone identifier starts after the
	// last percent sign.
	i := byteslite::LastIndexByteStr(s, '%')
	if i > 0 {
		host, zone = s[:i], s[i+1:]
	} else {
		host = s
	}
	ret
}

fn internetAddr(net: Network, mut ip: IPAddr, port: int): Addr {
	match net {
	| TCP | TCP4 | TCP6:
		ret &TCPAddr{IP: ip.IP, Port: port, Zone: ip.Zone}
	| UDP | UDP4 | UDP6:
		ret &UDPAddr{IP: ip.IP, Port: port, Zone: ip.Zone}
	| IP | IP4 | IP6:
		ret &IPAddr{IP: ip.IP, Zone: ip.Zone}
	|:
		panic("net: unexpected network: " + str(net))
	}
}

// Parses addr as an IP address, returning the result. The string
// addr can be in dotted decimal ("192.0.2.1"), IPv6 ("2001:db8::68"),
// or IPv6 with a scoped addressing zone ("fe80::1cc0:3e8c:119f:c2e1%ens18").
fn parseAddr(addr: str)!: IPAddr {
	for _, r in addr {
		match r {
		| '.':
			ret parseIPv4(addr)?
		| ':':
			ret parseIPv6(addr)?
		| '%':
			// Assume that this was trying to be an IPv6 address with
			// a zone specifier, but the address is missing.
			error(&parseAddrError{input: addr, msg: "missing IPv6 address"})
		}
	}
	error(&parseAddrError{input: addr, msg: "unable to parse IP"})
}

// Represents a list of network endpoint addresses.
type addrList: []Addr

// Reports whether addr contains an IPv4 address.
fn isIPv4(mut addr: Addr): bool {
	match type addr {
	| &TCPAddr:
		ret addr.(&TCPAddr).IP.To4() != nil
	| &UDPAddr:
		ret addr.(&UDPAddr).IP.To4() != nil
	| &IPAddr:
		ret addr.(&IPAddr).IP.To4() != nil
	|:
		ret false
	}
}

// Reports whether addr does not contain an IPv4 address.
fn isNotIPv4(mut addr: Addr): bool { ret !isIPv4(addr) }

impl addrList {
	// Returns the most appropriate address in address for a call to ResolveXAddr variants.
	// IPv4 is preferred, unless addr contains an IPv6 literal.
	fn forResolve(mut *self, network: Network, addr: str): Addr {
		let mut want6: bool
		match network {
		| IP:
			// IPv6 literal (addr does NOT contain a port)
			want6 = byteslite::CountStr(addr, ':') > 0
		| TCP | UDP:
			// IPv6 literal. (addr contains a port, so look for '[')
			want6 = byteslite::CountStr(addr, '[') > 0
		|:
			break // no-op
		}
		if want6 {
			ret self.first(isNotIPv4)
		}
		ret self.first(isIPv4)
	}

	// first returns the first address which satisfies strategy, or if
	// none do, then the first address of any kind.
	fn first(mut *self, strategy: fn(mut Addr): bool): Addr {
		for (_, mut addr) in *self {
			if strategy(addr) {
				ret addr
			}
		}
		ret (*self)[0]
	}
}

// Applies a filter to a list of IP addresses,
// yielding a list of Addr objects. Known filters are nil, ipv4only,
// and ipv6only. It returns every address when the filter is nil.
// The result contains at least one address when error is nil.
fn filterAddrList(filter: fn(mut IPAddr): bool, net: Network, mut ips: []IPAddr, port: int, originalAddr: str)!: addrList {
	let mut addrs: addrList
	for (_, mut ip) in ips {
		if filter == nil || filter(ip) {
			addrs = append(addrs, internetAddr(net, ip, port))
		}
	}
	if len(addrs) == 0 {
		error(&AddrError{Err: "no suitable address found", Addr: originalAddr})
	}
	ret addrs
}

// Resolves addr which may be aliteral IP address and
// returns internal protocol family address.
//
// Forwards any exceptional from used methods.
fn resolveInternetAddrList(net: Network, addr: str)!: addrList {
	mut host, mut port := "", ""
	mut portnum := 0
	match net {
	| TCP | TCP4 | TCP6
	| UDP | UDP4 | UDP6:
		host, port = SplitHostPort(addr)?
		portnum = lookupPort(net, port)?
	| IP | IP4 | IP6:
		if addr != "" {
			host = addr
		}
	|:
		error(&AddrError{Err: "invalid network: " + str(net)})
	}
	if host == "" {
		ret [internetAddr(net, IPAddr{}, portnum)]
	}

	// Try as a literal IP address, then as a DNS name.
	mut ips := lookupIPAddr(net, host)?
	// If the machine has halfway configured
	// IPv6 such that it can bind on "::" (IPv6Unspecified)
	// but not connect back to that same address, fall
	// back to dialing 0.0.0.0.
	// See Go's issue 18806.
	if len(ips) == 1 && ips[0].IP.Equal(IPv6Unspecified) {
		ips = append(ips, IPAddr{IP: IPv4Zero})
	}
	let mut filter: fn(mut IPAddr): bool
	match net {
	| TCP | UDP:
		filter = nil
	| TCP4 | UDP4:
		filter = ipv4only
	| TCP6 | UDP6:
		filter = ipv6only
	|:
		panic("unreachable")
	}
	ret filterAddrList(filter, net, ips, portnum, host)?
}

// Reports whether addr is an IPv4 address.
fn ipv4only(mut addr: IPAddr): bool {
	ret addr.IP.To4() != nil
}

// Reports whether addr is an IPv6 address except IPv4-mapped IPv6 address.
fn ipv6only(mut addr: IPAddr): bool {
	ret len(addr.IP) == IPv6Len && addr.IP.To4() == nil
}
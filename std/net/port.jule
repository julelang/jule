// Copyright 2025 The Jule Project Contributors. All rights reserved.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

// Parses service as a decimal integer and returns the corresponding value as port.
// It is the caller's responsibility to parse service as a non-decimal integer when needsLookup is true.
//
// Some system resolvers will return a valid port number when given a number
// over 65536 (see Go's issue: https://golang.org/issues/11715). Alas, the parser
// can't bail early on numbers > 65536. Therefore reasonably large/small
// numbers are parsed in full and rejected if invalid.
fn parsePort(mut service: str): (port: int, needsLookup: bool) {
	if service == "" {
		// Lock in the legacy behavior that an empty string
		// means port 0. See golang.org/issue/13610.
		ret 0, false
	}
	const (
		max    = u32(1<<32 - 1)
		cutoff = u32(1 << 30)
	)
	mut neg := false
	if service[0] == '+' {
		service = service[1:]
	} else if service[0] == '-' {
		neg = true
		service = service[1:]
	}
	let mut n: u32
	for (_, mut d) in service {
		if '0' <= d && d <= '9' {
			d -= '0'
		} else {
			ret 0, true
		}
		if n >= cutoff {
			n = max
			break
		}
		n *= 10
		nn := n + u32(d)
		if nn < n || nn > max {
			n = max
			break
		}
		n = nn
	}
	if !neg && n >= cutoff {
		port = int(cutoff - 1)
	} else if neg && n > cutoff {
		port = int(cutoff)
	} else {
		port = int(n)
	}
	if neg {
		port = -port
	}
	ret port, false
}
// Copyright 2025 The Jule Project Contributors. All rights reserved.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/internal/poll"
use "std/mem"
use "std/sys"
use "std/time"

struct netFD {
	pfd: &poll::FD
}

impl netFD {
	fn init(mut *self)! {
		const Pollable = true // Network is always non-blocking.
		self.pfd.Init(Pollable)?
	}

	// Returns NetHandle.
	fn Handle(*self): poll::NetHandle {
		ret poll::NetHandle(self.pfd.File)
	}

	fn SetDeadline(mut *self, mut deadline: time::Duration) {
		self.pfd.SetDeadline(deadline)
	}

	fn SetReadDeadline(mut *self, mut deadline: time::Duration) {
		self.pfd.SetReadDeadline(deadline)
	}

	fn SetWriteDeadline(mut *self, mut deadline: time::Duration) {
		self.pfd.SetWriteDeadline(deadline)
	}

	// Wrapper for [poll::FD.Write].
	async fn Write(mut *self, buf: []byte)!: (n: int) {
		ret self.pfd.Write(buf).await?
	}

	// Wrapper for [poll::FD.Read].
	async fn Read(mut *self, mut buf: []byte)!: (n: int) {
		ret self.pfd.Read(buf).await?
	}

	// Wrapper for [poll::FD.ReadV].
	async fn ReadV(mut *self, mut buf: []byte, addr: uintptr, addrLen: sys::Socklen)!: (n: int) {
		ret self.pfd.ReadV(buf, addr, addrLen).await?
	}

	// Wrapper for [poll::FD.ReadV4].
	async fn ReadV4(mut *self, mut buf: []byte, addr: sys::RawSockaddrInet4)!: (n: int) {
		addrLen := mem::SizeOf(addr)
		ret self.ReadV(buf, uintptr(&addr), sys::Socklen(addrLen)).await?
	}

	// Wrapper for [poll::FD.ReadV6].
	async fn ReadV6(mut *self, mut buf: []byte, addr: sys::RawSockaddrInet6)!: (n: int) {
		addrLen := mem::SizeOf(addr)
		ret self.ReadV(buf, uintptr(&addr), sys::Socklen(addrLen)).await?
	}

	// Wrapper for [poll::FD.WriteV].
	async fn WriteV(mut *self, buf: []byte, addr: uintptr, addrLen: sys::Socklen)!: (n: int) {
		ret self.pfd.WriteV(buf, addr, addrLen).await?
	}

	// Wrapper for [poll::FD.WriteV4].
	async fn WriteV4(mut *self, buf: []byte, addr: sys::RawSockaddrInet4)!: (n: int) {
		addrLen := mem::SizeOf(addr)
		ret self.WriteV(buf, uintptr(&addr), sys::Socklen(addrLen)).await?
	}

	// Wrapper for [poll::FD.WriteV6].
	async fn WriteV6(mut *self, buf: []byte, addr: sys::RawSockaddrInet6)!: (n: int) {
		addrLen := mem::SizeOf(addr)
		ret self.WriteV(buf, uintptr(&addr), sys::Socklen(addrLen)).await?
	}

	// Wrapper for [poll::FD.Close].
	async fn Close(mut *self)! {
		self.pfd.Close().await?
	}
}

fn newFD(h: poll::NetHandle, flags: int, sotype: int): &netFD {
	mut pfd := &poll::FD{
		File: u64(h),
		Flags: flags,
		IsStream: sotype == sys::SOCK_STREAM,
		ZeroReadIsEOF: sotype != sys::SOCK_DGRAM && sotype != sys::SOCK_RAW,
	}
	ret &netFD{
		pfd: pfd,
	}
}
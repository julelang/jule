// Copyright 2025 The Jule Project Contributors. All rights reserved.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/testing"

fn isValidIP(network: Network, mut ip: IP): bool {
	if len(ip) != IPv6Len && len(ip) != IPv4Len {
		ret false
	}
	if ip.Equal(IPv6Zero) || ip.Equal(IPv4Zero) {
		ret false
	}
	match network {
	| IP | TCP | UDP:
		ret true
	| IP4 | TCP4 | UDP4:
		ret ip.To4() != nil
	| IP6 | TCP6 | UDP6:
		ret ip.To4() == nil
	}
	ret false
}

// Hosts for lookup tests.
// Supports IPv4 and IPv6.
let testHosts = [
	"jule.dev",
	"manual.jule.dev",
	"example.com",
	"google.com",
	"cloudflare.com",
	"wikipedia.org",
]

async fn _testLookupIP(t: &testing::T) {
	networks := [Network.IP, Network.IP4, Network.IP6]
	for _, host in testHosts {
		for _, network in networks {
			comb := host + ":" + networkToStr(network)

			mut ips := LookupIP(network, host).await else {
				t.Errorf("[{}]: unexpected error: {}", comb, error)
				continue
			}
			if len(ips) == 0 {
				t.Errorf("[{}]: zero addresses returned", comb)
			}
			for (_, mut ip) in ips {
				if !isValidIP(network, ip.IP) {
					t.Errorf("[{}]: invalid IP: ", comb, ip.IP.Str())
				}
			}
		}
	}
}

#test
async fn testLookupIP(t: &testing::T) {
	_testLookupIP(t).await
}

#test
async fn testLookupIPJule(t: &testing::T) {
	DefaultResolver.PreferJule = true
	_testLookupIP(t).await
	DefaultResolver.PreferJule = false
}

#test
async fn testLookupIPJuleTCP(t: &testing::T) {
	t.Skip() // Skip TCP tests because it may be fail on CI.
	ret

	DefaultResolver.PreferJule = true
	conf.useTCP = true
	_testLookupIP(t).await
	DefaultResolver.PreferJule = false
	conf.useTCP = false
}

#test
async fn testLookupIPJuleParallel(t: &testing::T) {
	DefaultResolver.PreferJule = true
	DefaultResolver.ForceParallel = true
	_testLookupIP(t).await
	DefaultResolver.PreferJule = false
	DefaultResolver.ForceParallel = false
}

#test
async fn testLookupIPJuleParallelTCP(t: &testing::T) {
	t.Skip() // Skip TCP tests because it may be fail on CI.
	ret

	DefaultResolver.PreferJule = true
	DefaultResolver.ForceParallel = true
	conf.useTCP = true
	_testLookupIP(t).await
	DefaultResolver.PreferJule = false
	DefaultResolver.ForceParallel = false
	conf.useTCP = false
}

#test
async fn testTCPAddrResolve(t: &testing::T) {
	networks := [Network.TCP, Network.TCP4, Network.TCP6]
	for _, host in testHosts {
		for _, network in networks {
			comb := host + ":" + networkToStr(network)

			mut addr := TCPAddr.Resolve(network, host+":53").await else {
				t.Errorf("[{}]: unexpected error: {}", comb, error)
				continue
			}
			if addr == nil {
				t.Errorf("[{}]: nil address returned", comb)
			}
			if !isValidIP(network, addr.IP) {
				t.Errorf("[{}]: invalid IP: ", comb, addr.IP.Str())
			}
		}
	}
}

#test
async fn testUDPAddrResolve(t: &testing::T) {
	networks := [Network.UDP, Network.UDP4, Network.UDP6]
	for _, host in testHosts {
		for _, network in networks {
			comb := host + ":" + networkToStr(network)

			mut addr := UDPAddr.Resolve(network, host+":53").await else {
				t.Errorf("[{}]: unexpected error: {}", comb, error)
				continue
			}
			if addr == nil {
				t.Errorf("[{}]: nil address returned", comb)
			}
			if !isValidIP(network, addr.IP) {
				t.Errorf("[{}]: invalid IP: ", comb, addr.IP.Str())
			}
		}
	}
}

#test
async fn testIPAddrResolve(t: &testing::T) {
	networks := [Network.IP, Network.IP4, Network.IP6]
	for _, host in testHosts {
		for _, network in networks {
			comb := host + ":" + networkToStr(network)

			mut addr := IPAddr.Resolve(network, host).await else {
				t.Errorf("[{}]: unexpected error: {}", comb, error)
				continue
			}
			if addr == nil {
				t.Errorf("[{}]: nil address returned", comb)
			}
			if !isValidIP(network, addr.IP) {
				t.Errorf("[{}]: invalid IP: ", comb, addr.IP.Str())
			}
		}
	}
}
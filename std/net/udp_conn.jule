// Copyright 2024 The Jule Project Contributors. All rights reserved.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/internal/poll"
use "std/io"
use "std/mem"
use "std/sys"
use "std/time"

// UDP connection.
// This structure represents server and client connections.
struct UDPConn {
	mut sockaddr4: sys::RawSockaddrInet4
	mut sockaddr6: sys::RawSockaddrInet6
	mut fd:        &netFD
	Addr:          &UDPAddr
	v6:            bool
	connect:       bool
}

impl Conn for UDPConn {}
impl io::Reader for UDPConn {}
impl io::Writer for UDPConn {}
impl io::ReadWriteCloser for UDPConn {}
impl io::WriteCloser for UDPConn {}

impl UDPConn {
	// Binds new UDP listener and starts listening given address.
	// Returns relevant created &UDPConn if success.
	// If addr is not a valid address, it will forward relevant parse exceptionals.
	// In addition, any bind and listening error will be return as exceptional.
	//
	// See the [Dial] function for a description of the addr parameter.
	async fn Bind(addr: str)!: &UDPConn {
		ret udpBind(Network.UDP, addr).await?
	}

	// Connects to UDP listener by given address.
	// Returns relevant created &UDPConn if success.
	// If addr is not a valid address, it will forward relevant parse exceptionals.
	// In addition, any bind and listening error will be return as exceptional.
	//
	// See the [Dial] function for a description of the addr parameter.
	async fn Dial(addr: str)!: &UDPConn {
		ret udpDial(Network.UDP, addr).await?
	}

	// Read bytes to buffer from connection and returns read byte count.
	// The number of bytes read can never exceed the length of the buffer.
	// If the buffer is larger than the number of bytes that can be read,
	// the buffer will not cause an overflow.
	// It will panic if connection is closed.
	async fn Read(mut *self, mut buf: []byte)!: (n: int) {
		if self.fd == nil {
			panic("net: UDPConn.Read: connection is closed")
		}
		if self.connect {
			ret self.fd.Read(buf).await?
		}
		if self.v6 {
			ret self.fd.ReadV6(buf, self.sockaddr6).await?
		} else {
			ret self.fd.ReadV4(buf, self.sockaddr4).await?
		}
	}

	// Writes bytes to connection and returns written byte count.
	// The number of bytes written can never exceed the length of the buffer.
	async fn Write(mut *self, buf: []byte)!: (n: int) {
		if self.fd == nil {
			panic("net: UDPConn.Write: connection is closed")
		}
		if self.connect {
			ret self.fd.Write(buf).await?
		}
		if self.v6 {
			ret self.fd.WriteV6(buf, self.sockaddr6).await?
		} else {
			ret self.fd.WriteV4(buf, self.sockaddr4).await?
		}
	}

	// Sets or updates a deadline for the future read operations.
	// If the deadline is given as 0, the deadline is cleared.
	// The deadline is evaluated against an absolute point in time.
	// In practice, the given deadline is equivalent to `time::Now().Add(deadline)`.
	// It does not apply per operation, but remains valid until this absolute time.
	// Any operation initiated after this deadline has passed will fail.
	fn SetReadDeadline(mut *self, deadline: time::Duration)! {
		if self.fd == nil {
			panic("net: TCPConn.SetReadDeadline: connection is closed")
		}
		self.fd.SetReadDeadline(deadline)
	}

	// Sets or updates a deadline for the future write operations.
	// If the deadline is given as 0, the deadline is cleared.
	// The deadline is evaluated against an absolute point in time.
	// In practice, the given deadline is equivalent to `time::Now().Add(deadline)`.
	// It does not apply per operation, but remains valid until this absolute time.
	// Any operation initiated after this deadline has passed will fail.
	fn SetWriteDeadline(mut *self, deadline: time::Duration)! {
		if self.fd == nil {
			panic("net: TCPConn.SetWriteDeadline: connection is closed")
		}
		self.fd.SetWriteDeadline(deadline)
	}

	// Returns network name which is connected or listening.
	// If connection closed, returns Network.UDP as a general network.
	fn Network(*self): Network {
		match {
		| self.fd == nil:
			ret Network.UDP
		| self.v6:
			ret Network.UDP6
		|:
			ret Network.UDP4
		}
	}

	// Returns raw socket/file-descriptor of the connection.
	// Intended for low-level use. Just borrow, do not close or something else.
	fn RawFD(*self): u64 {
		ret self.fd.pfd.File
	}

	// Closes connection.
	async fn Close(mut *self)! {
		if self.fd == nil {
			ret
		}
		self.fd.Close().await?
		self.fd = nil
		self.v6 = false
	}
}

async fn udpBind(network: Network, addr: str)!: &UDPConn {
	mut connAddr := UDPAddr.Resolve(network, addr).await?
	mut conn := UDPConn{
		Addr: connAddr,
	}
	if conn.Addr.IP.Empty() {
		match network {
		| UDP | UDP4:
			conn.sockaddr4 = sys::RawSockaddrInet4{}
			conn.fd = socketipv4(false, uintptr(&conn.sockaddr4), connAddr, sys::SOCK_DGRAM, 0).await?
		| UDP6:
			conn.v6 = true
			conn.sockaddr6 = sys::RawSockaddrInet6{}
			conn.fd = socketipv6(false, uintptr(&conn.sockaddr6), connAddr, sys::SOCK_DGRAM, 0).await?
		|:
			error(&AddrError{Err: "invalid network: " + str(network)})
		}
	} else {
		mut ipv4 := conn.Addr.IP.To4()
		if ipv4.Empty() {
			if network == Network.UDP4 {
				error(&AddrError{Err: "expected IPv4 address but found IPv6", Addr: addr})
			}
			conn.v6 = true
			conn.sockaddr6 = sys::RawSockaddrInet6{}
			conn.fd = socketipv6(false, uintptr(&conn.sockaddr6), connAddr, sys::SOCK_DGRAM, 0).await?
		} else {
			if network == Network.UDP6 {
				error(&AddrError{Err: "expected IPv6 address but found IPv4", Addr: addr})
			}
			conn.Addr.IP = ipv4
			conn.sockaddr4 = sys::RawSockaddrInet4{}
			conn.fd = socketipv4(false, uintptr(&conn.sockaddr4), connAddr, sys::SOCK_DGRAM, 0).await?
		}
	}
	ret new(UDPConn, conn)
}

async fn udpDial(network: Network, addr: str)!: &UDPConn {
	mut connAddr := UDPAddr.Resolve(network, addr).await?
	mut conn := UDPConn{
		Addr: connAddr,
		connect: true,
	}
	if conn.Addr.IP.Empty() {
		match network {
		| UDP | UDP4:
			conn.sockaddr4 = sys::RawSockaddrInet4{}
			conn.fd = socketipv4(true, uintptr(&conn.sockaddr4), connAddr, sys::SOCK_DGRAM, 0).await?
		| UDP6:
			conn.sockaddr6 = sys::RawSockaddrInet6{}
			conn.fd = socketipv6(true, uintptr(&conn.sockaddr6), connAddr, sys::SOCK_DGRAM, 0).await?
		|:
			error(&AddrError{Err: "invalid network: " + str(network)})
		}
	} else {
		mut ipv4 := conn.Addr.IP.To4()
		if ipv4.Empty() {
			if network == Network.UDP4 {
				error(&AddrError{Err: "expected IPv4 address but found IPv6", Addr: addr})
			}
			conn.v6 = true
			conn.sockaddr6 = sys::RawSockaddrInet6{}
			conn.fd = socketipv6(true, uintptr(&conn.sockaddr6), connAddr, sys::SOCK_DGRAM, 0).await?
		} else {
			if network == Network.UDP6 {
				error(&AddrError{Err: "expected IPv6 address but found IPv4", Addr: addr})
			}
			conn.Addr.IP = ipv4
			conn.sockaddr4 = sys::RawSockaddrInet4{}
			conn.fd = socketipv4(true, uintptr(&conn.sockaddr4), connAddr, sys::SOCK_DGRAM, 0).await?
		}
	}
	ret new(UDPConn, conn)
}
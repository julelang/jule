// Copyright 2025 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/internal/byteslite"
use "std/sync"
use "std/time"
use "std/unsafe"

const cacheMaxAge = 5 * time::Second

fn parseLiteralIP(addr: str): str {
	ip := parseAddr(addr) else { ret "" }
	ret ip.Str()
}

struct byName {
	addrs:         []str
	canonicalName: str
}

struct hostsdata {
	mu: sync::Mutex

	// Key for the list of literal IP addresses must be a host
	// name. It would be part of DNS labels, a FQDN or an absolute
	// FQDN.
	// For now the key is converted to lower case for convenience.
	byName: map[str]byName

	// Key for the list of host names must be a literal IP address
	// including IPv6 address with zone identifier.
	// We don't support old-classful IP address notation.
	byAddr: map[str][]str

	expire: time::Time
	path:   str
	mtime:  time::Time
	size:   i64
}

// hosts contains known host entries.
let mut hosts = hostsdata{}

fn readHosts() {
	now := time::Now()
	hp := hostsFilePath

	if now.Before(hosts.expire) && hosts.path == hp && len(hosts.byName) > 0 {
		ret
	}
	mtime, size, mut ok := stat(hp)
	if ok && hosts.path == hp && hosts.mtime.Equal(mtime) && hosts.size == size {
		hosts.expire = now.Add(cacheMaxAge)
		ret
	}

	mut hs := map[str]byName{}
	mut is := map[str][]str{}

	mut file, ok := open(hp)

	if ok {
		defer { file.close() }
		mut line, (ok) := file.readLine()
		for ok; line, ok = file.readLine() {
			mut i := byteslite::IndexByteStr(line, '#')
			if i >= 0 {
				// Discard comments.
				line = line[0:i]
			}
			f := getFields(line)
			if len(f) < 2 {
				continue
			}
			addr := parseLiteralIP(f[0])
			if addr == "" {
				continue
			}

			let mut canonical: str
			i = 1
			for i < len(f); i++ {
				name := absDomainName(f[i])
				mut h := []byte(f[i])
				lowerASCIIBytes(h)
				key := absDomainName(unsafe::StrFromBytes(h))

				if i == 1 {
					canonical = key
				}

				is[addr] = append(is[addr], name)

				mut v, (ok) := hs[key]
				if ok {
					hs[key] = byName{
						addrs: append(v.addrs, addr),
						canonicalName: v.canonicalName,
					}
					continue
				}

				hs[key] = byName{
					addrs: [addr],
					canonicalName: canonical,
				}
			}
		}
	}
	// Update the data cache.
	hosts.expire = now.Add(cacheMaxAge)
	hosts.path = hp
	hosts.byName = hs
	hosts.byAddr = is
	hosts.mtime = mtime
	hosts.size = size
}

// Returns an absolute domain name which ends with a trailing dot to match
// pure Jule reverse resolver and all other lookup routines.
// See issue of Go: golang.org/issue/12189.
// But we don't want to add dots for local names from /etc/hosts.
// It's hard to tell so we settle on the heuristic that names without dots
// (like "localhost" or "myhost") do not get trailing dots, but any other
// names do.
fn absDomainName(mut s: str): str {
	if byteslite::IndexByteStr(s, '.') != -1 && s[len(s)-1] != '.' {
		s += "."
	}
	ret s
}
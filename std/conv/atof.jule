// Copyright 2022 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use std::math

let OPTIMIZE = true

const FN_PARSE_FLOAT = "parse_float"

//doc:
// Returns the length of the common
// prefix of s and prefix, with the character case of s ignored.
// The prefix argument must be all lower-case.
fn common_prefix_len_ignore_case(s: str, prefix: str) int {
	let n = prefix.len
	if n > s.len {
		n = s.len
	}
	for let i = 0; i < n; i++ {
		let c = s[i]
		if 'A' <= c && c <= 'Z' {
			c += 'a' - 'A'
		}
		if c != prefix[i] {
			ret i
		}
	}
	ret n
}

//doc:
// Returns the floating-point value for the special,
// possibly signed floating-point representations inf, infinity,
// and nan. The result is ok if a prefix of s contains one
// of these representations and n is the length of that prefix.
// The character case is ignored.
fn special(s: str) (f: f64, n: int, ok: bool) {
	if s.empty() {
		ret 0, 0, false
	}
	let sign = 1
	let nsign = 0
	match s[0] {
	case '+', '-':
		if s[0] == '-' {
			sign = -1
		}
		nsign = 1
		s = s[1:]
		fallthrough
	case 'i', 'I':
		let case_n = common_prefix_len_ignore_case(s, "infinity")
		// Anything longer than "inf" is ok, but if we
		// don't have "infinity", only consume "inf".
		if 3 < case_n && case_n < 8 {
			case_n = 3
		}
		if case_n == 3 || case_n == 8 {
			ret std::math::inf(sign), nsign + n, true
		}
	case 'n', 'N':
		if common_prefix_len_ignore_case(s, "nan") == 3 {
			ret std::math::nan(), 3, true
		}
	}
	ret 0, 0, false
}

// Reads a decimal or hexadecimal mantissa and exponent from a float
// string representation in s; the number may be followed by other characters.
// Reports the number of bytes consumed (i), and whether the number is valid (ok).
fn read_float(s: str) (mantissa: u64, exp: int, neg: bool,
						trunc: bool, hex: bool, i: int, ok: bool) {
	// optional sign
	if i >= s.len {
		ret
	}
	match {
	case s[i] == '+':
		i++
	case s[i] == '-':
		neg = true
		i++
	}

	// digits
	let base: u64 = 10
	let max_mant_digits = 19 // 10^19 fits in u64
	let exp_char = 'e'
	if i+2 < s.len && s[i] == '0' && lower(s[i+1]) == 'x' {
		base = 16
		max_mant_digits = 16 // 16^16 fits in u64
		i += 2
		exp_char = 'p'
		hex = true
	}
	let sawdot = false
	let sawdigits = false
	let nd = 0
	let nd_mant = 0
	let dp = 0
	for ; i < s.len; i++ {
		let c = s[i]
		match true {
		case c == '.':
			if sawdot {
				goto loop_end
			}
			sawdot = true
			dp = nd
			continue
		case '0' <= c && c <= '9':
			sawdigits = true
			if c == '0' && nd == 0 { // ignore leading zeros
				dp--
				continue
			}
			nd++
			if nd_mant < max_mant_digits {
				mantissa *= base
				mantissa += u64(c - '0')
				nd_mant++
			} else if c != '0' {
				trunc = true
			}
			continue
		case base == 16 && 'a' <= lower(c) && lower(c) <= 'f':
			sawdigits = true
			nd++
			if nd_mant < max_mant_digits {
				mantissa *= 16
				mantissa += u64(lower(c) - 'a' + 10)
				nd_mant++
			} else {
				trunc = true
			}
			continue
		}
		break
	}
loop_end:
	if !sawdigits {
		ret
	}
	if !sawdot {
		dp = nd
	}

	if base == 16 {
		dp *= 4
		nd_mant *= 4
	}

	// optional exponent moves decimal point.
	// if we read a very large, very long number,
	// just be sure to move the decimal point by
	// a lot (say, 100000).  it doesn't matter if it's
	// not the exact number.
	if i < s.len && lower(s[i]) == exp_char {
		i++
		if i >= s.len {
			ret
		}
		let esign = 1
		if s[i] == '+' {
			i++
		} else if s[i] == '-' {
			i++
			esign = -1
		}
		if i >= s.len || s[i] < '0' || s[i] > '9' {
			ret
		}
		let e = 0
		for ; i < s.len && ('0' <= s[i] && s[i] <= '9'); i++ {
			if e < 10000 {
				e = e*10 + int(s[i]) - '0'
			}
		}
		dp += e * esign
	} else if base == 16 {
		// Must have exponent.
		ret
	}

	if mantissa != 0 {
		exp = dp - nd_mant
	}

	ok = true
	ret
}

// Decimal power of ten to binary power of two.
let powtab = []int{1, 3, 6, 9, 13, 16, 19, 23, 26}

impl Decimal {
	fn &set(s: str) (ok: bool) {
		let i = 0
		.neg = false
		.trunc = false

		// optional sign
		if i >= s.len {
			ret
		}
		match {
		case s[i] == '+':
			i++
		case s[i] == '-':
			.neg = true
			i++
		}

		// digits
		let sawdot = false
		let sawdigits = false
		for ; i < s.len; i++ {
			match {
			case s[i] == '.':
				if sawdot {
					ret
				}
				sawdot = true
				.dp = .nd
				continue
			case '0' <= s[i] && s[i] <= '9':
				sawdigits = true
				if s[i] == '0' && .nd == 0 { // ignore leading zeros
					.dp--
					continue
				}
				if .nd < .d.len {
					.d[.nd] = s[i]
					.nd++
				} else if s[i] != '0' {
					.trunc = true
				}
				continue
			}
			break
		}
		if !sawdigits {
			ret
		}
		if !sawdot {
			.dp = .nd
		}

		// optional exponent moves decimal point.
		// if we read a very large, very long number,
		// just be sure to move the decimal point by
		// a lot (say, 100000).  it doesn't matter if it's
		// not the exact number.
		if i < s.len && lower(s[i]) == 'e' {
			i++
			if i >= s.len {
				ret
			}
			let esign = 1
			if s[i] == '+' {
				i++
			} else if s[i] == '-' {
				i++
				esign = -1
			}
			if i >= s.len || s[i] < '0' || s[i] > '9' {
				ret
			}
			let e = 0
			for ; i < s.len && ('0' <= s[i] && s[i] <= '9'); i++ {
				if e < 10000 {
					e = e*10 + int(s[i]) - '0'
				}
			}
			.dp += e * esign
		}

		if i != s.len {
			ret
		}

		ok = true
		ret
	}

	fn &float_bits(flt: *FloatInfo) (b: u64, overflow: bool) {
		let exp: int
		let mant: u64

		// Zero is always a special case.
		if .nd == 0 {
			mant = 0
			exp = flt.bias
			goto out
		}

		// Obvious overflow/underflow.
		// These bounds are for 64-bit floats.
		// Will have to change if we want to support 80-bit floats in the future.
		if .dp > 310 {
			goto overflow
		}
		if .dp < -330 {
			// zero
			mant = 0
			exp = flt.bias
			goto out
		}

		// Scale by powers of two until in range [0.5, 1.0)
		exp = 0
		for .dp > 0 {
			let n: int
			if .dp >= powtab.len {
				n = 27
			} else {
				n = powtab[.dp]
			}
			.shift(-n)
			exp += n
		}
		for .dp < 0 || .dp == 0 && .d[0] < '5' {
			let n: int
			if -.dp >= powtab.len {
				n = 27
			} else {
				n = powtab[-.dp]
			}
			.shift(n)
			exp -= n
		}

		// Our range is [0.5,1) but floating point range is [1,2).
		exp--

		// Minimum representable exponent is flt.bias+1.
		// If the exponent is smaller, move it up and
		// adjust d accordingly.
		if exp < flt.bias+1 {
			let n = flt.bias + 1 - exp
			.shift(-n)
			exp += n
		}

		if exp-flt.bias >= 1<<flt.expbits-1 {
			goto overflow
		}

		// Extract 1+flt.mantbits bits.
		.shift(int(1 + flt.mantbits))
		mant = .rounded_integer()

		// Rounding might have added a bit; shift down.
		if mant == 2<<flt.mantbits {
			mant >>= 1
			exp++
			if exp-flt.bias >= 1<<flt.expbits-1 {
				goto overflow
			}
		}

		// Denormalized?
		if mant&(1<<flt.mantbits) == 0 {
			exp = flt.bias
		}
		goto out

		overflow:
			// ±inf
			mant = 0
			exp = 1<<flt.expbits - 1 + flt.bias
			overflow = true

		out:
		// Assemble bits.
		let bits = mant & (u64(1)<<flt.mantbits - 1)
		bits |= u64((exp-flt.bias)&(1<<flt.expbits-1)) << flt.mantbits
		if .neg {
			bits |= 1 << flt.mantbits << flt.expbits
		}
		ret bits, overflow
	}
}

// Exact powers of 10.
let f64_pow10 = []f64{
	1e0, 1e1, 1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9,
	1e10, 1e11, 1e12, 1e13, 1e14, 1e15, 1e16, 1e17, 1e18, 1e19,
	1e20, 1e21, 1e22,
}
let f32_pow10 = []f32{1e0, 1e1, 1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10}

// If possible to convert decimal representation to 64-bit float f exactly,
// entirely in floating-point math, do so, avoiding the expense of decimal_to_float_bits.
// Three common cases:
//  value is exact integer
//  value is exact integer * exact power of ten
//  value is exact integer / exact power of ten
//
// These all produce potentially inexact but correctly rounded answers.
fn atof64_exact(mantissa: u64, exp: int, neg: bool) (f: f64, ok: bool) {
	if mantissa>>f64_info.mantbits != 0 {
		ret
	}
	f = f64(mantissa)
	if neg {
		f = -f
	}
	match {
	case exp == 0:
		// an integer.
		ret f, true
	// Exact integers are <= 10^15.
	// Exact powers of ten are <= 10^22.
	case exp > 0 && exp <= 15+22: // int * 10^k
		// If exponent is big but number of digits is not,
		// can move a few zeros into the integer part.
		if exp > 22 {
			f *= f64_pow10[exp-22]
			exp = 22
		}
		if f > 1e15 || f < -1e15 {
			// the exponent was really too large.
			ret
		}
		ret f * f64_pow10[exp], true
	case exp < 0 && exp >= -22: // int / 10^k
		ret f / f64_pow10[-exp], true
	}
	ret
}

// If possible to convert decimal representation to 64-bit float f exactly,
// entirely in floating-point math, do so, avoiding the expense of decimalToFloatBits.
// Three common cases:
//  value is exact integer
//  value is exact integer * exact power of ten
//  value is exact integer / exact power of ten
// These all produce potentially inexact but correctly rounded answers.
fn atof64exact(mantissa: u64, exp: int, neg: bool) (f: f64, ok: bool) {
	if mantissa>>f64_info.mantbits != 0 {
		ret
	}
	f = f64(mantissa)
	if neg {
		f = -f
	}
	match {
	case exp == 0:
		// an integer.
		ret f, true
	// Exact integers are <= 10^15.
	// Exact powers of ten are <= 10^22.
	case exp > 0 && exp <= 15+22: // int * 10^k
		// If exponent is big but number of digits is not,
		// can move a few zeros into the integer part.
		if exp > 22 {
			f *= f64_pow10[exp-22]
			exp = 22
		}
		if f > 1e15 || f < -1e15 {
			// the exponent was really too large.
			ret
		}
		ret f * f64_pow10[exp], true
	case exp < 0 && exp >= -22: // int / 10^k
		ret f / f64_pow10[-exp], true
	}
	ret
}

// If possible to compute mantissa*10^exp to 32-bit float f exactly,
// entirely in floating-point math, do so, avoiding the machinery above.
fn atof32exact(mantissa: u64, exp: int, neg: bool) (f: f32, ok: bool) {
	if mantissa>>f32_info.mantbits != 0 {
		ret
	}
	f = f32(mantissa)
	if neg {
		f = -f
	}
	match {
	case exp == 0:
		ret f, true
	// Exact integers are <= 10^7.
	// Exact powers of ten are <= 10^10.
	case exp > 0 && exp <= 7+10: // int * 10^k
		// If exponent is big but number of digits is not,
		// can move a few zeros into the integer part.
		if exp > 10 {
			f *= f32_pow10[exp-10]
			exp = 10
		}
		if f > 1e7 || f < -1e7 {
			// the exponent was really too large.
			ret
		}
		ret f * f32_pow10[exp], true
	case exp < 0 && exp >= -10: // int / 10^k
		ret f / f32_pow10[-exp], true
	}
	ret
}

// Converts the hex floating-point string s
// to a rounded f32 or f64 value (depending on flt==&f32_info or flt==&f64_info)
// and returns it as a f64.
// The string s has already been parsed into a mantissa, exponent, and sign (neg==true for negative).
// If trunc is true, trailing non-zero bits have been omitted from the mantissa.
fn atof_hex(s: str, flt: *FloatInfo, mantissa: u64, exp: int, neg: bool, trunc: bool) (f64, Error) {
	let max_exp = 1<<flt.expbits + flt.bias - 2
	let min_exp = flt.bias + 1
	exp += int(flt.mantbits) // mantissa now implicitly divided by 2^mantbits.

	// Shift mantissa and exponent to bring representation into float range.
	// Eventually we want a mantissa with a leading 1-bit followed by mantbits other bits.
	// For rounding, we need two more, where the bottom bit represents
	// whether that bit or any later bit was non-zero.
	// (If the mantissa has already lost non-zero bits, trunc is true,
	// and we OR in a 1 below after shifting left appropriately.)
	for mantissa != 0 && mantissa>>(flt.mantbits+2) == 0 {
		mantissa <<= 1
		exp--
	}
	if trunc {
		mantissa |= 1
	}
	for mantissa>>(1+flt.mantbits+2) != 0 {
		mantissa = mantissa>>1 | mantissa&1
		exp++
	}

	// If exponent is too negative,
	// denormalize in hopes of making it representable.
	// (The -2 is for the rounding bits.)
	for mantissa > 1 && exp < min_exp-2 {
		mantissa = mantissa>>1 | mantissa&1
		exp++
	}

	// Round using two bottom bits.
	let round = mantissa & 3
	mantissa >>= 2
	round |= mantissa & 1 // round to even (round up if mantissa is odd)
	exp += 2
	if round == 3 {
		mantissa++
		if mantissa == 1<<(1+flt.mantbits) {
			mantissa >>= 1
			exp++
		}
	}

	if mantissa>>flt.mantbits == 0 { // Denormal or zero.
		exp = flt.bias
	}
	let err: Error
	if exp > max_exp { // infinity and range error
		mantissa = 1 << flt.mantbits
		exp = max_exp + 1
		err = range_error(FN_PARSE_FLOAT, s)
	}

	let bits = mantissa & (1<<flt.mantbits - 1)
	bits |= u64((exp-flt.bias)&(1<<flt.expbits-1)) << flt.mantbits
	if neg {
		bits |= 1 << flt.mantbits << flt.expbits
	}
	if flt == &f32_info {
		ret f64(std::math::f32_from_bits(u32(bits))), err
	}
	ret std::math::f64_from_bits(bits), err
}

fn atof32(s: str) (f: f32, n: int, err: Error) {
	{
		let (val, _n, ok) = special(s)
		if ok {
			ret f32(val), _n, nil
		}
	}

	let (mantissa, exp, neg, trunc, hex, _n, ok) = read_float(s)
	n = _n
	if !ok {
		ret 0, n, syntax_error(FN_PARSE_FLOAT, s)
	}

	if hex {
		let ff: f64
		ff, err = atof_hex(s[:n], &f32_info, mantissa, exp, neg, trunc)
		ret f32(ff), n, err
	}

	if OPTIMIZE {
		// Try pure floating-point arithmetic conversion, and if that fails,
		// the Eisel-Lemire algorithm.
		if !trunc {
			f, ok = atof32exact(mantissa, exp, neg)
			if ok {
				ret f, n, nil
			}
		}
		f, ok = eisel_lemire32(mantissa, exp, neg)
		if ok {
			if !trunc {
				ret f, n, nil
			}
			// Even if the mantissa was truncated, we may
			// have found the correct result. Confirm by
			// converting the upper mantissa bound.
			let f_up: f32
			f_up, ok = eisel_lemire32(mantissa+1, exp, neg)
			if ok && f == f_up {
				ret f, n, nil
			}
		}
	}

	// Slow fallback.
	let d: Decimal
	if !d.set(s[:n]) {
		ret 0, n, syntax_error(FN_PARSE_FLOAT, s)
	}
	let (b, ovf) = d.float_bits(&f32_info)
	f = std::math::f32_from_bits(u32(b))
	if ovf {
		err = range_error(FN_PARSE_FLOAT, s)
	}
	ret f, n, err
}

fn atof64(s: str) (f: f64, n: int, err: Error) {
	{
		let (val, _n, ok) = special(s)
		if ok {
			ret val, _n, nil
		}
	}

	let (mantissa, exp, neg, trunc, hex, _n, ok) = read_float(s)
	n = _n
	if !ok {
		ret 0, n, syntax_error(FN_PARSE_FLOAT, s)
	}

	if hex {
		f, err = atof_hex(s[:n], &f64_info, mantissa, exp, neg, trunc)
		ret f, n, err
	}

	if OPTIMIZE {
		// Try pure floating-point arithmetic conversion, and if that fails,
		// the Eisel-Lemire algorithm.
		if !trunc {
			f, ok = atof64exact(mantissa, exp, neg)
			if ok {
				ret f, n, nil
			}
		}
		f, ok = eisel_lemire64(mantissa, exp, neg)
		if ok {
			if !trunc {
				ret f, n, nil
			}
			// Even if the mantissa was truncated, we may
			// have found the correct result. Confirm by
			// converting the upper mantissa bound.
			let f_up: f64
			f_up, ok = eisel_lemire64(mantissa+1, exp, neg)
			if ok && f == f_up {
				ret f, n, nil
			}
		}
	}

	// Slow fallback.
	let d: Decimal
	if !d.set(s[:n]) {
		ret 0, n, syntax_error(FN_PARSE_FLOAT, s)
	}
	let (b, ovf) = d.float_bits(&f64_info)
	f = std::math::f64_from_bits(b)
	if ovf {
		err = range_error(FN_PARSE_FLOAT, s)
	}
	ret f, n, err
}

fn parse_float_prefix(s: str, bit_size: int) (f64, int, Error) {
	if bit_size == 32 {
		let (f, n, err) = atof32(s)
		ret f64(f), n, err
	}
	ret atof64(s)
}

// Converts the string s to a floating-point number
// with the precision specified by bit_size: 32 for f32, or 64 for f64.
// When bit_size=32, the result still has type f64, but it will be
// convertible to f32 without changing its value.
//
// Accepts decimal and hexadecimal floating-point numbers
// as defined by the Jule syntax for [floating-point literals].
// If s is well-formed and near a valid floating-point number,
// returns the nearest floating-point number rounded
// using IEEE754 unbiased rounding.
// (Parsing a hexadecimal floating-point value only rounds when
// there are more bits in the hexadecimal representation than
// will fit in the mantissa.)
//
// The errors that returns have concrete type *ConvError
// and include err.Num = s.
//
// If s is not syntactically well-formed, returns err.Err = ERROR_SYNTAX.
//
// If s is syntactically well-formed but is more than 1/2 ULP
// away from the largest floating point number of the given size,
// Returns f = ±inf, err.Error = ERROR_RANGE.
//
// Recognizes the string "nan", and the (possibly signed) strings "inf" and "infinity"
// as their respective special floating point values. It ignores case when matching.
pub fn parse_float(s: str, bit_size: int) (f64, Error) {
	let (f, n, err) = parse_float_prefix(s, bit_size)
	if n != s.len && (err == nil || ( (*ConvError)(err) ).Error  != ERROR_SYNTAX) {
		ret 0, syntax_error(FN_PARSE_FLOAT, s)
	}
	ret f, err
}

// Copyright 2022 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use std::math::bits

// enable fast path for small integers
const FAST_SMALLS = true
const N_SMALLS    = 100
const DIGITS      = "0123456789abcdefghijklmnopqrstuvwxyz"
const HOST_32BIT  = ^uint(0)>>32 == 0

const SMALLS_STR = (
	"00010203040506070809" +
	"10111213141516171819" +
	"20212223242526272829" +
	"30313233343536373839" +
	"40414243444546474849" +
	"50515253545556575859" +
	"60616263646566676869" +
	"70717273747576777879" +
	"80818283848586878889" +
	"90919293949596979899"
)

// Returns the string representation of i in the given base,
// for 2 <= base <= 36. The result uses the lower-case letters 'a' to 'z'
// for digit values >= 10.
pub fn fmt_uint(i: u64, base: int) str {
	if FAST_SMALLS && i < N_SMALLS && base == 10 {
		ret small(int(i))
	}
	let (_, s) = fmt_bits(nil, i, base, false, false)
	ret s
}

// Returns the string representation of i in the given base,
// for 2 <= base <= 36. The result uses the lower-case letters 'a' to 'z'
// for digit values >= 10.
pub fn fmt_int(i: i64, base: int) str {
	if FAST_SMALLS && 0 <= i && i < N_SMALLS && base == 10 {
		ret small(int(i))
	}
	let (_, s) = fmt_bits(nil, u64(i), base, i < 0, false)
	ret s
}

// Is equivalent to fmt_int(i64(i), 10).
pub fn itoa(i: int) str {
	ret fmt_int(i64(i), 10)
}

// Returns the string for an i with 0 <= i < nSmalls.
fn small(i: int) str {
	if i < 10 {
		ret DIGITS[i : i+1]
	}
	ret SMALLS_STR[i*2 : i*2+2]
}

fn is_power_of_two(x: int) bool {
	ret x&(x-1) == 0
}

// Computes the string representation of u in the given base.
// If neg is set, u is treated as negative int64 value. If append_ is
// set, the string is appended to dst and the resulting byte slice is
// returned as the first result value; otherwise the string is returned
// as the second result value.
fn fmt_bits(dst: []byte, mut u: u64, base: int, neg: bool, append_: bool) (d: []byte, s: str) {
	if base < 2 || base > DIGITS.len {
		panic("std::conv: illegal base")
	}
	// 2 <= base && base <= DIGITS.len

	let mut a = [64 + 1]byte{} // +1 for sign of 64bit value in base 2
	let mut i = a.len

	if neg {
		u = -u
	}

	// convert bits
	// We use uint values where we can because those will
	// fit into a single register even on a 32bit machine.
	if base == 10 {
		// common case: use constants for / because
		// the compiler can optimize it into a multiply+shift

		if HOST_32BIT {
			// convert the lower digits using 32bit operations
			for u >= 1e9 {
				// Avoid using r = a%b in addition to q = a/b
				// since 64bit division and modulo operations
				// are calculated by runtime functions on 32bit machines.
				let q = u / 1e9
				let mut us = uint(u - q*1e9) // u % 1e9 fits into a uint
				for let mut j = 4; j > 0; j-- {
					let is = us % 100 * 2
					us /= 100
					i -= 2
					a[i+1] = SMALLS_STR[is+1]
					a[i+0] = SMALLS_STR[is+0]
				}

				// us < 10, since it contains the last digit
				// from the initial 9-digit us.
				i--
				a[i] = SMALLS_STR[us*2+1]

				u = q
			}
			// u < 1e9
		}

		// u guaranteed to fit into a uint
		let mut us = uint(u)
		for us >= 100 {
			let is = us % 100 * 2
			us /= 100
			i -= 2
			a[i+1] = SMALLS_STR[is+1]
			a[i+0] = SMALLS_STR[is+0]
		}

		// us < 100
		let is = us * 2
		i--
		a[i] = SMALLS_STR[is+1]
		if us >= 10 {
			i--
			a[i] = SMALLS_STR[is]
		}
	} else if is_power_of_two(base) {
		// Use shifts and masks instead of / and %.
		// Base is a power of 2 and 2 <= base <= len(digits) where len(digits) is 36.
		// The largest power of 2 below or equal to 36 is 32, which is 1 << 5;
		// i.e., the largest possible shift count is 5. By &-ind that value with
		// the constant 7 we tell the compiler that the shift count is always
		// less than 8 which is smaller than any register width. This allows
		// the compiler to generate better code for the shift operation.
		let shift = uint(std::math::bits::trailing_zeros(uint(base))) & 7
		let b = u64(base)
		let m = uint(base) - 1 // == 1<<shift - 1
		for u >= b {
			i--
			a[i] = DIGITS[uint(u)&m]
			u >>= shift
		}
		// u < base
		i--
		a[i] = DIGITS[uint(u)]
	} else {
		// general case
		let b = u64(base)
		for u >= b {
			i--
			// Avoid using r = a%b in addition to q = a/b
			// since 64bit division and modulo operations
			// are calculated by runtime functions on 32bit machines.
			let q = u / b
			a[i] = DIGITS[uint(u-q*b)]
			u = q
		}
		// u < base
		i--
		a[i] = DIGITS[uint(u)]
	}

	// add sign, if any
	if neg {
		i--
		a[i] = '-'
	}

	if append_ {
		d = append[byte](dst, a[i:]...)
		ret
	}
	s = (str)(a[i:])
	ret
}

// Copyright 2022-2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

// The Jule code is a modified version of the original Go code from
// https://github.com/golang/go/blob/go1.19/src/strconv/itoa.go and came with this notice.
//
// ====================================================
// Copyright (c) 2009 The Go Authors. All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
// 
//    * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//    * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//    * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// ====================================================

use "std/unsafe"
use "std/math/bits"

// enable fast path for small integers
const fastSmalls = true
const nSmalls = 100
const digits = "0123456789abcdefghijklmnopqrstuvwxyz"
const host32bit = ^uint(0)>>32 == 0

const smallsStr = "00010203040506070809" +
	"10111213141516171819" +
	"20212223242526272829" +
	"30313233343536373839" +
	"40414243444546474849" +
	"50515253545556575859" +
	"60616263646566676869" +
	"70717273747576777879" +
	"80818283848586878889" +
	"90919293949596979899"

// Returns the string representation of i in the given base,
// for 2 <= base <= 36. The result uses the lower-case letters 'a' to 'z'
// for digit values >= 10.
fn FmtUint(i: u64, base: int): str {
	if fastSmalls && i < nSmalls && base == 10 {
		ret small(int(i))
	}
	_, s := fmtBits(nil, i, base, false, false)
	ret s
}

// Returns the string representation of i in the given base,
// for 2 <= base <= 36. The result uses the lower-case letters 'a' to 'z'
// for digit values >= 10.
fn FmtInt(i: i64, base: int): str {
	if fastSmalls && 0 <= i && i < nSmalls && base == 10 {
		ret small(int(i))
	}
	_, s := fmtBits(nil, u64(i), base, i < 0, false)
	ret s
}

// Is equivalent to FmtInt(i64(i), 10).
fn Itoa(i: int): str {
	ret FmtInt(i64(i), 10)
}

// Returns the string for an i with 0 <= i < nSmalls.
fn small(i: int): str {
	if i < 10 {
		ret str(byte('0' + i))
	}
	mut buf := make([]byte, 3)
	buf[0] = smallsStr[i<<1]
	buf[1] = smallsStr[i<<1+1]
	ret unsafe::StrFromBytes(buf[:2])
}

fn isPowerOfTwo(x: int): bool {
	ret x&(x-1) == 0
}

// Computes the string representation of u in the given base.
// If neg is set, u is treated as negative int64 value. If append_ is
// set, the string is appended to dst and the resulting byte slice is
// returned as the first result value; otherwise the string is returned
// as the second result value.
fn fmtBits(mut dst: []byte, mut u: u64, base: int, neg: bool, append_: bool): (d: []byte, s: str) {
	if base < 2 || base > len(digits) {
		panic("conv: illegal base")
	}
	// 2 <= base && base <= len(digits)

	mut a := make([]byte, 64+1) // +1 for sign of 64bit value in base 2
	mut i := len(a)

	if neg {
		u = -u
	}

	// convert bits
	// We use uint values where we can because those will
	// fit into a single register even on a 32bit machine.
	match {
	| base == 10:
		// common case: use constants for / because
		// the compiler can optimize it into a multiply+shift

		if host32bit {
			// convert the lower digits using 32bit operations
			for u >= 1e9 {
				// Avoid using r = a%b in addition to q = a/b
				// since 64bit division and modulo operations
				// are calculated by runtime functions on 32bit machines.
				q := u / 1e9
				mut us := uint(u - q*1e9) // u % 1e9 fits into a uint
				mut j := 4
				for j > 0; j-- {
					is := us % 100 * 2
					us /= 100
					i -= 2
					a[i+1] = smallsStr[is+1]
					a[i+0] = smallsStr[is+0]
				}

				// us < 10, since it contains the last digit
				// from the initial 9-digit us.
				i--
				a[i] = smallsStr[us*2+1]

				u = q
			}
			// u < 1e9
		}

		// u guaranteed to fit into a uint
		mut us := uint(u)
		for us >= 100 {
			is := us % 100 * 2
			us /= 100
			i -= 2
			a[i+1] = smallsStr[is+1]
			a[i+0] = smallsStr[is+0]
		}

		// us < 100
		is := us * 2
		i--
		a[i] = smallsStr[is+1]
		if us >= 10 {
			i--
			a[i] = smallsStr[is]
		}
	| isPowerOfTwo(base):
		// Use shifts and masks instead of / and %.
		// Base is a power of 2 and 2 <= base <= len(digits) where len(digits) is 36.
		// The largest power of 2 below or equal to 36 is 32, which is 1 << 5;
		// i.e., the largest possible shift count is 5. By &-ind that value with
		// the constant 7 we tell the compiler that the shift count is always
		// less than 8 which is smaller than any register width. This allows
		// the compiler to generate better code for the shift operation.
		shift := uint(bits::TrailingZeros(uint(base))) & 0b111
		b := u64(base)
		m := uint(base) - 1 // == 1<<shift - 1
		for u >= b {
			i--
			a[i] = digits[uint(u)&m]
			u >>= shift
		}
		// u < base
		i--
		a[i] = digits[uint(u)]
	|:
		// general case
		b := u64(base)
		for u >= b {
			i--
			// Avoid using r = a%b in addition to q = a/b
			// since 64bit division and modulo operations
			// are calculated by runtime functions on 32bit machines.
			q := u / b
			a[i] = digits[uint(u-q*b)]
			u = q
		}
		// u < base
		i--
		a[i] = digits[uint(u)]
	}

	// add sign, if any
	if neg {
		i--
		a[i] = '-'
	}

	if append_ {
		d = append(dst, a[i:]...)
		ret
	}
	n := copy(a, a[i:])
	s = unsafe::StrFromBytes(a[:n])
	ret
}
// Copyright 2022-2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

// The Jule code is a modified version of the original Go code from
// https://github.com/golang/go/blob/go1.19/src/strconv/ftoa.go and came with this notice.
//
// ====================================================
// Copyright (c) 2009 The Go Authors. All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
// 
//    * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//    * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//    * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// ====================================================

use std::unsafe
use math for std::math

struct floatInfo {
    mantbits: uint
    expbits:  uint
    bias:     int
}

static f32info = floatInfo{23, 8, -127}
static f64info = floatInfo{52, 11, -1023}

struct decimalSlice {
    d:   []byte
    nd:  int
    dp:  int
    neg: bool
}

// Converts the floating-point number f to a string,
// according to the format fmt and precision prec. It rounds the
// result assuming that the original was obtained from a floating-point
// value of bitSize bits (32 for f32, 64 for f64).
//
// The format fmt is one of
// 'b' (-ddddp±ddd, a binary exponent),
// 'e' (-d.dddde±dd, a decimal exponent),
// 'E' (-d.ddddE±dd, a decimal exponent),
// 'f' (-ddd.dddd, no exponent),
// 'g' ('e' for large exponents, 'f' otherwise),
// 'G' ('E' for large exponents, 'f' otherwise),
// 'x' (-0xd.ddddp±ddd, a hexadecimal fraction and binary exponent), or
// 'X' (-0Xd.ddddP±ddd, a hexadecimal fraction and binary exponent).
//
// The precision prec controls the number of digits (excluding the exponent)
// printed by the 'e', 'E', 'f', 'g', 'G', 'x', and 'X' formats.
// For 'e', 'E', 'f', 'x', and 'X', it is the number of digits after the decimal point.
// For 'g' and 'G' it is the maximum number of significant digits (trailing
// zeros are removed).
// The special precision -1 uses the smallest number of digits
// necessary such that parse_float will return f exactly.
fn FmtFloat(f: f64, fmt: byte, prec: int, bitSize: int): str {
    // Return value of [genericFtoa] can be converted with [unsafe::StrFromBytes] safely.
    // It returns always head pointer of slice, so deallocation is safe.
    // There is no need to make new allocation for string.
    ret unsafe::StrFromBytes(
        genericFtoa(make([]byte, 0, max(prec + 4 + 1, 24 + 1)), f, fmt, prec, bitSize))
}

fn genericFtoa(mut dst: []byte, val: f64, fmt: byte, mut prec: int, bitSize: int): []byte {
    mut bits := u64(0)
    let mut flt: &floatInfo = nil
    match bitSize {
    | 32:
        bits = u64(math::F32Bits(f32(val)))
        flt = unsafe { (&floatInfo)(&f32info) }
    | 64:
        bits = math::F64Bits(val)
        flt = unsafe { (&floatInfo)(&f64info) }
    |:
        panic("std::conv: illegal bitSize")
    }

    neg := bits>>(flt.expbits + flt.mantbits) != 0
    mut exp := int(bits >> flt.mantbits) & int(1 << flt.expbits - 1)
    mut mant := bits & (u64(1) << flt.mantbits - 1)

    match exp {
    | int(1 << flt.expbits - 1):
        // +inf, NaN
        match {
        | mant != 0:
            ret append(dst, "nan"...)
        | neg:
            ret append(dst, "-inf"...)
        |:
            ret append(dst, "+inf"...)
        }
    | 0:
        // denormalized
        exp++
    |:
        // add implicit top bit
        mant |= u64(1) << flt.mantbits
    }
    exp += flt.bias

    // Pick off easy binary, hex formats.
    if fmt == 'b' {
        ret fmtB(dst, neg, mant, exp, *flt)
    }
    if fmt == 'x' || fmt == 'X' {
        ret fmtX(dst, prec, fmt, neg, mant, exp, *flt)
    }

    if !optimize {
        ret bigFtoa(dst, prec, fmt, neg, mant, exp, *flt)
    }

    mut digs := decimalSlice{}
    mut ok := false
    // Negative precision means "only as much as needed to be exact."
    shortest := prec < 0
    if shortest {
        // Use Ryu algorithm.
        digs.d = make([]byte, 32)
        ryuFtoaShortest(digs, mant, exp - int(flt.mantbits), *flt)
        ok = true
        // Precision for shortest representation mode.
        match fmt {
        | 'e' | 'E':
            prec = max(digs.nd - 1, 0)
        | 'f':
            prec = max(digs.nd - digs.dp, 0)
        | 'g' | 'G':
            prec = digs.nd
        }
    } else if fmt != 'f' {
        // Fixed number of digits.
        mut digits := prec
        match fmt {
        | 'e' | 'E':
            digits++
        | 'g' | 'G':
            if prec == 0 {
                prec = 1
            }
            digits = prec
        |:
            // Invalid mode.
            digits = 1
        }
        if bitSize == 32 && digits <= 9 {
            digs.d = make([]byte, 24)
            ryuFtoaFixed32(digs, u32(mant), exp - int(flt.mantbits), digits)
            ok = true
        } else if digits <= 18 {
            digs.d = make([]byte, 24)
            ryuFtoaFixed64(digs, mant, exp - int(flt.mantbits), digits)
            ok = true
        }
    }
    if !ok {
        ret bigFtoa(dst, prec, fmt, neg, mant, exp, *flt)
    }
    ret fmtDigits(dst, shortest, neg, digs, prec, fmt)
}

// Uses multiprecision computations to format a float.
fn bigFtoa(mut dst: []byte, mut prec: int, fmt: byte, neg: bool,
    mant: u64, exp: int, &flt: floatInfo): []byte {
    mut d := decimal{}
    d.assign(mant)
    d.shift(exp - int(flt.mantbits))
    mut digs := decimalSlice{}
    shortest := prec < 0
    if shortest {
        roundShortest(d, mant, exp, flt)
        digs = decimalSlice{d: d.d[:], nd: d.nd, dp: d.dp}
        // Precision for shortest representation mode.
        match fmt {
        | 'e' | 'E':
            prec = digs.nd - 1
        | 'f':
            prec = max(digs.nd - digs.dp, 0)
        | 'g' | 'G':
            prec = digs.nd
        }
    } else {
        // Round appropriately.
        match fmt {
        | 'e' | 'E':
            d.round(prec + 1)
        | 'f':
            d.round(d.dp + prec)
        | 'g' | 'G':
            if prec == 0 {
                prec = 1
            }
            d.round(prec)
        }
        digs = decimalSlice{d: d.d[:], nd: d.nd, dp: d.dp}
    }
    ret fmtDigits(dst, shortest, neg, digs, prec, fmt)
}

fn fmtDigits(mut dst: []byte, shortest: bool, neg: bool,
    digs: decimalSlice, mut prec: int, fmt: byte): []byte {
    match fmt {
    | 'e' | 'E':
        ret fmtE(dst, neg, digs, prec, fmt)
    | 'f':
        ret fmtF(dst, neg, digs, prec)
    | 'g' | 'G':
        // trailing fractional zeros in 'e' form will be trimmed.
        mut eprec := prec
        if eprec > digs.nd && digs.nd >= digs.dp {
            eprec = digs.nd
        }
        // %e is used if the exponent from the conversion
        // is less than -4 or greater than or equal to the precision.
        // if precision was the shortest possible, use precision 6 for this decision.
        if shortest {
            eprec = 6
        }
        exp := digs.dp - 1
        if exp < -4 || exp >= eprec {
            if prec > digs.nd {
                prec = digs.nd
            }
            ret fmtE(dst, neg, digs, prec - 1, fmt + 'e' - 'g')
        }
        if prec > digs.dp {
            prec = digs.nd
        }
        ret fmtF(dst, neg, digs, max(prec - digs.dp, 0))
    }

    // unknown format
    ret append(dst, '%', fmt)
}

// Rounds d (= mant * 2^exp) to the shortest number of digits
// that will let the original floating point value be precisely reconstructed.
fn roundShortest(mut &d: decimal, mant: u64, exp: int, &flt: floatInfo) {
    // If mantissa is zero, the number is zero; stop now.
    if mant == 0 {
        d.nd = 0
        ret
    }

    // Compute upper and lower such that any decimal number
    // between upper and lower (possibly inclusive)
    // will round to the original floating point number.

    // We may see at once that the number is already shortest.
    //
    // Suppose d is not denormal, so that 2^exp <= d < 10^dp.
    // The closest shorter number is at least 10^(dp-nd) away.
    // The lower/upper bounds computed below are at distance
    // at most 2^(exp-mantbits).
    //
    // So the number is already shortest if 10^(dp-nd) > 2^(exp-mantbits),
    // or equivalently log2(10)*(dp-nd) > exp-mantbits.
    // It is true if 332/100*(dp-nd) >= exp-mantbits (log2(10) > 3.32).
    minexp := flt.bias + 1 // minimum possible exponent
    if exp > minexp && 332*(d.dp-d.nd) >= 100*(exp-int(flt.mantbits)) {
        // The number is already shortest.
        ret
    }

    // d = mant << (exp - mantbits)
    // Next highest floating point number is mant+1 << exp-mantbits.
    // Our upper bound is halfway between, mant*2+1 << exp-mantbits-1.
    mut upper := decimal{}
    upper.assign(mant * 2 + 1)
    upper.shift(exp - int(flt.mantbits) - 1)

    // d = mant << (exp - mantbits)
    // Next lowest floating point number is mant-1 << exp-mantbits,
    // unless mant-1 drops the significant bit and exp is not the minimum exp,
    // in which case the next lowest is mant*2-1 << exp-mantbits-1.
    // Either way, call it mantlo << explo-mantbits.
    // Our lower bound is halfway between, mantlo*2+1 << explo-mantbits-1.
    mut mantlo := u64(0)
    mut explo := 0
    if mant > 1<<flt.mantbits || exp == minexp {
        mantlo = mant - 1
        explo = exp
    } else {
        mantlo = mant * 2 - 1
        explo = exp - 1
    }
    mut lower := decimal{}
    lower.assign(mantlo * 2 + 1)
    lower.shift(explo - int(flt.mantbits) - 1)

    // The upper and lower bounds are possible outputs only if
    // the original mantissa is even, so that IEEE round-to-even
    // would round to the original mantissa and not the neighbors.
    inclusive := mant%2 == 0

    // As we walk the digits we want to know whether rounding up would fall
    // within the upper bound. This is tracked by upperdelta:
    //
    // If upperdelta == 0, the digits of d and upper are the same so far.
    //
    // If upperdelta == 1, we saw a difference of 1 between d and upper on a
    // previous digit and subsequently only 9s for d and 0s for upper.
    // (Thus rounding up may fall outside the bound, if it is exclusive.)
    //
    // If upperdelta == 2, then the difference is greater than 1
    // and we know that rounding up falls within the bound.
    mut upperdelta := u8(0)

    // Now we can figure out the minimum number of digits required.
    // Walk along until d has distinguished itself from upper and lower.
    mut ui := 0
    for ; ui++ {
        // lower, d, and upper may have the decimal points at different
        // places. In this case upper is the longest, so we iterate from
        // ui==0 and start li and mi at (possibly) -1.
        mi := ui - upper.dp + d.dp
        if mi >= d.nd {
            break
        }
        li := ui - upper.dp + lower.dp
        mut l := byte('0') // lower digit
        if li >= 0 && li < lower.nd {
            l = lower.d[li]
        }
        mut m := byte('0') // middle digit
        if mi >= 0 {
            m = d.d[mi]
        }
        mut u := byte('0') // upper digit
        if ui < upper.nd {
            u = upper.d[ui]
        }

        // Okay to round down (truncate) if lower has a different digit
        // or if lower is inclusive and is exactly the result of rounding
        // down (i.e., and we have reached the final digit of lower).
        okdown := l != m || inclusive && li+1 == lower.nd

        match {
        | upperdelta == 0 && m+1 < u:
            // Example:
            // m = 12345xxx
            // u = 12347xxx
            upperdelta = 2
        | upperdelta == 0 && m != u:
            // Example:
            // m = 12345xxx
            // u = 12346xxx
            upperdelta = 1
        | upperdelta == 1 && (m != '9' || u != '0'):
            // Example:
            // m = 1234598x
            // u = 1234600x
            upperdelta = 2
        }
        // Okay to round up if upper has a different digit and either upper
        // is inclusive or upper is bigger than the result of rounding up.
        okup := upperdelta > 0 && (inclusive || upperdelta > 1 || ui+1 < upper.nd)

        // If it's okay to do either, then round to the nearest one.
        // If it's okay to do only one, do it.
        match {
        | okdown && okup:
            d.round(mi + 1)
            ret
        | okdown:
            d.roundDown(mi + 1)
            ret
        | okup:
            d.roundUp(mi + 1)
            ret
        }
    }
}

// %e: -d.ddddde±dd
fn fmtE(mut dst: []byte, neg: bool, d: decimalSlice, prec: int, fmt: byte): []byte {
    // sign
    if neg {
        dst = append(dst, '-')
    }

    // first digit
    mut ch := '0'
    if d.nd != 0 {
        ch = d.d[0]
    }
    dst = append(dst, ch)

    // .moredigits
    if prec > 0 {
        dst = append(dst, '.')
        mut i := 1
        m := min(d.nd, prec + 1)
        if i < m {
            dst = append(dst, d.d[i:m]...)
            i = m
        }
        for i <= prec; i++ {
            dst = append(dst, '0')
        }
    }

    // e±
    dst = append(dst, fmt)
    mut exp := d.dp - 1
    if d.nd == 0 { // special case: 0 has exponent 0
        exp = 0
    }
    if exp < 0 {
        ch = '-'
        exp = -exp
    } else {
        ch = '+'
    }
    dst = append(dst, ch)

    // dd or ddd
    match {
    | exp < 10:
        dst = append(dst, '0', byte(exp) + '0')
    | exp < 100:
        dst = append(dst, byte(exp / 10) + '0', byte(exp % 10) + '0')
    |:
        dst = append(dst, byte(exp / 100) + '0', byte(exp / 10) % 10 + '0', byte(exp % 10) + '0')
    }

    ret dst
}

// %f: -ddddddd.ddddd
fn fmtF(mut dst: []byte, neg: bool, d: decimalSlice, prec: int): []byte {
    // sign
    if neg {
        dst = append(dst, '-')
    }

    // integer, padded with zeros as needed.
    if d.dp > 0 {
        mut m := min(d.nd, d.dp)
        dst = append(dst, d.d[:m]...)
        for m < d.dp; m++ {
            dst = append(dst, '0')
        }
    } else {
        dst = append(dst, '0')
    }
    // fraction
    if prec > 0 {
        dst = append(dst, '.')
        mut i := 0
        for i < prec; i++ {
            mut ch := byte('0')
            j := d.dp + i
            if 0 <= j && j < d.nd {
                ch = d.d[j]
            }
            dst = append(dst, ch)
        }
    }
    ret dst
}

// %b: -ddddddddp±ddd
fn fmtB(mut dst: []byte, neg: bool, mant: u64, mut exp: int, &flt: floatInfo): []byte {
    // sign
    if neg {
        dst = append(dst, '-')
    }

    // mantissa
    dst, _ = fmtBits(dst, mant, 10, false, true)

    // p
    dst = append(dst, 'p')

    // ±exponent
    exp -= int(flt.mantbits)
    if exp >= 0 {
        dst = append(dst, '+')
    }
    dst, _ = fmtBits(dst, u64(exp), 10, exp < 0, true)
    ret dst
}

// %x: -0x1.yyyyyyyyp±ddd or -0x0p+0. (y is hex digit, d is decimal digit)
fn fmtX(mut dst: []byte, prec: int, fmt: byte, neg: bool,
    mut mant: u64, mut exp: int, &flt: floatInfo): []byte {
    if mant == 0 {
        exp = 0
    }

    // Shift digits so leading 1 (if any) is at bit 1<<60.
    mant <<= 60 - flt.mantbits
    for mant != 0 && mant&(1<<60) == 0 {
        mant <<= 1
        exp--
    }

    // Round if requested.
    if prec >= 0 && prec < 15 {
        shift := uint(prec * 4)
        extra := (mant << shift) & (1 << 60 - 1)
        mant >>= 60 - shift
        if extra|(mant & 1) > 1<<59 {
            mant++
        }
        mant <<= 60 - shift
        if mant&(1 << 61) != 0 {
            // Wrapped around.
            mant >>= 1
            exp++
        }
    }

    mut hex := ""
    if fmt == 'X' {
        hex = upperhex
    } else {
        hex = lowerhex
    }

    // sign, 0x, leading digit
    if neg {
        dst = append(dst, '-')
    }
    dst = append(dst, '0', fmt, '0' + byte((mant >> 60) & 1))

    // .fraction
    mant <<= 4 // remove leading 0 or 1
    if prec < 0 && mant != 0 {
        dst = append(dst, '.')
        for mant != 0 {
            dst = append(dst, hex[(mant>>60)&15])
            mant <<= 4
        }
    } else if prec > 0 {
        dst = append(dst, '.')
        mut i := 0
        for i < prec; i++ {
            dst = append(dst, hex[(mant>>60)&15])
            mant <<= 4
        }
    }

    // p±
    mut ch := byte('P')
    if fmt == lower(fmt) {
        ch = 'p'
    }
    dst = append(dst, ch)
    if exp < 0 {
        ch = '-'
        exp = -exp
    } else {
        ch = '+'
    }
    dst = append(dst, ch)

    // dd or ddd or dddd
    match {
    | exp < 100:
        dst = append(dst, byte(exp / 10) + '0', byte(exp % 10) + '0')
    | exp < 1000:
        dst = append(dst, byte(exp / 100) + '0', byte((exp / 10) % 10) + '0', byte(exp % 10) + '0')
    |:
        dst = append(dst, byte(exp / 1000) + '0', byte(exp / 100) % 10 + '0', byte((exp / 10) % 10) + '0', byte(exp % 10) + '0')
    }
    ret dst
}

fn min(a: int, b: int): int {
    if a < b {
        ret a
    }
    ret b
}

fn max(a: int, b: int): int {
    if a > b {
        ret a
    }
    ret b
}
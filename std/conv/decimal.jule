// Copyright 2022 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

// Multiprecision decimal numbers.
// For floating-point formatting only; not general purpose.
// Only operations are assign and (binary) left/right shift.
// Can do binary floating point in multiprecision decimal precisely
// because 2 divides 10; cannot do decimal floating point
// in multiprecision binary precisely.

// Maximum shift that we can do in one pass without overflow.
// A uint has 32 or 64 bits, and we have to be able to accommodate 9<<k.
const uint_size = 32 << (^uint(0) >> 63)
const max_shift = uint_size - 4

// Cheat sheet for left shift: table indexed by shift count giving
// number of new digits that will be introduced by that shift.
//
// For example, leftcheats[4] = {2, "625"}.  That means that
// if we are shifting by 4 (multiplying by 16), it will add 2 digits
// when the string prefix is "625" through "999", and one fewer digit
// if the string prefix is "000" through "624".
//
// Credit for this trick goes to Ken.

struct LeftCheat {
	delta : int // number of new digits
	cutoff: str // minus one digit if original < a.
}

let leftcheats = []LeftCheat{
	// Leading digits of 1/2^i = 5^i.
	// 5^23 is not an exact 64-bit floating point number,
	// so have to use bc for the math.
	// Go up to 60 to be large enough for 32bit and 64bit platforms.
	/*
		seq 60 | sed 's/^/5^/' | bc |
		awk 'BEGIN{ print "\t{ 0, \"\" }," }
		{
			log2 = log(2)/log(10)
			printf("\t{ %d, \"%s\" },\t// * %d\n",
				int(log2*NR+1), $0, 2**NR)
		}'
	*/
	LeftCheat{0, ""},
	LeftCheat{1, "5"},                                           // * 2
	LeftCheat{1, "25"},                                          // * 4
	LeftCheat{1, "125"},                                         // * 8
	LeftCheat{2, "625"},                                         // * 16
	LeftCheat{2, "3125"},                                        // * 32
	LeftCheat{2, "15625"},                                       // * 64
	LeftCheat{3, "78125"},                                       // * 128
	LeftCheat{3, "390625"},                                      // * 256
	LeftCheat{3, "1953125"},                                     // * 512
	LeftCheat{4, "9765625"},                                     // * 1024
	LeftCheat{4, "48828125"},                                    // * 2048
	LeftCheat{4, "244140625"},                                   // * 4096
	LeftCheat{4, "1220703125"},                                  // * 8192
	LeftCheat{5, "6103515625"},                                  // * 16384
	LeftCheat{5, "30517578125"},                                 // * 32768
	LeftCheat{5, "152587890625"},                                // * 65536
	LeftCheat{6, "762939453125"},                                // * 131072
	LeftCheat{6, "3814697265625"},                               // * 262144
	LeftCheat{6, "19073486328125"},                              // * 524288
	LeftCheat{7, "95367431640625"},                              // * 1048576
	LeftCheat{7, "476837158203125"},                             // * 2097152
	LeftCheat{7, "2384185791015625"},                            // * 4194304
	LeftCheat{7, "11920928955078125"},                           // * 8388608
	LeftCheat{8, "59604644775390625"},                           // * 16777216
	LeftCheat{8, "298023223876953125"},                          // * 33554432
	LeftCheat{8, "1490116119384765625"},                         // * 67108864
	LeftCheat{9, "7450580596923828125"},                         // * 134217728
	LeftCheat{9, "37252902984619140625"},                        // * 268435456
	LeftCheat{9, "186264514923095703125"},                       // * 536870912
	LeftCheat{10, "931322574615478515625"},                      // * 1073741824
	LeftCheat{10, "4656612873077392578125"},                     // * 2147483648
	LeftCheat{10, "23283064365386962890625"},                    // * 4294967296
	LeftCheat{10, "116415321826934814453125"},                   // * 8589934592
	LeftCheat{11, "582076609134674072265625"},                   // * 17179869184
	LeftCheat{11, "2910383045673370361328125"},                  // * 34359738368
	LeftCheat{11, "14551915228366851806640625"},                 // * 68719476736
	LeftCheat{12, "72759576141834259033203125"},                 // * 137438953472
	LeftCheat{12, "363797880709171295166015625"},                // * 274877906944
	LeftCheat{12, "1818989403545856475830078125"},               // * 549755813888
	LeftCheat{13, "9094947017729282379150390625"},               // * 1099511627776
	LeftCheat{13, "45474735088646411895751953125"},              // * 2199023255552
	LeftCheat{13, "227373675443232059478759765625"},             // * 4398046511104
	LeftCheat{13, "1136868377216160297393798828125"},            // * 8796093022208
	LeftCheat{14, "5684341886080801486968994140625"},            // * 17592186044416
	LeftCheat{14, "28421709430404007434844970703125"},           // * 35184372088832
	LeftCheat{14, "142108547152020037174224853515625"},          // * 70368744177664
	LeftCheat{15, "710542735760100185871124267578125"},          // * 140737488355328
	LeftCheat{15, "3552713678800500929355621337890625"},         // * 281474976710656
	LeftCheat{15, "17763568394002504646778106689453125"},        // * 562949953421312
	LeftCheat{16, "88817841970012523233890533447265625"},        // * 1125899906842624
	LeftCheat{16, "444089209850062616169452667236328125"},       // * 2251799813685248
	LeftCheat{16, "2220446049250313080847263336181640625"},      // * 4503599627370496
	LeftCheat{16, "11102230246251565404236316680908203125"},     // * 9007199254740992
	LeftCheat{17, "55511151231257827021181583404541015625"},     // * 18014398509481984
	LeftCheat{17, "277555756156289135105907917022705078125"},    // * 36028797018963968
	LeftCheat{17, "1387778780781445675529539585113525390625"},   // * 72057594037927936
	LeftCheat{18, "6938893903907228377647697925567626953125"},   // * 144115188075855872
	LeftCheat{18, "34694469519536141888238489627838134765625"},  // * 288230376151711744
	LeftCheat{18, "173472347597680709441192448139190673828125"}, // * 576460752303423488
	LeftCheat{19, "867361737988403547205962240695953369140625"}, // * 1152921504606846976
}

struct Decimal {
	d    : [800]byte // digits, big-endian representation
	nd   : int       // number of digits used
	dp   : int       // decimal point
	neg  : bool      // negative flag
	trunc: bool      // discarded nonzero digits beyond d[:nd]
}

impl Decimal {
	// Assign v.
	fn assign(mut self, mut v: u64) {
		let mut buf: [24]byte

		// Write reversed decimal in buf.
		let mut n = 0
		for v > 0 {
			let v1 = v / 10
			v -= 10 * v1
			buf[n] = byte(v + '0')
			n++
			v = v1
		}

		// Reverse again to produce forward decimal in a.d.
		self.nd = 0
		for n--; n >= 0; n-- {
			self.d[self.nd] = buf[n]
			self.nd++
		}
		self.dp = self.nd
		unsafe{ trim(&self) }
	}

	// Binary shift left (k > 0) or right (k < 0).
	fn shift(mut self, mut k: int) {
		match {
		case self.nd == 0:
			// nothing to do: a == 0
		case k > 0:
			for k > max_shift {
				unsafe{ left_shift(&self, max_shift) }
				k -= max_shift
			}
			unsafe{ left_shift(&self, uint(k)) }
		case k < 0:
			for k < -max_shift {
				unsafe{ right_shift(&self, max_shift) }
				k += max_shift
			}
			unsafe{ right_shift(&self, uint(-k)) }
		}
	}

	// Round a down to nd digits (or fewer).
	fn round_down(mut self, nd: int) {
		if nd < 0 || nd >= self.nd {
			ret
		}
		self.nd = nd
		unsafe{ trim(&self) }
	}

	// Round a up to nd digits (or fewer).
	fn round_up(mut self, nd: int) {
		if nd < 0 || nd >= self.nd {
			ret
		}

		// round up
		for let mut i = nd - 1; i >= 0; i-- {
			let c = self.d[i]
			if c < '9' { // can stop after this digit
				self.d[i]++
				self.nd = i + 1
				ret
			}
		}

		// Number is all 9s.
		// Change to single 1 with adjusted decimal point.
		self.d[0] = '1'
		self.nd = 1
		self.dp++
	}

	// Round a to nd digits (or fewer).
	// If nd is zero, it means we're rounding
	// just to the left of the digits, as in
	// 0.09 -> 0.1.
	fn round(mut self, nd: int) {
		if nd < 0 || nd >= self.nd {
			ret
		}
		if (unsafe{ should_round_up(&self, nd) }) {
			self.round_up(nd)
		} else {
			self.round_down(nd)
		}
	}

	// Extract integer part, rounded appropriately.
	// No guarantees about overflow.
	fn rounded_integer(mut self) u64 {
		if self.dp > 20 {
			ret 0xFFFFFFFFFFFFFFFF
		}
		let mut i: int
		let mut n: u64 = 0
		for i = 0; i < self.dp && i < self.nd; i++ {
			n = n*10 + u64(self.d[i]-'0')
		}
		for ; i < self.dp; i++ {
			n *= 10
		}
		if (unsafe{ should_round_up(&self, self.dp) }) {
			n++
		}
		ret n
	}
}

fn digit_zero(mut dst: []byte) int {
	for i in dst {
		dst[i] = '0'
	}
	ret dst.len
}

// Trailing zeros from number.
// (They are meaningless; the decimal point is tracked
// independent of the number of digits.)
unsafe fn trim(mut a: *Decimal) {
	for a.nd > 0 && a.d[a.nd-1] == '0' {
		a.nd--
	}
	if a.nd == 0 {
		a.dp = 0
	}
}

// Binary shift right (/ 2) by k bits.  k <= maxShift to avoid overflow.
unsafe fn right_shift(mut a: *Decimal, k: uint) {
	let mut r = 0 // read pointer
	let mut w = 0 // write pointer

	// Pick up enough leading digits to cover first shift.
	let mut n: uint
	for ; n>>k == 0; r++ {
		if r >= a.nd {
			if n == 0 {
				// a == 0; shouldn't get here, but handle anyway.
				a.nd = 0
				ret
			}
			for n>>k == 0 {
				n = n * 10
				r++
			}
			break
		}
		let c = uint(a.d[r])
		n = n*10 + c - '0'
	}
	a.dp -= r - 1

	let mask: uint = (1 << k) - 1

	// Pick up a digit, put down a digit.
	for ; r < a.nd; r++ {
		let c = uint(a.d[r])
		let dig = n >> k
		n &= mask
		a.d[w] = byte(dig + '0')
		w++
		n = n*10 + c - '0'
	}

	// Put down extra digits.
	for n > 0 {
		let dig = n >> k
		n &= mask
		if w < a.d.len {
			a.d[w] = byte(dig + '0')
			w++
		} else if dig > 0 {
			a.trunc = true
		}
		n = n * 10
	}

	a.nd = w
	trim(a)
}

// Is the leading prefix of b lexicographically less than s?
fn prefix_is_less_than(b: []byte, s: str) bool {
	for let mut i = 0; i < s.len; i++ {
		if i >= b.len {
			ret true
		}
		if b[i] != s[i] {
			ret b[i] < s[i]
		}
	}
	ret false
}

// Binary shift left (* 2) by k bits.  k <= maxShift to avoid overflow.
unsafe fn left_shift(mut a: *Decimal, k: uint) {
	let mut delta = leftcheats[k].delta
	if prefix_is_less_than(a.d[0:a.nd], leftcheats[k].cutoff) {
		delta--
	}

	let mut r = a.nd         // read index
	let mut w = a.nd + delta // write index

	// Pick up a digit, put down a digit.
	let mut n: uint
	for r--; r >= 0; r-- {
		n += (uint(a.d[r]) - '0') << k
		let quo = n / 10
		let rem = n - 10*quo
		w--
		if w < a.d.len {
			a.d[w] = byte(rem + '0')
		} else if rem != 0 {
			a.trunc = true
		}
		n = quo
	}

	// Put down extra digits.
	for n > 0 {
		let quo = n / 10
		let rem = n - 10*quo
		w--
		if w < a.d.len {
			a.d[w] = byte(rem + '0')
		} else if rem != 0 {
			a.trunc = true
		}
		n = quo
	}

	a.nd += delta
	if a.nd >= a.d.len {
		a.nd = a.d.len
	}
	a.dp += delta
	trim(a)
}

// If we chop a at nd digits, should we round up?
unsafe fn should_round_up(a: *Decimal, nd: int) bool {
	if nd < 0 || nd >= a.nd {
		ret false
	}
	if a.d[nd] == '5' && nd+1 == a.nd { // exactly halfway - round to even
		// if we truncated, a little higher than what's recorded - always round up
		if a.trunc {
			ret true
		}
		ret nd > 0 && (a.d[nd-1]-'0')%2 != 0
	}
	// not halfway - digit tells all
	ret a.d[nd] >= '5'
}

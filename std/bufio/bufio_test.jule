// Copyright 2025 The Jule Project Contributors. All rights reserved.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/bytes"
use "std/conv"
use "std/errors"
use "std/fmt"
use "std/io"
use "std/math/rand"
use "std/strings"
use "std/testing"
use "std/testing/iotest"
use "std/unicode/utf8"
use "std/unsafe"

// Reads from a reader and rot13s the result.
struct rot13Reader {
	r: io::Reader
}

fn newRot13Reader(mut r: io::Reader): &rot13Reader {
	mut r13 := new(rot13Reader)
	r13.r = r
	ret r13
}

impl io::Reader for rot13Reader {
	async fn Read(mut *self, mut p: []byte)!: int {
		n := self.r.Read(p).await?
		mut i := 0
		for i < n; i++ {
			c := p[i] | 0x20 // lowercase byte
			if 'a' <= c && c <= 'm' {
				p[i] += 13
			} else if 'n' <= c && c <= 'z' {
				p[i] -= 13
			}
		}
		ret n
	}
}

// Call ReadByte to accumulate the text of a file
async fn readBytes(mut buf: &Reader): str {
	let mut b: [1000]byte
	mut nb := 0
	for {
		c, n := buf.ReadByte().await!
		if n == io::EOF {
			break
		}
		b[nb] = c
		nb++
	}
	ret str(b[0:nb])
}

#test
async fn testReaderSimple(t: &testing::T) {
	data := "hello world"
	mut b := Reader.New(strings::Reader.New(data).Async())
	mut s := readBytes(b).await
	if s != "hello world" {
		t.Errorf("simple hello world test failed: got {}", s)
	}

	b = Reader.New(newRot13Reader(strings::Reader.New(data).Async()))
	s = readBytes(b).await
	if s != "uryyb jbeyq" {
		t.Errorf("rot13 hello world test failed: got {}", s)
	}
}

struct readMaker {
	name: str
	fnc:  fn(mut io::Reader): io::Reader
}

let readMakers: []readMaker = [
	{"full", fn(mut r: io::Reader): io::Reader { ret r }},
	{"byte", iotest::OneByteReader},
	{"half", iotest::HalfReader},
	{"data+err", iotest::DataErrReader},
]

// Call ReadStr (which ends up calling everything else)
// to accumulate the text of a file.
async fn readLines(mut b: &Reader): str {
	mut s := ""
	for {
		s1, eof := b.ReadStr('\n').await!
		s += s1
		if eof {
			break
		}
	}
	ret s
}

// Call Read to accumulate the text of a file
async fn reads(mut buf: &Reader, m: int): str {
	let mut b: [1000]byte
	mut bs := unsafe::Slice(&b[0], 1000, 1000)
	mut nb := 0
	for {
		n := buf.Read(bs[nb : nb+m]).await!
		if n == io::EOF {
			break
		}
		nb += n
	}
	ret str(b[0:nb])
}

struct bufReader {
	name: str
	fnc:  async fn(mut &Reader): str
}

let bufreaders: []bufReader = [
	{"1", async fn(mut b: &Reader): str { ret reads(b, 1).await }},
	{"2", async fn(mut b: &Reader): str { ret reads(b, 2).await }},
	{"3", async fn(mut b: &Reader): str { ret reads(b, 3).await }},
	{"4", async fn(mut b: &Reader): str { ret reads(b, 4).await }},
	{"5", async fn(mut b: &Reader): str { ret reads(b, 5).await }},
	{"7", async fn(mut b: &Reader): str { ret reads(b, 7).await }},
	{"bytes", readBytes},
	{"lines", readLines},
]

let bufsizes = [
	0, minReadBufferSize, 23, 32, 46, 64, 93, 128, 1024, 4096,
]

#test
async fn testReader(t: &testing::T) {
	let mut texts: [31]str
	mut strn := ""
	mut all := ""
	mut i := 0
	for i < len(texts)-1; i++ {
		texts[i] = strn + "\n"
		all += texts[i]
		strn += str(rune(i%26 + 'a'))
	}
	texts[len(texts)-1] = all

	mut h := 0
	for h < len(texts); h++ {
		text := texts[h]
		i = 0
		for i < len(readMakers); i++ {
			mut j := 0
			for j < len(bufreaders); j++ {
				mut k := 0
				for k < len(bufsizes); k++ {
					readmaker := readMakers[i]
					bufreader := bufreaders[j]
					bufsize := bufsizes[k]
					mut read := readmaker.fnc(strings::Reader.New(text).Async())
					mut buf := Reader.NewSize(read, bufsize)
					s := bufreader.fnc(buf).await
					if s != text {
						t.Errorf("reader={} fn={} bufsize={} want={} got={}",
							readmaker.name, bufreader.name, bufsize, []byte(text), []byte(s))
					}
				}
			}
		}
	}
}

struct zeroReader{}

impl io::Reader for zeroReader {
	async fn Read(mut *self, p: []byte)!: int {
		ret 0
	}
}

#test
async fn testZeroReader(t: &testing::T) {
	let mut z: zeroReader
	mut r := Reader.New(z)

	mut c := make(chan any)
	co async fn() {
		r.ReadByte().await else {
			c <- error
		}
	}()

	err := <-c
	if err == nil {
		t.Errorf("error expected")
	} else if err != io::ErrNoProgress {
		t.Errorf("unexpected error: {}", err)
	}
}

// Delivers its data one string segment at a time via Read.
struct StrReader {
	data: []str
	step: int
}

impl io::Reader for StrReader {
	async fn Read(mut *self, mut p: []byte)!: (n: int) {
		if self.step < len(self.data) {
			s := self.data[self.step]
			n = copy(p, s)
			self.step++
		} else {
			ret io::EOF
		}
		ret
	}
}

async fn readRuneSegments(t: &testing::T, mut segments: []str) {
	mut got := ""
	want := strings::Join(segments, "")
	mut r := Reader.New(&StrReader{data: segments})
	for {
		rn, n := r.ReadRune().await else { ret }
		if n == io::EOF {
			break
		}
		got += str(rn)
	}
	if got != want {
		t.Errorf("segments={} got={} want={}", segments, got, want)
	}
}

let mut segmentList: [][]str = [
	[],
	[""],
	["日", "本語"],
	["\u65e5", "\u672c", "\u8a9e"],
	["\U000065e5", "\U0000672c", "\U00008a9e"],
	["\xe6", "\x97\xa5\xe6", "\x9c\xac\xe8\xaa\x9e"],
	["Hello", ", ", "World", "!"],
	["Hello", ", ", "", "World", "!"],
]

#test
async fn testReadRune(t: &testing::T) {
	for (_, mut s) in segmentList {
		readRuneSegments(t, s).await
	}
}

#test
async fn testUnreadRune(t: &testing::T) {
	mut segments := ["Hello, world:", "日本語"]
	mut r := Reader.New(&StrReader{data: segments})
	mut got := ""
	want := strings::Join(segments, "")
	// Normal execution.
	for {
		r1, mut n := r.ReadRune().await else {
			t.Errorf("unexpected error on ReadRune: {}", error)
			break
		}
		if n == io::EOF {
			break
		}
		got += str(r1)
		// Put it back and read it again.
		r.UnreadRune().await else {
			t.Errorf("unexpected error on UnreadRune: {}", error)
			ret
		}
		r2, n := r.ReadRune().await else {
			t.Errorf("unexpected error reading after unreading: {}", error)
			ret
		}
		if n == io::EOF {
			t.Errorf("unexpected EOF")
			ret
		}
		if r1 != r2 {
			t.Errorf("incorrect rune after unread: got {}, want {}", r1, r2)
			ret
		}
	}
	if got != want {
		t.Errorf("got {}, want {}", got, want)
	}
}

#test
async fn testNoUnreadRuneAfterPeek(t: &testing::T) {
	mut br := Reader.New(strings::Reader.New("example").Async())
	br.ReadRune().await!
	br.Peek(1).await!
	br.UnreadRune().await else { ret }
	t.Errorf("UnreadRune didn't fail after Peek")
}

#test
async fn testNoUnreadByteAfterPeek(t: &testing::T) {
	mut br := Reader.New(strings::Reader.New("example").Async())
	br.ReadByte().await!
	br.Peek(1).await!
	br.UnreadByte().await else { ret }
	t.Errorf("UnreadByte didn't fail after Peek")
}

#test
async fn testNoUnreadRuneAfterDiscard(t: &testing::T) {
	mut br := Reader.New(strings::Reader.New("example").Async())
	br.ReadRune().await!
	br.Discard(1).await!
	br.UnreadRune().await else { ret }
	t.Errorf("UnreadRune didn't fail after Discard")
}

#test
async fn testNoUnreadByteAfterDiscard(t: &testing::T) {
	mut br := Reader.New(strings::Reader.New("example").Async())
	br.ReadByte().await!
	br.Discard(1).await!
	br.UnreadByte().await else { ret }
	t.Errorf("UnreadByte didn't fail after Discard")
}

#test
async fn testNoUnreadRuneAfterWriteTo(t: &testing::T) {
	mut br := Reader.New(strings::Reader.New("example").Async())
	br.WriteTo(io::Discard).await!
	br.UnreadRune().await else { ret }
	t.Errorf("UnreadRune didn't fail after WriteTo")
}

#test
async fn testNoUnreadByteAfterWriteTo(t: &testing::T) {
	mut br := Reader.New(strings::Reader.New("example").Async())
	br.WriteTo(io::Discard).await!
	br.UnreadByte().await else { ret }
	t.Errorf("UnreadByte didn't fail after WriteTo")
}

#test
async fn testUnreadByte(t: &testing::T) {
	mut segments := ["Hello, ", "world"]
	mut r := Reader.New(&StrReader{data: segments})
	mut got := ""
	want := strings::Join(segments, "")
	// Normal execution.
	for {
		b1, mut n := r.ReadByte().await else {
			t.Errorf("unexpected error on ReadByte: {}", error)
			break
		}
		if n == io::EOF {
			break
		}
		got += str(b1)
		// Put it back and read it again.
		r.UnreadByte().await else {
			t.Errorf("unexpected error on UnreadByte: {}", error)
			ret
		}
		b2, n := r.ReadByte().await else {
			t.Errorf("unexpected error reading after unreading: {}", error)
			ret
		}
		if n == io::EOF {
			t.Errorf("unexpected EOF")
			ret
		}
		if b1 != b2 {
			t.Errorf("incorrect byte after unread: got {}, want {}", b1, b2)
			ret
		}
	}
	if got != want {
		t.Errorf("got {}, want {}", got, want)
	}
}

#test
async fn testUnreadByteMultiple(t: &testing::T) {
	mut segments := ["Hello, ", "world"]
	data := strings::Join(segments, "")
	mut n := 0
	for n <= len(data); n++ {
		mut r := Reader.New(&StrReader{data: segments})
		// Read n bytes.
		mut i := 0
		for i < n; i++ {
			b, size := r.ReadByte().await else {
				t.Errorf("n = {}: unexpected error on ReadByte: {}", n, error)
				ret
			}
			if size == io::EOF {
				t.Errorf("unexpected EOF")
				ret
			}
			if b != data[i] {
				t.Errorf("n = {}: incorrect byte returned from ReadByte: got {}, want {}", n, b, data[i])
				ret
			}
		}
		// Unread one byte if there is one.
		if n > 0 {
			r.UnreadByte().await else {
				t.Errorf("n = {}: unexpected error on UnreadByte: {}", n, error)
			}
		}
		// Test that we cannot unread any further.
		r.UnreadByte().await else { continue }
		t.Errorf("n = {}: expected error on UnreadByte", n)
	}
}

// Test that UnreadRune fails if the preceding operation was not a ReadRune.
#test
async fn testUnreadRuneError(t: &testing::T) {
	mut buf := make([]byte, 3) // All runes in this test are 3 bytes long
	mut r := Reader.New(&StrReader{data: ["日本語日本語日本語"]})
	let mut err: bool
	r.UnreadRune().await else { err = true }
	if !err {
		t.Errorf("expected error on UnreadRune from fresh buffer")
	}
	r.ReadRune().await else {
		t.Errorf("unexpected error on ReadRune (1): {}", error)
	}
	r.UnreadRune().await else {
		t.Errorf("unexpected error on UnreadRune (1): {}", error)
	}
	err = false
	r.UnreadRune().await else { err = true }
	if !err {
		t.Errorf("expected error after UnreadRune (1)")
	}
	// Test error after Read.
	// reset state
	r.ReadRune().await else {
		t.Errorf("unexpected error on ReadRune (2):", error)
	}
	r.Read(buf).await else {
		t.Errorf("unexpected error on Read (2): {}", error)
	}
	err = false
	r.UnreadRune().await else { err = true }
	if !err {
		t.Errorf("expected error after Read (2)")
	}
	// Test error after ReadByte.
	// reset state
	r.ReadRune().await else {
		t.Errorf("unexpected error on ReadRune (2): {}", error)
	}
	for in buf {
		r.ReadByte().await else {
			t.Errorf("unexpected error on ReadByte (2): {}", error)
		}
	}
	err = false
	r.UnreadRune().await else { err = true }
	if !err {
		t.Errorf("expected error after ReadByte")
	}
	// Test error after UnreadByte.
	// reset state
	r.ReadRune().await else {
		t.Errorf("unexpected error on ReadRune (3): {}", error)
	}
	r.ReadByte().await else {
		t.Errorf("unexpected error on ReadByte (3): {}", error)
	}
	r.UnreadByte().await else {
		t.Errorf("unexpected error on UnreadByte (3): {}", error)
	}
	err = false
	r.UnreadRune().await else { err = true }
	if !err {
		t.Errorf("expected error after UnreadByte (3)")
	}
	// Test error after ReadSlice.
	// reset state
	r.ReadRune().await else {
		t.Errorf("unexpected error on ReadRune (4): {}", error)
	}
	mut line, _, _ := r.ReadSlice(0).await else {
		t.Errorf("unexpected error on ReadSlice (4):", error)
		use buf, false, false
	}
	if line == nil || len(line) == 0 {
		t.Errorf("unexpected result on ReadSlice (4)")
	}
	line, _, _ = r.ReadSlice(0).await else {
		t.Errorf("unexpected error on ReadSlice (4):", error)
		use make([]byte, 0), false, false
	}
	if line == nil || len(line) != 0 {
		t.Errorf("expected EOF on ReadSlice (4)")
	}
	err = false
	r.UnreadRune().await else { err = true }
	if !err {
		t.Errorf("expected error after ReadSlice (4)")
	}
}

#test
async fn testUnreadRuneAtEOF(t: &testing::T) {
	// UnreadRune/ReadRune should error at EOF (was a bug; used to panic)
	mut r := Reader.New(strings::Reader.New("x").Async())
	r.ReadRune().await else {}
	r.ReadRune().await else {}
	r.UnreadRune().await else {}
	_, n := r.ReadRune().await else {
		t.Errorf("unexpected error: {}", error)
		use 0, io::EOF
	}
	if n != io::EOF {
		t.Errorf("expected error at EOF")
	}
}

#test
fn testReaderNewSizeIdempotent(t: &testing::T) {
	const BufSize = 1000
	mut b := Reader.NewSize(strings::Reader.New("hello world").Async(), BufSize)
	// Does it recognize itself?
	b1 := Reader.NewSize(b, BufSize)
	if b1 != b {
		t.Errorf("Reader.NewSize did not detect underlying Reader")
	}
	// Does it wrap if existing buffer is too small?
	b2 := Reader.NewSize(b, 2*BufSize)
	if b2 == b {
		t.Errorf("Reader.NewSize did not enlarge buffer")
	}
}

#test
async fn testBufferFull(t: &testing::T) {
	const longString = "And now, hello, world! It is the time for all good men to come to the aid of their party"
	mut buf := Reader.NewSize(strings::Reader.New(longString).Async(), minReadBufferSize)
	mut line, mut full, _ := buf.ReadSlice('!').await else {
		t.Errorf("unexpected error: {}", error)
		ret
	}
	if str(line) != "And now, hello, " || !full {
		t.Errorf("first ReadSlice(,) = {}, {}", line, full)
	}
	line, full, _ = buf.ReadSlice('!').await else {
		t.Errorf("unexpected error: {}", error)
		ret
	}
	if str(line) != "world!" || full {
		t.Errorf("second ReadSlice(,) = {}, {}", line, full)
	}
}

#test
async fn testPeek(t: &testing::T) {
	mut p := make([]byte, 10)
	_ = p
	// string is 16 (minReadBufferSize) long.
	mut buf := Reader.NewSize(strings::Reader.New("abcdefghijklmnop").Async(), minReadBufferSize)
	mut s, _, _ := buf.Peek(1).await else {
		t.Errorf("unexpected error: {}", error)
		ret
	}
	if str(s) != "a" {
		t.Errorf("want {} got {}", "a", str(s))
		ret
	}
	s, _, _ = buf.Peek(4).await else {
		t.Errorf("unexpected error: {}", error)
		ret
	}
	if str(s) != "abcd" {
		t.Errorf("want {} got {}", "abcd", str(s))
		ret
	}
	mut err := false
	buf.Peek(-1).await else {
		if error != ErrNegativeCount {
			t.Errorf("unexpected error: {}", error)
			ret
		}
		err = true
	}
	if !err {
		t.Errorf("expected error")
		ret
	}

	_, full, _ := buf.Peek(32).await else {
		t.Errorf("unexpected error: {}", error)
		use nil, false, false
	}
	if !full {
		t.Errorf("expected full")
		ret
	}
	buf.Read(p[0:3]).await else {
		t.Errorf("unexpected error: {}", error)
		ret
	}
	if str(p[0:3]) != "abc" {
		t.Errorf("want {} got {}", "abc", str(p[0:3]))
		ret
	}
	s, _, _ = buf.Peek(1).await else {
		t.Errorf("unexpected error: {}", error)
		ret
	}
	if str(s) != "d" {
		t.Errorf("want {} got {}", "d", str(s))
		ret
	}
	s, _, _ = buf.Peek(2).await else {
		t.Errorf("unexpected error: {}", error)
		ret
	}
	if str(s) != "de" {
		t.Errorf("want {} got {}", "de", str(s))
		ret
	}
	buf.Read(p[0:3]).await else {
		t.Errorf("unexpected error: {}", error)
		ret
	}
	if str(p[0:3]) != "def" {
		t.Errorf("want {} got {}", "def", str(p[0:3]))
		ret
	}
	s, _, _ = buf.Peek(4).await else {
		t.Errorf("unexpected error: {}", error)
		ret
	}
	if str(s) != "ghij" {
		t.Errorf("want {} got {}", "ghij", str(s))
		ret
	}
	buf.Read(p[0:]).await else {
		t.Errorf("unexpected error: {}", error)
		ret
	}
	if str(p[0:]) != "ghijklmnop" {
		t.Errorf("want {} got {}", "ghijklmnop", str(p[0:3]))
		ret
	}
	s, _, _ = buf.Peek(0).await else {
		t.Errorf("unexpected error: {}", error)
		ret
	}
	if str(s) != "" {
		t.Errorf("want {} got {}", "", str(s))
		ret
	}
	s, _, _ = buf.Peek(1).await else {
		t.Errorf("unexpected error: {}", error)
		ret
	}
	if s == nil || len(s) > 0 {
		t.Errorf("want EOF got {}", str(s))
		ret
	}
}

#test
async fn testPeekThenUnreadRune(t: &testing::T) {
	// This sequence used to cause a crash.
	mut r := Reader.New(strings::Reader.New("x").Async())
	r.ReadRune().await else {}
	r.Peek(1).await else {}
	r.UnreadRune().await else {}
	r.ReadRune().await else {} // Used to panic here
}

let mut testOutput = []byte("0123456789abcdefghijklmnopqrstuvwxy")
let mut testInput = []byte("012\n345\n678\n9ab\ncde\nfgh\nijk\nlmn\nopq\nrst\nuvw\nxy")
let mut testInputrn = []byte("012\r\n345\r\n678\r\n9ab\r\ncde\r\nfgh\r\nijk\r\nlmn\r\nopq\r\nrst\r\nuvw\r\nxy\r\n\n\r\n")

// Wraps a []byte and returns reads of a specific length.
struct testReaderImpl {
	data:   []byte
	stride: int
}

impl io::Reader for testReaderImpl {
	async fn Read(mut *self, mut buf: []byte)!: (n: int) {
		n = self.stride
		if n > len(self.data) {
			n = len(self.data)
		}
		if n > len(buf) {
			n = len(buf)
		}
		copy(buf, self.data)
		self.data = self.data[n:]
		if n == 0 {
			ret io::EOF
		}
		ret
	}
}

async fn _testReadLine(t: &testing::T, mut input: []byte) {
	mut stride := 1
	for stride < 2; stride++ {
		mut done := 0
		mut reader := &testReaderImpl{input, stride}
		mut l := Reader.NewSize(reader, len(input)+1)
		for {
			line, isPrefix, _ := l.ReadLine().await else {
				t.Errorf("unknown error: {}", error)
				ret
			}
			if isPrefix {
				t.Errorf("ReadLine returned prefix")
			}
			if line != nil && len(line) == 0 {
				break
			}
			want := testOutput[done : done+len(line)]
			if !bytes::Equal(want, line) {
				t.Errorf("Bad line at stride {}: want: {} got: {}", stride, want, line)
			}
			done += len(line)
		}
		if done != len(testOutput) {
			t.Errorf("ReadLine didn't return everything: got: {}, want: {} (stride: {})", done, len(testOutput), stride)
		}
	}
}

#test
async fn testReadLine(t: &testing::T) {
	_testReadLine(t, testInput).await
	_testReadLine(t, testInputrn).await
}

#test
async fn testLineTooLong(t: &testing::T) {
	mut sb := strings::Builder{}
	mut i := 0
	for i < minReadBufferSize*5/2; i++ {
		sb.WriteByte('0' + byte(i%10))!
	}
	mut data := unsafe { sb.Buf() }
	mut buf := strings::Reader.New(sb.Str())
	mut l := Reader.NewSize(buf.Async(), minReadBufferSize)
	mut line, mut isPrefix, _ := l.ReadLine().await else {
		t.Errorf("unexpected error: {}", error)
		use nil, false, false
	}
	if !isPrefix || !bytes::Equal(line, data[:minReadBufferSize]) {
		t.Errorf("bad result for first line: got {} want {}", line, data[:minReadBufferSize])
	}
	data = data[len(line):]
	line, isPrefix, _ = l.ReadLine().await else {
		t.Errorf("unexpected error: {}", error)
		use nil, false, false
	}
	if !isPrefix || !bytes::Equal(line, data[:minReadBufferSize]) {
		t.Errorf("bad result for second line: got {} want {}", line, data[:minReadBufferSize])
	}
	data = data[len(line):]
	line, isPrefix, _ = l.ReadLine().await else {
		t.Errorf("unexpected error: {}", error)
		use nil, false, false
	}
	if isPrefix || !bytes::Equal(line, data[:minReadBufferSize/2]) {
		t.Errorf("bad result for third line: got {} want {}", line, data[:minReadBufferSize/2])
	}
	line, isPrefix, _ = l.ReadLine().await else {
		t.Errorf("unexpected error: {}", error)
		use nil, false, false
	}
	if isPrefix || line == nil || len(line) > 0 {
		t.Errorf("expected no more lines: {}", line)
	}
}

#test
async fn testReadAfterLines(t: &testing::T) {
	line1 := "this is line1"
	restData := "this is line2\nthis is line 3\n"
	mut inbuf := strings::Reader.New(line1 + "\n" + restData)
	mut outbuf := new(strings::Builder)
	maxLineLength := len(line1) + len(restData)/2
	mut l := Reader.NewSize(inbuf.Async(), maxLineLength)
	line, isPrefix, _ := l.ReadLine().await else {
		t.Errorf("unexpected error: {}", error)
		use nil, false, false
	}
	if isPrefix || str(line) != line1 {
		t.Errorf("bad result for first line: isPrefix={} line={}", isPrefix, str(line))
	}
	n := io::Copy(outbuf.Async(), l).await else {
		t.Errorf("unexpected error: {}", error)
		ret
	}
	if int(n) != len(restData) {
		t.Errorf("bad result for Read: n={}", n)
	}
	if outbuf.Str() != restData {
		t.Errorf("bad result for Read: got {}; expected {}", outbuf.Str(), restData)
	}
}

#test
async fn testReadEmptyBuffer(t: &testing::T) {
	mut l := Reader.NewSize(strings::Reader.New("").Async(), minReadBufferSize)
	line, isPrefix, _ := l.ReadLine().await else {
		t.Errorf("unexpected error: {}", error)
		ret
	}
	if isPrefix || line == nil || len(line) > 0 {
		t.Errorf("expected EOF from ReadLine, got '{}' {}", line, isPrefix)
	}
}

#test
async fn testLinesAfterRead(t: &testing::T) {
	mut l := Reader.NewSize(strings::Reader.New("foo").Async(), minReadBufferSize)
	io::ReadAll(l).await else {
		t.Errorf("unexpected error: {}", error)
		ret
	}

	line, isPrefix, _ := l.ReadLine().await else {
		t.Errorf("unexpected error: {}", error)
		ret
	}
	if isPrefix || line == nil || len(line) > 0 {
		t.Errorf("expected EOF from ReadLine, got '{}' {}", line, isPrefix)
	}
}

struct readLineResult {
	line:     []byte
	isPrefix: bool
	err:      any
}

struct readLineTest {
	input:  str
	expect: []readLineResult
}

let mut readLineNewlinesTests: []readLineTest = [
	{"012345678901234\r\n012345678901234\r\n", []readLineResult([
			{[]byte("012345678901234"), true, nil},
			{nil, false, nil},
			{[]byte("012345678901234"), true, nil},
			{nil, false, nil},
			{make([]byte, 0), false, nil},
		])},
	{"0123456789012345\r012345678901234\r", []readLineResult([
			{[]byte("0123456789012345"), true, nil},
			{[]byte("\r012345678901234"), true, nil},
			{[]byte("\r"), false, nil},
			{make([]byte, 0), false, nil},
		])},
]

#test
async fn testReadLineNewlines(t: &testing::T) {
	for (_, mut e) in readLineNewlinesTests {
		_testReadLineNewlines(t, e.input, e.expect).await
	}
}

async fn _testReadLineNewlines(t: &testing::T, input: str, expect: []readLineResult) {
	mut b := Reader.NewSize(strings::Reader.New(input).Async(), minReadBufferSize)
	for i, e in expect {
		let mut err: any
		line, isPrefix, _ := b.ReadLine().await else {
			err = error
			use e.line, e.isPrefix, false
		}
		if !bytes::Equal(line, e.line) {
			t.Errorf("{} call {}, line == {}, want {}", input, i, line, e.line)
			ret
		}
		if isPrefix != e.isPrefix {
			t.Errorf("{} call {}, isPrefix == {}, want {}", input, i, isPrefix, e.isPrefix)
			ret
		}
		if err != e.err {
			t.Errorf("{} call {}, err == {}, want {}", input, i, err, e.err)
			ret
		}
	}
}

fn createTestInput(n: int): []byte {
	mut input := make([]byte, n)
	for i in input {
		// 101 and 251 are arbitrary prime numbers.
		// The idea is to create an input sequence
		// which doesn't repeat too frequently.
		input[i] = byte(i % 251)
		if i%101 == 0 {
			input[i] ^= byte(i / 101)
		}
	}
	ret input
}

#test
async fn testReaderWriteTo(t: &testing::T) {
	mut input := createTestInput(8192)
	mut r := Reader.New(strings::Reader.New(str(input)).Async())
	mut w := new(strings::Builder)
	n := r.WriteTo(w.Async()).await else {
		t.Errorf("unexpected error: {}", error)
		ret
	}
	if n != i64(len(input)) {
		t.Errorf("r.WriteTo(w) = {}, want {}", n, len(input))
		ret
	}

	for i, val in unsafe { w.Buf() } {
		if val != input[i] {
			t.Errorf("after write: out[{}] = {}, want {}", i, val, input[i])
		}
	}
}

let mut errFake = errors::New("fake error")

struct errorThenGoodReader {
	didErr: bool
	nread:  int
}

impl io::Reader for errorThenGoodReader {
	async fn Read(mut *self, mut p: []byte)!: int {
		self.nread++
		if !self.didErr {
			self.didErr = true
			error(errFake)
		}
		ret len(p)
	}
}

#test
async fn testReaderClearError(t: &testing::T) {
	mut r := &errorThenGoodReader{}
	mut b := Reader.New(r)
	mut buf := make([]byte, 1)
	b.Read(nil).await else {
		t.Errorf("1st nil Read = {}; want success", error)
		ret
	}
	let mut err: any
	b.Read(buf).await else { err = error }
	if err != errFake {
		t.Errorf("1st Read = {}; want errFake", err)
		ret
	}
	b.Read(nil).await else {
		t.Errorf("2nd nil Read = {}; want nil", error)
		ret
	}
	b.Read(buf).await else {
		t.Errorf("3rd Read with buffer = {}; want nil", error)
	}
	if r.nread != 2 {
		t.Errorf("num reads = {}; want 2", r.nread)
	}
}

#test
async fn testReaderReset(t: &testing::T) {
	checkAll := async fn(mut r: &Reader, want: str) {
		all := io::ReadAll(r).await else {
			t.Errorf("{}", error)
			ret
		}
		if str(all) != want {
			t.Errorf("ReadAll returned {}, want {}", all, want)
		}
	}

	mut r := Reader.New(strings::Reader.New("foo foo").Async())
	mut buf := make([]byte, 3)
	r.Read(buf).await!
	if str(buf) != "foo" {
		t.Errorf("buf = {}; want foo", buf)
	}

	r.Reset(strings::Reader.New("bar bar").Async())
	checkAll(r, "bar bar").await

	*r = Reader{} // zero out the Reader
	r.Reset(strings::Reader.New("bar bar").Async())
	checkAll(r, "bar bar").await

	// Wrap a reader and then Reset to that reader.
	r.Reset(strings::Reader.New("recur").Async())
	mut r2 := Reader.New(r)
	checkAll(r2, "recur").await
	r.Reset(strings::Reader.New("recur2").Async())
	r2.Reset(r)
	checkAll(r2, "recur2").await
}

#test
fn testReaderSize(t: &testing::T) {
	mut got, mut want := Reader.New(nil).Size(), defaultBufSize
	if got != want {
		t.Errorf("Reader.New's Reader.Size = {}; want {}", got, want)
	}
	got, want = Reader.NewSize(nil, 1234).Size(), 1234
	if got != want {
		t.Errorf("Reader.NewSize's Reader.Size = {}; want {}", got, want)
	}
}

// An io::Reader that executes its steps sequentially.
type scriptedReader: []fn(mut p: []byte)!: (n: int)

impl io::Reader for scriptedReader {
	async fn Read(mut *self, mut p: []byte)!: (n: int) {
		if len(*self) == 0 {
			panic("too many Read calls on scripted Reader. No steps remain.")
		}
		step := (*self)[0]
		*self = (*self)[1:]
		ret step(p)?
	}
}

fn newScriptedReader(mut steps: ...fn(mut p: []byte)!: (n: int)): io::Reader {
	mut sr := new(scriptedReader)
	*sr = scriptedReader(steps)
	ret sr
}

struct readerDiscardTest {
	name:     str
	r:        io::Reader
	bufSize:  int // 0 means 16
	peekSize: int

	n: int // input to Discard

	want:    int // from Discard
	wantErr: any // from Discard

	wantBuffered: int
}

#test
async fn testReaderDiscard(t: &testing::T) {
	mut tests := []readerDiscardTest([
		{
			name: "normal case",
			r: strings::Reader.New("abcdefghijklmnopqrstuvwxyz").Async(),
			peekSize: 16,
			n: 6,
			want: 6,
			wantBuffered: 10,
		},
		{
			name: "discard causing read",
			r: strings::Reader.New("abcdefghijklmnopqrstuvwxyz").Async(),
			n: 6,
			want: 6,
			wantBuffered: 10,
		},
		{
			name: "discard all without peek",
			r: strings::Reader.New("abcdefghijklmnopqrstuvwxyz").Async(),
			n: 26,
			want: 26,
			wantBuffered: 0,
		},
		{
			name: "discard more than end",
			r: strings::Reader.New("abcdefghijklmnopqrstuvwxyz").Async(),
			n: 27,
			want: 26,
			wantErr: nil,
			wantBuffered: 0,
		},
		// Discard of 0 shouldn't cause a read:
		{
			name: "discard zero",
			r: newScriptedReader(), // will panic on Read
			n: 0,
			want: 0,
			wantErr: nil,
			wantBuffered: 0,
		},
		{
			name: "discard negative",
			r: newScriptedReader(), // will panic on Read
			n: -1,
			want: 0,
			wantErr: ErrNegativeCount,
			wantBuffered: 0,
		},
	])
	for (_, mut tt) in tests {
		mut br := Reader.NewSize(tt.r, tt.bufSize)
		if tt.peekSize > 0 {
			peekBuf, _, _ := br.Peek(tt.peekSize).await else {
				t.Errorf("{}: Peek({}): {}", tt.name, tt.peekSize, error)
				continue
			}
			if len(peekBuf) != tt.peekSize {
				t.Errorf("{}: len(Peek({})) = {}; want {}", tt.name, tt.peekSize, len(peekBuf), tt.peekSize)
				continue
			}
		}
		let mut err: any
		discarded := br.Discard(tt.n).await else {
			err = error
			use tt.want
		}
		ge, we := fmt::Sprint(err), fmt::Sprint(tt.wantErr)
		if discarded != tt.want || ge != we {
			t.Errorf("{}: Discard({}) = ({}, {}); want ({}, {})", tt.name, tt.n, discarded, ge, tt.want, we)
			continue
		}
		bn := br.Buffered()
		if bn != tt.wantBuffered {
			t.Errorf("{}: after Discard, Buffered = {}; want {}", tt.name, bn, tt.wantBuffered)
		}
	}
}

#test
async fn testReadWriteRune(t: &testing::T) {
	const NRune = 1000
	mut sb := new(strings::Builder)
	mut w := Writer.New(sb.Async())
	// Write the runes out using WriteRune
	mut buf := make([]byte, utf8::UTFMax)
	mut r0 := rune(0)
	for r0 < NRune; r0++ {
		size := utf8::EncodeRune(buf, r0)
		nbytes := w.WriteRune(r0).await else {
			t.Errorf("WriteRune({}) error: {}", r0, error)
			ret
		}
		if nbytes != size {
			t.Errorf("WriteRune({}) expected {}, got {}", r0, size, nbytes)
			ret
		}
	}
	w.Flush().await else {}

	mut r := Reader.New(strings::Reader.New(sb.Str()).Async())
	// Read them back with ReadRune
	mut r1 := rune(0)
	for r1 < NRune; r1++ {
		size := utf8::EncodeRune(buf, r1)
		nr, nbytes := r.ReadRune().await else {
			t.Errorf("WriteRune({}) error: {}", r, error)
			ret
		}
		if nr != r1 || nbytes != size {
			t.Errorf("ReadRune({}) got {},{} not {},{}", r1, nr, nbytes, r1, size)
		}
	}
}

#test
async fn testWriteInvalidRune(t: &testing::T) {
	// Invalid runes, including negative ones, should be written as the
	// replacement character.
	for _, r in []rune([-1, utf8::MaxRune + 1]) {
		mut buf := new(strings::Builder)
		mut w := Writer.New(buf.Async())
		w.WriteRune(r).await!
		w.Flush().await!
		s := buf.Str()
		if s != "\uFFFD" {
			t.Errorf("WriteRune({}) wrote {}, not replacement character", r, s)
		}
	}
}

#test
async fn testWriter(t: &testing::T) {
	let mut data: [8192]byte
	mut i := 0
	for i < len(data); i++ {
		data[i] = byte(' ' + i%('~'-' '))
	}
	mut w := new(strings::Builder)
	i = 0
	for i < len(bufsizes); i++ {
		mut j := 0
		for j < len(bufsizes); j++ {
			nwrite := bufsizes[i]
			bs := bufsizes[j]

			// Write nwrite bytes using buffer size bs.
			// Check that the right amount makes it out
			// and that the data is correct.

			w.Clear()
			mut buf := Writer.NewSize(w.Async(), bs)
			context := fmt::Sprintf("nwrite={} bufsize={}", nwrite, bs)
			n := buf.Write(data[0:nwrite]).await else {
				t.Errorf("{}: buf.Write = {}", context, error)
				continue
			}
			if n != nwrite {
				t.Errorf("{}: buf.Write {} = {}", context, nwrite, n)
				continue
			}
			buf.Flush().await else {
				t.Errorf("{}: buf.Flush = {}", context, error)
			}

			written := w.Str()
			if len(written) != nwrite {
				t.Errorf("{}: {} bytes written", context, len(written))
			}
			mut l := 0
			for l < len(written); l++ {
				if written[l] != data[l] {
					t.Errorf("wrong bytes written")
					t.Errorf("want={}", data[:len(written)])
					t.Errorf("have={}", written)
				}
			}
		}
	}
}

#test
async fn testWriterAppend(t: &testing::T) {
	mut got := new(strings::Builder)
	let mut want: []byte
	rn := rand::New(rand::NewPCG(0, 0))
	mut w := Writer.NewSize(got.Async(), 64)
	mut i := 0
	for i < 100; i++ {
		// Obtain a buffer to append to.
		mut b := w.AvailableBuffer()
		if w.Available() != cap(b) {
			t.Errorf("Available() = {}, want {}", w.Available(), cap(b))
			ret
		}

		// While not recommended, it is valid to append to a shifted buffer.
		// This forces Write to copy the input.
		if rn.IntN(8) == 0 && cap(b) > 0 {
			b = b[1:1:cap(b)]
		}

		// Append a random integer of varying width.
		n := i64(rn.IntN(1 << rn.IntN(30)))
		want = append(conv::AppendInt(want, n, 10), ' ')
		b = append(conv::AppendInt(b, n, 10), ' ')
		w.Write(b).await!
	}
	w.Flush().await!

	wantS := str(want)
	if got.Str() != wantS {
		t.Errorf("output mismatch:\ngot  {}\nwant {}", got.Str(), wantS)
	}
}

struct errorWriterTest {
	n:      int
	m:      int
	err:    any
	expect: any
}

impl io::Writer for errorWriterTest {
	async fn Write(mut *self, p: []byte)!: int {
		if self.err != nil {
			error(self.err)
		}
		ret len(p) * self.n / self.m
	}
}

let mut errorWriterTests: []errorWriterTest = [
	{0, 1, nil, io::ErrShortWrite},
	{1, 2, nil, io::ErrShortWrite},
	{1, 1, nil, nil},
	{0, 1, io::ErrShortBuffer, io::ErrShortBuffer},
	{1, 2, io::ErrShortBuffer, io::ErrShortBuffer},
	{1, 1, io::ErrShortBuffer, io::ErrShortBuffer},
]

#test
async fn testWriteErrors(t: &testing::T) {
	for (_, mut w) in errorWriterTests {
		mut buf := Writer.New(w)
		buf.Write([]byte("hello world")).await else {
			t.Errorf("Write hello to {}: {}", w, error)
			continue
		}
		// Two flushes, to verify the error is sticky.
		mut i := 0
		for i < 2; i++ {
			let mut err: any
			buf.Flush().await else { err = error }
			if err != w.expect {
				t.Errorf("Flush {}/2 {}: got {}, wanted {}", i+1, w, err, w.expect)
			}
		}
	}
}

#test
async fn testWriteString(t: &testing::T) {
	const BufSize = 8
	mut buf := new(strings::Builder)
	mut b := Writer.NewSize(buf.Async(), BufSize)
	b.WriteStr("0").await!                         // easy
	b.WriteStr("123456").await!                    // still easy
	b.WriteStr("7890").await!                      // easy after flush
	b.WriteStr("abcdefghijklmnopqrstuvwxy").await! // hard
	b.WriteStr("z").await!
	b.Flush().await else {
		t.Errorf("WriteStr", error)
	}
	s := "01234567890abcdefghijklmnopqrstuvwxyz"
	if buf.Str() != s {
		t.Errorf("WriteStr wants {} gets {}", s, buf.Str())
	}
}

#test
fn testNewWriterSizeIdempotent(t: &testing::T) {
	const BufSize = 1000
	mut b := Writer.NewSize(new(strings::Builder).Async(), BufSize)
	// Does it recognize itself?
	b1 := Writer.NewSize(b, BufSize)
	if b1 != b {
		t.Errorf("Writer.NewSize did not detect underlying Writer")
	}
	// Does it wrap if existing buffer is too small?
	b2 := Writer.NewSize(b, 2*BufSize)
	if b2 == b {
		t.Errorf("Writer.NewSize did not enlarge buffer")
	}
}

#test
fn testWriterSize(t: &testing::T) {
	mut got, mut want := Writer.New(nil).Size(), defaultBufSize
	if got != want {
		t.Errorf("Writer.New's Writer.Size = {}; want {}", got, want)
	}
	got, want := Writer.NewSize(nil, 1234).Size(), 1234
	if got != want {
		t.Errorf("Writer.NewSize's Writer.Size = {}; want {}", got, want)
	}
}

#test
async fn restWriterReadFrom(t: &testing::T) {
	ws := [
		fn(mut w: io::Writer): io::Writer { ret w },
	]

	rs := [
		iotest::DataErrReader,
		fn(mut r: io::Reader): io::Reader { ret r },
	]

	for ri, rfunc in rs {
		for wi, wfunc in ws {
			mut input := str(createTestInput(8192))
			mut b := new(strings::Builder)
			mut w := Writer.New(wfunc(b.Async()))
			mut r := rfunc(strings::Reader.New(input).Async())
			n := w.ReadFrom(r).await else {
				t.Errorf("ReadFrom returned {}", error)
				continue
			}
			if n != i64(len(input)) {
				t.Errorf("ws[{}],rs[{}]: w.ReadFrom(r) = {}, want {}", wi, ri, n, len(input))
				continue
			}
			w.Flush().await else {
				t.Errorf("Flush returned {}", error)
				continue
			}
			got := b.Str()
			if got != input {
				t.Errorf("ws[{}], rs[{}]:\ngot  {}\nwant {}\n", wi, ri, got, input)
			}
		}
	}
}

struct errorReaderFromTest {
	rn:       int
	wn:       int
	rerr:     any
	werr:     any
	expected: any
}

impl io::Reader for errorReaderFromTest {
	async fn Read(mut *self, p: []byte)!: int {
		if self.rerr != nil {
			error(self.rerr)
		}
		ret len(p) * self.rn
	}
}

impl io::Writer for errorReaderFromTest {
	async fn Write(mut *self, p: []byte)!: int {
		if self.werr != nil {
			error(self.werr)
		}
		ret len(p) * self.wn
	}
}

let mut errorReaderFromTests: []errorReaderFromTest = [
	{0, 1, io::ErrShortBuffer, nil, io::ErrShortBuffer},
	{0, 0, io::ErrShortBuffer, io::ErrShortWrite, io::ErrShortBuffer},
	{1, 0, nil, io::ErrShortWrite, io::ErrShortWrite},
]

#test
async fn testWriterReadFromErrors(t: &testing::T) {
	for (i, mut rw) in errorReaderFromTests {
		mut w := Writer.New(rw)
		let mut err: any
		w.ReadFrom(rw).await else { err = error }
		if err != rw.expected {
			t.Errorf("w.ReadFrom(errorReaderFromTests[{}]) = _, {}, want _,{}", i, err, rw.expected)
		}
	}
}

// Like io::Discard and counts the number of times Write is called on it.
type writeCountingDiscard: int

impl io::Writer for writeCountingDiscard {
	async fn Write(mut *self, p: []byte)!: int {
		*self++
		ret len(p)
	}
}

// Tests that using io::Copy to copy into a
// bufio::Writer does not prematurely flush the buffer. For example, when
// buffering writes to a network socket, excessive network writes should be
// avoided.
#test
async fn testWriterReadFromCounts(t: &testing::T) {
	mut w0 := new(writeCountingDiscard)
	mut b0 := Writer.NewSize(w0, 1234)
	b0.WriteStr(strings::Repeat("x", 1000)).await!
	if *w0 != 0 {
		t.Errorf("write 1000 'x's: got {} writes, want 0", w0)
		ret
	}
	b0.WriteStr(strings::Repeat("x", 200)).await!
	if *w0 != 0 {
		t.Errorf("write 1200 'x's: got {} writes, want 0", w0)
		ret
	}
	io::Copy(b0, strings::Reader.New(strings::Repeat("x", 30)).Async()).await!
	if *w0 != 0 {
		t.Errorf("write 1230 'x's: got {} writes, want 0", w0)
		ret
	}
	io::Copy(b0, strings::Reader.New(strings::Repeat("x", 9)).Async()).await!
	if *w0 != 1 {
		t.Errorf("write 1239 'x's: got {} writes, want 1", w0)
		ret
	}

	mut w1 := new(writeCountingDiscard)
	mut b1 := Writer.NewSize(w1, 1234)
	b1.WriteStr(strings::Repeat("x", 1200)).await!
	b1.Flush().await!
	if *w1 != 1 {
		t.Errorf("flush 1200 'x's: got {} writes, want 1", w1)
		ret
	}
	b1.WriteStr(strings::Repeat("x", 89)).await!
	if *w1 != 1 {
		t.Errorf("write 1200 + 89 'x's: got {} writes, want 1", w1)
		ret
	}
	io::Copy(b1, strings::Reader.New(strings::Repeat("x", 700)).Async()).await!
	if *w1 != 1 {
		t.Errorf("write 1200 + 789 'x's: got {} writes, want 1", w1)
		ret
	}
	io::Copy(b1, strings::Reader.New(strings::Repeat("x", 600)).Async()).await!
	if *w1 != 2 {
		t.Errorf("write 1200 + 1389 'x's: got {} writes, want 2", w1)
		ret
	}
	b1.Flush().await!
	if *w1 != 3 {
		t.Errorf("flush 1200 + 1389 'x's: got {} writes, want 3", w1)
		ret
	}
}

// Test for golang.org/issue/5947
#test
async fn testWriterReadFromWhileFull(t: &testing::T) {
	mut buf := new(strings::Builder)
	mut w := Writer.NewSize(buf.Async(), 10)

	// Fill buffer exactly.
	n := w.Write([]byte("0123456789")).await else {
		t.Errorf("Write: unexpected error: {}", error)
		ret
	}
	if n != 10 {
		t.Errorf("Write returned ({}), want (10)", n)
		ret
	}

	// Use ReadFrom to read in some data.
	n2 := w.ReadFrom(strings::Reader.New("abcdef").Async()).await else {
		t.Errorf("ReadFrom: unexpected error: {}", error)
		ret
	}
	if n2 != 6 {
		t.Errorf("ReadFrom returned ({}), want (6)", n2)
		ret
	}
}

struct emptyThenNonEmptyReader {
	r: io::Reader
	n: int
}

impl io::Reader for emptyThenNonEmptyReader {
	async fn Read(mut *self, mut p: []byte)!: int {
		if self.n <= 0 {
			ret self.r.Read(p).await?
		}
		self.n--
		ret 0
	}
}

// Test for golang.org/issue/7611
#test
async fn testWriterReadFromUntilEOF(t: &testing::T) {
	mut buf := new(strings::Builder)
	mut w := Writer.NewSize(buf.Async(), 5)

	// Partially fill buffer
	n := w.Write([]byte("0123")).await else {
		t.Errorf("Write: unexpected error: {}", error)
		ret
	}
	if n != 4 {
		t.Errorf("Write returned ({}), want (4)", n)
		ret
	}

	// Use ReadFrom to read in some data.
	mut r := &emptyThenNonEmptyReader{r: strings::Reader.New("abcd").Async(), n: 3}
	n2 := w.ReadFrom(r).await else {
		t.Errorf("ReadFrom: unexpected error: {}", error)
		ret
	}
	if n2 != 4 {
		t.Errorf("ReadFrom returned ({}), want (4)", n2)
	}
	w.Flush().await!
	got, want := buf.Str(), "0123abcd"
	if got != want {
		t.Errorf("buf.Str() returned {}, want {}", got, want)
	}
}

#test
async fn testWriterReadFromErrNoProgress(t: &testing::T) {
	mut buf := new(strings::Builder)
	mut w := Writer.NewSize(buf.Async(), 5)

	// Partially fill buffer
	n := w.Write([]byte("0123")).await else {
		t.Errorf("Write: unexpected error: {}", error)
		ret
	}
	if n != 4 {
		t.Errorf("Write returned ({}), want (4)", n)
		ret
	}

	// Use ReadFrom to read in some data.
	mut r := &emptyThenNonEmptyReader{r: strings::Reader.New("abcd").Async(), n: 100}
	let mut err: any
	n2 := w.ReadFrom(r).await else {
		err = error
		use 0
	}
	if n2 != 0 || err != io::ErrNoProgress {
		t.Errorf("buf.Bytes() returned ({}, {}), want (0, io::ErrNoProgress)", n2, err)
		ret
	}
}

#test
async fn testWriterReset(t: &testing::T) {
	mut buf1 := new(strings::Builder)
	mut buf2 := new(strings::Builder)
	mut buf3 := new(strings::Builder)
	mut buf4 := new(strings::Builder)
	mut buf5 := new(strings::Builder)
	mut w := Writer.New(buf1.Async())
	w.WriteStr("foo").await!

	w.Reset(buf2.Async()) // and not flushed
	w.WriteStr("bar").await!
	w.Flush().await!
	if buf1.Str() != "" {
		t.Errorf("buf1 = {}; want empty", buf1.Str())
	}
	if buf2.Str() != "bar" {
		t.Errorf("buf2 = {}; want bar", buf2.Str())
	}

	*w = Writer{}         // zero out the Writer
	w.Reset(buf3.Async()) // and not flushed
	w.WriteStr("bar").await!
	w.Flush().await!
	if buf1.Str() != "" {
		t.Errorf("buf1 = {}; want empty", buf1.Str())
	}
	if buf3.Str() != "bar" {
		t.Errorf("buf3 = {}; want bar", buf3.Str())
	}

	// Wrap a writer and then Reset to that writer.
	w.Reset(buf4.Async())
	mut w2 := Writer.New(w)
	w2.WriteStr("recur").await!
	w2.Flush().await!
	if buf4.Str() != "recur" {
		t.Errorf("buf4 = {}, want {}", buf4.Str(), "recur")
	}
	w.Reset(buf5.Async())
	w2.Reset(w)
	w2.WriteStr("recur2").await!
	w2.Flush().await!
	if buf5.Str() != "recur2" {
		t.Errorf("buf5 = {}, want {}", buf5.Str(), "recur2")
	}
}

struct writeErrorOnlyWriter{}

impl io::Writer for writeErrorOnlyWriter {
	async fn Write(*self, p: []byte)!: (n: int) {
		error(errors::New("writeErrorOnlyWriter error"))
	}
}

// Ensure that previous Write errors are immediately returned
// on any ReadFrom. See golang.org/issue/35194.
#test
async fn testWriterReadFromMustReturnUnderlyingError(t: &testing::T) {
	mut wr := Writer.New(writeErrorOnlyWriter{})
	s := "test1"
	wantBuffered := len(s)
	wr.WriteStr(s).await else {
		t.Errorf("unexpected error: {}", error)
		ret
	}
	let mut err: any
	wr.Flush().await else { err = error }
	if err == nil {
		t.Errorf("expected flush error, got nil")
	}
	err = nil
	wr.ReadFrom(strings::Reader.New("test2").Async()).await else { err = error }
	if err == nil {
		t.Errorf("expected error, got nil")
		ret
	}
	buffered := wr.Buffered()
	if buffered != wantBuffered {
		t.Errorf("Buffered = {}; want {}", buffered, wantBuffered)
		ret
	}
}
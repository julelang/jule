// Copyright 2024 The Jule Project Contributors. All rights reserved.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/io"
use "std/mem"
use "std/runtime"
use "std/sys"
use "std/time"

// FD flags. Kind flags should not be combined like File|Console|Socket.
const (
	File         = 1 << iota // Standard file descriptor.
	Socket                   // Socket file descriptor, not connectionless, such as TCP.
	SocketNoConn             // Like Socket kind, but connectionless, such as UDP.
	Console                  // Console file descriptor.
	Pipe                     // Pipe.
)

impl FD {
	// Returns new FD by file and kind.
	fn New(file: u64, flags: int, pollable: bool)!: &FD {
		mut f := &FD{
			File: file,
			Flags: flags,
		}
		f.Init(pollable)?
		ret f
	}

	// Reports whether the FD kind is file.
	fn isFile(*self): bool {
		ret self.Flags&File == File ||
			self.Flags&Pipe == Pipe
	}

	// Returns io::EOF when fd is available for reading end of file.
	// Otherwise returns n.
	fn statEOF(*self, n: int): int {
		if n == 0 && self.ZeroReadIsEOF {
			ret io::EOF
		}
		ret n
	}

	// Like Read, but wraps the recvfrom syscall.
	async fn ReadV4(mut *self, mut buf: []byte, addr: sys::RawSockaddrInet4)!: (n: int) {
		addrLen := mem::SizeOf(addr)
		ret self.ReadV(buf, uintptr(&addr), sys::Socklen(addrLen)).await?
	}

	// Like Read, but wraps the recvfrom syscall.
	async fn ReadV6(mut *self, mut buf: []byte, addr: sys::RawSockaddrInet6)!: (n: int) {
		addrLen := mem::SizeOf(addr)
		ret self.ReadV(buf, uintptr(&addr), sys::Socklen(addrLen)).await?
	}

	// Like Write, but wraps the sendto syscall.
	async fn WriteV4(mut *self, buf: []byte, addr: sys::RawSockaddrInet4)!: (n: int) {
		addrLen := mem::SizeOf(addr)
		ret self.WriteV(buf, uintptr(&addr), sys::Socklen(addrLen)).await?
	}

	// Like Write, but wraps the sendo syscall.
	async fn WriteV6(mut *self, buf: []byte, addr: sys::RawSockaddrInet6)!: (n: int) {
		addrLen := mem::SizeOf(addr)
		ret self.WriteV(buf, uintptr(&addr), sys::Socklen(addrLen)).await?
	}

	// Like Read, but wraps the recvfrom syscall.
	fn ReadV4Sync(mut *self, mut buf: []byte, addr: sys::RawSockaddrInet4)!: (n: int) {
		addrLen := mem::SizeOf(addr)
		ret self.ReadVSync(buf, uintptr(&addr), sys::Socklen(addrLen))?
	}

	// Like Read, but wraps the recvfrom syscall.
	fn ReadV6Sync(mut *self, mut buf: []byte, addr: sys::RawSockaddrInet6)!: (n: int) {
		addrLen := mem::SizeOf(addr)
		ret self.ReadVSync(buf, uintptr(&addr), sys::Socklen(addrLen))?
	}

	// Like Write, but wraps the sendto syscall.
	fn WriteV4Sync(mut *self, buf: []byte, addr: sys::RawSockaddrInet4)!: (n: int) {
		addrLen := mem::SizeOf(addr)
		ret self.WriteVSync(buf, uintptr(&addr), sys::Socklen(addrLen))?
	}

	// Like Write, but wraps the sendo syscall.
	fn WriteV6Sync(mut *self, buf: []byte, addr: sys::RawSockaddrInet6)!: (n: int) {
		addrLen := mem::SizeOf(addr)
		ret self.WriteVSync(buf, uintptr(&addr), sys::Socklen(addrLen))?
	}

	// Sets a general deadline for pd.
	fn SetDeadline(mut *self, mut deadline: time::Duration) {
		self.pd.setDeadline(i64(deadline))
	}

	// Sets a read deadline for pd.
	fn SetReadDeadline(mut *self, mut deadline: time::Duration) {
		self.pd.setReadDeadline(i64(deadline))
	}

	// Sets a write deadline for pd.
	fn SetWriteDeadline(mut *self, mut deadline: time::Duration) {
		self.pd.setWriteDeadline(i64(deadline))
	}

	// Waits until an event is triggered by netpoll according to the mode.
	// After returning, either the coroutine is ready to be executed
	// according to the mode, or an error has occurred (e.g., deadline exceeded).
	async fn Wait(mut *self, mode: i32)! {
		runtime::netpollwait(self.pd, mode).await?
	}

	// Waits until an event is triggered by netpoll for read operation.
	// After returning, either the coroutine is ready to be executed
	// according to the mode, or an error has occurred (e.g., deadline exceeded).
	async fn WaitRead(mut *self)! {
		self.Wait('r').await?
	}

	// Waits until an event is triggered by netpoll for write operation.
	// After returning, either the coroutine is ready to be executed
	// according to the mode, or an error has occurred (e.g., deadline exceeded).
	async fn WaitWrite(mut *self)! {
		self.Wait('w').await?
	}
}
// Copyright 2024 The Jule Project Contributors. All rights reserved.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/internal/conv"
use "std/io"
use "std/runtime"
use "std/sys"

// This information adopted from the Go programming language:
//
// Darwin and FreeBSD can't read or write 2GB+ files at a time,
// even on 64-bit systems.
// The same is true of socket implementations on many systems.
// See golang.org/issue/7812 and golang.org/issue/16266.
// Use 1GB instead of, say, 2GB-1, to keep subsequent reads aligned.
const maxRW = 1 << 30

// FD is a file descriptor.
// Provides internal, common implementation for
// file descriptors, console handles, and sockets.
struct FD {
	// Lock File and serialize access to Read and Write methods.
	fdmu: fdMutex

	// Semaphore signaled when file is closed.
	csema: u32

	// Poll descriptor for the FD.
	pd:       &runtime::polldesc
	pollable: bool

	// The file descriptor should be compatible
	// with pointers and other integer kinds such as UNIX file descriptors.
	File:  u64
	Flags: int

	// Whether this is a streaming descriptor,
	// as opposed to a packet-based descriptor like a UDP socket.
	IsStream: bool

	// Whether a zero byte read indicates EOF. This is false for a
	// message based socket connection.
	ZeroReadIsEOF: bool
}

impl FD {
	fn Init(mut *self, pollable: bool)! {
		if pollable {
			self.pd = new(runtime::polldesc)
			self.pd.init(self.File)
			self.pollable = true
		}
	}

	// Writes bytes to the file descriptor and returns written byte count.
	// The number of bytes written can never exceed the length of the buf.
	async fn Write(mut *self, buf: []byte)!: (n: int) {
		// File and console descriptors, also socket descriptors, can use the Write function.
		// But other kinds are not supported. For socket descriptors, correct use case
		// will be equivalent to send syscall.
		if self.Flags&File != File && self.Flags&Pipe != Pipe && self.Flags&Console != Console && self.Flags&Socket != Socket && self.Flags&SocketNoConn != SocketNoConn {
			panic("std/internal/poll: unimplemented/unsupported file descriptor kind for Write")
		}
		if len(buf) == 0 {
			// If the caller wanted a zero byte write, return immediately
			// without trying to write.
			ret 0
		}
		self.writeLock().await?
		defer { self.writeUnlock() }
		for {
			mut max := len(buf)
			if self.IsStream && max-n > maxRW {
				max = n + maxRW
			}
			part := buf[n:max]
			nn := ignoringEINTRIO2(sys::Write, int(self.File), part) else {
				if error == sys::EAGAIN && self.pollable {
					self.WaitWrite().await?
					continue
				}
				error(error)
			}
			if n > max-nn {
				// This can reportedly happen when using
				// some VPN software. Go's issue #61060.
				// If we don't check this we will panic
				// with slice bounds out of range.
				// Use a more informative panic.
				panic("invalid return from write: got " + conv::Itoa(n) + " from a write of " + conv::Itoa(max-nn))
			}
			n += nn
			if n == len(buf) {
				ret
			}
		}
	}

	// Writes bytes to the file descriptor and returns written byte count.
	// The number of bytes written can never exceed the length of the buf.
	fn WriteSync(mut *self, buf: []byte)!: (n: int) {
		// File and console descriptors, also socket descriptors, can use the Write function.
		// But other kinds are not supported. For socket descriptors, correct use case
		// will be equivalent to send syscall.
		if self.Flags&File != File && self.Flags&Pipe != Pipe && self.Flags&Console != Console && self.Flags&Socket != Socket && self.Flags&SocketNoConn != SocketNoConn {
			panic("std/internal/poll: unimplemented/unsupported file descriptor kind for Write")
		}
		if len(buf) == 0 {
			// If the caller wanted a zero byte write, return immediately
			// without trying to write.
			ret 0
		}
		for {
			mut max := len(buf)
			if self.IsStream && max-n > maxRW {
				max = n + maxRW
			}
			part := buf[n:max]
			nn := ignoringEINTRIO2(sys::Write, int(self.File), part)?
			if n > max-nn {
				// This can reportedly happen when using
				// some VPN software. Go's issue #61060.
				// If we don't check this we will panic
				// with slice bounds out of range.
				// Use a more informative panic.
				panic("invalid return from write: got " + conv::Itoa(n) + " from a write of " + conv::Itoa(max-nn))
			}
			n += nn
			if n == len(buf) {
				ret
			}
		}
	}

	// Like Write, but wraps sendto syscall.
	// General for V4 and V6. Unsafe variant.
	async fn WriteV(mut *self, buf: []byte, addr: uintptr, addrLen: sys::Socklen)!: (n: int) {
		if self.Flags&SocketNoConn != SocketNoConn {
			panic("std/internal/poll: unimplemented/unsupported file descriptor kind for ReadV")
		}
		if len(buf) == 0 {
			// If the caller wanted a zero byte read, return immediately
			// without trying to read.
			ret 0
		}
		self.writeLock().await?
		defer { self.writeUnlock() }
		for {
			sys::Sendto(int(self.File), buf, 0, addr, addrLen) else {
				if error == sys::EINTR {
					continue
				}
				if error == sys::EAGAIN && self.pollable {
					self.WaitWrite().await?
					continue
				}
				error(error)
			}
			ret len(buf)
		}
	}

	// Like Write, but wraps sendto syscall.
	// General for V4 and V6. Unsafe variant.
	fn WriteVSync(mut *self, buf: []byte, addr: uintptr, addrLen: sys::Socklen)!: (n: int) {
		if self.Flags&SocketNoConn != SocketNoConn {
			panic("std/internal/poll: unimplemented/unsupported file descriptor kind for ReadV")
		}
		if len(buf) == 0 {
			// If the caller wanted a zero byte read, return immediately
			// without trying to read.
			ret 0
		}
		for {
			sys::Sendto(int(self.File), buf, 0, addr, addrLen) else {
				if error == sys::EINTR {
					continue
				}
				error(error)
			}
			ret len(buf)
		}
	}

	// Read bytes to buffer from the file descriptor and returns read byte count.
	// The number of bytes read can never exceed the length of the buf.
	// If the buf is larger than the number of bytes that can be read,
	// the buffer will not cause an overflow. Offset will be shifted
	// by the number of bytes read.
	async fn Read(mut *self, mut buf: []byte)!: (n: int) {
		// File and console descriptors, also socket descriptors, can use the Read function.
		// But other kinds are not supported. For socket descriptors, correct use case
		// will be equivalent to recv syscall.
		if self.Flags&File != File && self.Flags&Pipe != Pipe && self.Flags&Console != Console && self.Flags&Socket != Socket && self.Flags&SocketNoConn != SocketNoConn {
			panic("std/internal/poll: unimplemented/unsupported file descriptor kind for Read")
		}
		if len(buf) == 0 {
			// If the caller wanted a zero byte read, return immediately
			// without trying to read.
			ret 0
		}
		if self.IsStream && len(buf) > maxRW {
			buf = buf[:maxRW]
		}
		self.readLock().await?
		defer { self.readUnlock() }

		for {
			n = ignoringEINTRIO(sys::Read, int(self.File), buf) else {
				if error == sys::EAGAIN && self.pollable {
					self.WaitRead().await?
					continue
				}
				error(error)
			}
			n = self.statEOF(n)
			ret n
		}
	}

	// Read bytes to buffer from the file descriptor and returns read byte count.
	// The number of bytes read can never exceed the length of the buf.
	// If the buf is larger than the number of bytes that can be read,
	// the buffer will not cause an overflow. Offset will be shifted
	// by the number of bytes read.
	fn ReadSync(mut *self, mut buf: []byte)!: (n: int) {
		// File and console descriptors, also socket descriptors, can use the Read function.
		// But other kinds are not supported. For socket descriptors, correct use case
		// will be equivalent to recv syscall.
		if self.Flags&File != File && self.Flags&Pipe != Pipe && self.Flags&Console != Console && self.Flags&Socket != Socket && self.Flags&SocketNoConn != SocketNoConn {
			panic("std/internal/poll: unimplemented/unsupported file descriptor kind for Read")
		}
		if len(buf) == 0 {
			// If the caller wanted a zero byte read, return immediately
			// without trying to read.
			ret 0
		}
		if self.IsStream && len(buf) > maxRW {
			buf = buf[:maxRW]
		}

		n = ignoringEINTRIO(sys::Read, int(self.File), buf)?
		n = self.statEOF(n)
		ret n
	}

	// Like Read, but wraps recvfrom syscall.
	// General for V4 and V6. Unsafe variant.
	async fn ReadV(mut *self, mut buf: []byte, addr: uintptr, addrLen: sys::Socklen)!: (n: int) {
		if self.Flags&SocketNoConn != SocketNoConn {
			panic("std/internal/poll: unimplemented/unsupported file descriptor kind for ReadV")
		}
		if len(buf) == 0 {
			// If the caller wanted a zero byte read, return immediately
			// without trying to read.
			ret 0
		}
		self.readLock().await?
		defer { self.readUnlock() }
		for {
			n = sys::Recvfrom(int(self.File), buf, 0, addr, addrLen) else {
				if error == sys::EINTR {
					continue
				}
				if error == sys::EAGAIN && self.pollable {
					self.WaitRead().await?
					continue
				}
				error(error)
			}
			n = self.statEOF(n)
			ret n
		}
	}

	// Like Read, but wraps recvfrom syscall.
	// General for V4 and V6. Unsafe variant.
	fn ReadVSync(mut *self, mut buf: []byte, addr: uintptr, addrLen: sys::Socklen)!: (n: int) {
		if self.Flags&SocketNoConn != SocketNoConn {
			panic("std/internal/poll: unimplemented/unsupported file descriptor kind for ReadV")
		}
		if len(buf) == 0 {
			// If the caller wanted a zero byte read, return immediately
			// without trying to read.
			ret 0
		}
		for {
			n = sys::Recvfrom(int(self.File), buf, 0, addr, addrLen) else {
				if error == sys::EINTR {
					continue
				}
				error(error)
			}
			n = self.statEOF(n)
			ret n
		}
	}

	// Sets offset to next Read/Write operation and returns the new offset.
	// whence: 0 (Seek.Set) means, relative to the whence of the file, 1 (Seek.Cur)
	// means relative to the current offset, and 2 (Seek.End) means relative to end.
	async fn Seek(mut *self, offset: i64, whence: int)!: (pos: i64) {
		self.incref()?
		defer { self.decref() else {} }
		ret sys::Seek(int(self.File), offset, whence)?
	}

	// Wraps sys::Ftruncate.
	fn Ftruncate(mut *self, size: i64)! {
		self.incref()?
		defer { self.decref() else {} }
		sys::Ftruncate(int(self.File), size)?
	}

	// Wraps the accept network call.
	async fn Accept(mut *self, addr: uintptr, mut &addrlen: *sys::Socklen)!: NetHandle {
		self.readLock().await?
		defer { self.readUnlock() }

		for {
			h := sys::Accept(NetHandle(self.File), addr, addrlen) else {
				match error {
				| sys::EINTR:
					continue
				| sys::ECONNABORTED:
					// This means that a socket on the listen
					// queue was closed before we Accept()ed it;
					// it's a silly error, so try again.
					continue
				| sys::EAGAIN:
					if self.pollable {
						self.WaitRead().await?
						continue
					}
				}
				error(error)
			}
			sys::CloseOnExec(h)
			sys::SetNonblock(h, true) else {
				sys::Close(h) else {}
				error(error)
			}
			ret h
		}
	}

	// Closes file descriptor.
	fn destroy(mut *self)! {
		// Poller may want to unregister fd in notification mechanism,
		// so this must be executed before Close.
		self.pd.close()

		// All kinds are supports the Close function.
		sys::Close(int(self.File))?

		semrelease(&self.csema)
	}

	// Closes file descriptor.
	fn CloseSync(mut *self)! {
		// All kinds are supports the Close function.
		sys::Close(int(self.File))?
	}

	// Closes file descriptor.
	async fn Close(mut *self)! {
		if !self.pollable {
			self.CloseSync()?
			ret
		}

		if !self.fdmu.increfAndClose() {
			errClosing(self.isFile())?
		}

		// The call to decref will call destroy if there are no other
		// references.
		let mut err: any
		self.decref() else { err = error }

		// Wait until the descriptor is closed. If this was the only
		// reference, it is already closed.
		semacquire(&self.csema).await

		if err != nil {
			error(err)
		}
	}
}

// It is like ignoringEINTR, but just for IO calls.
fn ignoringEINTRIO(f: fn(fd: int, mut p: []byte)!: int, fd: int, mut p: []byte)!: int {
	for {
		ret f(fd, p) else {
			if error != sys::EINTR {
				error(error)
			}
			continue
		}
	}
}

// It is like ignoringEINTRIO, but immutable.
fn ignoringEINTRIO2(f: fn(fd: int, p: []byte)!: int, fd: int, p: []byte)!: int {
	for {
		ret f(fd, p) else {
			if error != sys::EINTR {
				error(error)
			}
			continue
		}
	}
}
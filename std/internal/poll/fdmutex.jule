// Copyright 2025 The Jule Project Contributors. All rights reserved.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/errors"
use "std/internal/runtime/atomic"
use "std/runtime"

// A specialized synchronization primitive that manages
// lifetime of an fd and serializes access to Read, Write and Close
// methods on FD.
struct fdMutex {
	state: u64
	rsema: u32
	wsema: u32
}

// fdMutex.state is organized as follows:
// 1 bit - whether FD is closed, if set all subsequent lock operations will fail.
// 1 bit - lock for read operations.
// 1 bit - lock for write operations.
// 20 bits - total number of references (read+write+misc).
// 20 bits - number of outstanding read waiters.
// 20 bits - number of outstanding write waiters.
const (
	mutexClosed  = 1 << 0
	mutexRLock   = 1 << 1
	mutexWLock   = 1 << 2
	mutexRef     = 1 << 3
	mutexRefMask = (1<<20 - 1) << 3
	mutexRWait   = 1 << 23
	mutexRMask   = (1<<20 - 1) << 23
	mutexWWait   = 1 << 43
	mutexWMask   = (1<<20 - 1) << 43
)

const overflowMsg = "too many concurrent operations on a single file or socket (max 1048575)"

// Read operations must do rwlock(true)/rwunlock(true).
//
// Write operations must do rwlock(false)/rwunlock(false).
//
// Misc operations must do incref/decref.
// Misc operations include functions like setsockopt and setDeadline.
// They need to use incref/decref to ensure that they operate on the
// correct fd in presence of a concurrent close call (otherwise fd can
// be closed under their feet).
//
// Close operations must do increfAndClose/decref.

impl fdMutex {
	// Adds a reference to mutex.
	// It reports whether mutex is available for reading or writing.
	fn incref(mut *self): bool {
		for {
			old := atomic::Load(&self.state, atomic::SeqCst)
			if old&mutexClosed != 0 {
				ret false
			}
			new := old + mutexRef
			if new&mutexRefMask == 0 {
				panic(overflowMsg)
			}
			if atomic::CompareAndSwap(&self.state, old, new, atomic::SeqCst, atomic::Relaxed) {
				ret true
			}
		}
	}

	// Sets the state of mutex to closed.
	// It returns false if the file was already closed.
	fn increfAndClose(mut *self): bool {
		for {
			mut old := atomic::Load(&self.state, atomic::SeqCst)
			if old&mutexClosed != 0 {
				ret false
			}
			// Mark as closed and acquire a reference.
			mut new := (old | mutexClosed) + mutexRef
			if new&mutexRefMask == 0 {
				panic(overflowMsg)
			}
			// Remove all read and write waiters.
			new &= ^(mutexRMask | mutexWMask)
			if atomic::CompareAndSwap(&self.state, old, new, atomic::SeqCst, atomic::Relaxed) {
				// Wake all read and write waiters,
				// they will observe closed flag after wakeup.
				for old&mutexRMask != 0 {
					old -= mutexRWait
					semrelease(&self.rsema)
				}
				for old&mutexWMask != 0 {
					old -= mutexWWait
					semrelease(&self.wsema)
				}
				ret true
			}
		}
	}

	// Removes a reference from mutex.
	// It reports whether there is no remaining reference.
	fn decref(mut *self): bool {
		for {
			old := atomic::Load(&self.state, atomic::SeqCst)
			if old&mutexRefMask == 0 {
				panic("inconsistent poll.fdMutex")
			}
			new := old - mutexRef
			if atomic::CompareAndSwap(&self.state, old, new, atomic::SeqCst, atomic::Relaxed) {
				ret new&(mutexClosed|mutexRefMask) == mutexClosed
			}
		}
	}

	// Adds a reference to mutex and locks mutex.
	// It reports whether mu is available for reading or writing.
	async fn rwlock(mut *self, read: bool): bool {
		let mut mutexBit: u64
		let mut mutexWait: u64
		let mut mutexMask: u64
		let mut mutexSema: *u32
		if read {
			mutexBit = mutexRLock
			mutexWait = mutexRWait
			mutexMask = mutexRMask
			mutexSema = &self.rsema
		} else {
			mutexBit = mutexWLock
			mutexWait = mutexWWait
			mutexMask = mutexWMask
			mutexSema = &self.wsema
		}
		for {
			old := atomic::Load(&self.state, atomic::SeqCst)
			if old&mutexClosed != 0 {
				ret false
			}
			let mut new: u64
			if old&mutexBit == 0 {
				// Lock is free, acquire it.
				new = (old | mutexBit) + mutexRef
				if new&mutexRefMask == 0 {
					panic(overflowMsg)
				}
			} else {
				// Wait for lock.
				new = old + mutexWait
				if new&mutexMask == 0 {
					panic(overflowMsg)
				}
			}
			if atomic::CompareAndSwap(&self.state, old, new, atomic::SeqCst, atomic::Relaxed) {
				if old&mutexBit == 0 {
					ret true
				}
				unsafe { semacquire(&(*mutexSema)).await }
				// The signaller has subtracted mutexWait.
			}
		}
	}

	// Removes a reference from mutex and unlocks mutex.
	// It reports whether there is no remaining reference.
	fn rwunlock(mut *self, read: bool): bool {
		let mut mutexBit: u64
		let mut mutexWait: u64
		let mut mutexMask: u64
		let mut mutexSema: *u32
		if read {
			mutexBit = mutexRLock
			mutexWait = mutexRWait
			mutexMask = mutexRMask
			mutexSema = &self.rsema
		} else {
			mutexBit = mutexWLock
			mutexWait = mutexWWait
			mutexMask = mutexWMask
			mutexSema = &self.wsema
		}
		for {
			old := atomic::Load(&self.state, atomic::SeqCst)
			if old&mutexBit == 0 || old&mutexRefMask == 0 {
				panic("inconsistent poll.fdMutex")
			}
			// Drop lock, drop reference and wake read waiter if present.
			mut new := (old & ^mutexBit) - mutexRef
			if old&mutexMask != 0 {
				new -= mutexWait
			}
			if atomic::CompareAndSwap(&self.state, old, new, atomic::SeqCst, atomic::Relaxed) {
				if old&mutexMask != 0 {
					unsafe { semrelease(&(*mutexSema)) }
				}
				ret new&(mutexClosed|mutexRefMask) == mutexClosed
			}
		}
	}
}

async fn semacquire(mut &addr: *u32) {
	runtime::semacquire(addr, false, runtime::reasonMutex).await
}

fn semrelease(mut &addr: *u32) {
	runtime::semrelease(addr, false)
}

// Return the appropriate closing error based on isFile.
fn errClosing(isFile: bool)! {
	if isFile {
		error(errors::New("use of closed file"))
	}
	error(errors::New("use of closed network connection"))
}

impl FD {
	// Adds a reference to fd.
	// It returns an error when fd cannot be used.
	fn incref(mut *self)! {
		if !self.fdmu.incref() {
			errClosing(self.isFile())?
		}
	}

	// Removes a reference from fd.
	// It also closes fd when the state of fd is set to closed and there
	// is no remaining reference.
	fn decref(mut *self)! {
		if self.fdmu.decref() {
			self.destroy()?
		}
	}

	// Adds a reference to fd and locks fd for reading.
	// It returns an error when fd cannot be used for reading.
	async fn readLock(mut *self)! {
		if !self.fdmu.rwlock(true).await {
			errClosing(self.isFile())?
		}
	}

	// Removes a reference from fd and unlocks fd for reading.
	// It also closes fd when the state of fd is set to closed and there
	// is no remaining reference.
	fn readUnlock(mut *self) {
		if self.fdmu.rwunlock(true) {
			self.destroy() else {}
		}
	}

	// Adds a reference to fd and locks fd for writing.
	// It returns an error when fd cannot be used for writing.
	async fn writeLock(mut *self)! {
		if !self.fdmu.rwlock(false).await {
			errClosing(self.isFile())?
		}
	}

	// Removes a reference from fd and unlocks fd for writing.
	// It also closes fd when the state of fd is set to closed and there
	// is no remaining reference.
	fn writeUnlock(mut *self) {
		if self.fdmu.rwunlock(false) {
			self.destroy() else {}
		}
	}

	// Adds a reference to fd and locks fd for reading and writing.
	// It returns an error when fd cannot be used for reading and writing.
	async fn readWriteLock(mut *self)! {
		if !self.fdmu.rwlock(true).await || !self.fdmu.rwlock(false).await {
			errClosing(self.isFile())?
		}
	}

	// Removes a reference from fd and unlocks fd for reading and writing.
	// It also closes fd when the state of fd is set to closed and there
	// is no remaining reference.
	fn readWriteUnlock(mut *self) {
		self.fdmu.rwunlock(true)
		self.fdmu.rwunlock(false)
	}

	// closing returns true if fd is closing.
	fn closing(*self): bool {
		ret atomic::Load(&self.fdmu.state, atomic::SeqCst)&mutexClosed != 0
	}
}
// Copyright 2024-2025 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

type MemoryOrder: int

const (
	Relaxed = MemoryOrder(0)
	Consume = MemoryOrder(1)
	Acquire = MemoryOrder(2)
	Release = MemoryOrder(3)
	AcqRel  = MemoryOrder(4)
	SeqCst  = MemoryOrder(5)
)

#cdef
extern unsafe fn __atomic_store(*unsafe, *unsafe, MemoryOrder)

#cdef
extern unsafe fn __atomic_load(*unsafe, *unsafe, MemoryOrder)

#cdef
extern unsafe fn __atomic_exchange[T](*unsafe, *unsafe, *unsafe, MemoryOrder): T

#cdef
extern unsafe fn __atomic_compare_exchange_n[T](*unsafe, *unsafe, T, int, MemoryOrder, MemoryOrder): bool

#cdef
extern unsafe fn __atomic_fetch_add[T](*unsafe, T, MemoryOrder): T

// Atomically stores new value to p with memory order mo, and returns the old value.
fn Swap[T](mut p: *T, new: T, mo: MemoryOrder): (old: T) {
	ret SwapZ(p, new, mo)
}

// Atomically reads value of the p with memory order mo and returns.
fn Load[T](p: *T, mo: MemoryOrder): T {
	ret LoadZ[T, T](p, mo)
}

// Atomically reads value of the p and compares it with old.
// If comparison results with true, it atomically stores new value into p.
// Reports whether swap succeeded.
fn CompareAndSwap[T](mut p: *T, old: T, new: T, succ: MemoryOrder, fail: MemoryOrder): (swapped: bool) {
	ret CompareAndSwapZ(p, old, new, succ, fail)
}

// Atomically reads value of the p and compares it with old.
// If comparison results with true, it atomically stores new value into p.
// Reports whether swap succeeded.
fn CompareAndSwapWeak[T](mut p: *T, old: T, new: T, succ: MemoryOrder, fail: MemoryOrder): (swapped: bool) {
	ret CompareAndSwapWeakZ(p, old, new, succ, fail)
}

// Atomically adds delta to p with memory order mo and returns the new value.
fn Add[T](mut p: *T, delta: T, mo: MemoryOrder): (new: T) {
	ret AddZ(p, delta, mo)
}

// Atomically stores new value to p with memory order mo.
fn Store[T](mut p: *T, val: T, mo: MemoryOrder) {
	StoreZ(p, val, mo)
}

// Atomically stores new value to p with memory order mo, and returns the old value.
// T1 is a base pointer type, T2 is the output type.
fn SwapZ[T1, T2](mut p: *T1, new: T2, mo: MemoryOrder): (old: T2) {
	let mut tmp: T2
	unsafe { extern.__atomic_exchange[T2](p, &new, &tmp, mo) }
	ret tmp
}

// Atomically reads value of the p with memory order mo and returns.
// T1 is a base pointer type, T2 is the output type.
fn LoadZ[T1, T2](p: *T1, mo: MemoryOrder): T2 {
	let mut tmp: T2
	unsafe { extern.__atomic_load(p, &tmp, mo) }
	ret tmp
}

// Atomically reads value of the p and compares it with old.
// If comparison results with true, it atomically stores new value into p.
// Reports whether swap succeeded.
// T1 is a base pointer type, T2 is the output type.
fn CompareAndSwapZ[T1, T2](mut p: *T1, old: T2, new: T2, succ: MemoryOrder, fail: MemoryOrder): (swapped: bool) {
	const Strong = 0 // strong atomicity
	ret unsafe { extern.__atomic_compare_exchange_n[T2](p, &old, new, Strong, succ, fail) }
}

// Atomically reads value of the p and compares it with old.
// If comparison results with true, it atomically stores new value into p.
// Reports whether swap succeeded.
// T1 is a base pointer type, T2 is the output type.
fn CompareAndSwapWeakZ[T1, T2](mut p: *T1, old: T2, new: T2, succ: MemoryOrder, fail: MemoryOrder): (swapped: bool) {
	const Weak = 1 // weak atomicity
	ret unsafe { extern.__atomic_compare_exchange_n[T2](p, &old, new, Weak, succ, fail) }
}

// Atomically adds delta to p with memory order mo and returns the new value.
// T1 is a base pointer type, T2 is the output type.
fn AddZ[T1, T2](mut p: *T1, delta: T2, mo: MemoryOrder): (new: T2) {
	ret unsafe { extern.__atomic_fetch_add[T2](p, delta, mo) } + delta
}

// Atomically stores new value to p with memory order mo.
// T1 is a base pointer type, T2 is the output type.
fn StoreZ[T1, T2](mut p: *T1, val: T2, mo: MemoryOrder) {
	unsafe { extern.__atomic_store(p, &val, mo) }
}
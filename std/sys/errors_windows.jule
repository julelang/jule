// Copyright 2023-2025 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/internal/conv"
use integ "std/jule/integrated"

cpp fn FormatMessageW(flags: cpp.DWORD, msgsrc: *unsafe, msgid: cpp.DWORD, langid: cpp.DWORD, mut buf: *integ::Wchar, size: cpp.DWORD, args: *unsafe): cpp.DWORD

const E2BIG = Errno(0x7)            // Argument list too long
const EACCES = Errno(0xd)           // Permission denied
const EADDRINUSE = Errno(0x64)      // Address already in use
const EADDRNOTAVAIL = Errno(0x65)   // Cannot assign requested address
const EAFNOSUPPORT = Errno(0x66)    // Address family not supported by protocol
const EAGAIN = Errno(0xb)           // Try again
const EALREADY = Errno(0x67)        // Operation already in progress
const EBADF = Errno(0x9)            // Bad file number
const EBADMSG = Errno(0x68)         // Not a data message
const EBUSY = Errno(0x10)           // Device or resource busy
const ECANCELED = Errno(0x69)       // Operation Canceled
const ECHILD = Errno(0xa)           // No child processes
const ECONNABORTED = Errno(0x6a)    // Software caused connection abort
const ECONNREFUSED = Errno(0x6b)    // Connection refused
const ECONNRESET = Errno(0x6c)      // Connection reset by peer
const EDEADLK = Errno(0x24)         // Resource deadlock would occur
const EDEADLOCK = Errno(0x24)       // File locking deadlock error
const EDESTADDRREQ = Errno(0x6d)    // Destination address required
const EDOM = Errno(0x21)            // Math argument out of domain of func
const EEXIST = Errno(0x11)          // File exists
const EFAULT = Errno(0xe)           // Bad address
const EFBIG = Errno(0x1b)           // File too large
const EHOSTUNREACH = Errno(0x6e)    // No route to host
const EIDRM = Errno(0x6f)           // Identifier removed
const EILSEQ = Errno(0x2a)          // Illegal byte sequence
const EINPROGRESS = Errno(0x70)     // Operation now in progress
const EINTR = Errno(0x4)            // Interrupted system call
const EINVAL = Errno(0x16)          // Invalid argument
const EIO = Errno(0x5)              // I/O error
const EISCONN = Errno(0x71)         // Transport endpoint is already connected
const EISDIR = Errno(0x15)          // Is a directory
const ELOOP = Errno(0x72)           // Too many symbolic links encountered
const EMFILE = Errno(0x18)          // Too many open files
const EMLINK = Errno(0x1f)          // Too many links
const EMSGSIZE = Errno(0x73)        // Message too long
const ENAMETOOLONG = Errno(0x26)    // File name too long
const ENETDOWN = Errno(0x74)        // Network is down
const ENETRESET = Errno(0x75)       // Network dropped connection because of reset
const ENETUNREACH = Errno(0x76)     // Network is unreachable
const ENFILE = Errno(0x17)          // File table overflow
const ENOBUFS = Errno(0x77)         // No buffer space available
const ENODATA = Errno(0x78)         // No data available
const ENODEV = Errno(0x13)          // No such device
const ENOENT = Errno(0x2)           // No such file or directory
const ENOEXEC = Errno(0x8)          // Exec format error
const ENOLCK = Errno(0x27)          // No record locks available
const ENOLINK = Errno(0x79)         // Link has been severed
const ENOMEM = Errno(0xc)           // Out of memory
const ENOMSG = Errno(0x7a)          // No message of desired type
const ENOPROTOOPT = Errno(0x7b)     // Protocol not available
const ENOSPC = Errno(0x1c)          // No space left on device
const ENOSR = Errno(0x7c)           // Out of streams resources
const ENOSTR = Errno(0x7d)          // Device not a stream
const ENOSYS = Errno(0x28)          // Function not implemented
const ENOTCONN = Errno(0x7e)        // Transport endpoint is not connected
const ENOTDIR = Errno(0x14)         // Not a directory
const ENOTEMPTY = Errno(0x29)       // Directory not empty
const ENOTRECOVERABLE = Errno(0x7f) // State not recoverable
const ENOTSOCK = Errno(0x80)        // Socket operation on non-socket
const ENOTSUP = Errno(0x81)         // Operation not supported
const ENOTTY = Errno(0x19)          // Not a typewriter
const ENXIO = Errno(0x6)            // No such device or address
const EOPNOTSUPP = Errno(0x82)      // Operation not supported on transport endpoint
const EOVERFLOW = Errno(0x84)       // Value too large for defined data type
const EOWNERDEAD = Errno(0x85)      // Owner died
const EPERM = Errno(0x1)            // Operation not permitted
const EPIPE = Errno(0x20)           // Broken pipe
const EPROTO = Errno(0x86)          // Protocol error
const EPROTONOSUPPORT = Errno(0x87) // Protocol not supported
const EPROTOTYPE = Errno(0x88)      // Protocol wrong type for socket
const ERANGE = Errno(0x22)          // Input is outside the range
const EROFS = Errno(0x1e)           // Read-only file system
const ESPIPE = Errno(0x1d)          // Illegal seek
const ESRCH = Errno(0x3)            // No such process
const ETIME = Errno(0x89)           // Timer expired
const ETIMEDOUT = Errno(0x8a)       // Connection timed out
const ETXTBSY = Errno(0x8b)         // Text file busy
const EWOULDBLOCK = Errno(0x8c)     // Operation would block
const EXDEV = Errno(0x12)           // Cross-device link

const FORMAT_MESSAGE_ALLOCATE_BUFFER = 0x00000100
const FORMAT_MESSAGE_ARGUMENT_ARRAY = 0x00002000
const FORMAT_MESSAGE_FROM_HMODULE = 0x00000800
const FORMAT_MESSAGE_FROM_STRING = 0x00000400
const FORMAT_MESSAGE_FROM_SYSTEM = 0x00001000
const FORMAT_MESSAGE_IGNORE_INSERTS = 0x00000200

// Underliying type of Errno for Windows.
type errno = uintptr

fn getLastErrno(): Errno { ret Errno(GetLastError()) }

fn langid(pri: u16, sub: u16): u32 { ret u32(sub)<<10 | u32(pri) }

fn formatError(e: Errno): str {
	let flags: u32 = FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ARGUMENT_ARRAY | FORMAT_MESSAGE_IGNORE_INSERTS
	mut b := make([]u16, 300)
	mut n := unsafe { cpp.FormatMessageW(cpp.DWORD(flags), nil, cpp.DWORD(e), cpp.DWORD(langid(LANG_ENGLISH, SUBLANG_ENGLISH_US)), (*integ::Wchar)(&b[0]), cpp.DWORD(len(b)), nil) }
	if n == 0 {
		n = unsafe { cpp.FormatMessageW(cpp.DWORD(flags), nil, cpp.DWORD(e), cpp.DWORD(0), (*integ::Wchar)(&b[0]), cpp.DWORD(len(b)), nil) }
		if n == 0 {
			ret "winapi error #" + conv::Itoa(int(e))
		}
	}
	// trim terminating \r and \n
	for n > 0 && (b[n-1] == '\n' || b[n-1] == '\r'); n-- {
	}
	ret integ::UTF16ToStr(b[:n])
}
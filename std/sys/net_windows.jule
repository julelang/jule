// Copyright 2024 The Jule Project Contributors. All rights reserved.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

// Useful links;
// - https://github.com/wine-mirror/wine/blob/master/include/winsock2.h

#pass "-lws2_32"

use "std/integ/c"

extern use "<winsock2.h>"
extern use "<ws2ipdef.h>"

#typedef
extern struct WSADATA{}

extern struct sockaddr{}

#typedef
extern struct fd_set{}

extern let WSASend: *unsafe
extern let WSASendTo: *unsafe
extern let WSARecv: *unsafe
extern let WSARecvFrom: *unsafe
extern let WSASocketW: *unsafe
extern let WSAAccept: *unsafe

extern unsafe fn select(int, *extern.fd_set, *extern.fd_set, *extern.fd_set, *extern.timeval): int
extern unsafe fn bind(Handle, *extern.sockaddr, Socklen): int
extern unsafe fn connect(Handle, *extern.sockaddr, Socklen): int
extern fn listen(Handle, int): int
extern unsafe fn accept(Handle, *extern.sockaddr, *c::Int): Handle
extern unsafe fn recv(uintptr, *c::Char, Socklen, int): int
extern unsafe fn recvfrom(uintptr, *c::Char, int, int, *extern.sockaddr, *c::Int): int
extern unsafe fn sendto(uintptr, *c::Char, int, int, *extern.sockaddr, c::Int): int
extern fn closesocket(Handle): int
extern unsafe fn WSAStartup(u16, mut _: *extern.WSADATA): int
extern unsafe fn getsockopt(Handle, int, int, *c::Char, *c::Int): int
extern unsafe fn setsockopt(Handle, int, int, *c::Char, int): int
extern unsafe fn getsockname(Handle, *extern.sockaddr, *c::Int): int
extern unsafe fn WSAIoctl(Handle, extern.DWORD, *unsafe, extern.DWORD, *unsafe, extern.DWORD, *extern.DWORD, *unsafe, *unsafe): int

// C's WSADATA struct.
type WsaData: extern.WSADATA

const (
	INVALID_SOCKET = ^Handle(0)
	SOCKET_ERROR   = -1
)

const INADDR_ANY = 0

const (
	SO_ERROR    = 0x1007
	SO_RCVTIMEO = 0x1006
	SO_SNDTIMEO = 0x1005
)

fn WSASocket(domain: int, typ: int, proto: int, &protinfo: *WSAProtocolInfo, group: u32, flags: u32)!: (fd: Handle) {
	r := Addrcall[*unsafe](uintptr(extern.WSASocketW), domain, typ, proto, protinfo, group, flags)
	fd = Handle(r)
	if fd == INVALID_SOCKET {
		error(Errno(WSAGetLastError()))
	}
	ret
}

fn Bind(s: Handle, addr: uintptr, addrlen: Socklen)! {
	r := unsafe { extern.bind(s, (*extern.sockaddr)(addr), addrlen) }
	if r == SOCKET_ERROR {
		error(Errno(WSAGetLastError()))
	}
}

fn Connect(s: Handle, addr: uintptr, addrlen: Socklen)! {
	r := unsafe { extern.connect(s, (*extern.sockaddr)(addr), addrlen) }
	if r == SOCKET_ERROR {
		error(Errno(WSAGetLastError()))
	}
}

fn Listen(s: Handle, backlog: int)! {
	r := extern.listen(s, backlog)
	if r == SOCKET_ERROR {
		error(Errno(WSAGetLastError()))
	}
}

fn WSARecv(s: Handle, &bufs: *WSABuf, bufcnt: u32, mut recvd: *u32, flags: *u32, &overlapped: *Overlapped, croutine: *byte)! {
	r := Addrcall[i32](uintptr(extern.WSARecv), s, bufs, bufcnt, recvd, flags, overlapped, croutine)
	if r == SOCKET_ERROR {
		error(Errno(WSAGetLastError()))
	}
}

fn WSARecvFrom(s: Handle, &bufs: *WSABuf, bufcnt: u32, mut &recvd: *u32, &flags: *u32, &from: *RawSockaddrAny, &fromlen: *i32, &overlapped: *Overlapped, croutine: *byte)! {
	r := Addrcall[i32](uintptr(extern.WSARecv), s, bufs, bufcnt, recvd, flags, from, fromlen, overlapped, croutine)
	if r == SOCKET_ERROR {
		error(Errno(WSAGetLastError()))
	}
}

fn WSASend(s: Handle, &bufs: *WSABuf, bufcnt: u32, mut &sent: *u32, flags: u32, &overlapped: *Overlapped, &croutine: *byte)! {
	r := Addrcall[i32](uintptr(extern.WSASend), s, bufs, bufcnt, sent, flags, overlapped, croutine)
	if r == SOCKET_ERROR {
		error(Errno(WSAGetLastError()))
	}
}

fn WSASendto(s: Handle, &bufs: *WSABuf, bufcnt: u32, mut &sent: *u32, flags: u32, &to: *RawSockaddrAny, tolen: i32, &overlapped: *Overlapped, &croutine: *byte)! {
	r := Addrcall[i32](uintptr(extern.WSASendTo), s, bufs, bufcnt, sent, flags, to, tolen, overlapped, croutine)
	if r == SOCKET_ERROR {
		error(Errno(WSAGetLastError()))
	}
}

fn CloseSocket(s: Handle)! {
	r := extern.closesocket(s)
	if r == SOCKET_ERROR {
		error(Errno(WSAGetLastError()))
	}
}

fn WSAStartup(verReq: u16, mut &data: *WsaData)! {
	r := unsafe { extern.WSAStartup(verReq, (*extern.WSADATA)(data)) }
	if r != 0 {
		error(Errno(WSAGetLastError()))
	}
}

unsafe fn WSAIoctl(h: Handle, iocc: u32, inbuf: *byte, cbif: u32, outbuf: *byte, cbob: u32, cbbr: *u32): int {
	ret extern.WSAIoctl(h, extern.DWORD(iocc), inbuf, extern.DWORD(cbif), outbuf, extern.DWORD(cbob), (*extern.DWORD)(cbbr), nil, nil)
}

fn MakeWord(a: u8, b: u8): u16 {
	ret u16(a) | u16(b)<<8
}

fn Getsockopt(s: Handle, level: int, name: int, val: Handle, vallen: Socklen)! {
	vallen2 := unsafe { c::Int(vallen) }
	r := unsafe { extern.getsockopt(s, level, name, (*c::Char)(val), &vallen2) }
	if r == SOCKET_ERROR {
		error(Errno(WSAGetLastError()))
	}
}

fn Setsockopt(s: Handle, level: int, name: int, val: uintptr, vallen: Socklen)! {
	r := unsafe { extern.setsockopt(s, level, name, (*c::Char)(val), int(vallen)) }
	if r == SOCKET_ERROR {
		error(Errno(WSAGetLastError()))
	}
}

fn Getsockname(fd: Handle, addr: uintptr, addrlen: Socklen)! {
	addrlen2 := unsafe { c::Int(addrlen) }
	r := unsafe { extern.getsockname(fd, (*extern.sockaddr)(addr), &addrlen2) }
	if r == SOCKET_ERROR {
		error(Errno(WSAGetLastError()))
	}
}

fn Select(nfd: int, mut &r: *FdSet, mut &w: *FdSet, mut &e: *FdSet, mut &timeout: *Timeval)!: (n: int) {
	n = unsafe { extern.select(nfd, (*extern.fd_set)(r), (*extern.fd_set)(w), (*extern.fd_set)(e), (*extern.timeval)(timeout)) }
	if n < 0 {
		error(Errno(WSAGetLastError()))
	}
	ret
}
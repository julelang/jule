// Copyright 2023-2025 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/conv"
use "std/internal/byteslite"
use "std/unicode/utf8"
use "std/unsafe"

// An error for literal parsing.
struct Error {
	Offset: int
	Text:   str
}

// Reports whether rune is byte actually.
// In other words, whether rune is ASCII.
fn IsAscii(r: rune): bool {
	const MaxAscii = 1<<7 - 1
	ret r <= MaxAscii
}

// Returns rune value string from literal, includes quotes.
// Bytes are represents rune literal, allows escape sequences.
// Returns zero rune if len(lit) == 0.
// Assumes lit is syntaticaly and semantically correct.
fn ToRune(mut lit: str): (rune, errors: []Error) {
	mut r := rune(0)
	lit = lit[1 : len(lit)-1]
	if lit[0] == '\\' && len(lit) > 1 {
		mut i := 0
		r, _ = runeFromEsqSeq(lit, i, errors)
	} else {
		r, _ = utf8::DecodeRuneStr(lit)
	}
	ret r, errors
}

// Returns raw-string value string from literal, includes quotes.
// Bytes are represents string characters.
// Returns empty string if len(lit) == 0.
// Assumes lit is syntaticaly and semantically correct.
fn ToRawStr(lit: str): str {
	if len(lit) == 2 {
		ret ""
	}
	ret lit[1 : len(lit)-1]
}

// Returns string value string from literal, includes quotes.
// Bytes are represents string characters, allows escape sequences.
// Returns empty string if len(lit) == 0.
// Assumes lit is syntaticaly and semantically correct.
fn ToStr(mut lit: str): (str, errors: []Error) {
	if len(lit) == 2 {
		ret "", nil
	}
	// If no escape sequence used, return the string directly with no quotes.
	escapeseq := byteslite::IndexByteStr(lit, '\\') >= 0
	if escapeseq {
		ret lit[1 : len(lit)-1], nil
	}

	// String is not pure.
	// Handle unicode characters and escape sequences.
	lit = lit[1 : len(lit)-1]
	mut s := make([]byte, 0, len(lit))
	mut i := 0
	for i < len(lit) {
		b := lit[i]
		if b == '\\' {
			strEsqSeq(s, lit, i, errors)
		} else {
			r, size := utf8::DecodeRuneStr(lit[i:])
			i += size
			s = utf8::AppendRune(s, r)
		}
	}
	ret unsafe::StrFromBytes(s), errors
}

fn tryBtoaCommonEsq(s: str): (seq: byte, ok: bool) {
	if len(s) < 2 || s[0] != '\\' {
		ret
	}
	match s[1] {
	| '\\':
		seq = '\\'
	| '\'':
		seq = '\''
	| '"':
		seq = '"'
	| 'a':
		seq = '\a'
	| 'b':
		seq = '\b'
	| 'f':
		seq = '\f'
	| 'n':
		seq = '\n'
	| 'r':
		seq = '\r'
	| 't':
		seq = '\t'
	| 'v':
		seq = '\v'
	}
	ok = seq != 0
	ret
}

fn runeFromEsqSeq(s: str, mut &i: int, mut &errors: []Error): (r: rune, isByte: bool) {
	b, ok := tryBtoaCommonEsq(s[i:])
	i++ // Skip escape sequence solidus.
	if ok {
		i++ // Skip sequence specifier.
		ret rune(b), true
	}

	match s[i] {
	| 'u':
		const SeqLen = 5
		r = rune(conv::ParseUint(s[i+1:i+SeqLen], 16, 64)!)
		i += SeqLen
	| 'U':
		const SeqLen = 9
		r = rune(conv::ParseUint(s[i+1:i+SeqLen], 16, 64)!)
		i += SeqLen
	| 'x':
		isByte = true
		const SeqLen = 3
		seq := s[i+1 : i+SeqLen]
		hex := conv::ParseUint(seq, 16, 64)!
		if hex > 255 {
			// This should be impossible case, but play safe.
			errors = append(errors, Error{
				Offset: i,
				Text: "hexadecimal escape value "+conv::FmtUint(hex, 10)+" > 255",
			})
		}
		i += SeqLen
		r = rune(hex)
	|:
		isByte = true
		const SeqLen = 3
		seq := s[i : i+SeqLen]
		octal := conv::ParseUint(seq, 8, 64)!
		if octal > 255 {
			errors = append(errors, Error{
				Offset: i,
				Text: "octal escape value "+conv::FmtUint(octal, 10)+" > 255",
			})
		}
		i += SeqLen
		r = rune(octal)
	}
	ret
}

fn strEsqSeq(mut &buf: []byte, s: str, mut &i: int, mut &errors: []Error) {
	r, isByte := runeFromEsqSeq(s, i, errors)
	if isByte {
		buf = append(buf, byte(r))
		ret
	}
	// Unicode code point.
	buf = utf8::AppendRune(buf, r)
}
// Copyright 2023-2025 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/conv"
use "std/math/big"

// Constant data.
// Use Const.new_nil function instead of Const{} for nil literal.
struct Const {
	Kind: str
	data: any
}

impl Const {
	// Returns new constant value instance from big-integer.
	static fn NewInt(i: big::Int): &Const { ret &Const{data: i} }

	// Returns new constant value instance from 64-bit signed integer.
	static fn NewI64(x: i64): &Const { ret &Const{data: big::Int.FromI64(x)} }

	// Returns new constant value instance from 64-bit unsigned integer.
	static fn NewU64(x: u64): &Const { ret &Const{data: big::Int.FromU64(x)} }

	// Returns new constant value instance from boolean.
	static fn NewBool(x: bool): &Const { ret &Const{data: x} }

	// Returns new constant value instance from string.
	static fn NewStr(x: str): &Const { ret &Const{data: x} }

	// Returns new constant value instance from 64-bit floating-point.
	static fn NewF64(x: f64): &Const { ret &Const{data: x} }

	// Returns new constant value instance with nil.
	static fn NewNil(): &Const { ret &Const{data: nil} }
}

impl Const {
	//
	// Read
	//

	// Reads integer data.
	// Returns zero value if data is not integer.
	fn ReadInt(mut self): big::Int {
		mut i, _ := (big::Int)(self.data)
		ret i
	}

	// Reads boolean data.
	// Returns false if data is not boolean.
	fn ReadBool(self): bool {
		if !self.IsBool() {
			ret false
		}
		ret bool(self.data)
	}

	// Reads string data.
	// Returns empty string if data is not string.
	fn ReadStr(self): str {
		if !self.IsStr() {
			ret ""
		}
		ret str(self.data)
	}

	// Reads 64-bit floating-point data.
	// Returns 0 if data is not 64-bit floating-point.
	fn ReadF64(self): f64 {
		if !self.IsF64() {
			ret 0
		}
		ret f64(self.data)
	}

	//
	// Castings
	//

	// Reads data as 64-bit signed integer.
	// Returns 0 if data is string, bool or which is not numeric.
	fn AsI64(self): i64 {
		match type self.data {
		| big::Int:
			i := (big::Int)(self.data)
			if i.IsI64() {
				ret i.I64()
			}
			ret i64(i.U64())
		| f64:
			ret i64(f64(self.data))
		|:
			ret 0
		}
	}

	// Reads data as 64-bit unsigned integer.
	// Returns 0 if data is string, bool or which is not numeric.
	fn AsU64(self): u64 {
		match type self.data {
		| big::Int:
			i := (big::Int)(self.data)
			if i.IsU64() {
				ret i.U64()
			}
			ret u64(i.I64())
		| f64:
			ret u64(f64(self.data))
		|:
			ret 0
		}
	}

	// Reads data as 64-bit floating-point.
	// Returns 0 if data is string, bool or which is not numeric.
	fn AsF64(self): f64 {
		match type self.data {
		| f64:
			ret f64(self.data)
		| big::Int:
			f, _ := (big::Int)(self.data).F64()
			ret f
		|:
			ret 0
		}
	}

	//
	// Set
	//

	// Sets constant value from big-integer.
	fn SetInt(mut self, x: big::Int) { self.data = x }

	// Sets constant value from 64-bit signed integer.
	fn SetI64(mut self, x: i64) { self.data = big::Int.FromI64(x) }

	// Sets constant value from 64-bit unsigned integer.
	fn SetU64(mut self, x: u64) { self.data = big::Int.FromU64(x) }

	// Sets constant value from boolean.
	fn SetBool(mut self, x: bool) { self.data = x }

	// Sets constant value from string.
	fn SetStr(mut self, x: str) { self.data = x }

	// Sets constant value from 64-bit floating-point.
	fn SetF64(mut self, x: f64) { self.data = x }

	// Sets constant value to nil.
	fn SetNil(mut self) { self.data = nil }

	//
	// Types
	//

	// Reports whether data is integer.
	fn IsInt(self): bool {
		_, ok := (big::Int)(self.data)
		ret ok
	}

	// Reports whether data is boolean.
	fn IsBool(self): bool {
		_, ok := bool(self.data)
		ret ok
	}

	// Reports whether data is string.
	fn IsStr(self): bool {
		_, ok := str(self.data)
		ret ok
	}

	// Reports whether data is 64-bit floating-point.
	fn IsF64(self): bool {
		_, ok := f64(self.data)
		ret ok
	}

	// Reports whether data is nil.
	fn IsNil(self): bool { ret self.data == nil }

	// Reports whether self and x has same type.
	fn AreSameTypes(self, x: Const): bool {
		match {
		| self.IsInt() == x.IsInt():
			ret true
		| self.IsF64() == x.IsF64():
			ret true
		| self.IsBool() == x.IsBool():
			ret true
		| self.IsStr() == x.IsStr():
			ret true
		| self.IsNil() == x.IsNil():
			ret true
		|:
			ret false
		}
	}

	//
	// Logical
	//

	// Reports whether self and x are true.
	// Returns false if type is not supported.
	fn And(self, x: Const): bool {
		match {
		| self.IsBool() && x.IsBool():
			ret self.ReadBool() && x.ReadBool()
		|:
			ret false
		}
	}

	// Reports whether self or x is true.
	// Returns false if type is not supported.
	fn Or(self, x: Const): bool {
		match {
		| self.IsBool() && x.IsBool():
			ret self.ReadBool() || x.ReadBool()
		|:
			ret false
		}
	}

	// Reports whether self and x are equals.
	// Returns false if type is not supported.
	fn Eq(self, x: Const): bool {
		match {
		| self.IsNil():
			ret x.IsNil()
		| self.IsBool():
			ret x.IsBool() && self.ReadBool() == x.ReadBool()
		| self.IsStr():
			ret x.IsStr() && self.ReadStr() == x.ReadStr()
		| self.IsInt():
			i := (big::Int)(self.data)
			if x.IsInt() {
				ret i.Cmp((big::Int)(x.data)) == 0
			}
			if i.Sign() == -1 {
				ret i.I64() == x.AsI64()
			}
			ret i.U64() == x.AsU64()
		| self.IsF64():
			ret self.ReadF64() == x.AsF64()
		|:
			ret false
		}
	}

	// Reports whether self less than x.
	// Returns false if type is unsupported by operation.
	//
	// Supported types are:
	//	- strings
	//	- 64-bit signed integer
	//	- 64-bit unsigned integer
	//	- 64-bit floating-point
	fn Lt(self, x: Const): bool {
		match {
		| self.IsStr():
			ret x.IsStr() && self.ReadStr() < x.ReadStr()
		| self.IsInt():
			i := (big::Int)(self.data)
			if x.IsInt() {
				ret i.Cmp((big::Int)(x.data)) == -1
			}
			if i.Sign() == -1 {
				ret i.I64() < x.AsI64()
			}
			ret i.U64() < x.AsU64()
		| self.IsF64():
			ret self.ReadF64() < x.AsF64()
		|:
			ret false
		}
	}

	// Reports whether self less than or equals to x.
	// Returns false if type is unsupported by operation.
	//
	// Supported types are:
	//	- strings
	//	- 64-bit signed integer
	//	- 64-bit unsigned integer
	//	- 64-bit floating-point
	fn LtEq(self, x: Const): bool {
		match {
		| self.IsStr():
			ret x.IsStr() && self.ReadStr() <= x.ReadStr()
		| self.IsInt():
			i := (big::Int)(self.data)
			if x.IsInt() {
				ret i.Cmp((big::Int)(x.data)) <= 0
			}
			if i.Sign() == -1 {
				ret i.I64() <= x.AsI64()
			}
			ret i.U64() <= x.AsU64()
		| self.IsF64():
			ret self.ReadF64() <= x.AsF64()
		|:
			ret false
		}
	}

	// Reports whether self greater than x.
	// Returns false if type is unsupported by operation.
	//
	// Supported types are:
	//	- strings
	//	- 64-bit signed integer
	//	- 64-bit unsigned integer
	//	- 64-bit floating-point
	fn Gt(self, x: Const): bool {
		match {
		| self.IsStr():
			ret x.IsStr() && self.ReadStr() > x.ReadStr()
		| self.IsInt():
			i := (big::Int)(self.data)
			if x.IsInt() {
				ret i.Cmp((big::Int)(x.data)) > 0
			}
			if i.Sign() == -1 {
				ret i.I64() > x.AsI64()
			}
			ret i.U64() > x.AsU64()
		| self.IsF64():
			ret self.ReadF64() > x.AsF64()
		|:
			ret false
		}
	}

	// Reports whether self greater than or equals to x.
	// Returns false if type is unsupported by operation.
	//
	// Supported types are:
	//	- strings
	//	- 64-bit signed integer
	//	- 64-bit unsigned integer
	//	- 64-bit floating-point
	fn GtEq(self, x: Const): bool {
		match {
		| self.IsStr():
			ret x.IsStr() && self.ReadStr() >= x.ReadStr()
		| self.IsInt():
			i := (big::Int)(self.data)
			if x.IsInt() {
				ret i.Cmp((big::Int)(x.data)) >= 0
			}
			if i.Sign() == -1 {
				ret i.I64() >= x.AsI64()
			}
			ret i.U64() >= x.AsU64()
		| self.IsF64():
			ret self.ReadF64() >= x.AsF64()
		|:
			ret false
		}
	}

	//
	// Ops
	//

	// Adds x's value to itself value.
	// Reports whether operation is success.
	fn Add(mut self, x: Const): bool {
		match {
		| self.IsStr():
			if !x.IsStr() {
				ret false
			}
			self.SetStr(self.ReadStr() + x.ReadStr())
		| self.IsF64():
			self.SetF64(self.ReadF64() + x.AsF64())
		| self.IsInt():
			i := (big::Int)(self.data)
			if x.IsInt() {
				self.SetInt(i.Add((big::Int)(x.data)))
			} else {
				// If x is not integer, it should be float.
				if i.Sign() == -1 {
					self.SetF64(f64(i.I64()) + x.AsF64())
				} else {
					self.SetF64(f64(i.U64()) + x.AsF64())
				}
			}
		|:
			ret false
		}
		ret true
	}

	// Subs x's value from itself value.
	// Reports whether operation is success.
	fn Sub(mut self, x: Const): bool {
		match {
		| self.IsF64():
			self.SetF64(self.ReadF64() - x.AsF64())
		| self.IsInt():
			i := (big::Int)(self.data)
			if x.IsInt() {
				self.SetInt(i.Sub((big::Int)(x.data)))
			} else {
				// If x is not integer, it should be float.
				if i.Sign() == -1 {
					self.SetF64(f64(i.I64()) - x.AsF64())
				} else {
					self.SetF64(f64(i.U64()) - x.AsF64())
				}
			}
		|:
			ret false
		}
		ret true
	}

	// Multiplies x's value to c's value.
	// Reports whether operation is success.
	fn Mul(mut self, x: Const): bool {
		match {
		| self.IsF64():
			self.SetF64(self.ReadF64() * x.AsF64())
		| self.IsInt():
			i := (big::Int)(self.data)
			if x.IsInt() {
				self.SetInt(i.Mul((big::Int)(x.data)))
			} else {
				// If x is not integer, it should be float.
				if i.Sign() == -1 {
					self.SetF64(f64(i.I64()) * x.AsF64())
				} else {
					self.SetF64(f64(i.U64()) * x.AsF64())
				}
			}
		|:
			ret false
		}
		ret true
	}

	// Divides itself value to x's value.
	// Reports whether operation is success.
	// Reports false if divided-by-zero.
	//
	// NOTICE
	//	This operation makes constant value is floating-point.
	fn Div(mut self, x: Const): bool {
		match {
		| self.IsF64():
			l := x.AsF64()
			if l == 0 {
				ret false
			}
			self.SetF64(self.ReadF64() / l)
		| self.IsInt():
			i := (big::Int)(self.data)
			if x.IsInt() {
				j := (big::Int)(x.data)
				if j.Cmp(big::Int{}) == 0 {
					ret false
				}
				r, _ := i.QuoRem(j)
				self.SetInt(r)
			} else {
				// If x is not integer, it should be float.
				if i.Sign() == -1 {
					self.SetF64(f64(i.I64()) / x.AsF64())
				} else {
					self.SetF64(f64(i.U64()) / x.AsF64())
				}
			}
		|:
			ret false
		}
		ret true
	}

	// Mods itself value to x's value.
	// Reports whether operation is success.
	// Reports false if divided-by-zero.
	fn Mod(mut self, x: Const): bool {
		i, mut ok := (big::Int)(self.data)
		if !ok {
			ret false
		}
		xi, ok := (big::Int)(x.data)
		if !ok {
			ret false
		}
		_, r := i.QuoRem(xi)
		self.SetInt(r)
		ret true
	}

	// Bitwise and itself value to x's value.
	// Reports whether operation is success.
	fn BitwiseAnd(mut self, x: Const): bool {
		i, mut ok := (big::Int)(self.data)
		if !ok {
			ret false
		}
		xi, ok := (big::Int)(x.data)
		if !ok {
			ret false
		}
		self.SetInt(i.And(xi))
		ret true
	}

	// Bitwise or itself value to x's value.
	// Reports whether operation is success.
	fn BitwiseOr(mut self, x: Const): bool {
		i, mut ok := (big::Int)(self.data)
		if !ok {
			ret false
		}
		xi, ok := (big::Int)(x.data)
		if !ok {
			ret false
		}
		self.SetInt(i.Or(xi))
		ret true
	}

	// Bitwise xor itself value to x's value.
	// Reports whether operation is success.
	fn Xor(mut self, x: Const): bool {
		i, mut ok := (big::Int)(self.data)
		if !ok {
			ret false
		}
		xi, ok := (big::Int)(x.data)
		if !ok {
			ret false
		}
		self.SetInt(i.Xor(xi))
		ret true
	}

	// Left shifts itself value to x's value.
	// Reports whether operation is success.
	fn Lshift(mut self, x: Const): bool {
		i, mut ok := (big::Int)(self.data)
		if !ok {
			ret false
		}
		xi, ok := (big::Int)(x.data)
		if !ok {
			ret false
		}
		self.SetInt(i.Lsh(uint(xi.U64())))
		ret true
	}

	// Right shifts itself value to x's value.
	// Reports whether operation is success.
	fn Rshift(mut self, x: Const): bool {
		i, mut ok := (big::Int)(self.data)
		if !ok {
			ret false
		}
		xi, ok := (big::Int)(x.data)
		if !ok {
			ret false
		}
		self.SetInt(i.Rsh(uint(xi.U64())))
		ret true
	}

	fn Str(self): str {
		match {
		| self.IsNil():
			ret "nil"
		| self.IsBool():
			if bool(self.data) {
				ret "true"
			}
			ret "false"
		| self.IsStr():
			ret str(self.data)
		| self.IsInt():
			i := (big::Int)(self.data)
			ret i.Format(10)
		| self.IsF64():
			ret conv::FormatFloat(f64(self.data), 'g', -1, 64)
		|:
			panic("unreachable")
		}
	}
}
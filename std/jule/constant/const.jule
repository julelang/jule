// Copyright 2023 The Jule Project Contributors. All rights reserved.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/conv"
use "std/math/big"

// Constant data.
// Use NewNil function instead of Const{} for nil literal.
struct Const {
	Kind: str
	data: any
}

// Returns new constant value instance from big-integer.
fn NewInt(i: big::Int): &Const { ret &Const{data: i} }

// Returns new constant value instance from 64-bit signed integer.
// Value will have big-integer precision.
fn NewI64(x: i64): &Const { ret &Const{data: big::Int.New(x)} }

// Returns new constant value instance from 64-bit unsigned integer.
// Value will have big-integer precision.
fn NewU64(x: u64): &Const {
	let mut i: big::Int
	i.SetU64(x)
	ret &Const{data: i}
}

// Returns new constant value instance from boolean.
fn NewBool(x: bool): &Const { ret &Const{data: x} }

// Returns new constant value instance from string.
fn NewStr(x: str): &Const { ret &Const{data: x} }

// Returns new constant value instance from 64-bit floating-point.
fn NewF64(x: f64): &Const { ret &Const{data: x} }

// Returns new constant value instance from 128-bit floating-point complex.
fn NewCmplx128(x: cmplx128): &Const { ret &Const{data: x} }

// Returns new constant value instance with nil.
fn NewNil(): &Const { ret &Const{data: nil} }

impl Const {
	//
	// Read
	//

	// Reads integer data.
	// Returns zero value if data is not integer.
	fn ReadInt(*self): big::Int {
		mut i, _ := self.data.(big::Int)
		ret i
	}

	// Reads boolean data.
	// Returns false if data is not boolean.
	fn ReadBool(*self): bool {
		if !self.IsBool() {
			ret false
		}
		ret self.data.(bool)
	}

	// Reads string data.
	// Returns empty string if data is not string.
	fn ReadStr(*self): str {
		if !self.IsStr() {
			ret ""
		}
		ret self.data.(str)
	}

	// Reads 64-bit floating-point data.
	// Returns 0 if data is not 64-bit floating-point.
	fn ReadF64(*self): f64 {
		if !self.IsF64() {
			ret 0
		}
		ret self.data.(f64)
	}

	// Reads 128-bit floating-point complex data.
	// Returns 0 if data is not 128-bit floating-point complex.
	fn ReadCmplx128(*self): cmplx128 {
		if !self.IsCmplx128() {
			ret 0
		}
		ret self.data.(cmplx128)
	}

	//
	// Castings
	//

	// Reads data as 64-bit signed integer.
	// Returns 0 if data is string, bool or which is not numeric.
	fn AsI64(*self): i64 {
		match type self.data {
		| big::Int:
			i := self.data.(big::Int)
			if i.IsI64() {
				ret i.I64()
			}
			ret i64(i.U64())
		| f64:
			ret i64(self.data.(f64))
		|:
			ret 0
		}
	}

	// Reads data as 64-bit unsigned integer.
	// Returns 0 if data is string, bool or which is not numeric.
	fn AsU64(*self): u64 {
		match type self.data {
		| big::Int:
			i := self.data.(big::Int)
			if i.IsU64() {
				ret i.U64()
			}
			ret u64(i.I64())
		| f64:
			ret u64(self.data.(f64))
		|:
			ret 0
		}
	}

	// Reads data as 64-bit floating-point.
	// Returns 0 if data is string, bool or which is not numeric.
	fn AsF64(*self): f64 {
		match type self.data {
		| f64:
			ret self.data.(f64)
		| big::Int:
			f, _ := self.data.(big::Int).F64()
			ret f
		|:
			ret 0
		}
	}

	// Reads data as 128-bit floating-point complex.
	// Returns 0 if data is string, bool or which is not numeric.
	fn AsCmplx128(*self): cmplx128 {
		match type self.data {
		| f64:
			ret cmplx(self.data.(f64), 0)
		| big::Int:
			f, _ := self.data.(big::Int).F64()
			ret cmplx(f, 0)
		| cmplx128:
			ret self.data.(cmplx128)
		|:
			ret 0
		}
	}

	// Sets constant value from big-integer.
	fn SetInt(mut *self, x: big::Int) { self.data = x }

	// Sets constant value from 64-bit signed integer.
	fn SetI64(mut *self, x: i64) { self.data = big::Int.New(x) }

	// Sets constant value from 64-bit unsigned integer.
	fn SetU64(mut *self, x: u64) {
		let mut i: big::Int
		i.SetU64(x)
		self.data = i
	}

	// Sets constant value from boolean.
	fn SetBool(mut *self, x: bool) { self.data = x }

	// Sets constant value from string.
	fn SetStr(mut *self, x: str) { self.data = x }

	// Sets constant value from 64-bit floating-point.
	fn SetF64(mut *self, x: f64) { self.data = x }

	// Sets constant value from 128-bit floating-point complex.
	fn SetCmplx128(mut *self, x: cmplx128) { self.data = x }

	// Sets constant value to nil.
	fn SetNil(mut *self) { self.data = nil }

	// Reports whether data is integer.
	fn IsInt(*self): bool {
		_, ok := self.data.(big::Int)
		ret ok
	}

	// Reports whether data is boolean.
	fn IsBool(*self): bool {
		_, ok := self.data.(bool)
		ret ok
	}

	// Reports whether data is string.
	fn IsStr(*self): bool {
		_, ok := self.data.(str)
		ret ok
	}

	// Reports whether data is 64-bit floating-point.
	fn IsF64(*self): bool {
		_, ok := self.data.(f64)
		ret ok
	}

	// Reports whether data is 128-bit floating-point complex.
	fn IsCmplx128(*self): bool {
		_, ok := self.data.(cmplx128)
		ret ok
	}

	// Reports whether data is nil.
	fn IsNil(*self): bool { ret self.data == nil }

	// Reports whether self and x has same type.
	fn AreSameTypes(*self, x: Const): bool {
		match {
		| self.IsInt() == x.IsInt():
			ret true
		| self.IsF64() == x.IsF64():
			ret true
		| self.IsCmplx128() == x.IsCmplx128():
			ret true
		| self.IsBool() == x.IsBool():
			ret true
		| self.IsStr() == x.IsStr():
			ret true
		| self.IsNil() == x.IsNil():
			ret true
		|:
			ret false
		}
	}

	// Reports whether self and x are true.
	// Returns false if type is not supported.
	fn LAND(*self, x: Const): bool {
		match {
		| self.IsBool() && x.IsBool():
			ret self.ReadBool() && x.ReadBool()
		|:
			ret false
		}
	}

	// Reports whether self or x is true.
	// Returns false if type is not supported.
	fn LOR(*self, x: Const): bool {
		match {
		| self.IsBool() && x.IsBool():
			ret self.ReadBool() || x.ReadBool()
		|:
			ret false
		}
	}

	// Reports whether self and x are equals.
	// Returns false if type is not supported.
	fn EQL(*self, x: Const): bool {
		match {
		| self.IsNil():
			ret x.IsNil()
		| self.IsBool():
			ret x.IsBool() && self.ReadBool() == x.ReadBool()
		| self.IsStr():
			ret x.IsStr() && self.ReadStr() == x.ReadStr()
		| self.IsInt():
			a := self.data.(big::Int)
			if x.IsInt() {
				b := x.data.(big::Int)
				ret a.Cmp(&b) == 0
			}
			if a.Sign() == -1 {
				ret a.I64() == x.AsI64()
			}
			ret a.U64() == x.AsU64()
		| self.IsF64():
			ret self.ReadF64() == x.AsF64()
		| self.IsCmplx128():
			ret self.ReadCmplx128() == x.AsCmplx128()
		|:
			ret false
		}
	}

	// Reports whether self less than x.
	// Returns false if type is unsupported by operation.
	//
	// Supported types are:
	//	- strings
	//	- 64-bit signed integer
	//	- 64-bit unsigned integer
	//	- 64-bit floating-point
	fn LSS(*self, x: Const): bool {
		match {
		| self.IsStr():
			ret x.IsStr() && self.ReadStr() < x.ReadStr()
		| self.IsInt():
			a := self.data.(big::Int)
			if x.IsInt() {
				b := x.data.(big::Int)
				ret a.Cmp(&b) == -1
			}
			if a.Sign() == -1 {
				ret a.I64() < x.AsI64()
			}
			ret a.U64() < x.AsU64()
		| self.IsF64():
			ret self.ReadF64() < x.AsF64()
		|:
			ret false
		}
	}

	// Reports whether self less than or equals to x.
	// Returns false if type is unsupported by operation.
	//
	// Supported types are:
	//	- strings
	//	- 64-bit signed integer
	//	- 64-bit unsigned integer
	//	- 64-bit floating-point
	fn LEQ(*self, x: Const): bool {
		match {
		| self.IsStr():
			ret x.IsStr() && self.ReadStr() <= x.ReadStr()
		| self.IsInt():
			a := self.data.(big::Int)
			if x.IsInt() {
				b := x.data.(big::Int)
				ret a.Cmp(&b) <= 0
			}
			if a.Sign() == -1 {
				ret a.I64() <= x.AsI64()
			}
			ret a.U64() <= x.AsU64()
		| self.IsF64():
			ret self.ReadF64() <= x.AsF64()
		|:
			ret false
		}
	}

	// Reports whether self greater than x.
	// Returns false if type is unsupported by operation.
	//
	// Supported types are:
	//	- strings
	//	- 64-bit signed integer
	//	- 64-bit unsigned integer
	//	- 64-bit floating-point
	fn GTR(*self, x: Const): bool {
		match {
		| self.IsStr():
			ret x.IsStr() && self.ReadStr() > x.ReadStr()
		| self.IsInt():
			a := self.data.(big::Int)
			if x.IsInt() {
				b := x.data.(big::Int)
				ret a.Cmp(&b) > 0
			}
			if a.Sign() == -1 {
				ret a.I64() > x.AsI64()
			}
			ret a.U64() > x.AsU64()
		| self.IsF64():
			ret self.ReadF64() > x.AsF64()
		|:
			ret false
		}
	}

	// Reports whether self greater than or equals to x.
	// Returns false if type is unsupported by operation.
	//
	// Supported types are:
	//	- strings
	//	- 64-bit signed integer
	//	- 64-bit unsigned integer
	//	- 64-bit floating-point
	fn GEQ(*self, x: Const): bool {
		match {
		| self.IsStr():
			ret x.IsStr() && self.ReadStr() >= x.ReadStr()
		| self.IsInt():
			a := self.data.(big::Int)
			if x.IsInt() {
				b := x.data.(big::Int)
				ret a.Cmp(&b) >= 0
			}
			if a.Sign() == -1 {
				ret a.I64() >= x.AsI64()
			}
			ret a.U64() >= x.AsU64()
		| self.IsF64():
			ret self.ReadF64() >= x.AsF64()
		|:
			ret false
		}
	}

	// Adds x's value to itself value.
	// Reports whether operation is success.
	fn ADD(mut *self, x: Const): bool {
		match {
		| self.IsStr():
			if !x.IsStr() {
				ret false
			}
			self.SetStr(self.ReadStr() + x.ReadStr())
		| self.IsCmplx128() || x.IsCmplx128():
			a := self.AsCmplx128()
			b := x.AsCmplx128()
			self.SetCmplx128(a + b)
		| self.IsF64():
			self.SetF64(self.ReadF64() + x.AsF64())
		| self.IsInt():
			a := self.data.(big::Int)
			if x.IsInt() {
				b := x.data.(big::Int)
				let mut r: big::Int
				r.Add(&a, &b)
				self.SetInt(r)
			} else {
				// If x is not integer, it should be float.
				if a.Sign() == -1 {
					self.SetF64(self.AsF64() + x.AsF64())
				} else {
					self.SetF64(self.AsF64() + x.AsF64())
				}
			}
		|:
			ret false
		}
		ret true
	}

	// Subs x's value from itself value.
	// Reports whether operation is success.
	fn SUB(mut *self, x: Const): bool {
		match {
		| self.IsF64():
			self.SetF64(self.ReadF64() - x.AsF64())
		| self.IsCmplx128() || x.IsCmplx128():
			a := self.AsCmplx128()
			b := x.AsCmplx128()
			self.SetCmplx128(a - b)
		| self.IsInt():
			a := self.data.(big::Int)
			if x.IsInt() {
				b := x.data.(big::Int)
				let mut r: big::Int
				r.Sub(&a, &b)
				self.SetInt(r)
			} else {
				// If x is not integer, it should be float.
				if a.Sign() == -1 {
					self.SetF64(self.AsF64() - x.AsF64())
				} else {
					self.SetF64(self.AsF64() - x.AsF64())
				}
			}
		|:
			ret false
		}
		ret true
	}

	// Multiplies x's value to c's value.
	// Reports whether operation is success.
	fn MUL(mut *self, x: Const): bool {
		match {
		| self.IsF64():
			self.SetF64(self.ReadF64() * x.AsF64())
		| self.IsCmplx128() || x.IsCmplx128():
			a := self.AsCmplx128()
			b := x.AsCmplx128()
			self.SetCmplx128(a * b)
		| self.IsInt():
			a := self.data.(big::Int)
			if x.IsInt() {
				b := x.data.(big::Int)
				let mut r: big::Int
				r.Mul(&a, &b)
				self.SetInt(r)
			} else {
				// If x is not integer, it should be float.
				if a.Sign() == -1 {
					self.SetF64(self.AsF64() * x.AsF64())
				} else {
					self.SetF64(self.AsF64() * x.AsF64())
				}
			}
		|:
			ret false
		}
		ret true
	}

	// Divides itself value to x's value.
	// Reports whether operation is success.
	// Reports false if divided-by-zero.
	//
	// NOTICE
	//	This operation makes constant value is floating-point.
	fn DIV(mut *self, x: Const): bool {
		match {
		| self.IsF64():
			l := x.AsF64()
			if l == 0 {
				ret false
			}
			self.SetF64(self.ReadF64() / l)
		| self.IsCmplx128() || x.IsCmplx128():
			a := self.AsCmplx128()
			b := x.AsCmplx128()
			if b == 0 {
				ret false
			}
			self.SetCmplx128(a / b)
		| self.IsInt():
			a := self.data.(big::Int)
			if x.IsInt() {
				b := x.data.(big::Int)
				if b.BitLen() == 0 { // b == 0
					ret false
				}
				let mut tmp: big::Int
				let mut r: big::Int
				r.QuoRem(&a, &b, &tmp)
				self.SetInt(r)
			} else {
				// If x is not integer, it should be float.
				if a.Sign() == -1 {
					self.SetF64(self.AsF64() / x.AsF64())
				} else {
					self.SetF64(self.AsF64() / x.AsF64())
				}
			}
		|:
			ret false
		}
		ret true
	}

	// Mods itself value to x's value.
	// Reports whether operation is success.
	// Reports false if divided-by-zero.
	fn REM(mut *self, x: Const): bool {
		i, mut ok := self.data.(big::Int)
		if !ok {
			ret false
		}
		xi, ok := x.data.(big::Int)
		if !ok {
			ret false
		}
		let mut tmp: big::Int
		let mut r: big::Int
		tmp.QuoRem(&i, &xi, &r)
		self.SetInt(r)
		ret true
	}

	// Bitwise and itself value to x's value.
	// Reports whether operation is success.
	fn AND(mut *self, x: Const): bool {
		i, mut ok := self.data.(big::Int)
		if !ok {
			ret false
		}
		xi, ok := x.data.(big::Int)
		if !ok {
			ret false
		}
		let mut r: big::Int
		r.And(&i, &xi)
		self.SetInt(r)
		ret true
	}

	// Bitwise or itself value to x's value.
	// Reports whether operation is success.
	fn OR(mut *self, x: Const): bool {
		i, mut ok := self.data.(big::Int)
		if !ok {
			ret false
		}
		xi, ok := x.data.(big::Int)
		if !ok {
			ret false
		}
		let mut r: big::Int
		r.Or(&i, &xi)
		self.SetInt(r)
		ret true
	}

	// Bitwise xor itself value to x's value.
	// Reports whether operation is success.
	fn XOR(mut *self, x: Const): bool {
		i, mut ok := self.data.(big::Int)
		if !ok {
			ret false
		}
		xi, ok := x.data.(big::Int)
		if !ok {
			ret false
		}
		let mut r: big::Int
		r.Xor(&i, &xi)
		self.SetInt(r)
		ret true
	}

	// Left shifts itself value to x's value.
	// Reports whether operation is success.
	fn SHL(mut *self, x: Const): bool {
		i, mut ok := self.data.(big::Int)
		if !ok {
			ret false
		}
		xi, ok := x.data.(big::Int)
		if !ok {
			ret false
		}
		let mut r: big::Int
		r.Lsh(&i, uint(xi.U64()))
		self.SetInt(r)
		ret true
	}

	// Right shifts itself value to x's value.
	// Reports whether operation is success.
	fn SHR(mut *self, x: Const): bool {
		i, mut ok := self.data.(big::Int)
		if !ok {
			ret false
		}
		xi, ok := x.data.(big::Int)
		if !ok {
			ret false
		}
		let mut r: big::Int
		r.Rsh(&i, uint(xi.U64()))
		self.SetInt(r)
		ret true
	}

	fn Str(*self): str {
		match {
		| self.IsNil():
			ret "nil"
		| self.IsBool():
			if self.data.(bool) {
				ret "true"
			}
			ret "false"
		| self.IsStr():
			ret self.data.(str)
		| self.IsInt():
			i := self.data.(big::Int)
			ret i.Format(10)
		| self.IsF64():
			ret conv::FormatFloat(self.data.(f64), 'g', -1, 64)
		| self.IsCmplx128():
			ret conv::FormatCmplx(self.data.(cmplx128), 'g', -1, 128)
		|:
			panic("unreachable")
		}
	}
}
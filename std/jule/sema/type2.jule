// Copyright 2023-2025 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

// This file reserved for type compatibility checking.

use "std/jule"
use "std/jule/ast"
use "std/jule/build"
use "std/jule/constant/lit"
use "std/jule/log"
use "std/jule/token"
use "std/jule/types"
use "std/math"
use "std/math/big"
use "std/strings"

fn traitHasReferenceReceiver(&t: &Trait): bool {
	for _, f in t.Methods {
		// Skip static functions.
		if f.Statically {
			continue
		}

		p := f.Params[0]
		if p.IsRef() && p.IsSelf() {
			ret true
		}
	}
	ret false
}

fn floatAssignable(&kind: str, &v: &Value): bool {
	if !v.Constant.IsInt() && !v.Constant.IsF64() {
		ret false
	}
	// If value is not untyped, trust wrap-around.
	if !v.untyped {
		ret true
	}
	let mut f: f64
	bits := types::BitSizeOf(kind)
	if v.Constant.IsInt() {
		(f), acc := v.Constant.ReadInt().F64()
		if acc != big::Exact {
			ret false
		}
	} else {
		f = v.Constant.AsF64()
	}
	// If float is 64-bit, all typed primitive types should fit.
	if bits == 64 {
		ret true
	}
	f2 := f64(f32(f))
	match {
	| math::IsNaN(f2):
		ret math::IsNaN(f)
	| math::IsInf(f2, 1):
		ret math::IsInf(f, 1)
	| math::IsInf(f2, -1):
		ret math::IsInf(f, -1)
	|:
		ret true
	}
}

fn sigAssignable(kind: str, mut &v: &Value): bool {
	min := types::MinI(kind)
	max := types::MaxI(kind)
	match {
	| v.Constant.IsF64():
		x := v.Constant.ReadF64()
		i, frac := math::Modf(x)
		if frac != 0 {
			ret false
		}
		ret i64(i) >= min && i64(i) <= max
	| v.Constant.IsInt():
		i := v.Constant.ReadInt()
		if i.IsU64() {
			ret i.U64() <= u64(max)
		}
		if i.IsI64() {
			x := i.I64()
			ret min <= x && x <= max
		}
	}
	ret false
}

fn unsigAssignable(kind: str, mut &v: &Value): bool {
	max := types::MaxU(kind)
	if v.IsRune && kind == types::U8 {
		ret lit::IsAscii(rune(v.Constant.ReadInt().U64()))
	}

	match {
	| v.Constant.IsF64():
		x := v.Constant.ReadF64()
		if x < 0 {
			ret false
		}
		i, frac := math::Modf(x)
		if frac != 0 {
			ret false
		}
		ret u64(i) <= max
	| v.Constant.IsInt():
		i := v.Constant.ReadInt()
		if i.Sign() == -1 {
			ret false
		}
		if !i.IsU64() {
			ret false
		}
		x := i.U64()
		if x <= max {
			ret true
		}
	}
	ret false
}

fn intAssignable(kind: str, mut &v: &Value): bool {
	match {
	| types::IsSigInt(kind):
		ret sigAssignable(kind, v)
	| types::IsUnsigInt(kind):
		ret unsigAssignable(kind, v)
	|:
		ret false
	}
}

struct typeCompatibilityChecker {
	s:          &sema // Used for error logging.
	dest:       &Type
	src:        &Type
	errorToken: &token::Token
}

impl typeCompatibilityChecker {
	fn pushErr(mut self, fmt: str, args: ...any) {
		self.s.pushErr(self.errorToken, fmt, args...)
	}

	fn checkTrait(mut self): (ok: bool) {
		if self.src.IsNil() {
			ret true
		}
		mut trt := self.dest.Trait()
		mut ref := false
		match {
		| self.src.SoftStruct() != nil:
			goto Struct
		| self.src.Sptr() != nil:
			ref = true
			self.src = self.src.Sptr().Elem
			if self.src.SoftStruct() == nil {
				ret false
			}
			goto Struct
		| self.src.Trait() != nil:
			mut base := self.src.Trait()
			if trt == base {
				ret true
			}
		lookup:
			for _, s1 in base.Implemented {
				for _, s2 in trt.Implemented {
					if s1 == s2 {
						continue lookup
					}
				}
				ret false
			}
			for (_, mut m1) in trt.Methods {
				mut m2 := base.FindMethod(m1.Ident)
				if m2 == nil {
					ret false
				}
				m1k := self.s.getTraitCheckFuncKind(m1)
				m2k := self.s.getTraitCheckFuncKind(m2)
				if !m1k.equalTrait(m2k) {
					ret false
				}
			}
			ret true
		|:
			ret false
		}
	Struct:
		s := self.src.SoftStruct()
		if !s.Decl.IsImplements(trt) {
			ret false
		}
		if !ref && traitHasReferenceReceiver(trt) {
			self.pushErr(log::TraitHasRefParamFunc)
			ret false
		}
		ret true
	}

	fn checkPtr(mut self): (ok: bool) {
		if self.src.IsNil() {
			ret true
		}
		mut dest := self.dest.Ptr()
		if dest.IsUnsafe() {
			ret self.src.Ptr() != nil
		}
		ret self.dest.Equal(self.src)
	}

	fn checkPrim(mut self): (ok: bool) {
		if !self.dest.Variadic {
			prim := self.dest.Prim()
			if prim != nil && prim.IsAny() {
				ret true
			}
		}
		ret self.dest.Equal(self.src)
	}

	fn typeEnum(self, mut &e: &TypeEnum, mut &t2: &Type): (ok: bool) {
		for (_, mut item) in e.Items {
			if item.TypeSym.Type.Equal(t2) {
				ret true
			}
			// If item is not strict type alias, check inherited types if it is type-enum.
			if item.TypeSym.Type.SoftStruct() == nil {
				mut ke := item.TypeSym.Type.TypeEnum()
				if ke == nil {
					continue
				}
				if self.typeEnum(ke, t2) {
					ret true
				}
			}
		}
		ret false
	}

	fn checkTypeEnum(mut self): (ok: bool) {
		if self.dest.Equal(self.src) {
			ret true
		}
		mut e := self.dest.TypeEnum()
		ret self.typeEnum(e, self.src)
	}

	fn check(mut self): (ok: bool) {
		match {
		| self.dest.NilCompatible() && self.src.IsNil():
			ret true
		| self.dest.TypeEnum() != nil:
			ret self.checkTypeEnum()
		| self.dest.Trait() != nil:
			ret self.checkTrait()
		}

		prim := self.dest.Prim()
		if prim != nil && !self.dest.Variadic && prim.IsAny() {
			ret true
		}
		if prim != nil {
			ret self.checkPrim()
		}

		// dest or src type is created by the strict type alias
		// they should be the same type
		if self.dest.SoftStruct() != nil ||
			self.src.SoftStruct() != nil {
			ret self.dest.Equal(self.src)
		}

		match {
		| self.dest.Ptr() != nil:
			ret self.checkPtr()
		|:
			ret self.dest.Equal(self.src)
		}
	}
}

// Checks value and type compatibility for assignment.
struct assignTypeChecker {
	s:          &sema // Used for error logging and type checking.
	dest:       &Type
	v:          &Value
	errorToken: &token::Token
	refers:     &ReferenceStack
}

impl assignTypeChecker {
	fn pushErr(mut self, fmt: str, args: ...any) {
		self.s.pushErr(self.errorToken, fmt, args...)
	}

	fn checkValidity(mut self): bool {
		mut valid := true
		match {
		| self.v.Type.Func() != nil:
			f := self.v.Type.Func()
			match {
			| f.IsBuiltin():
				self.pushErr(log::BuiltinAsNonFunc)
				valid = false
			| f.Decl.Binded:
				self.pushErr(log::BindedFuncAsAnonFunc)
				valid = false
			| !f.Decl.Statically && f.Decl.IsMethod():
				self.pushErr(log::MethodAsAnonFunc)
				valid = false
			| len(f.Decl.Generics) > 0 && len(f.Generics) == 0:
				self.pushErr(log::GenericedFuncAsAnonFunc)
				self.s.pushSuggestion(log::InstantiateGenericFuncToUseAsAnon)
				valid = false
			}
		| self.v.Type.Tuple() != nil:
			self.pushErr(log::TupleAssignToSingle)
			valid = false
		}
		ret valid
	}

	fn checkConst(mut self): bool {
		if !self.v.untyped {
			ret false
		}
		if !self.v.IsConst() {
			// Allow if value is untyped and actual kinds are equal.
			ret self.dest.ActualEqual(self.v.Type)
		}
		mut prim := self.dest.Prim()
		if prim == nil {
			ret false
		}
		match {
		| prim.IsStr():
			prim = self.v.Type.Prim()
			ok := prim != nil && prim.IsStr()
			// If type compatibility is ok, use the destination type and make
			// literal untyped, a kind of brief implicit casting.
			if ok {
				self.v.Type = self.dest
				self.v.untyped = false
			}
			ret ok
		| prim.IsBool():
			prim = self.v.Type.Prim()
			ok := prim != nil && prim.IsBool()
			// If type compatibility is ok, use the destination type and make
			// literal untyped, a kind of brief implicit casting.
			if ok {
				self.v.Type = self.dest
				self.v.untyped = false
			}
			ret ok
		}
		// Should be numeric.
		kind := prim.Kind
		match {
		| types::IsFloat(kind):
			if !floatAssignable(kind, self.v) {
				self.s.pushErr(self.errorToken, log::ConstantOverflowType, self.v.Constant.Str(), self.dest.Str())
				ret true // Return true to avoid more errors.
			}
			self.v.Constant.Kind = kind
			self.v.Type = self.dest
			self.v.untyped = false
		| types::IsInt(kind):
			if !intAssignable(kind, self.v) {
				self.s.pushErr(self.errorToken, log::ConstantOverflowType, self.v.Constant.Str(), self.dest.Str())
				ret true // Return true to avoid more errors.
			}
			self.v.Constant.Kind = kind
			self.v.Type = self.dest
			self.v.untyped = false
		|:
			ret false
		}
		ret true
	}

	fn checkFunc(mut self): bool {
		f1 := self.dest.Func()
		if f1 == nil {
			ret false
		}
		// Report false for strict type alias wrapped function types.
		if self.v.Type.SoftStruct() != nil {
			ret false
		}
		f2 := self.v.Type.Func()
		if f2 == nil {
			ret false
		}
		ret f1.EqualFunc(f2, true)
	}

	fn checkCompatibility(mut self): bool {
		match {
		| self.v == nil:
			// Skip Data is nil.
			ret false
		| !self.checkValidity():
			// Data is invalid and error(s) logged about it.
			ret false
		| self.checkConst():
			ret true
		| self.v.Type.Enum() != nil:
			mut dkind := self.dest
			if self.dest.Enum() != nil {
				dkind = self.dest.Enum().TypeSym.Type
			}
			prim := self.dest.Prim()
			if prim == nil || prim.IsAny() {
				// Ignore direct comparison if prim is nil or any.
				break
			}
			mut dest := self.v.Type.Enum().TypeSym.Type
			ret self.s.checkTypeCompatibility(dest, dkind, self.errorToken)
		| self.v.Type.Chan() != nil:
			dc := self.dest.Chan()
			if dc == nil {
				break
			}
			vc := self.v.Type.Chan()
			if !dc.Elem.Equal(vc.Elem) {
				break
			}
			if dc.Recv && !vc.Recv || dc.Send && !vc.Send {
				break
			}
			ret true
		| self.v.Type.Func() != nil:
			if self.checkFunc() {
				ret true
			}
		}
		if self.v.untyped {
			// If value is untyped and constant checking is failed,
			// it is not fits in the destination type.
			p := self.dest.Prim()
			if p != nil && types::IsNum(p.Kind) {
				self.s.pushCompatibilityError(self.dest, self.v, self.errorToken)
				ret false
			}
			// Destination type is not numeric.
			// So check and make sure the untyped value can unwrap safely.
			_ = checkValue(self.v, self.s, self.errorToken, evalDefault|evalPhysicalMem|evalUnwrapUntyped)
		}
		ret self.s.checkTypeCompatibility1(self.dest, self.v, self.errorToken)
	}

	fn check(mut self): bool {
		ok := self.checkCompatibility()
		if ok && !self.v.Type.Variadic {
			applyImplicitCast(self.s, self.dest, self.v, self.errorToken, self.refers)
		}
		ret ok
	}
}

struct dynamicTypeAnnotation {
	e:          &eval
	f:          &FuncIns
	p:          &ParamIns
	a:          &Value
	errorToken: &token::Token
	k:          *&Type
	c:          &ast::Type
	ignored:    []&Type // Ignored generics.
}

impl dynamicTypeAnnotation {
	fn annotateConstraintElem[T](mut self, mut &k: &Type): bool {
		mut c, mut ok := self.c.Kind.(&T)
		if !ok {
			ret false
		}
		mut elem := (&Type)(nil)
		const match type T {
		| ast::ArrayType:
			elem = k.Array().Elem
		| ast::SliceType:
			elem = k.Slice().Elem
		| ast::PtrType:
			mut p := k.Ptr()
			if p.IsUnsafe() {
				self.e.pushErr(self.errorToken, log::UnsafePointerForAnnotation)
				ret false
			}
			elem = p.Elem
		| ast::SptrType:
			elem = k.Sptr().Elem
		| ast::ChanType:
			elem = k.Chan().Elem
		}
		self.c = c.Elem
		ret self.annotateConstraint(elem)
	}

	fn annotateConstraintMap(mut self, mut &k: &Type): (ok: bool) {
		mut m2, ok := self.c.Kind.(&ast::MapType)
		if !ok {
			ret
		}
		mut m := k.Map()
		self.c = m2.Key
		if !self.annotateConstraint(m.Key) {
			ret false
		}
		self.c = m2.Val
		ret self.annotateConstraint(m.Val)
	}

	fn annotateConstraintTuple(mut self, mut &k: &Type): (ok: bool) {
		mut tup, ok := self.c.Kind.(&ast::TupleType)
		if ok {
			mut tup2 := k.Tuple()
			for (_, mut t2) in tup2.Types {
				for (_, mut t) in tup.Types {
					self.c = t
					if self.annotateConstraint(t2) {
						ret true
					}
				}
			}
		}
		ret false
	}

	fn annotateConstraintFunc(mut self, mut &k: &Type): (ok: bool) {
		mut pf, ok := self.c.Kind.(&ast::Func)
		if ok {
			mut f := k.Func()
			for (i, mut fp) in f.Params {
				self.c = pf.Params[i].Kind
				if self.annotateConstraint(fp.Type) {
					ret true
				}
			}
			if pf.Result != nil {
				self.c = pf.Result.Kind
				if self.annotateConstraint(f.Result) {
					ret true
				}
			}
		}
		ret false
	}

	fn annotateConstraintIdent(mut self, mut &k: &Type): bool {
		mut ident := self.c.Kind.(&ast::IdentType)
		mut s := k.Struct()
		for i, g in self.f.Decl.Generics {
			if g.Ident == ident.Ident {
				mut fg := self.f.Generics[i]
				if fg != nil {
					ret false
				}
				p := k.Ptr()
				if p != nil && p.IsUnsafe() {
					self.e.pushErr(self.errorToken, log::UnsafePointerForAnnotation)
					ret false
				}
				self.pushGeneric(k, i)
				ret true
			}
			if s == nil {
				continue
			}
			mut c := self.c
			for (_, mut ig) in ident.Generics {
				self.c = ig
				for (_, mut sg) in s.Generics {
					if self.annotateConstraint(sg.Type) {
						ret true
					}
				}
			}
			self.c = c
		}
		ret false
	}

	fn annotateConstraint(mut self, mut &k: &Type): bool {
		match type self.c.Kind {
		| &ast::IdentType:
			ret self.annotateConstraintIdent(k)
		}
		match {
		| k.Array() != nil:
			ret self.annotateConstraintElem[ast::ArrayType](k)
		| k.Slice() != nil:
			ret self.annotateConstraintElem[ast::SliceType](k)
		| k.Ptr() != nil:
			ret self.annotateConstraintElem[ast::PtrType](k)
		| k.Sptr() != nil:
			ret self.annotateConstraintElem[ast::SptrType](k)
		| k.Chan() != nil:
			ret self.annotateConstraintElem[ast::ChanType](k)
		| k.Map() != nil:
			ret self.annotateConstraintMap(k)
		| k.Func() != nil:
			ret self.annotateConstraintFunc(k)
		| k.Tuple() != nil:
			ret self.annotateConstraintTuple(k)
		|:
			ret false
		}
	}

	fn pushGeneric(mut self, mut &k: &Type, i: int) {
		self.f.Generics[i] = &InsGeneric{Type: k}
		mut gd := self.f.Decl.Generics[i]
		for (_, mut ignored) in self.ignored {
			if gd.Ident == ignored.Str() {
				ignored.Kind = k.Kind
			}
		}
		if gd.Constraint == nil || len(gd.Constraint.Mask) != 1 {
			ret
		}
		self.c = gd.Constraint.Mask[0]
		self.annotateConstraint(k)
	}

	unsafe fn annotatePrim(mut self, mut &k: &Type): (ok: bool) {
		ret self.annotateAny(k)
	}

	unsafe fn annotateArray(mut self, mut &k: &Type): (ok: bool) {
		mut parr := (*self.k).Array()
		if parr == nil {
			ret false
		}
		mut arr := k.Array()
		self.k = &parr.Elem
		ret self.annotateKind(arr.Elem)
	}

	unsafe fn annotateSlice(mut self, mut &k: &Type): (ok: bool) {
		mut pslc := (*self.k).Slice()
		if pslc == nil {
			ret false
		}
		mut slc := k.Slice()
		self.k = &pslc.Elem
		ret self.annotateKind(slc.Elem)
	}

	unsafe fn checkMapKey(mut self, mut k: *&Type, mut &ck: &Type): (ok: bool) {
		mut old := self.k
		self.k = k
		ok = self.annotateKind(ck)
		self.k = old
		ret ok
	}

	unsafe fn annotateMap(mut self, mut &k: &Type): (ok: bool) {
		mut pmap := (*self.k).Map()
		if pmap == nil {
			ret false
		}
		mut m := k.Map()
		ret self.checkMapKey(&pmap.Key, m.Key) &&
			self.checkMapKey(&pmap.Val, m.Val)
	}

	unsafe fn annotateFunc(mut self, mut &k: &Type): (ok: bool) {
		mut pf := (*self.k).Func()
		if pf == nil {
			ret false
		}
		mut f := k.Func()
		match {
		| len(pf.Params) != len(f.Params):
			ret false
		| pf.Decl.IsVoid() != f.Decl.IsVoid():
			ret false
		}

		ok = true
		mut old := self.k
		for (i, mut fp) in f.Params {
			self.k = &pf.Params[i].Type
			ok = self.annotateKind(fp.Type) && ok
		}

		if !pf.Decl.IsVoid() {
			self.k = &pf.Result
			ok = self.annotateKind(f.Result) && ok
		}

		self.k = old
		ret ok
	}

	unsafe fn annotatePtr(mut self, mut &k: &Type): (ok: bool) {
		mut pptr := (*self.k).Ptr()
		if pptr == nil {
			ret false
		}
		mut ptr := k.Ptr()
		if ptr.IsUnsafe() {
			self.e.pushErr(self.errorToken, log::UnsafePointerForAnnotation)
			ret false
		}
		self.k = &pptr.Elem
		ret self.annotateKind(ptr.Elem)
	}

	unsafe fn annotateSptr(mut self, mut &k: &Type): (ok: bool) {
		mut ssptr := (*self.k).Sptr()
		if ssptr == nil {
			ret false
		}
		mut sptr := k.Sptr()
		self.k = &ssptr.Elem
		ret self.annotateKind(sptr.Elem)
	}

	unsafe fn annotateStruct(mut self, mut &k: &Type): (ok: bool) {
		mut s := (*self.k).Struct()
		if s == nil {
			ret false
		}
		mut s2 := k.Struct()
		if len(s.Generics) != len(s2.Generics) {
			ret false
		}
		for (i, mut g) in s.Generics {
			mut g2 := s2.Generics[i]
			if g.Type.Equal(g2.Type) {
				continue
			}
			self.k = &g.Type
			if !self.annotateKind(g2.Type) {
				ret false
			}
		}
		ret true
	}

	unsafe fn annotateChan(mut self, mut &k: &Type): (ok: bool) {
		mut c := (*self.k).Chan()
		if c == nil {
			ret false
		}
		mut c2 := k.Chan()
		self.k = &c.Elem
		ret self.annotateKind(c2.Elem)
	}

	unsafe fn annotateAny(mut self, mut &k: &Type): (ok: bool) {
		kind := (*self.k).Str()
		for i, g in self.f.Decl.Generics {
			if kind != g.Ident {
				continue
			}
			t := self.f.Generics[i]
			match {
			| t == nil | t.Type == nil:
				self.pushGeneric(k, i)
			| !t.Type.Equal(k):
				// Generic already pushed but generic type and current kind
				// is different, so incompatible.
				ret false
			}
			(*self.k).Kind = k.Kind
			ret true
		}
		ret false
	}

	unsafe fn annotateKind(mut self, mut &k: &Type): (ok: bool) {
		if self.k == nil || *self.k == nil {
			ret
		}
		match {
		| self.annotateAny(k):
			ret true
		| k.Prim() != nil:
			ret self.annotatePrim(k)
		| k.Array() != nil:
			ret self.annotateArray(k)
		| k.Slice() != nil:
			ret self.annotateSlice(k)
		| k.Map() != nil:
			ret self.annotateMap(k)
		| k.Func() != nil:
			ret self.annotateFunc(k)
		| k.Ptr() != nil:
			ret self.annotatePtr(k)
		| k.Sptr() != nil:
			ret self.annotateSptr(k)
		| k.Struct() != nil:
			ret self.annotateStruct(k)
		| k.Chan() != nil:
			ret self.annotateChan(k)
		|:
			ret false
		}
	}

	unsafe fn annotate(mut self): (ok: bool) {
		self.k = &self.p.Type
		ret self.annotateKind(self.a.Type)
	}
}

struct fnCallArgChecker {
	e:                 &eval
	args:              []&ast::Expr
	errorToken:        &token::Token
	f:                 &FuncIns
	dynamicAnnotation: bool
	argModels:         []Expr
	ignored:           []&Type // Ignored generics.
}

impl fnCallArgChecker {
	fn pushErrToken(mut self, token: &token::Token, fmt: str, args: ...any) {
		self.e.s.pushErr(token, fmt, args...)
	}

	fn pushErr(mut self, fmt: str, args: ...any) {
		self.pushErrToken(self.errorToken, fmt, args...)
	}

	fn getParams(mut self): []&ParamIns {
		if len(self.f.Params) > 0 &&
			self.f.Params[0].Decl != nil &&
			self.f.Params[0].Decl.IsSelf() {
			ret self.f.Params[1:] // Remove receiver parameter.
		}
		ret self.f.Params
	}

	fn checkCounts(mut self, &params: []&ParamIns): (ok: bool) {
		mut n := len(params)
		if n > 0 && params[0].Decl.IsSelf() {
			n--
		}
		variadic := n > 0 && params[len(params)-1].Decl.Variadic
		if variadic {
			n--
		}

		mut diff := n - len(self.args)
		mut log := ""
		match {
		| diff == 0:
			ret true
		| diff < 0:
			if variadic {
				ret true
			}
			fall
		| diff > n:
			log = log::ArgumentOverflow
		|:
			log = log::MissingArgs
		}
		mut err := strings::Builder{}
		err.Grow(1 << 5)
		err.WriteStr(self.f.Decl.Ident)!
		err.WriteStr("\n       want (")!
		for i, p in params {
			err.WriteStr(p.Type.Str())!
			if len(params)-i > 1 {
				err.WriteStr(", ")!
			}
		}
		err.WriteByte(')')!
		self.pushErr(log, err.Str())
		ret false
	}

	fn checkArg(mut self, mut &p: &ParamIns, mut &arg: &Value, mut &errorToken: &token::Token): (ok: bool) {
		if self.dynamicAnnotation && parameterUsesGenerics(p, self.f.Decl.Generics) {
			// Accept as fail if parameter is variadic or expression is invalid.
			ok = !p.Decl.Variadic && isGoodValueToInfer(arg)
			if ok {
				mut dta := dynamicTypeAnnotation{
					e: self.e,
					f: self.f,
					p: p,
					a: arg,
					errorToken: errorToken,
					ignored: self.ignored,
				}
				ok = unsafe { dta.annotate() }
			}
			if !ok {
				self.pushErrToken(errorToken, log::DynamicTypeAnnotationFailed)
				ret false
			}
		}

		if self.e.s.checkValidityForInitExpr(p.Decl.Mutable, p.Decl.Reference, p.Type, arg, errorToken) {
			// Check type if validity is good.
			// Helps to reduce error logs and duplicated logs.
			ret self.e.s.checkAssignType(p.Decl.Reference, p.Type, arg, errorToken, self.e.getOwnerRefers())
		}
		ret false
	}

	fn push(mut self, mut &p: &ParamIns, mut arg: &ast::Expr): (ok: bool) {
		mut old := self.e.prefix
		oldMut := self.e.target.mutable

		self.e.target.mutable = p.Decl.Mutable
		if !self.dynamicAnnotation && !p.Decl.Variadic {
			self.e.prefix = p.Type
		} else {
			self.e.prefix = nil
		}
		// Do not unwrap untyped literals, type analysis will check overflows.
		mut v := self.e.evalExpr(arg, evalDefault)

		self.e.prefix = old
		self.e.target.mutable = oldMut

		if v == nil {
			ret false
		}

		ok = self.checkArg(p, v, arg.Token)
		self.argModels = append(self.argModels, v.Model)
		ret
	}

	fn pushVariadic(mut self, mut &p: &ParamIns, mut i: int): (ok: bool) {
		ok = true
		mut variadiced := false
		more := i+1 < len(self.args)
		mut model := &SliceExpr{
			ElemType: p.Type,
		}

		mut old := self.e.prefix

		oldMut := self.e.target.mutable
		self.e.target.mutable = p.Decl.Mutable

		// Save variadic status into separate variable.
		// Because parameter might be variadic, but type might be not variadic.
		// Some built-in functions passes non-variadic types.
		// Also allocate new type based on [p.Kind] because type should be remain non-variadic.
		// The [p.Kind] used as prefix and base type.
		mut oldKind := p.Type
		p.Type = new(Type, *p.Type)
		p.Type.Variadic = false
		defer {
			p.Type.Variadic = false // Set actual type as non-variadic.
			p.Type = oldKind
		}

		for i < len(self.args); i++ {
			mut arg := self.args[i]

			match type arg.Kind {
			| &ast::VariadicExpr:
				self.e.prefix = &Type{
					Kind: &Slice{
						Elem: p.Type,
					},
				}
			|:
				self.e.prefix = p.Type
			}

			mut v := self.e.eval(arg, evalDefault|evalPhysicalMem|evalUnwrapUntyped)
			if v == nil {
				ok = false
				continue
			}

			if v.Type.Variadic {
				variadiced = true
				p.Type.Variadic = true
				ok = ok && self.checkArg(p, v, arg.Token)
				p.Type.Variadic = false
				match type v.Model {
				| &SliceExpr:
					model = v.Model.(&SliceExpr)
					model.ElemType = p.Type
				|:
					model = nil
					self.argModels = append(self.argModels, v.Model)
				}
				// Break iteration early, this argument is variadic, so should be last.
				// If this argument is not last, following algorithm will create error log for that.
				// Increase variable i for point to following argument.
				i++
				break
			}

			ok = ok && self.checkArg(p, v, arg.Token)
			model.Elems = append(model.Elems, v)
		}
		self.e.prefix = old
		self.e.target.mutable = oldMut

		if variadiced && more {
			// Use variable i because when variadic argument appears iteral will break.
			// And it will increase variable i for point to following argument.
			// Therefore, variable i always points to problematic argument.
			self.pushErrToken(self.args[i].Token, log::MoreArgsWithVariadiced)
		}

		if model != nil {
			self.argModels = append(self.argModels, model)
		}
		ret ok
	}

	fn checkArgs(mut self, mut &params: []&ParamIns): (ok: bool) {
		target := self.e.target
		self.e.target.ignored = false

		ok = true
		mut i := 0
		if len(params) > 0 && params[0].Decl.IsSelf() {
			// Ignore self.
			i++
		}
	iter:
		for i < len(params) {
			mut p := params[i]
			match {
			| p.Decl.Variadic:
				ok = self.pushVariadic(p, i) && ok
				// Variadiced parameters always last.
				break iter
			| len(self.args) <= i:
				ok = false
				break iter
			|:
				ok = self.push(p, self.args[i]) && ok
			}
			i++
		}

		self.e.target = target
		ret ok
	}

	fn checkDynamicTypeAnnotation(mut self): (ok: bool) {
		for _, g in self.f.Generics {
			if g == nil {
				self.pushErr(log::DynamicTypeAnnotationFailed)
				ret false
			}
		}
		ret true
	}

	fn check(mut self): (ok: bool) {
		mut params := self.getParams()
		ok = self.checkCounts(params)
		if !ok {
			ret false
		}
		ok = self.checkArgs(params)
		if ok && self.dynamicAnnotation {
			ok = self.checkDynamicTypeAnnotation()
		}
		ret ok
	}
}

// Checks mutability risk of struct literals.
// Assumes evaluated by [structLitChecker].
// Therefore, it will not check interior mutability risks.
// Assumes mutable structure literal and checks field assignments.
fn checkMutRiskOfStructLit(mut &s: &sema, &m: &StructLitExpr) {
	for _, arg in m.Args {
		if arg.Field.Decl.Mutable {
			// Skip this field.
			// If there is a mutability risk, it will be logged by [structLitChecker].
			continue
		}
		if !arg.Expr.Mutable && arg.Expr.Type.Mutable() {
			s.pushErr(arg.Token, log::AssignNonMutToMut, arg.Expr.Type.Str())
		}
	}
}

struct structLitChecker {
	e:          &eval
	errorToken: &token::Token
	s:          &StructIns
	args:       []&StructArgExpr
}

impl structLitChecker {
	fn pushErr(mut self, token: &token::Token, fmt: str, args: ...any) {
		self.e.pushErr(token, fmt, args...)
	}

	// Push suggestion to last log.
	fn pushSuggestion(mut self, fmt: str, args: ...any) {
		self.e.pushSuggestion(fmt, args...)
	}

	fn pushMatch(mut self, mut &f: &FieldIns, mut &v: &Value, mut &errorToken: &token::Token) {
		const Reference = false
		// If evaluated for the immutable memory, check as immutable.
		// But if field in scope of the interior mutability, check as mutable.
		// Do not accept as risky if structure is not have any method.
		// Because if there is no method, no risk for interior mutability.
		mutable := self.e.target.mutable || (f.Decl.Mutable && len(self.s.Methods) > 0)
		if self.e.s.checkValidityForInitExpr(mutable, Reference, f.Type, v, errorToken) {
			// Check type if validity is good.
			// Helps to reduce error logs and duplicated logs.
			_ = self.e.s.checkAssignType(false, f.Type, v, errorToken, self.e.getOwnerRefers())
		}
		self.args = append(self.args, &StructArgExpr{
			Token: errorToken,
			Field: f,
			Expr: v,
		})
	}

	fn checkPair(mut self, mut &pair: &ast::FieldExprPair, mut &exprs: []&ast::Expr) {
		// Check existing.
		mut f := self.s.FindField(pair.Field.Kind)
		if f == nil {
			self.pushErr(pair.Field, log::IdentNotExist, pair.Field.Kind)
			ret
		}

		if jule::IsBlank(pair.Field.Kind) {
			self.pushErr(pair.Field, log::IgnoreIdent)
			ret
		}

		// Check duplications.
	dupLookup:
		for (_, mut expr) in exprs {
			mut dpair, ok := expr.Kind.(&ast::FieldExprPair)
			if ok {
				match {
				| pair == dpair:
					break dupLookup
				| pair.Field.Kind == dpair.Field.Kind:
					self.pushErr(pair.Field, log::AlreadyHasExpr, pair.Field.Kind)
					ret
				}
			}
		}

		if !self.e.s.isAccessibleDefine(f.Decl.Public, f.Decl.Token) {
			self.pushErr(pair.Field, log::IdentIsNotAccessible, pair.Field.Kind)
			self.pushSuggestion(log::MakePubToAccess)
			ret
		}

		mut prefix := self.e.prefix
		defer { self.e.prefix = prefix }
		self.e.prefix = f.Type

		// Do not unwrap untyped literals, type analysis will check overflows.
		mut v := self.e.evalExpr(pair.Expr, evalDefault)
		if v == nil {
			ret
		}
		self.pushMatch(f, v, pair.Field)
	}

	fn readyExprs(mut self, mut &exprs: []&ast::Expr): bool {
		mut ok := true
		for (i, mut expr) in exprs {
			match type expr.Kind {
			| &ast::KeyValPair:
				mut pair := expr.Kind.(&ast::KeyValPair)
				match type pair.Key.Kind {
				| &ast::IdentExpr:
					// Ok
					break
				|:
					self.pushErr(pair.Colon, log::InvalidSyntax)
					ok = false
					continue
				}
				exprs[i].Kind = &ast::FieldExprPair{
					Field: pair.Key.Token,
					Expr: pair.Val,
				}
			}
		}
		ret ok
	}

	fn check(mut self, mut &exprs: []&ast::Expr) {
		if len(exprs) == 0 {
			ret
		}
		if !self.readyExprs(exprs) {
			ret
		}
		mut paired := false
		for (i, mut expr) in exprs {
			match type expr.Kind {
			| &ast::FieldExprPair:
				mut pair := expr.Kind.(&ast::FieldExprPair)
				if i > 0 && !paired {
					self.pushErr(pair.Field, log::InvalidSyntax)
				}
				paired = true
				self.checkPair(pair, exprs)
			|:
				if paired {
					self.pushErr(expr.Token, log::ArgMustTargetToField)
				}
				if i >= len(self.s.Fields) {
					self.pushErr(expr.Token, log::FieldOverflow)
					continue
				}

				mut field := self.s.Fields[i]

				if !self.e.s.isAccessibleDefine(field.Decl.Public, field.Decl.Token) {
					self.pushErr(self.errorToken, log::StructureLitWithPrivFields)
					self.pushSuggestion(log::UseFieldPairToInstantiate)
					ret
				}

				mut prefix := self.e.prefix
				defer { self.e.prefix = prefix }
				self.e.prefix = field.Type

				// Do not unwrap untyped literals, type analysis will check overflows.
				mut v := self.e.evalExpr(expr, evalDefault)
				if v == nil {
					continue
				}

				self.pushMatch(field, v, expr.Token)
			}
		}

		// Check missing arguments for fields.
		if !paired {
			n := len(self.s.Fields)
			mut diff := n - len(exprs)
			match {
			| diff <= 0:
				ret
			}

			mut idents := strings::Builder{}
			idents.Grow(1 << 5)
			for diff > 0; diff-- {
				idents.WriteStr(", ")!
				idents.WriteStr(self.s.Fields[n-diff].Decl.Ident)!
			}
			self.pushErr(self.errorToken, log::MissingExprFor,
				str(unsafe { idents.Buf() }[2:])) /* Remove first separator. */
		}
	}
}

// Range checker and setter.
struct rangeChecker {
	sc:   &scopeChecker
	rang: &ast::RangeKind
	Kind: &RangeIter
	v:    &Value
}

impl rangeChecker {
	fn buildVar(self, mut &decl: &ast::Var): &Var {
		mut v := buildVar(decl)
		ret v
	}

	fn setSizeKey(mut self) {
		if self.rang.KeyA == nil || jule::IsBlank(self.rang.KeyA.Ident) {
			ret
		}
		self.Kind.KeyA = self.buildVar(self.rang.KeyA)
		self.Kind.KeyA.TypeSym = findBuiltinTypeAlias(types::Int).TypeSym
	}

	// Check range expression validity.
	// It bypass mutability error if necessary.
	//
	//	- v:   value to check.
	//	- key: data passed to this key.
	//	- k:   element kind of expression.
	fn checkRangeExprValidity(mut self, mut &v: &Value, &key: &Var, mut &k: &Type) {
		mut _mut := key.Mutable
		if _mut && !k.Mutable() {
			// Bypass mutability error.
			// Element kind is immutable.
			// There is no mutation.
			_mut = false
		}

		self.sc.s.checkValidityForInitExpr(
			_mut, key.Reference, key.TypeSym.Type, v, self.rang.InToken)
	}

	fn checkSlice(mut self) {
		self.setSizeKey()
		if self.rang.KeyB == nil || jule::IsBlank(self.rang.KeyB.Ident) {
			ret
		}

		mut slc := self.v.Type.Slice()
		self.Kind.KeyB = self.buildVar(self.rang.KeyB)
		self.Kind.KeyB.TypeSym = &TypeSym{Type: slc.Elem}

		self.checkRangeExprValidity(self.v, self.Kind.KeyB, slc.Elem)
	}

	fn checkArray(mut self) {
		self.setSizeKey()
		if self.rang.KeyB == nil || jule::IsBlank(self.rang.KeyB.Ident) {
			ret
		}

		mut arr := self.v.Type.Array()
		self.Kind.KeyB = self.buildVar(self.rang.KeyB)
		self.Kind.KeyB.TypeSym = &TypeSym{Type: arr.Elem}

		self.checkRangeExprValidity(self.v, self.Kind.KeyB, arr.Elem)
	}

	fn checkMapKeyA(mut self) {
		if self.rang.KeyA == nil || jule::IsBlank(self.rang.KeyA.Ident) {
			ret
		}

		mut m := self.v.Type.Map()
		self.Kind.KeyA = self.buildVar(self.rang.KeyA)
		self.Kind.KeyA.TypeSym = &TypeSym{Type: m.Key}

		mut v := new(Value, *self.v)
		v.Type = m.Key

		self.checkRangeExprValidity(v, self.Kind.KeyA, m.Key)
	}

	fn checkMapKeyB(mut self) {
		if self.rang.KeyB == nil || jule::IsBlank(self.rang.KeyB.Ident) {
			ret
		}

		mut m := self.v.Type.Map()
		self.Kind.KeyB = self.buildVar(self.rang.KeyB)
		self.Kind.KeyB.TypeSym = &TypeSym{Type: m.Val}

		mut v := new(Value, *self.v)
		v.Type = m.Val

		self.checkRangeExprValidity(v, self.Kind.KeyB, m.Val)
	}

	fn checkMap(mut self) {
		self.checkMapKeyA()
		self.checkMapKeyB()
	}

	fn checkStr(mut self) {
		self.setSizeKey()
		if self.rang.KeyB == nil || jule::IsBlank(self.rang.KeyB.Ident) {
			ret
		}
		self.Kind.KeyB = self.buildVar(self.rang.KeyB)
		self.Kind.KeyB.TypeSym = findBuiltinTypeAlias("rune").TypeSym
	}

	fn checkChan(mut self) {
		mut c := self.v.Type.Chan()
		if !c.Recv {
			self.sc.s.pushErr(self.rang.InToken, log::RecvFromSendOnlyChan)
		}
		if self.rang.KeyB != nil && !jule::IsBlank(self.rang.KeyB.Ident) {
			self.sc.s.pushErr(self.rang.KeyB.Token, log::IterPermitsNVar, c.Str(), "1")
		}
		if self.rang.KeyA == nil || jule::IsBlank(self.rang.KeyA.Ident) {
			ret
		}
		self.Kind.KeyA = self.buildVar(self.rang.KeyA)
		self.Kind.KeyA.TypeSym = &TypeSym{Type: c.Elem}
		mut v := new(Value, *self.v)
		v.Type = c.Elem
		self.checkRangeExprValidity(v, self.Kind.KeyA, c.Elem)
	}

	fn checkComptime(mut self) {
		self.setSizeKey()
		if self.rang.KeyA != nil && self.rang.KeyA.Mutable {
			self.sc.s.pushErr(self.rang.KeyA.Token, log::CannotBeMut, self.rang.KeyA.Ident)
		}
		if self.rang.KeyB != nil && self.rang.KeyB.Mutable {
			self.sc.s.pushErr(self.rang.KeyB.Token, log::CannotBeMut, self.rang.KeyB.Ident)
		}
		if self.rang.KeyB == nil || jule::IsBlank(self.rang.KeyB.Ident) {
			ret
		}
		self.Kind.KeyB = self.buildVar(self.rang.KeyB)
	}

	fn checkComptimeRange(mut self): bool {
		mut range := self.v.Type.comptimeRange()
		match type range.kind {
		| &comptimeStructFields
		| &comptimeEnumFields
		| &comptimeParams
		| &comptimeTypeInfos
		| &comptimeStatics
		| &comptimeFiles
		| &comptimeDecls
		| &comptimeSliceRange:
			self.checkComptime()
			ret true
		|:
			self.sc.s.pushErr(self.rang.InToken, log::IterRangeRequireEnumerableExpr)
			ret false
		}
	}

	fn check(mut self): bool {
		match {
		| self.v.Type.Variadic:
			// Fail.
		| self.v.Type.Slice() != nil:
			self.checkSlice()
			ret true
		| self.v.Type.Array() != nil:
			self.checkArray()
			ret true
		| self.v.Type.Map() != nil:
			self.checkMap()
			ret true
		| self.v.Type.Chan() != nil:
			self.checkChan()
			ret true
		| self.v.Type.comptimeRange() != nil:
			ret self.checkComptimeRange()
		|:
			prim := self.v.Type.Prim()
			if prim != nil && prim.IsStr() {
				self.checkStr()
				ret true
			}
		}
		self.sc.s.pushErr(self.rang.InToken, log::IterRangeRequireEnumerableExpr)
		ret false
	}
}

// Return type checker for return statements.
struct retTypeChecker {
	sc:         &scopeChecker
	f:          &FuncIns
	types:      []&Type  // Return types.
	expr:       &Value   // Return expression single value.
	exprs:      []&Value // Return expressions.
	exprDecls:  []&ast::Expr
	errorToken: &token::Token
	model:      Expr
	mutable:    bool // Whether the return expression should be mutable.
}

impl retTypeChecker {
	fn prepareTypes(mut self) {
		if self.f != nil {
			self.types = self.f.Types()
		}
	}

	fn prepareExprs(mut self, mut &e: &ast::Expr): (ok: bool) {
		if e == nil {
			ret true
		}
		match type e.Kind {
		| &ast::TupleExpr:
			self.exprDecls = e.Kind.(&ast::TupleExpr).Expr
		|:
			self.exprDecls = [e]
		}
		ok = true
		mut eval := self.sc.s.eval(self.sc)
		eval.target.mutable = self.mutable
		// Do not unwrap untyped literals, type analysis will check overflows.
		// Allow using of exceptional function result if value is single.
		mut flags := evalDefault
		if len(self.exprDecls) == 1 {
			flags |= evalExceptional
		}
		for (i, mut expr) in self.exprDecls {
			if i < len(self.types) {
				eval.prefix = self.types[i]
			}
			mut v := eval.evalExpr(expr, flags)
			ok = ok && v != nil
			if ok {
				self.exprs = append(self.exprs, v)
			}
		}
		if ok {
			if len(self.exprs) == 1 {
				self.expr = self.exprs[0]
			} else {
				self.expr = &Value{
					Type: self.f.Result,
					Model: &TupleExpr{
						Values: self.exprs,
					},
				}
			}
		}
		ret
	}

	fn checkExprs(mut self) {
		if len(self.exprs) == 0 {
			ret
		}
		for (i, mut v) in self.exprs {
			mut expr := self.exprDecls[i]
			if self.mutable && !v.Mutable && v.Type.Mutable() {
				self.sc.s.pushErr(expr.Token, log::RetWithMutTypedNonMut)
				ret
			}
			mut ac := assignTypeChecker{
				s: self.sc.s,
				dest: self.types[i],
				v: v,
				errorToken: expr.Token,
				refers: self.sc.getHardRoot().owner.Refers,
			}
			ac.check()
		}

		// Set Model.
		if len(self.exprs) > 1 { // Tuple
			self.model = &TupleExpr{Values: self.exprs}
		} else if len(self.exprs) == 1 {
			self.model = self.exprs[0].Model
		}
	}

	// Assumes the len(self.exprs) == 1 and self.exprs[0].Type.Tuple() != nil.
	fn tryFuncMultiRetForward(mut self) {
		mut tup := self.exprs[0].Type.Tuple()
		if len(tup.Types) != len(self.types) {
			goto err
		}
		self.model = self.exprs[0].Model
		for i in self.types {
			mut t1 := self.types[i]
			mut t2 := tup.Types[i]
			if !self.sc.s._checkTypeCompatibility(t1, t2, self.errorToken) {
				goto err
			}
		}
		ret
	err:
		self.notFitVariables()
	}

	fn notFitVariables(mut self) {
		mut wanted := strings::Builder{}
		wanted.Grow(1 << 5)
		for i, t in self.types {
			wanted.WriteStr(t.Str())!
			if len(self.types)-i > 1 {
				wanted.WriteStr(", ")!
			}
		}
		mut given := strings::Builder{}
		given.Grow(1 << 5)
		for i, d in self.exprs {
			given.WriteStr(d.Type.Str())!
			if len(self.exprs)-i > 1 {
				given.WriteStr(", ")!
			}
		}
		if len(self.exprs) < len(self.types) {
			self.sc.s.pushErr(self.errorToken, log::NotEnoughVariablesForRet, wanted.Str(), given.Str())
		} else {
			self.sc.s.pushErr(self.errorToken, log::TooManyVariablesForRet, wanted.Str(), given.Str())
		}
	}

	fn check(mut self, mut &e: &ast::Expr): bool {
		self.prepareTypes()
		mut ok := self.prepareExprs(e)
		if !ok {
			ret false
		}

		// Check whether we have enough variables for return.
		match {
		| len(self.exprs) == 0 && len(self.types) > 0 && self.f.Decl.AnyVar():
			ret true
		| len(self.exprs) == 1 && len(self.types) > 1 && self.exprs[0].Type.Tuple() != nil:
			match type self.exprs[0].Model {
			| &FuncCallExpr:
				self.tryFuncMultiRetForward()
				ret true
			}
			fall
		| len(self.exprs) != len(self.types):
			self.notFitVariables()
			ret false
		}

		self.checkExprs()
		ret true
	}
}

fn lenKind(): &Type { ret primInt }

// Reports whether d is good for dynamic type infer.
fn isGoodValueToInfer(&v: &Value): bool {
	ret !v.IsNil()
}
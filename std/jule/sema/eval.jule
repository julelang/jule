// Copyright 2023-2025 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/conv"
use "std/jule"
use "std/jule/ast"
use "std/jule/build"
use "std/jule/constant"
use "std/jule/constant/lit"
use "std/jule/internal/mod"
use "std/jule/token"
use "std/jule/types"
use "std/math"
use "std/math/big"
use "std/os/filepath"
use "std/strings"
use "std/unsafe"

// Bitsize limit of comptime arbitrary large literals.
const bitLimit = 256

// Value.
struct Value {
	// Means data is have not any exact strict type. Possibly constant.
	// For most untyped data, it probably a numeric.
	untyped: bool

	Type:      &Type
	Mutable:   bool
	Reference: bool
	Lvalue:    bool
	IsRune:    bool
	Model:     Expr

	// True if kind is declaration such as:
	//	- &Enum
	//	- &Struct
	//	- int type
	//	- bool type
	Decl: bool

	// Constant expression data.
	Constant: &constant::Const
}

impl Value {
	// Reports whether Value is nil literal.
	fn IsNil(self): bool {
		ret self.Type.IsNil()
	}

	// Reports whether Value is void.
	fn IsVoid(self): bool {
		ret self.Type.Void()
	}

	// Reports whether Value is constant expression.
	fn IsConst(self): bool {
		ret self.Constant != nil
	}

	// See developer reference (9.2).
	// Reports left and right operand is good order.
	// If reports false, left and right operand should be swapped.
	// Accepts itself as left operand.
	fn GoodOperand(self, mut &other: &Value): bool {
		if other.Type.TypeEnum() != nil {
			ret false
		}
		ret (other.Type.Prim() == nil || !other.Type.Prim().IsAny()) &&
			other.Type.Trait() == nil &&
			!self.Type.IsNil()
	}
}

// Value.
struct ValueSym {
	Expr:  &ast::Expr
	Value: &Value
}

// Informations about expressions that evaluating for assignments.
struct target {
	ignored: bool // whether the destination ignores the evaluated expression.
	mutable: bool // Will be assigned to the mutable storage.
}

// Eval flags.
const evalDefault = 0            // Default evaluation mode.
const evalPhysicalMem = 1 << 0   // Checks whether the value is sutaible for physical memory.
const evalUnwrapUntyped = 1 << 1 // Unwraps untyped literal value to physical memory with default type.

// Evaluator.
struct eval {
	s:          &sema // Used for error logging.
	lookup:     Lookup
	prefix:     &Type
	unsafety:   bool
	disBuiltin: bool      // Disallow/suppress Jule's built-in defines.
	owner:      &Var      // Global variable, which is owner of this evaluation.
	field:      &FieldIns // Field of this default expression. Used for checking cycles and dependency collection.
	target:     target

	// The built-in iota variable.
	// The Used field is also a flag whether the iota variable used,
	// therefore it should be set to the false to catch use cases.
	// The default state is false for both flags.
	varIota: &Var
}

impl eval {
	fn pushErr(mut self, token: &token::Token, fmt: build::LogMsg, args: ...any) {
		self.s.pushErr(token, fmt, args...)
	}

	// Push suggestion to last log.
	fn pushSuggestion(mut self, fmt: build::LogMsg, args: ...any) {
		self.s.pushSuggestion(fmt, args...)
	}

	fn allowBuiltin(mut self) {
		self.disBuiltin = false
	}

	fn disallowBuiltin(mut self) {
		self.disBuiltin = true
	}

	// Reports whether evaluation in unsafe scope.
	fn isUnsafe(self): bool {
		ret self.unsafety
	}

	// Reports whether evaluated expression is in global scope.
	fn isGlobal(self): bool {
		_, ok := self.lookup.(&sema)
		ret ok
	}

	fn applyNumericPrefix(mut self, mut &v: &Value): bool {
		if v == nil ||
			!v.IsConst() ||
			v.Type.Prim() == nil ||
			self.prefix == nil {
			ret false
		}
		prim := self.prefix.Prim()
		if prim == nil {
			ret false
		}

		match {
		| types::IsFloat(prim.Str()):
			v.Type = new(Type, *self.prefix)
			v.Constant.SetF64(v.Constant.AsF64())
			v.Constant.Kind = prim.Kind
		| types::IsSigInt(prim.Str()):
			if !sigAssignable(prim.Str(), v) {
				ret false
			}
			v.Type = new(Type, *self.prefix)
			v.Constant.SetI64(v.Constant.AsI64())
			v.Constant.Kind = prim.Kind
		| types::IsUnsigInt(prim.Str()):
			if !unsigAssignable(prim.Str(), v) {
				ret false
			}
			v.Type = new(Type, *self.prefix)
			v.Constant.SetU64(v.Constant.AsU64())
			v.Constant.Kind = prim.Kind
		}
		ret true
	}

	fn pushErrorsFromLitError(mut self, &l: &ast::LitExpr, errors: []lit::Error) {
		for _, err in errors {
			self.s.errors = append(self.s.errors, build::Log{
				Kind: build::LogKind.Error,
				Row: l.Token.Row,
				Column: l.Token.Column+err.Offset,
				Path: l.Token.File.Path,
				Text: err.Text,
			})
		}
	}

	fn litStr(mut self, &l: &ast::LitExpr): &Value {
		mut s := ""
		if token::IsRawStr(l.Value) {
			s = lit::ToRawStr(l.Value)
		} else {
			mut errors := []lit::Error(nil)
			s, errors = lit::ToStr(l.Value)
			if len(errors) != 0 {
				self.pushErrorsFromLitError(l, errors)
				ret nil
			}
		}
		mut constant := constant::Const.NewStr(s)

		ret &Value{
			untyped: true,
			Mutable: true,
			Constant: constant,
			Type: primStr,
			Model: constant,
		}
	}

	fn litRune(mut self, &l: &ast::LitExpr): &Value {
		r, errors := lit::ToRune(l.Value)
		if len(errors) != 0 {
			self.pushErrorsFromLitError(l, errors)
			ret nil
		}
		mut data := &Value{
			Constant: constant::Const.NewI64(i64(r)),
		}

		if r <= 255 {
			data.Type = findBuiltinTypeAlias("byte").TypeSym.Type
		} else {
			data.Type = findBuiltinTypeAlias("rune").TypeSym.Type
		}

		data.Model = &RuneExpr{Code: r}
		data.Mutable = true
		data.IsRune = true
		data.untyped = true
		ret data
	}

	fn litFloat(mut self, &l: &ast::LitExpr): &Value {
		f := conv::ParseFloat(l.Value, 64) else {
			self.pushErr(l.Token, build::LogMsg.ConstantOverflow)
			ret nil
		}
		mut constant := constant::Const.NewF64(f)
		ret &Value{
			untyped: true,
			Mutable: true,
			Constant: constant,
			Type: primF64,
			Model: constant,
		}
	}

	fn litInt(mut self, &l: &ast::LitExpr): &Value {
		// Maximum value of bitLimit integer.
		const maxbinary = "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
		const maxoctal = "17777777777777777777777777777777777777777777777777777777777777777777777777777777777777"
		const maxdecimal = "115792089237316195423570985008687907853269984665640564039457584007913129639935"
		const maxhex = "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
		match {
		| strings::HasPrefix(l.Value, "0x"): // Hexadecimal
			lit := l.Value[2:]
			n := len(lit) - strings::Count(lit, "_")
			if n > len(maxhex) {
				self.pushErr(l.Token, build::LogMsg.ConstantOverflow)
				ret nil
			}
		| strings::HasPrefix(l.Value, "0b"): // Binary
			lit := l.Value[2:]
			n := len(lit) - strings::Count(lit, "_")
			if n > len(maxbinary) {
				self.pushErr(l.Token, build::LogMsg.ConstantOverflow)
				ret nil
			}
		| strings::HasPrefix(l.Value, "0o"): // Ocatal
			lit := l.Value[2:]
			n := len(lit) - strings::Count(lit, "_")
			if n > len(maxoctal) {
				self.pushErr(l.Token, build::LogMsg.ConstantOverflow)
				ret nil
			}
		| l.Value[0] == '0' && len(l.Value) > 1: // Octal
			lit := l.Value[1:]
			n := len(lit) - strings::Count(lit, "_")
			if n > len(maxoctal) {
				self.pushErr(l.Token, build::LogMsg.ConstantOverflow)
				ret nil
			}
		|:
			// Decimal
			lit := l.Value[1:]
			n := len(lit) - strings::Count(lit, "_")
			if n > len(maxdecimal) {
				self.pushErr(l.Token, build::LogMsg.ConstantOverflow)
				ret nil
			}
		}

		mut v := new(Value)
		i, _ := big::Int.Parse(l.Value, 0)
		if i.BitLen() > bitLimit {
			self.pushErr(l.Token, build::LogMsg.ConstantOverflow)
			ret nil
		}
		v.Constant = constant::Const.NewInt(i)
		v.Type = primInt // Default type for unwrap.
		v.Model = v.Constant
		v.untyped = true
		_ = self.applyNumericPrefix(v)
		ret v
	}

	fn litNum(mut self, &l: &ast::LitExpr): &Value {
		match {
		| token::IsFloat(l.Value):
			ret self.litFloat(l)
		|:
			ret self.litInt(l)
		}
	}

	fn evalLit(mut self, lit: &ast::LitExpr): &Value {
		match {
		| token::IsStr(lit.Value):
			ret self.litStr(lit)
		| token::IsRune(lit.Value):
			ret self.litRune(lit)
		| token::IsNum(lit.Value):
			ret self.litNum(lit)
		|:
			ret nil
		}
	}

	fn findBuiltins(mut self, &ident: str): any {
		if mod::IsPub(ident) {
			match type self.lookup {
			| &ImportInfo:
				mut def := findBuiltinsImport(ident, self.lookup.(&ImportInfo))
				if def != nil {
					ret def
				}
			| &sema:
				mut def := findBuiltinsSema(ident, self.lookup.(&sema))
				if def != nil {
					ret def
				}
			| &scopeChecker:
				mut def := findBuiltinsSema(ident, self.lookup.(&scopeChecker).s)
				if def != nil {
					ret def
				}
			}
			ret nil
		}
		if self.disBuiltin {
			ret nil
		}
		ret findBuiltinDef(ident)
	}

	fn getDef(mut self, &ident: str, binded: bool): any {
		// Find variables and type aliases first.
		// Because self.lookup might be a scopeChecker, and shadowing may occurred.
		// If any variable or type aliases is shadowing other declarations such us structure,
		// it will result as wrong expression evaluation.
		mut v := self.lookup.FindVar(ident, binded)
		if v != nil {
			ret v
		}

		mut ta := self.lookup.FindTypeAlias(ident, binded)
		if ta != nil {
			ret ta
		}

		if !binded {
			mut t := self.lookup.FindTrait(ident)
			if t != nil {
				ret t
			}

			mut enm := self.lookup.FindEnum(ident)
			if enm != nil {
				ret enm
			}

			mut tenm := self.lookup.FindTypeEnum(ident)
			if tenm != nil {
				ret tenm
			}
		}

		mut f := self.lookup.FindFunc(ident, binded)
		if f != nil {
			ret f
		}

		mut s := self.lookup.FindStruct(ident, binded)
		if s != nil {
			ret s
		}

		// Special variables.
		match ident {
		| "iota":
			if self.varIota == nil {
				ret nil
			}
			ret self.varIota
		}

		ret self.findBuiltins(ident)
	}

	fn getOwnerRefers(mut self): &ReferenceStack {
		match type self.lookup {
		| &scopeChecker:
			ret self.lookup.(&scopeChecker).getOwnerRefers()
		|:
			// Push reference to owner if global.
			if self.owner != nil &&
				self.owner.Scope == nil {
				ret self.owner.Refers
			}
			// If field exist, push reference to struct.
			if self.field != nil {
				ret self.field.Owner.Refers
			}
		}
		ret nil
	}

	fn pushReference[T](mut self, mut &ref: T) {
		mut refers := self.getOwnerRefers()
		if refers != nil && !refers.Exist[T](ref) {
			refers.Push(ref)
		}
	}

	fn _evalEnum(self, mut enm: &Enum): &Value {
		ret &Value{
			Decl: true,
			Type: &Type{
				Kind: enm,
			},
		}
	}

	fn evalEnum(mut self, mut enm: &Enum, errorToken: &token::Token): &Value {
		if !self.s.isAccessibleDefine(enm.Public, enm.Token) {
			self.pushErr(errorToken, build::LogMsg.IdentIsNotAccessible, enm.Ident)
			self.pushSuggestion(build::LogMsg.MakePubToAccess)
			ret nil
		}
		ret self._evalEnum(enm)
	}

	fn _evalTypeEnum(self, mut enm: &TypeEnum): &Value {
		ret &Value{
			Decl: true,
			Type: &Type{
				Kind: enm,
			},
		}
	}

	fn evalTypeEnum(mut self, mut enm: &TypeEnum, errorToken: &token::Token): &Value {
		if !self.s.isAccessibleDefine(enm.Public, enm.Token) {
			self.pushErr(errorToken, build::LogMsg.IdentIsNotAccessible, enm.Ident)
			self.pushSuggestion(build::LogMsg.MakePubToAccess)
			ret nil
		}
		ret self._evalTypeEnum(enm)
	}

	fn _evalStruct(self, mut s: &StructIns): &Value {
		mut v := &Value{
			Decl: true,
			Type: &Type{
				Kind: s,
			},
			Model: s,
		}
		ret v
	}

	fn evalStruct(mut self, mut s: &Struct, mut errorToken: &token::Token): &Value {
		if !self.s.isAccessibleDefine(s.Public, s.Token) {
			self.pushErr(errorToken, build::LogMsg.IdentIsNotAccessible, s.Ident)
			self.pushSuggestion(build::LogMsg.MakePubToAccess)
			ret nil
		}

		mut ins := s.instance()
		if len(s.Generics) == 0 {
			// For generics; it is safe. Because compiler should disallow using
			// genericed structures without instantiation. So, structures should be
			// instantiated. But, there is no generics, structure may have different
			// instances. So, append instance to structure if not exist, use
			// the existing instance if exist already.
			mut exist := s.appendInstance(ins)
			if exist != nil {
				ins = exist
			} else {
				// If this is a new instance; precheck structure instance to make ready.
				if !self.s.precheckStructIns(ins, nil, errorToken) {
					ret nil
				}
			}
		}
		self.pushReference[&StructIns](ins)
		ret self._evalStruct(ins)
	}

	fn evalFuncIns(self, mut f: &FuncIns): &Value {
		ret &Value{
			Type: &Type{
				Kind: f,
			},
			Model: f,
		}
	}

	fn evalFunc(mut self, mut f: &Func, errorToken: &token::Token): &Value {
		if !self.s.isAccessibleDefine(f.Public, f.Token) {
			self.pushErr(errorToken, build::LogMsg.IdentIsNotAccessible, f.Ident)
			self.pushSuggestion(build::LogMsg.MakePubToAccess)
			ret nil
		}

		mut ins := f.instance()
		if len(f.Generics) == 0 {
			// For generics; it is safe. Because compiler should disallow using
			// genericed functions without instantiation. So, functions should be
			// instantiated. But, there is no generics, function may have different
			// instances. So, append instance to function if not exist, use
			// the existing instance if exist already.
			mut exist := f.appendInstance(ins)
			if exist != nil {
				ins = exist
			}
		}
		self.pushReference[&FuncIns](ins)
		ret self.evalFuncIns(ins)
	}

	fn evalVar(mut self, mut v: &Var, errorToken: &token::Token): &Value {
		if !self.s.isAccessibleDefine(v.Public, v.Token) {
			self.pushErr(errorToken, build::LogMsg.IdentIsNotAccessible, v.Ident)
			self.pushSuggestion(build::LogMsg.MakePubToAccess)
			ret nil
		}

		if v.Token == nil {
			// Variable is built-in.
			v.Used = true
			goto data
		}

		match type self.lookup {
		| &scopeChecker:
			mut s := self.lookup.(&scopeChecker)
			mut root := s.getRoot()
			if v.Scope != nil && !v.Constant && root.captured != nil && isVarCaptured(root, s, v) {
				// Push variable if it is not constant and global.
				// Only capture scope variables.
				root.pushCaptured(v)
			}
			if !v.Reference || self.isUnsafe() {
				break
			}
			for s.owner == nil && s.parent != nil {
				s = s.parent
			}
			// If scope owner is an anonymous function, it may be a closure.
			// But closures performs risky memory handling for references. So catch them.
			// Just one exception: deferred scope functions safe for references.
			if s.owner != nil && !s.owner.Scope.Deferred && s.owner.Anon && v.Scope != s.owner.Scope {
				self.pushErr(errorToken, build::LogMsg.UsedRefInAnonFuncFromParentScope, v.Ident)
			}
		}

		// Push reference to global variable.
		if v.Scope == nil {
			self.pushReference[&Var](v)
		}

		// Value is nil, kind is not determined.
		// In other word, not analyzed yet.
		// But this variable is dependency, therefore check this for eval.
		// Do not check if v.Used is true. It means it already analyzed.
		// If variable is global, it should be have initialize expression.
		// So, nil value means something may be wrong.
		if !v.Checked && !v.Binded && v.Scope == nil && (v.ValueSym == nil || v.ValueSym.Value == nil) {
			// Save source file of global variable.
			// Use it for evaluation and checking for correct analysis.
			// Otherwise, evaluation problems may occur.
			// Especially if variable uses use declaration namespaces in expression.
			mut varfile := findVarFileInPackage(self.s.files, v)
			mut file := self.s.getCurrentFile()
			self.s.setCurrentFile(varfile)

			// Variable is in global scope.
			// Use sema for lookup.
			self.s.checkVar(v, self.s)

			// Save the original file.
			self.s.setCurrentFile(file)
		}
		// variable guaranteed to be checked
		// any missing information means analysis failed
		// kind should not be nil because each variable must have a valid type
		v.Used = true
		if v.TypeSym == nil || v.TypeSym.Type == nil {
			ret nil
		}

	data:
		mut val := &Value{
			Lvalue: !v.Constant,
			Mutable: v.Mutable,
			Reference: v.Reference,
			Type: v.TypeSym.Type,
			Model: v,
		}
		if v.ValueSym != nil && v.ValueSym.Value != nil {
			if !v.Binded && v.IsInitialized() {
				val.IsRune = v.ValueSym.Value.IsRune
			}
			if v.Constant && v.ValueSym.Value.Constant != nil {
				val.Constant = new(constant::Const, *v.ValueSym.Value.Constant)
				val.Model = val.Constant
				if v.untypedConstant() {
					val.untyped = true
					self.applyNumericPrefix(val)
				}
			}
		}

		ret val
	}

	fn evalTypeAlias(mut self, mut ta: &TypeAlias, errorToken: &token::Token): &Value {
		if !self.s.isAccessibleDefine(ta.Public, ta.Token) {
			self.pushErr(errorToken, build::LogMsg.IdentIsNotAccessible, ta.Ident)
			self.pushSuggestion(build::LogMsg.MakePubToAccess)
			ret nil
		}

		ta.Used = true

		mut kind := ta.TypeSym.Type.Kind
		let mut v: &Value = nil
		match type kind {
		| &StructIns:
			// Eval structure instance directly.
			// No risk for instantiation because type aliases always points to
			// valid instance even with generics.
			//
			// For strict type aliases, their type structure may be not checked.
			// So, there is possible risk for type analysis and other semantics.
			// For example:
			//	The "std/comptime" package provides the TypeOf function,
			//	which is returns type information. This function may take
			//	type alias as argument. Like: comptime::TypeOf(Type)
			//	In this case, any method examination may cause crash or
			//	something like that. Because methods are may not be checked yet.
			//	But, comptime type information structure do not provides
			//	method interface directly. So, to examine types of method,
			//	developer should use the comptime::ValueOf function for the
			//	Method method to get a type information for a method.
			//	And comptime::ValueOf always takes checked type alias structs,
			//	So there is no way to occur such a fatal analysis issue,
			//	as far as tested.
			//
			// But, as far as tested, there is no risk for current implementation.
			// Future implementations should pay attention for here.
			mut s := kind.(&StructIns)
			self.pushReference[&StructIns](s)
			v = self._evalStruct(s)
		| &Enum:
			v = self._evalEnum(kind.(&Enum))
		| &TypeEnum:
			v = self._evalTypeEnum(kind.(&TypeEnum))
		|:
			v = &Value{
				Decl: true,
				Type: &Type{
					Kind: ta.TypeSym.Type.Kind,
				},
			}
			v.Model = v.Type
		}
		v.Type.Generic = ta.Generic
		ret v
	}

	fn evalTrait(mut self, mut t: &Trait): &Value {
		ret &Value{
			Decl: true,
			Type: &Type{
				Kind: t,
			},
		}
	}

	fn evalDef(mut self, mut &def: any, mut ident: &token::Token): &Value {
		match type def {
		| &Var:
			ret self.evalVar(def.(&Var), ident)
		| &Enum:
			ret self.evalEnum(def.(&Enum), ident)
		| &TypeEnum:
			ret self.evalTypeEnum(def.(&TypeEnum), ident)
		| &Struct:
			ret self.evalStruct(def.(&Struct), ident)
		| &Func:
			mut f := def.(&Func)
			if f.Ident != jule::InitFunc {
				ret self.evalFunc(f, ident)
			}
		| &FuncIns:
			ret self.evalFuncIns(def.(&FuncIns))
		| &TypeAlias:
			ret self.evalTypeAlias(def.(&TypeAlias), ident)
		| &Trait:
			ret self.evalTrait(def.(&Trait))
		}
		self.pushErr(ident, build::LogMsg.IdentNotExist, ident.Kind)
		ret nil
	}

	fn evalIdent(mut self, mut ident: &ast::IdentExpr): &Value {
		mut def := self.getDef(ident.Ident, ident.Binded)
		ret self.evalDef(def, ident.Token)
	}

	fn evalUnary(mut &self, mut u: &ast::UnaryExpr): &Value {
		mut unary := unaryEval.new(self)
		ret unary.eval(u)
	}

	fn evalVariadic(mut &self, mut v: &ast::VariadicExpr): &Value {
		if v.Expr == nil {
			self.pushErr(v.Token, build::LogMsg.InvalidExpr)
			ret nil
		}

		mut prefix := self.prefix
		self.prefix = nil
		defer { self.prefix = prefix }

		mut val := self.evalExpr(v.Expr, evalDefault|evalPhysicalMem|evalUnwrapUntyped)
		if val == nil {
			ret nil
		}
		if !val.Type.Variadicable() {
			self.pushErr(v.Token, build::LogMsg.VariadicWithNonVariadicable, val.Type.Str())
			ret nil
		}
		makeVariadic(val, val.Type.Slice().Elem)
		ret val
	}

	fn evalUnsafe(mut &self, mut u: &ast::UnsafeExpr): &Value {
		unsafety := self.unsafety
		self.unsafety = true
		mut v := self.evalExpr(u.Expr, evalDefault)
		self.unsafety = unsafety
		ret v
	}

	fn evalArray(mut &self, mut s: &ast::SliceExpr): &Value {
		// Arrays always has type prefixes.
		mut pt := self.prefix.Array()

		mut arr := &Array{
			Auto: false,
			N: 0,
			Elem: pt.Elem,
		}

		mut filled := false

		if len(s.Exprs) == 2 {
			vr, ok := s.Exprs[1].Kind.(&ast::VariadicExpr)
			if ok && vr.Expr == nil {
				// Filled.
				if pt.Auto {
					self.pushErr(s.Token, build::LogMsg.AutoSizedArrFilled)
					ret nil
				}
				filled = true
				s.Exprs = s.Exprs[:1]
			}
		}

		arr.N = len(s.Exprs)
		if !pt.Auto {
			if arr.N > pt.N {
				self.pushErr(s.Token, build::LogMsg.OverflowLimits)
			} else if arr.N < pt.N {
				arr.N = pt.N
			}
		}

		mut model := &ArrayExpr{
			Kind: arr,
		}
		if filled {
			model.Elems = make([]&Value, 0, 2)
		} else {
			model.Elems = make([]&Value, 0, len(s.Exprs))
		}

		mut prefix := self.prefix
		self.prefix = arr.Elem
		for (_, mut elem) in s.Exprs {
			// Do not unwrap untyped literals, type analysis will check overflows.
			mut v := self.evalExpr(elem, evalDefault)
			if v == nil {
				continue
			}
			const destIsRef = false
			if self.s.checkValidityForInitExpr(self.target.mutable, destIsRef, arr.Elem, v, elem.Token) {
				_ = self.s.checkAssignType(destIsRef, arr.Elem, v, elem.Token, self.getOwnerRefers())
			}
			model.Elems = append(model.Elems, v)
		}
		self.prefix = prefix

		if filled {
			// Fill mark.
			model.Elems = append(model.Elems, nil)
		}

		ret &Value{
			Mutable: true,
			Type: &Type{
				Kind: arr,
			},
			Model: model,
		}
	}

	fn evalExpSlice(mut &self, mut s: &ast::SliceExpr, mut t: &Type, mut first: &Value): &Value {
		mut slc := &Slice{
			Elem: t,
		}

		mut i := 0
		mut model := &SliceExpr{
			ElemType: t,
			Elems: make([]&Value, 0, len(s.Exprs)),
		}
		if first != nil {
			model.Elems = append(model.Elems, first)
			i = 1
		}

		mut prefix := self.prefix
		self.prefix = slc.Elem
		for (_, mut elem) in s.Exprs[i:] {
			// Do not unwrap untyped literals, type analysis will check overflows.
			mut v := self.evalExpr(elem, evalDefault)
			if v != nil {
				const destIsRef = false
				if self.s.checkValidityForInitExpr(self.target.mutable, destIsRef, slc.Elem, v, elem.Token) {
					_ = self.s.checkAssignType(destIsRef, slc.Elem, v, elem.Token, self.getOwnerRefers())
				}
				model.Elems = append(model.Elems, v)
			}
		}
		self.prefix = prefix

		ret &Value{
			Mutable: true,
			Type: &Type{
				Kind: slc,
			},
			Model: model,
		}
	}

	fn evalSliceExpr(mut &self, mut s: &ast::SliceExpr): (v: &Value) {
		if self.prefix != nil {
			match {
			| self.prefix.Array() != nil:
				v = self.evalArray(s)
			| self.prefix.Slice() != nil:
				mut pt := self.prefix.Slice()
				v = self.evalExpSlice(s, pt.Elem, nil)
			|:
				goto autoDetermine
			}
			// If prefix type is a strict type alias, we have to use its
			// underliying structure type for the value.
			if v != nil {
				mut strct := self.prefix.SoftStruct()
				if strct != nil && strct.Source != nil {
					v.Type = &Type{Kind: strct}
				}
			}
			ret
		}
	autoDetermine:
		mut prefix := self.prefix
		self.prefix = nil

		if len(s.Exprs) == 0 {
			self.pushErr(s.Token, build::LogMsg.DynamicTypeAnnotationFailed)
			ret nil
		}

		mut firstExpr := s.Exprs[0]
		mut firstElem := self.evalExpr(firstExpr, evalDefault|evalPhysicalMem|evalUnwrapUntyped)
		if firstElem == nil {
			ret nil
		}
		if self.s.checkDataForTypeInference(firstElem, firstExpr.Token) {
			// Check mutability for first element.
			const destIsRef = false
			self.s.checkValidityForInitExpr(self.target.mutable, destIsRef,
				firstElem.Type, firstElem, firstExpr.Token)

			v = self.evalExpSlice(s, firstElem.Type, firstElem)
		}
		self.prefix = prefix
		ret v
	}

	fn checkIntegerIndexingByData(mut self, mut &v: &Value, mut token: &token::Token): bool {
		errKey := checkDataForIntegerIndexing(self.s, v, token, self.getOwnerRefers())
		match errKey {
		| build::LogMsg.Empty:
			ret true
		| build::LogMsg.InvalidTypeForIndexing:
			self.pushErr(token, errKey, v.Type.Str())
		|:
			self.pushErr(token, errKey)
		}
		ret false
	}

	fn indexingPtr(mut self, mut &v: &Value, mut &index: &Value, mut &i: &ast::IndexingExpr) {
		self.checkIntegerIndexingByData(index, i.Token)
		v.Lvalue = true

		mut ptr := v.Type.Ptr()
		match {
		| ptr.IsUnsafe():
			self.pushErr(i.Token, build::LogMsg.UnsafePtrIndexing)
			ret
		| !self.isUnsafe():
			self.pushErr(i.Token, build::LogMsg.UnsafeBehaviorAtOutOfUnsafeScope)
			self.pushSuggestion(build::LogMsg.WriteYourCodeInUnsafeJule)
		}

		v.Type = ptr.Elem
	}

	fn indexingArr(mut self, mut &v: &Value, mut &index: &Value, mut &i: &ast::IndexingExpr) {
		mut arr := v.Type.Array()
		v.Type = arr.Elem
		self.checkIntegerIndexingByData(index, i.Token)
		v.Lvalue = true
		if index.IsConst() && index.Constant.AsF64() >= f64(arr.N) {
			self.pushErr(i.Token, build::LogMsg.OverflowLimits)
		}
	}

	fn indexingSlice(mut self, mut &v: &Value, mut &index: &Value, mut &i: &ast::IndexingExpr) {
		mut slc := v.Type.Slice()
		v.Type = slc.Elem
		self.checkIntegerIndexingByData(index, i.Token)
		v.Lvalue = true
	}

	fn indexingMap(mut self, mut &v: &Value, mut &index: &Value, mut &i: &ast::IndexingExpr) {
		v.Lvalue = false
		if index == nil {
			ret
		}
		mut m := v.Type.Map()
		mut atc := assignTypeChecker{
			s: self.s,
			dest: m.Key,
			v: index,
			errorToken: i.Token,
			refers: self.getOwnerRefers(),
		}
		_ = atc.check()
		v.Type = m.Val
	}

	fn indexingStr(mut self, mut &v: &Value, mut &index: &Value, mut &i: &ast::IndexingExpr) {
		v.Type = findBuiltinTypeAlias("byte").TypeSym.Type
		v.Mutable = false
		v.Lvalue = true

		if index == nil {
			ret
		}

		self.checkIntegerIndexingByData(index, i.Token)

		v.untyped = v.IsConst()
		if !index.IsConst() {
			v.Constant = nil
			v.untyped = false
			ret
		}

		if v.untyped {
			j := index.Constant.AsI64()
			s := v.Constant.ReadStr()
			if int(j) >= len(s) {
				self.pushErr(i.Token, build::LogMsg.OverflowLimits)
			} else {
				v.Constant.SetU64(u64(s[j]))
			}
		}
	}

	fn comptimeRange(mut self, mut &v: &Value, mut &index: &Value, mut &i: &ast::IndexingExpr) {
		if index == nil {
			v = nil
			ret
		}
		if !self.checkIntegerIndexingByData(index, i.Index.Token) {
			v = nil
			ret
		}
		if !index.IsConst() {
			v = nil
			self.pushErr(i.Index.Token, build::LogMsg.ExprNotConst)
			ret
		}
		// guaranteed: index >= 0
		j := int(index.Constant.AsI64())
		mut ci := v.Type.comptimeRange()
		if j >= ci.kind.len() {
			v = nil
			self.pushErr(i.Index.Token, build::LogMsg.OverflowLimits)
			ret
		}
		ci.kind.index(v, j)
	}

	fn toIndexing(mut self, mut &v: &Value, mut &index: &Value, mut &i: &ast::IndexingExpr) {
		match {
		| v.Type.Ptr() != nil:
			self.indexingPtr(v, index, i)
			ret
		| v.Type.Array() != nil:
			self.indexingArr(v, index, i)
			ret
		| v.Type.Slice() != nil:
			self.indexingSlice(v, index, i)
			ret
		| v.Type.Map() != nil:
			self.indexingMap(v, index, i)
			ret
		| v.Type.Prim() != nil:
			prim := v.Type.Prim()
			match {
			| prim.IsStr():
				self.indexingStr(v, index, i)
				ret
			}
		| v.Type.comptimeRange() != nil:
			self.comptimeRange(v, index, i)
			ret
		}
		self.pushErr(i.Token, build::LogMsg.NotSupportsIndexing, v.Type.Str())
	}

	fn pushGenericsFromData(mut &self, mut &generics: []&ast::Type, mut &expr: &ast::Expr): bool {
		match type expr.Kind {
		| &ast::UnaryExpr:
			mut u := expr.Kind.(&ast::UnaryExpr)
			match u.Op.Id {
			| token::Id.Star:
				mut kind := new(ast::PtrType)
				mut _generics := make([]&ast::Type, 0, 1)
				self.pushGenericsFromData(_generics, u.Expr)
				kind.Elem = _generics[0]
				generics = append(generics, &ast::Type{
					Token: expr.Token,
					Kind: kind,
				})
			| token::Id.Amper:
				mut kind := new(ast::SptrType)
				mut _generics := make([]&ast::Type, 0, 1)
				self.pushGenericsFromData(_generics, u.Expr)
				kind.Elem = _generics[0]
				generics = append(generics, &ast::Type{
					Token: expr.Token,
					Kind: kind,
				})
			|:
				self.pushErr(u.Op, build::LogMsg.InvalidType)
				ret false
			}
		| &ast::Type:
			generics = append(generics, expr.Kind.(&ast::Type))
		| &ast::IndexingExpr:
			mut v := self.eval(expr, evalDefault|evalPhysicalMem|evalUnwrapUntyped)
			if v == nil {
				ret false
			}
			if !v.Decl {
				self.pushErr(expr.Token, build::LogMsg.InvalidType)
				self.pushSuggestion(build::LogMsg.ExpectedType)
				ret false
			}
			mut kind := semaTypeKind(v.Type)
			generics = append(generics, &ast::Type{
				Kind: unsafe { *(*ast::TypeKind)(&kind) },
			})
		| &ast::IdentExpr:
			mut ident := expr.Kind.(&ast::IdentExpr)
			generics = append(generics, &ast::Type{
				Kind: &ast::IdentType{
					Binded: ident.Binded,
					Token: ident.Token,
					Ident: ident.Ident,
				},
			})
		| &ast::TupleExpr:
			for (_, mut texpr) in expr.Kind.(&ast::TupleExpr).Expr {
				if !self.pushGenericsFromData(generics, texpr) {
					ret false
				}
			}
		| &ast::NamespaceExpr:
			mut ns := expr.Kind.(&ast::NamespaceExpr)
			mut decl := &ast::IdentType{
				Token: ns.Ident,
				Ident: ns.Ident.Kind,
			}
			generics = append(generics, &ast::Type{
				Token: decl.Token,
				Kind: &ast::NamespaceType{
					Namespace: ns.Namespace,
					Kind: &ast::Type{
						Token: decl.Token,
						Kind: decl,
					},
				},
			})
		|:
			self.pushErr(expr.Token, build::LogMsg.InvalidSyntax)
			ret false
		}
		ret true
	}

	fn evalIdentDeclFromIndexing(mut &self, mut &v: &Value, mut &i: &ast::IndexingExpr) {
		mut s := v.Type.Struct()
		if s == nil {
			self.pushErr(i.Expr.Token, build::LogMsg.TypeNotSupportsGenerics, v.Type.Str())
			v = nil
			ret
		}

		let mut decl: &ast::IdentType = nil
		match type i.Expr.Kind {
		| &ast::IdentExpr:
			mut expr := i.Expr.Kind.(&ast::IdentExpr)
			decl = &ast::IdentType{
				Binded: expr.Binded,
				Token: expr.Token,
				Ident: expr.Ident,
			}
		| &ast::NamespaceExpr:
			mut expr := i.Expr.Kind.(&ast::NamespaceExpr)
			decl = &ast::IdentType{
				Token: expr.Ident,
				Ident: expr.Ident.Kind,
			}
		|:
			self.pushErr(i.Token, build::LogMsg.InvalidSyntax)
			v = nil
			ret
		}
		if !self.pushGenericsFromData(decl.Generics, i.Index) {
			v = nil
			ret
		}

		s = self.typeChecker().fromStruct(decl, s.Decl)
		if s == nil {
			v = nil
			ret
		}
		v.Type.Kind = s
	}

	// Checks new generics function instance.
	// If instance is already exist, f will point to exist instantantiation.
	fn checkGenericFunc(mut &self, mut &f: &FuncIns, mut &et: &token::Token, mut &model: Expr): (ok: bool, exist: bool) {
		mut old := f
		ok, exist = self.s.checkGenericFunc(f, et)
		if ok && exist {
			// Update model by exist function instance.
			// Generic functions returns always new instance, because might be
			// generics are inferred. Therefore, always returns new instance for requests.
			// So, if this absolute instance is already exist, update model.
			// Otherwise, model's instance will be a dangling, because it never
			// be appended into instances of function declaration since already exist.
			updateModelToGenericIns(model, f)
			updateRefer(self.getOwnerRefers(), old, f)
		}
		ret
	}

	fn evalFuncGenericFromIndexing(mut &self, mut &v: &Value, mut &i: &ast::IndexingExpr) {
		mut generics := make([]&ast::Type, 0, 1<<3)
		if !self.pushGenericsFromData(generics, i.Index) {
			v = nil
			ret
		}

		mut f := v.Type.Func()
		mut genericsLen := 0
		if f.Decl != nil {
			genericsLen = len(f.Decl.Generics)
		}
		if !self.s.checkGenericQuantity(genericsLen, len(generics), i.Expr.Token) {
			v = nil
			ret
		}

		// Build real kinds of generic types.
		f.Generics = make([]&InsGeneric, 0, len(f.Decl.Generics))
		for (_, mut g) in generics {
			mut k := self.evalType(g)
			if k == nil {
				v = nil
				ret
			}
			f.Generics = append(f.Generics, &InsGeneric{Type: k.Type})
		}

		if f.IsBuiltin() {
			ret
		}

		ok, _ := self.checkGenericFunc(f, i.Expr.Token, v.Model)
		if ok {
			v.Type.Kind = f
		} else {
			v = nil
		}
	}

	fn evalIndexing(mut &self, mut i: &ast::IndexingExpr): &Value {
		mut prefix := self.prefix
		self.prefix = nil
		defer { self.prefix = prefix }

		mut v := self.evalExprKind(i.Expr.Kind)
		if v == nil {
			ret nil
		}

		// Catch types.
		if v.Decl {
			self.evalIdentDeclFromIndexing(v, i)
			ret v
		}

		if v.Type.Func() != nil {
			self.evalFuncGenericFromIndexing(v, i)
			ret v
		}

		mut oldValue := *v

		// If indexing a map value, use key type of map as the prefix.
		mut m := v.Type.Map()
		if m != nil {
			self.prefix = m.Key
		}

		mut index := self.evalExpr(i.Index, evalDefault|evalPhysicalMem|evalUnwrapUntyped)
		self.prefix = nil
		if index == nil {
			ret nil
		}

		// caught comptime indexing expressions
		makeComptimeRange(v, true)

		// Set decl to true. It's a kind of flag.
		// If decl is true after indexing eval, do not touch Model:.
		// Set by indexing eval.
		v.Decl = false

		self.toIndexing(v, index, i)
		if v == nil {
			ret nil
		}
		if v.IsConst() {
			v.Decl = false
			v.Model = v.Constant
		} else if v.Decl {
			v.Decl = false
		} else {
			v.Model = &IndexingExpr{
				Token: i.Token,
				Expr: new(Value, oldValue),
				Index: index,
			}
		}

		ret v
	}

	// Returns left and right index values.
	// Returns zero integer expression if slicing have not left index.
	// So, left index always represents an expression.
	// Left data is nil if expression eval failed.
	fn evalSlicingExprs(mut &self, mut &s: &ast::SlicingExpr): (l: &Value, r: &Value, c: &Value) {
		mut prefix := self.prefix
		self.prefix = nil
		defer { self.prefix = prefix }

		if s.Start != nil {
			l = self.evalExpr(s.Start, evalDefault|evalPhysicalMem|evalUnwrapUntyped)
			if l != nil {
				self.checkIntegerIndexingByData(l, s.Token)
			} else {
				ret nil, nil, nil
			}
		} else {
			l = &Value{
				Constant: constant::Const.NewI64(0),
				Type: primInt,
			}
			l.Constant.Kind = types::Int
			l.Model = l.Constant
		}

		if s.To != nil {
			r = self.evalExpr(s.To, evalDefault|evalPhysicalMem|evalUnwrapUntyped)
			if r != nil {
				self.checkIntegerIndexingByData(r, s.Token)
			} else {
				ret nil, nil, nil
			}
		}

		if s.Cap != nil {
			c = self.evalExpr(s.Cap, evalDefault|evalPhysicalMem|evalUnwrapUntyped)
			if r != nil {
				self.checkIntegerIndexingByData(r, s.Token)
			} else {
				ret nil, nil, nil
			}
		}

		ret
	}

	fn slicingArr(mut self, &s: &ast::SlicingExpr, mut &v: &Value, &c: &Value) {
		if c != nil {
			self.pushErr(s.Token, build::LogMsg.UnsupportedTypeIndex3Slice, v.Type.Str())
		}

		mut elemType := v.Type.Array().Elem
		v.Type = &Type{
			Kind: &Slice{
				Elem: elemType,
			},
		}

		v.Lvalue = false

		// Keep mutability id already mutable.
		// Be mutable, if element is not mutable-type.
		v.Mutable = v.Mutable || !elemType.Mutable()
	}

	fn slicingStr(mut self, &s: &ast::SlicingExpr, mut &v: &Value, &l: &Value, &c: &Value, &r: &Value) {
		v.Lvalue = false
		v.Mutable = true
		if !v.IsConst() {
			ret
		}

		if l == nil || r == nil {
			v.Constant = nil
			v.untyped = false
			ret
		}

		if c != nil {
			self.pushErr(s.Token, build::LogMsg.UnsupportedTypeIndex3Slice, v.Type.Str())
		}

		if l.IsConst() && r.IsConst() {
			left := l.Constant.AsI64()
			if left < 0 {
				ret
			}

			sconst := v.Constant.ReadStr()
			mut right := i64(0)
			if r == nil {
				right = i64(len(sconst))
			} else {
				right = r.Constant.AsI64()
			}

			if left > right {
				ret
			}
			v.Constant.SetStr(sconst[left:right])
			v.Decl = true // Set Model: flag.
		} else {
			v.Constant = nil
			v.untyped = false
		}
	}

	fn checkSlicing(mut self, mut &v: &Value, &l: &Value, &r: &Value, &c: &Value, &s: &ast::SlicingExpr) {
		// NOTE: catch 3-index slicing expressions if type does not support it.
		match {
		| v.Type.Array() != nil:
			self.slicingArr(s, v, c)
			ret
		| v.Type.Slice() != nil:
			ret
		| v.Type.Prim() != nil:
			prim := v.Type.Prim()
			match {
			| prim.IsStr():
				self.slicingStr(s, v, l, c, r)
				ret
			}
		}

		self.pushErr(s.Token, build::LogMsg.NotSupportsSlicing, v.Type.Str())
	}

	fn evalSlicing(mut &self, mut s: &ast::SlicingExpr): &Value {
		mut v := self.evalExpr(s.Expr, evalDefault|evalPhysicalMem|evalUnwrapUntyped)
		if v == nil {
			ret nil
		}

		mut l, mut r, mut c := self.evalSlicingExprs(s)
		if l == nil {
			ret v
		}

		// Set decl to true. It's a kind of flag.
		// If decl is true after indexing eval, do not touch Model:.
		// Set by indexing eval.
		v.Decl = false

		// Store original copy of v, we need it for expression modelling.
		mut base := new(Value, *v)

		self.checkSlicing(v, l, r, c, s)

		if v.IsConst() {
			v.Decl = false
			v.Model = v.Constant
		} else if v.Decl {
			v.Decl = false
		} else {
			mut model := &SlicingExpr{
				Token: s.Token,
				Expr: base,
				Left: l.Model,
			}
			if r != nil {
				model.Right = r.Model
			}
			if c != nil {
				model.Cap = c.Model
			}
			v.Model = model
		}
		ret v
	}

	fn castPtr(mut self, mut t: &Type, mut v: &Value, errorToken: &token::Token) {
		v.Constant = nil
		v.untyped = false
		sptr := v.Type.Sptr()
		if sptr != nil {
			if !t.Ptr().Elem.Equal(sptr.Elem) {
				self.pushErr(errorToken, build::LogMsg.TypeNotSupportsCastingTo, v.Type.Str(), t.Str())
			}
			ret
		}

		if !self.isUnsafe() {
			self.pushErr(errorToken, build::LogMsg.UnsafeBehaviorAtOutOfUnsafeScope)
			self.pushSuggestion(build::LogMsg.WriteYourCodeInUnsafeJule)
			ret
		}

		prim := v.Type.Prim()
		if v.Type.Ptr() == nil && (prim == nil || !types::IsInt(prim.Str())) {
			self.pushErr(errorToken, build::LogMsg.TypeNotSupportsCastingTo, v.Type.Str(), t.Str())
		}
	}

	// Casts struct type. If preStrict mode is not enabled,
	// it will log error about casting failed for pre type check phase.
	// Reports whether pre type check phase completed.
	// The preStrict mode is useful to checking type and value is suitable for
	// struct casting. It returns with no error and checked as false, if not suitable.
	// Otherwise, logs errors and returns checked as true.
	fn castStruct(mut self, mut t: &Type, mut s: &StructIns, mut v: &Value, errorToken: &token::Token, preStrict: bool): (checked: bool) {
		mut tr := v.Type.Trait()
		if tr == nil {
			if !preStrict {
				self.pushErr(errorToken, build::LogMsg.TypeNotSupportsTypeAssertionTo, v.Type.Str(), t.Str())
			}
			ret false
		}

		v.Constant = nil
		v.untyped = false
		self.pushReference[&StructIns](s)

		if !s.Decl.IsImplements(tr) {
			// Log error but do not return false.
			// We know type is trait, casting is not possible.
			self.pushErr(errorToken, build::LogMsg.TypeNotSupportsTypeAssertionTo, v.Type.Str(), t.Str())
		}
		ret true
	}

	fn castSptr(mut self, mut t: &Type, mut v: &Value, errorToken: &token::Token) {
		v.Constant = nil
		v.untyped = false
		mut sptr := t.Sptr()

		mut ptr := v.Type.Ptr()
		if ptr != nil && sptr.Elem.Equal(ptr.Elem) {
			if !self.isUnsafe() {
				self.pushErr(errorToken, build::LogMsg.UnsafeBehaviorAtOutOfUnsafeScope)
				self.pushSuggestion(build::LogMsg.WriteYourCodeInUnsafeJule)
			}
			// Ok.
			ret
		}

		self.pushErr(errorToken, build::LogMsg.TypeNotSupportsCastingTo, v.Type.Str(), t.Str())
	}

	fn castSlice(mut self, mut t: &Type, mut v: &Value, errorToken: &token::Token) {
		c := v.Constant
		v.Constant = nil
		v.untyped = false

		if v.Type.Enum() != nil {
			if v.Type.Enum().TypeSym.Type.Prim() == nil || !v.Type.Enum().TypeSym.Type.Prim().IsStr() {
				self.pushErr(errorToken, build::LogMsg.TypeNotSupportsCastingTo, v.Type.Str(), t.Str())
				ret
			}
		} else if v.Type.Prim() == nil || !v.Type.Prim().IsStr() {
			self.pushErr(errorToken, build::LogMsg.TypeNotSupportsCastingTo, v.Type.Str(), t.Str())
			ret
		}

		t = t.Slice().Elem
		mut prim := t.Prim()
		if prim == nil || (!prim.IsU8() && !prim.IsI32()) {
			self.pushErr(errorToken, build::LogMsg.TypeNotSupportsCastingTo, v.Type.Str(), t.Str())
			ret
		}

		// Cast constant expressions.
		if c != nil {
			match {
			| prim.IsU8():
				s := c.ReadStr()
				mut model := &SliceExpr{
					ElemType: t,
					Elems: make([]&Value, 0, len(s)),
				}
				for _, b in []byte(s) {
					mut bc := constant::Const.NewU64(u64(b))
					bc.Kind = prim.Kind
					model.Elems = append(model.Elems, &Value{
						Type: &Type{Kind: prim},
						Constant: bc,
						Model: bc,
					})
				}
				v.Model = model
				v.Decl = true // Prevent model changing.
			| prim.IsI32():
				s := c.ReadStr()
				mut model := &SliceExpr{
					ElemType: t,
					Elems: make([]&Value, 0, len(s)),
				}
				for _, r in s {
					mut rc := constant::Const.NewI64(i64(r))
					rc.Kind = prim.Kind
					model.Elems = append(model.Elems, &Value{
						Type: &Type{Kind: prim},
						Constant: rc,
						Model: rc,
					})
				}
				v.Model = model
				v.Decl = true // Prevent model changing.
			}
		}
	}

	fn castBool(mut self, mut t: &Type, mut v: &Value, errorToken: &token::Token) {
		prim := v.Type.Prim()
		if prim == nil || !prim.IsBool() {
			self.pushErr(errorToken, build::LogMsg.TypeNotSupportsCastingTo, t.Str(), v.Type.Str())
		}
	}

	fn castStr(mut self, mut t: &Type, mut v: &Value, errorToken: &token::Token) {
		if v.Type.Enum() != nil {
			mut e := v.Type.Enum()
			if e.TypeSym.Type.Prim() != nil && e.TypeSym.Type.Prim().IsStr() {
				ret
			}
		}

		c := v.Constant
		v.Constant = nil
		v.untyped = false
		mut prim := v.Type.Prim()
		if prim != nil {
			if prim.IsStr() {
				ret
			}
			if !prim.IsU8() && !prim.IsI32() {
				self.pushErr(errorToken, build::LogMsg.TypeNotSupportsCastingTo, t.Str(), v.Type.Str())
				ret
			}
			// Cast constant expressions.
			if c != nil {
				match {
				| prim.IsU8():
					v.Constant = constant::Const.NewStr(str(byte(c.AsU64())))
					v.Model = v.Constant
					v.Decl = true // Prevent model changing.
				| prim.IsI32():
					v.Constant = constant::Const.NewStr(str(rune(c.AsI64())))
					v.Model = v.Constant
					v.Decl = true // Prevent model changing.
				}
			}
			ret
		}

		mut s := v.Type.Slice()
		if s == nil {
			self.pushErr(errorToken, build::LogMsg.TypeNotSupportsCastingTo, t.Str(), v.Type.Str())
			ret
		}

		t = s.Elem
		prim = t.Prim()
		if prim == nil || (!prim.IsU8() && !prim.IsI32()) {
			self.pushErr(errorToken, build::LogMsg.TypeNotSupportsCastingTo, t.Str(), v.Type.Str())
			ret
		}
	}

	fn castInt(mut self, mut t: &Type, mut v: &Value, errorToken: &token::Token) {
		if v.IsConst() {
			castConstByType(self.s, errorToken, t, v)
			v.Decl = true // Do not use casting model. See developer reference (11).
		} else {
			v.Constant = nil
			v.untyped = false
		}

		if v.Type.Enum() != nil {
			mut e := v.Type.Enum()
			if types::IsNum(e.TypeSym.Type.Prim().Str()) {
				ret
			}
		}

		if v.Type.Sptr() != nil {
			prim := t.Prim()
			if !prim.IsUintptr() {
				self.pushErr(errorToken, build::LogMsg.TypeNotSupportsCastingTo, v.Type.Str(), t.Str())
			}
			ret
		}
		if v.Type.Ptr() != nil {
			prim := t.Prim()
			if prim.IsUintptr() {
				// Ignore case.
			} else if !self.isUnsafe() {
				self.pushErr(errorToken, build::LogMsg.UnsafeBehaviorAtOutOfUnsafeScope)
				self.pushSuggestion(build::LogMsg.WriteYourCodeInUnsafeJule)
			}
			ret
		}

		prim := v.Type.Prim()
		if prim != nil && types::IsNum(prim.Str()) {
			ret
		}

		self.pushErr(errorToken, build::LogMsg.TypeNotSupportsCastingTo, v.Type.Str(), t.Str())
	}

	fn castNum(mut self, mut t: &Type, mut v: &Value, errorToken: &token::Token) {
		if v.IsConst() {
			castConstByType(self.s, errorToken, t, v)
			v.Decl = true // Do not use casting model. See developer reference (11).
		} else {
			v.Constant = nil
			v.untyped = false
		}

		if v.Type.Enum() != nil {
			mut e := v.Type.Enum()
			if types::IsNum(e.TypeSym.Type.Prim().Str()) {
				ret
			}
		}

		prim := v.Type.Prim()
		if prim != nil && types::IsNum(prim.Str()) {
			ret
		}

		self.pushErr(errorToken, build::LogMsg.TypeNotSupportsCastingTo, v.Type.Str(), t.Str())
	}

	fn castPrim(mut self, mut t: &Type, mut v: &Value, errorToken: &token::Token) {
		prim := t.Prim()
		match {
		| prim.IsAny():
			panic("sema: castPrim: any case should be unreachable in this routine")
		| prim.IsStr():
			self.castStr(t, v, errorToken)
		| prim.IsBool():
			self.castBool(t, v, errorToken)
		| types::IsInt(prim.Str()):
			self.castInt(t, v, errorToken)
		| types::IsNum(prim.Str()):
			self.castNum(t, v, errorToken)
		|:
			self.pushErr(errorToken, build::LogMsg.TypeNotSupportsCasting, t.Str())
		}
	}

	fn castTypeEnumT(mut self, mut &t: &Type, mut &v: &Value, mut &errorToken: &token::Token) {
		n := len(self.s.errors)
		// quick check: if type t and value type comparable.
		if !self.s.checkTypeCompatibility(t, v.Type, errorToken) {
			self.s.errors = self.s.errors[:n] // Remove logged errors by checkTypeCompatibility.
			self.pushErr(errorToken, build::LogMsg.TypeNotSupportsCastingTo, v.Type.Str(), t.Str())
		}
		v.Constant = nil
		v.untyped = false
	}

	fn castTrait(mut self, mut &t: &Type, mut &v: &Value, mut &errorToken: &token::Token) {
		n := len(self.s.errors)
		if !self.s.checkTypeCompatibility(t, v.Type, errorToken) {
			self.s.errors = self.s.errors[:n] // Remove logged errors by checkTypeCompatibility.
			self.pushErr(errorToken, build::LogMsg.TypeNotSupportsCastingTo, v.Type.Str(), t.Str())
		}
		v.Constant = nil
		v.untyped = false
	}

	fn castChan(mut self, mut &t: &Type, mut &v: &Value, mut &errorToken: &token::Token) {
		vc := v.Type.Chan()
		if vc == nil {
			self.pushErr(errorToken, build::LogMsg.TypeNotSupportsCastingTo, v.Type.Str(), t.Str())
			ret
		}
		c := t.Chan()
		if !vc.Elem.Equal(c.Elem) {
			self.pushErr(errorToken, build::LogMsg.TypeNotSupportsCastingTo, v.Type.Str(), t.Str())
			ret
		}
		if c.Recv && !vc.Recv || c.Send && !vc.Send {
			self.pushErr(errorToken, build::LogMsg.TypeNotSupportsCastingTo, v.Type.Str(), t.Str())
			ret
		}
	}

	fn evalCastByTypeNData(mut self, mut t: &Type, mut v: &Value, mut errorToken: &token::Token): &Value {
		if v != nil && v.Decl {
			self.pushErr(errorToken, build::LogMsg.InvalidExpr)
			ret nil
		}

		// if actual types are equal, allow casting
		// otherwise check casting in more detail
		if !v.Type.deepActualEqual(t) {
			match {
			| v.IsNil():
				if !t.NilCompatible() {
					self.pushErr(errorToken, build::LogMsg.TypeNotSupportsCastingTo, "<nil>", t.Str())
				}
				v.Constant = nil // Remove nil constant.
				v.untyped = false
			|:
				match {
				| t.Prim() != nil && t.Prim().IsAny():
					// The any type supports casting to any data type.
					v.Constant = nil
					v.untyped = false
				| t.TypeEnum() != nil:
					// We have to evaluate the type for type enum cases.
					// If destination type is enum, we can cast correctly.
					// Otherwise, value type-enum case evaluated first.
					// But in this case, it may be casted to type-enum.
					// But type checker only performs type-enum analysis if
					// the destination type is type-enum. So casting will be faliled
					// even for supported types.
					//
					// For example:
					//
					//	enum Bar: type {
					//		str,
					//	}
					//	enum Foo: type {
					//		Bar,
					//		int,
					//	}
					//	fn main() {
					//		let x: Bar = ""
					//		let y: Foo = str(x)
					//		let z: Foo = Foo(x)
					//		_ = y, z
					//	}
					//
					//	In the example code above will be failed if value case
					//	evaluated first. Because type destination will be str.
					//	So type checker will expect the variable |x| should be
					//	equal to any compatible type with str, which is not type-enum Bar.
					self.castTypeEnumT(t, v, errorToken)
				| t.Ptr() != nil:
					self.castPtr(t, v, errorToken)
				| t.Sptr() != nil:
					self.castSptr(t, v, errorToken)
				| t.Slice() != nil:
					self.castSlice(t, v, errorToken)
				| t.Prim() != nil:
					self.castPrim(t, v, errorToken)
				| t.Trait() != nil:
					self.castTrait(t, v, errorToken)
				| t.Chan() != nil:
					self.castChan(t, v, errorToken)
				|:
					self.pushErr(errorToken, build::LogMsg.TypeNotSupportsCasting, t.Str())
					v = nil
				}
			}
		}

		if v == nil {
			ret nil
		}
		// casting applied successfully

		if t.Binded() || v.Type.Binded() {
			// if destination or expression type is binded, it requires Unsafe Jule for this.
			// Push error if Unsafe Jule is not available. But do not return nil data,
			// casting is valid, just Unsafe Jule is missing. Push only information error for that.
			// Allow untyped constant literals for casting with no Unsafe Jule.
			if !self.isUnsafe() && (!v.IsConst() || !v.untyped) {
				self.pushErr(errorToken, build::LogMsg.UnsafeBehaviorAtOutOfUnsafeScope)
				self.pushSuggestion(build::LogMsg.CastingBindedTypesRequiresUnsafeJule)
			}
		}

		// Keep mutability if data is already mutable.
		// Even if the data is not mutable, set as mutable if the type is not mutable-type.
		v.Mutable = v.Mutable || !v.Type.Mutable()

		if !v.Decl && (v.Type.Enum() == nil || !v.Type.Enum().TypeSym.Type.Equal(t)) {
			applyCastKind(self.s, v, t, errorToken, self.getOwnerRefers())
			v.Model.(&CastingExpr).Token = errorToken
		} else {
			v.Type = t
		}

		// Remove flag.
		// The variable v cannot be v.Decl true because of checked already.
		// Therefore this field used as flag to say "do not touch to expression model".
		// So, if v.Decl is true, model will not be changed.
		v.Decl = false

		v.Lvalue = false
		v.untyped = false

		if v.IsConst() {
			mut prim := t.Prim()
			if prim != nil {
				v.Constant.Kind = prim.Kind
			} else {
				mut enm := t.Enum()
				if enm != nil {
					v.Constant.Kind = enm.TypeSym.Type.Prim().Kind
				}
			}
		}

		ret v
	}

	fn evalCastT(mut &self, mut &t: &Type, mut &e: &ast::Expr, mut &et: &token::Token): &Value {
		mut prefix := self.prefix
		self.prefix = nil
		defer { self.prefix = prefix }
		if t.Slice() != nil || t.Array() != nil {
			match type e.Kind {
			| &ast::SliceExpr:
				self.prefix = t
			}
		} else if t.Map() != nil {
			match type e.Kind {
			| &ast::BraceLit:
				self.prefix = t
			}
		}
		// Do not allow arbitrary large literals for casting.
		// Because casting will result as a valid memory type.
		// If we do not eval with the physical memory constraint,
		// arbitrary large literals may overflow largest bitsize of any actual type.
		// So we need to make sure that the value can fit at least the largest type.
		//
		// For numeric types; do not eval with physical memory constraint or unwrap.
		// Casting analysis will check the overflows for the corresponding type.
		mut flags := evalDefault
		if t.Prim() == nil || !types::IsNum(t.Prim().Kind) {
			flags |= evalPhysicalMem | evalUnwrapUntyped
		}
		mut v := self.evalExpr(e, flags)
		if v == nil || self.prefix != nil {
			ret v
		}
		ret self.evalCastByTypeNData(t, v, et)
	}

	fn evalCast(mut &self, mut c: &ast::CastExpr): &Value {
		mut t := self.evalType1(c.Kind)
		if t == nil {
			ret nil
		}
		ret self.evalCastT(t, c.Expr, c.Kind.Token)
	}

	fn evalNamespace(mut self, mut s: &ast::NamespaceExpr): &Value {
		mut imp := findNamespace(self.lookup, s.Namespace.Kind)
		if imp == nil {
			self.pushErr(s.Namespace, build::LogMsg.NamespaceNotExist, s.Namespace.Kind)
			ret nil
		}

		mut lookup := self.lookup
		self.lookup = imp

		const Binded = false
		self.disallowBuiltin()
		mut def := self.getDef(s.Ident.Kind, Binded)
		self.allowBuiltin()
		self.lookup = lookup
		ret self.evalDef(def, s.Ident)
	}

	// StructIns s is the struct type of literal.
	// Type t is the actual value type, it may be strict type alias or pure struct type.
	fn evalStructLitExplicit(mut &self, mut s: &StructIns, mut t: &Type,
		mut lit: &ast::BraceLit, mut errorToken: &token::Token): &Value {
		ok := self.s.checkGenericQuantity(len(s.Decl.Generics), len(s.Generics), errorToken)
		if !ok {
			ret nil
		}
		// NOTICE: Instance already checked (just fields) if generic quantity passes.

		if self.field != nil && self.field.Decl.Owner == s.Decl {
			self.pushErr(errorToken, build::LogMsg.IllegalCycleRefersItself, s.Decl.Ident)
		}

		self.pushReference[&StructIns](s)

		mut slc := structLitChecker{
			e: self,
			errorToken: errorToken,
			s: s,
		}
		slc.check(lit.Exprs)

		ret &Value{
			Mutable: self.target.mutable,
			Type: t,
			Model: &StructLitExpr{
				Strct: s,
				Args: slc.args,
			},
		}
	}

	fn evalTypedBraceLit(mut &self, mut lit: &ast::TypedBraceLit): &Value {
		mut t := self.evalType1(lit.Kind)
		if t == nil {
			ret nil
		}

		mut s := t.Struct()
		if s == nil {
			if t.Sptr() != nil {
				s = t.Sptr().Elem.Struct()
				if s != nil {
					goto eval
				}
			}
			mut m := t.Map()
			if m != nil {
				ret self.evalMap(m, t, lit.Lit)
			}
			self.pushErr(lit.Kind.Token, build::LogMsg.InvalidSyntax)
			ret nil
		}

	eval:
		mut v := self.evalStructLitExplicit(s, t, lit.Lit, lit.Kind.Token)
		match type t.Kind {
		| &Sptr:
			mut model := v.Model.(&StructLitExpr)
			makeStructLitAlloc(v, model)
		}

		if v != nil {
			mut strct := t.SoftStruct()
			if strct != nil && strct.Source != nil {
				v.Model.(&StructLitExpr).Strct = strct
				v.Type = &Type{Kind: strct}
			}
		}

		ret v
	}

	fn typeChecker(mut self): typeChecker {
		ret self.s.typeChecker(self.lookup, nil, nil)
	}

	fn evalType1(mut self, mut t: &ast::Type): &Type {
		let mut tc: typeChecker
		tc.s = self.s
		tc.refers = self.getOwnerRefers()
		tc.lookup = self.lookup
		tc.rootLookup = self.lookup
		// Push reference to owner if global.
		if self.owner != nil && self.owner.Scope == nil {
			tc.referencer = &referencer{
				name: self.owner.Ident,
				owner: self.owner,
			}
		}
		// If field exist, push reference to struct.
		if self.field != nil {
			tc.referencer = &referencer{
				name: self.field.Owner.Decl.Ident,
				owner: self.field.Owner,
			}
		}
		ret tc.checkDecl(t)
	}

	fn evalType(mut self, mut t: &ast::Type): &Value {
		mut t1 := self.evalType1(t)
		if t1 == nil {
			ret nil
		}
		ret &Value{
			Decl: true,
			Type: t1,
			Model: t1,
		}
	}

	fn callTypeFunc(mut &self, mut &fc: &ast::FuncCallExpr, mut &v: &Value) {
		if len(fc.Args) < 1 {
			self.pushErr(fc.Token, build::LogMsg.MissingExprFor, "v")
		} else if len(fc.Args) > 1 {
			self.pushErr(fc.Args[1].Token, build::LogMsg.ArgumentOverflow, v.Type.Str())
		} else if fc.IsCo {
			self.pushErr(fc.Token, build::LogMsg.CoForCastingCall)
			v = nil
			ret
		} else if fc.Exception != nil {
			self.pushErr(fc.Token, build::LogMsg.TypeCallWithExceptional)
			v = nil
			ret
		}

		if len(fc.Args) > 0 {
			mut arg := fc.Args[0]
			v = self.evalCastT(v.Type, arg, arg.Token)
			ret
		}

		if v != nil {
			v.Decl = false
		}
	}

	fn callBuiltinFunc(mut &self, mut &fc: &ast::FuncCallExpr, mut &v: &Value) {
		if !fc.Unhandled() { // Exceptional handled?
			// Built-in functions are not exceptional.
			self.pushErr(fc.Token, build::LogMsg.HandledUnexceptional)
		}
		v = v.Type.Func().caller(self, fc, v)
		if v == nil {
			ret
		}
		v.Mutable = true
	}

	fn checkFuncOfConcurrentCall(mut self, &f: &FuncIns, errorToken: &token::Token) {
		if self.isUnsafe() {
			ret
		}
		for _, p in f.Params {
			if p.Decl.IsSelf() {
				if !p.Decl.IsRef() {
					self.pushErr(errorToken, build::LogMsg.ConcurrentCallWithSelfParam)
					self.pushSuggestion(build::LogMsg.UseUnsafeJuleToCallCoSelf)
				}
			}
			if p.Decl.Reference {
				self.pushErr(errorToken, build::LogMsg.ConcurrentCallWithRefParam)
				self.pushSuggestion(build::LogMsg.UseUnsafeJuleToCallCo)
				ret
			}
		}
	}

	fn processExceptionalHandler(mut self, mut &f: &FuncIns, mut &fc: &ast::FuncCallExpr, mut &v: &Value) {
		resultNeeded := !self.target.ignored && !f.Decl.IsVoid()
		let mut csc: &scopeChecker = nil
		let mut ch: &Scope = nil

		mut model := v.Model.(&FuncCallExpr)

		// self.lookup is always scopeChecker because exceptionals are
		// not allowed in global scope.
		mut sc := self.lookup.(&scopeChecker)
		csc = sc.newChildChecker()
		if resultNeeded {
			csc.result = &result{func: f, mutable: self.target.mutable}
		}
		ch = sc.getChild()
		fc.Exception.Parent = sc.tree
		csc.table.Vars = append(csc.table.Vars, buildErrorVar(ch, fc))
		sc.checkChildSsc(fc.Exception, ch, csc)

		model.Assigned = resultNeeded
		model.Except = ch

		if resultNeeded && csc.result != nil {
			self.pushErr(fc.Token, build::LogMsg.MissingAssignRet)
		}
	}

	fn callFunc(mut &self, mut &fc: &ast::FuncCallExpr, mut &v: &Value) {
		mut f := v.Type.Func()
		if f.IsBuiltin() {
			self.callBuiltinFunc(fc, v)
			ret
		}

		if !f.Decl.IsMethod() && hasDirective(f.Decl.Directives, build::Directive.Test) {
			self.pushErr(fc.Token, build::LogMsg.TestCalled)
			v = nil
			ret
		}

		if !v.Mutable && f.Decl.IsMethod() && !f.Decl.Statically && f.Decl.Params[0].Mutable {
			if self.target.mutable {
				self.pushErr(fc.Token, build::LogMsg.MutOperationOnImmut)
			} else {
				// Caught mutability risk of immutable literals.
				// Literal will not be assigned to immutable memory,
				// used to call method with mutable receiver.
				// Assume literal as mutable and check accordingly.
				lit := isLitBased(v.Model)
				if lit == nil {
					// Expression is not literal based, so data is strictly immutable.
					self.pushErr(fc.Token, build::LogMsg.MutOperationOnImmut)
				} else {
					checkMutRiskOfStructLit(self.s, lit)
				}
			}
		} else if !self.isUnsafe() && f.Decl.Unsafety {
			self.pushErr(fc.Token, build::LogMsg.UnsafeBehaviorAtOutOfUnsafeScope)
			self.pushSuggestion(build::LogMsg.WriteYourCodeInUnsafeJule)
		}

		mut dynamicAnnotation := len(f.Decl.Generics) > 0 && len(f.Generics) == 0 && len(f.Params) > 0
		if dynamicAnnotation {
			f.Generics = make([]&InsGeneric, len(f.Decl.Generics))
		} else if len(f.Generics) != len(f.Decl.Generics) {
			_ = self.s.checkGenericQuantity(len(f.Decl.Generics), len(f.Generics), fc.Token)
			v = nil
			ret
		}

		mut old := self.s
		if f.Decl.Owner != nil {
			self.s = f.Decl.Owner.sema
		}

		defer {
			if old != self.s {
				old.errors = append(old.errors, self.s.errors...)
				self.s.errors = nil
			}
			self.s = old
		}

		mut fcac := fnCallArgChecker{
			e: self,
			args: fc.Args,
			dynamicAnnotation: dynamicAnnotation,
			errorToken: fc.Token,
		}

		if !dynamicAnnotation {
			if !f.reloaded {
				ok := self.s.reloadFuncInsTypes(f)
				f.reloaded = true
				if !ok {
					v = nil
					ret
				}
			}
			mut existInstance := f.Decl.appendInstance(f)
			if existInstance != nil {
				f = existInstance
			}
		} else if !self.s.buildFuncNonGenericTypes(f, fcac.ignored) {
			v = nil
			ret
		}

		fcac.f = f

		mut ok := false
		if f.Decl.Owner != nil {
			old, self.s = self.s, old // Save current Sema.
			ok = fcac.check()
			old, self.s = self.s, old // Save owner Sema.
		} else {
			ok = fcac.check()
		}

		if dynamicAnnotation {
			if !ok {
				v = nil
				ret
			}
			ok, _ = self.checkGenericFunc(f, fc.Token, v.Model)
			if !ok {
				v = nil
				ret
			}
		}

		mut callModel := v.Model

		if f.Decl.IsVoid() {
			v = buildVoidValue()
		} else {
			v.Type = f.Result
			v.Lvalue = false
		}

		mut model := &FuncCallExpr{
			Token: fc.Token,
			Func: f,
			Expr: callModel,
			Args: fcac.argModels,
			IsCo: fc.IsCo,
		}
		v.Model = model
		v.Mutable = true

		if f.Decl.Exceptional {
			if fc.IsCo {
				self.s.pushErr(fc.Token, build::LogMsg.CoForExceptional)
				self.s.pushSuggestion(build::LogMsg.HandleInFunc)
			}
			match {
			| fc.Unhandled():
				self.pushErr(fc.Token, build::LogMsg.UnhandledExceptional)
				self.pushSuggestion(build::LogMsg.HandleExceptional)
			| fc.Ignored():
				// Ok.
				break
			|:
				// Handled with scope.
				self.processExceptionalHandler(f, fc, v)
			}
		} else if !fc.Unhandled() {
			self.pushErr(fc.Token, build::LogMsg.HandledUnexceptional)
		}

		if fc.IsCo {
			model.Func.AsAnon = true
			model.Func.CalledCo = true
			self.checkFuncOfConcurrentCall(model.Func, fc.Token)
		}
	}

	fn evalFuncCall(mut &self, mut fc: &ast::FuncCallExpr): &Value {
		mut prefix := self.prefix
		self.prefix = nil
		defer { self.prefix = prefix }

		match type fc.Expr.Kind {
		| &ast::IdentExpr:
			// Use fc.expr.Token.Kind instead of casting.
			// Same thing, but more efficient and performant.
			if fc.Expr.Token.Kind == token::Kind.Error {
				ret builtinCallerError(self, fc)
			}
		}

		mut v := self.evalExprKind(fc.Expr.Kind)
		if v == nil {
			ret nil
		}

		if v.Decl {
			self.callTypeFunc(fc, v)
			ret v
		}

		if v.Type.Func() == nil {
			self.pushErr(fc.Token, build::LogMsg.CallingNonFunc)
			ret nil
		}

		self.callFunc(fc, v)
		ret v
	}

	fn evalEnumStatic(mut self, mut enm: &Enum, mut ident: &token::Token): &Value {
		mut item := enm.FindItem(ident.Kind)
		if item == nil {
			self.pushErr(ident, build::LogMsg.ObjHaveNotIdent, enm.Ident, ident.Kind)
		}
		ret evalEnumStatic(self.s, enm, item, ident, self.getOwnerRefers())
	}

	fn evalStructStatic(mut self, mut s: &StructIns, ident: &token::Token): &Value {
		mut v := new(Value)
		const Static = true
		mut method := s.FindMethod(ident.Kind, Static)
		if method != nil {
			if !self.s.isAccessibleDefine(method.Public, method.Token) {
				self.pushErr(ident, build::LogMsg.IdentIsNotAccessible, ident.Kind)
				self.pushSuggestion(build::LogMsg.MakePubToAccess)
			}

			mut ins := method.instance()
			ins.Owner = s
			self.pushReference[&FuncIns](ins)
			v.Model = &StructStaticIdentExpr{
				Structure: s,
				Expr: v.Model,
				Method: ins,
			}
			v.Type = &Type{
				Kind: ins,
			}
			ret v
		}
		self.pushErr(ident, build::LogMsg.ObjHaveNotIdent, s.Decl.Ident, ident.Kind)
		ret nil
	}

	fn evalTraitSubIdent(mut self, mut v: &Value, mut trt: &Trait, mut ident: &token::Token): &Value {
		mut f := trt.FindMethod(ident.Kind)
		if f == nil {
			self.pushErr(ident, build::LogMsg.ObjHaveNotIdent, trt.Ident, ident.Kind)
			ret nil
		}
		ret &Value{
			Mutable: v.Mutable,
			Type: &Type{
				Kind: f.instance(),
			},
			Model: &TraitSubIdentExpr{
				Token: ident,
				Expr: v.Model,
				Method: f,
				Trt: trt,
			},
		}
	}

	// This method evaluates expressions, will not check public availability.
	// The tok parameter should be identifier to accessed.
	fn evalStructSubIdentField(mut self, mut &v: &Value, mut &s: &StructIns, mut &tok: &token::Token, mut &f: &FieldIns): &Value {
		mut model := &StructSubIdentExpr{
			Token: tok,
			Expr: new(Value, *v),
			Field: f,
			Owner: s,
		}
		v.Model = model
		v.Type = f.Type
		v.Lvalue = true
		if f.Decl.Mutable && !v.Mutable {
			// Interior mutability.
			match type self.lookup {
			| &scopeChecker:
				// Use hard root scope to handle interior mutability.
				// To handle anonymous functions and closures too.
				scope := self.lookup.(&scopeChecker).getHardRoot()
				v.Mutable = scope.owner != nil && scope.owner.Owner == s
			}
		}
		ret v
	}

	// Like evalStructSubIdent, but checks only for fields.
	fn evalStructSubIdentFieldOnly(mut self, mut v: &Value, mut s: &StructIns, mut si: &ast::SubIdentExpr): (&Value, found: bool) {
		mut f := s.FindField(si.Ident.Kind)
		if f != nil {
			if !self.s.isAccessibleDefine(f.Decl.Public, f.Decl.Token) {
				self.pushErr(si.Ident, build::LogMsg.IdentIsNotAccessible, f.Decl.Ident)
				self.pushSuggestion(build::LogMsg.MakePubToAccess)
			}
			ret self.evalStructSubIdentField(v, s, si.Ident, f), true
		}
		ret nil, false
	}

	// This method evaluates expressions, will not check public availability.
	// The tok parameter should be identifier to accessed.
	fn evalStructSubIdentMethod(mut self, mut &v: &Value, mut &s: &StructIns, mut &tok: &token::Token, mut &m: &Func, ref: bool): &Value {
		if m.Params[0].IsRef() && !ref {
			self.pushErr(tok, build::LogMsg.RefMethodUsedWithNotRefInstance)
		}

		mut ins := m.instance()
		ins.Owner = s
		self.pushReference[&FuncIns](ins)
		mut model := new(Value, *v)
		v.Model = &StructSubIdentExpr{
			Token: tok,
			Expr: model,
			Method: ins,
			Owner: s,
		}
		v.Type = &Type{Kind: ins}
		ret v
	}

	fn evalStructSubIdent(mut self, mut v: &Value, mut s: &StructIns, mut si: &ast::SubIdentExpr, ref: bool): &Value {
		{
			mut tempS := s
			if s.Source != nil {
				tempS = s.Source.Struct()
			}
			if tempS != nil {
				mut r, found := self.evalStructSubIdentFieldOnly(v, tempS, si)
				if found {
					ret r
				}
			}
		}

		const Static = false
		mut m := s.FindMethod(si.Ident.Kind, Static)
		if m == nil {
			self.pushErr(si.Ident, build::LogMsg.ObjHaveNotIdent, s.Decl.Ident, si.Ident.Kind)
			ret nil
		}
		if !self.s.isAccessibleDefine(m.Public, m.Token) {
			self.pushErr(si.Ident, build::LogMsg.IdentIsNotAccessible, m.Ident)
			self.pushSuggestion(build::LogMsg.MakePubToAccess)
		}

		ret self.evalStructSubIdentMethod(v, s, si.Ident, m, ref)
	}

	fn evalIntTypeStatic(mut self, ident: &token::Token): &Value {
		const kind: str = types::Int
		match ident.Kind {
		| "Max":
			mut c := constant::Const.NewI64(types::MaxI(kind))
			c.Kind = kind
			ret &Value{
				Constant: c,
				Model: c,
				Type: primInt,
				untyped: true,
			}
		| "Min":
			mut c := constant::Const.NewI64(i64(types::Min(kind)))
			c.Kind = kind
			ret &Value{
				Constant: c,
				Model: c,
				Type: primInt,
				untyped: true,
			}
		|:
			self.pushErr(ident, build::LogMsg.TypeHaveNotIdent, kind, ident.Kind)
			ret nil
		}
	}

	fn evalUintTypeStatic(mut self, ident: &token::Token): &Value {
		const kind: str = types::Uint
		match ident.Kind {
		| "Max":
			mut c := constant::Const.NewU64(types::MaxU(kind))
			c.Kind = kind
			ret &Value{
				Constant: c,
				Model: c,
				Type: primUint,
				untyped: true,
			}
		|:
			self.pushErr(ident, build::LogMsg.TypeHaveNotIdent, kind, ident.Kind)
			ret nil
		}
	}

	fn evalI8TypeStatic(mut self, ident: &token::Token): &Value {
		const kind: str = types::I8
		const min = types::MinI8
		const max = types::MaxI8
		match ident.Kind {
		| "Max":
			mut c := constant::Const.NewI64(max)
			c.Kind = kind
			ret &Value{
				Constant: c,
				Model: c,
				Type: primI8,
				untyped: true,
			}
		| "Min":
			mut c := constant::Const.NewI64(min)
			c.Kind = kind
			ret &Value{
				Constant: c,
				Model: c,
				Type: primI8,
				untyped: true,
			}
		|:
			self.pushErr(ident, build::LogMsg.TypeHaveNotIdent, kind, ident.Kind)
			ret nil
		}
	}

	fn evalI16TypeStatic(mut self, ident: &token::Token): &Value {
		const kind: str = types::I16
		const min = types::MinI16
		const max = types::MaxI16
		match ident.Kind {
		| "Max":
			mut c := constant::Const.NewI64(max)
			c.Kind = kind
			ret &Value{
				Constant: c,
				Model: c,
				Type: primI16,
				untyped: true,
			}
		| "Min":
			mut c := constant::Const.NewI64(min)
			c.Kind = kind
			ret &Value{
				Constant: c,
				Model: c,
				Type: primI16,
				untyped: true,
			}
		|:
			self.pushErr(ident, build::LogMsg.TypeHaveNotIdent, kind, ident.Kind)
			ret nil
		}
	}

	fn evalI32TypeStatic(mut self, ident: &token::Token): &Value {
		const kind: str = types::I32
		const min = types::MinI32
		const max = types::MaxI32
		match ident.Kind {
		| "Max":
			mut c := constant::Const.NewI64(max)
			c.Kind = kind
			ret &Value{
				Constant: c,
				Model: c,
				Type: primI32,
				untyped: true,
			}
		| "Min":
			mut c := constant::Const.NewI64(min)
			c.Kind = kind
			ret &Value{
				Constant: c,
				Model: c,
				Type: primI32,
				untyped: true,
			}
		|:
			self.pushErr(ident, build::LogMsg.TypeHaveNotIdent, kind, ident.Kind)
			ret nil
		}
	}

	fn evalI64TypeStatic(mut self, ident: &token::Token): &Value {
		const kind: str = types::I64
		const min = types::MinI64
		const max = types::MaxI64
		match ident.Kind {
		| "Max":
			mut c := constant::Const.NewI64(max)
			c.Kind = kind
			ret &Value{
				Constant: c,
				Model: c,
				Type: primI64,
				untyped: true,
			}
		| "Min":
			mut c := constant::Const.NewI64(min)
			c.Kind = kind
			ret &Value{
				Constant: c,
				Model: c,
				Type: primI64,
				untyped: true,
			}
		|:
			self.pushErr(ident, build::LogMsg.TypeHaveNotIdent, kind, ident.Kind)
			ret nil
		}
	}

	fn evalU8TypeStatic(mut self, ident: &token::Token): &Value {
		const kind: str = types::U8
		const max = types::MaxU8
		match ident.Kind {
		| "Max":
			mut c := constant::Const.NewU64(max)
			c.Kind = kind
			ret &Value{
				Constant: c,
				Model: c,
				Type: primU8,
				untyped: true,
			}
		|:
			self.pushErr(ident, build::LogMsg.TypeHaveNotIdent, kind, ident.Kind)
			ret nil
		}
	}

	fn evalU16TypeStatic(mut self, ident: &token::Token): &Value {
		const kind: str = types::U16
		const max = types::MaxU16
		match ident.Kind {
		| "Max":
			mut c := constant::Const.NewU64(max)
			c.Kind = kind
			ret &Value{
				Constant: c,
				Model: c,
				Type: primU16,
				untyped: true,
			}
		|:
			self.pushErr(ident, build::LogMsg.TypeHaveNotIdent, kind, ident.Kind)
			ret nil
		}
	}

	fn evalU32TypeStatic(mut self, ident: &token::Token): &Value {
		const kind: str = types::U32
		const max = types::MaxU32
		match ident.Kind {
		| "Max":
			mut c := constant::Const.NewU64(max)
			c.Kind = kind
			ret &Value{
				Constant: c,
				Model: c,
				Type: primU32,
				untyped: true,
			}
		|:
			self.pushErr(ident, build::LogMsg.TypeHaveNotIdent, kind, ident.Kind)
			ret nil
		}
	}

	fn evalU64TypeStatic(mut self, ident: &token::Token): &Value {
		const kind: str = types::U64
		const max = types::MaxU64
		match ident.Kind {
		| "Max":
			mut c := constant::Const.NewU64(max)
			c.Kind = kind
			ret &Value{
				Constant: c,
				Model: c,
				Type: primU64,
				untyped: true,
			}
		|:
			self.pushErr(ident, build::LogMsg.TypeHaveNotIdent, kind, ident.Kind)
			ret nil
		}
	}

	fn evalF32TypeStatic(mut self, ident: &token::Token): &Value {
		const kind: str = types::F32
		const max = types::MaxF32
		const min = types::MinF32
		const smallestNonzero = types::SmallestNonzeroF32
		match ident.Kind {
		| "Max":
			mut c := constant::Const.NewF64(max)
			c.Kind = kind
			ret &Value{
				Constant: c,
				Model: c,
				Type: primF32,
				untyped: true,
			}
		| "Min":
			mut c := constant::Const.NewF64(min)
			c.Kind = kind
			ret &Value{
				Constant: c,
				Model: c,
				Type: primF32,
				untyped: true,
			}
		| "SmallestNonzero":
			mut c := constant::Const.NewF64(smallestNonzero)
			c.Kind = kind
			ret &Value{
				Constant: c,
				Model: c,
				Type: primF32,
				untyped: true,
			}
		|:
			self.pushErr(ident, build::LogMsg.TypeHaveNotIdent, kind, ident.Kind)
			ret nil
		}
	}

	fn evalF64TypeStatic(mut self, ident: &token::Token): &Value {
		const kind: str = types::F64
		const max = types::MaxF64
		const min = types::MinF64
		const smallestNonzero = types::SmallestNonzeroF64
		match ident.Kind {
		| "Max":
			mut c := constant::Const.NewF64(max)
			c.Kind = kind
			ret &Value{
				Constant: c,
				Model: c,
				Type: primF64,
				untyped: true,
			}
		| "Min":
			mut c := constant::Const.NewF64(min)
			c.Kind = kind
			ret &Value{
				Constant: c,
				Model: c,
				Type: primF64,
				untyped: true,
			}
		| "SmallestNonzero":
			mut c := constant::Const.NewF64(smallestNonzero)
			c.Kind = kind
			ret &Value{
				Constant: c,
				Model: c,
				Type: primF64,
				untyped: true,
			}
		|:
			self.pushErr(ident, build::LogMsg.TypeHaveNotIdent, kind, ident.Kind)
			ret nil
		}
	}

	fn evalPrimStatic(mut self, mut t: &Type, ident: &token::Token): (v: &Value) {
		kind := t.Prim().Kind
		match kind {
		| types::Int:
			v = self.evalIntTypeStatic(ident)
		| types::Uint:
			v = self.evalUintTypeStatic(ident)
		| types::I8:
			v = self.evalI8TypeStatic(ident)
		| types::I16:
			v = self.evalI16TypeStatic(ident)
		| types::I32:
			v = self.evalI32TypeStatic(ident)
		| types::I64:
			v = self.evalI64TypeStatic(ident)
		| types::U8:
			v = self.evalU8TypeStatic(ident)
		| types::U16:
			v = self.evalU16TypeStatic(ident)
		| types::U32:
			v = self.evalU32TypeStatic(ident)
		| types::U64:
			v = self.evalU64TypeStatic(ident)
		| types::F32:
			v = self.evalF32TypeStatic(ident)
		| types::F64:
			v = self.evalF64TypeStatic(ident)
		|:
			self.pushErr(ident, build::LogMsg.TypeHaveNotIdent, kind, ident.Kind)
			ret nil
		}
		if v != nil && t.Kind != t.ActualKind() {
			// Type is not actual, return as non-actual typed.
			v.Type = t
		}
		ret
	}

	fn evalTypeStatic(mut self, mut v: &Value, mut si: &ast::SubIdentExpr): &Value {
		match {
		| v.Type.SoftStruct() != nil:
			// Eval soft structures first, because strict type aliases may
			// jump into other cases. So caught they here.
			ret self.evalStructStatic(v.Type.SoftStruct(), si.Ident)
		| v.Type.Prim() != nil:
			ret self.evalPrimStatic(v.Type, si.Ident)
		| v.Type.Enum() != nil:
			ret self.evalEnumStatic(v.Type.Enum(), si.Ident)
		|:
			self.pushErr(si.Ident, build::LogMsg.TypeNotSupportSubFields, v.Type.Str())
			ret nil
		}
	}

	fn comptimeObjSubIdent[ComptimeType](mut self, mut &ct: &ComptimeType, &v: &Value, &si: &ast::SubIdentExpr): &Value {
		mut cd := ct.subIdent(si.Ident.Kind)
		if cd == nil {
			self.pushErr(si.Ident, build::LogMsg.ObjHaveNotIdent, v.Type.Str(), si.Ident.Kind)
		}
		ret cd
	}

	fn tryComptimeObjSubIdent(mut self, mut &v: &Value, mut si: &ast::SubIdentExpr): (&Value, bool) {
		match {
		| v.Type.comptimeTypeInfo() != nil:
			mut ct := v.Type.comptimeTypeInfo()
			ret self.comptimeObjSubIdent(ct, v, si), true
		| v.Type.comptimeStructField() != nil:
			mut ct := v.Type.comptimeStructField()
			ret self.comptimeObjSubIdent(ct, v, si), true
		| v.Type.comptimeEnumField() != nil:
			mut ct := v.Type.comptimeEnumField()
			ret self.comptimeObjSubIdent(ct, v, si), true
		| v.Type.comptimeParam() != nil:
			mut ct := v.Type.comptimeParam()
			ret self.comptimeObjSubIdent(ct, v, si), true
		| v.Type.comptimeStatic() != nil:
			mut ct := v.Type.comptimeStatic()
			ret self.comptimeObjSubIdent(ct, v, si), true
		| v.Type.comptimeValue() != nil:
			mut ct := v.Type.comptimeValue()
			ret self.comptimeObjSubIdent(ct, v, si), true
		| v.Type.comptimeFile() != nil:
			mut ct := v.Type.comptimeFile()
			ret self.comptimeObjSubIdent(ct, v, si), true
		| v.Type.comptimeDecl() != nil:
			mut ct := v.Type.comptimeDecl()
			ret self.comptimeObjSubIdent(ct, v, si), true
		|:
			ret nil, false
		}
	}

	fn evalObjSubIdent(mut self, mut v: &Value, mut si: &ast::SubIdentExpr): &Value {
		if token::IsIgnoreIdent(si.Ident.Kind) {
			self.pushErr(si.Ident, build::LogMsg.InvalidSyntax)
			ret nil
		}
		{
			mut compData, ok := self.tryComptimeObjSubIdent(v, si)
			if ok {
				ret compData
			}
		}
		mut kind := v.Type
		match type v.Type.Kind {
		| &Ptr:
			mut ptr := v.Type.Kind.(&Ptr)
			if ptr.IsUnsafe() {
				break
			}
			if !self.isUnsafe() {
				self.pushErr(si.Ident, build::LogMsg.UnsafeBehaviorAtOutOfUnsafeScope)
				self.pushSuggestion(build::LogMsg.WriteYourCodeInUnsafeJule)
			}
			kind = ptr.Elem
			makeImplicitDeref(v, si.Ident)
		| &Sptr:
			mut sptr := v.Type.Kind.(&Sptr)
			kind = sptr.Elem
			makeImplicitDeref(v, si.Ident)
		}

		match type kind.Kind {
		| &StructIns:
			mut s := kind.Kind.(&StructIns)
			if s.Source != nil || isInstancedStruct(s) {
				mut usedReferenceElem := false
				match type v.Type.Kind {
				| &Sptr:
					usedReferenceElem = true
				}
				ret self.evalStructSubIdent(v, s, si, usedReferenceElem)
			}
		}
		if v.Type.Trait() != nil {
			ret self.evalTraitSubIdent(v, v.Type.Trait(), si.Ident)
		}
		self.pushErr(si.Ident, build::LogMsg.ObjNotSupportSubFields, v.Type.Str())
		ret nil
	}

	fn evalSubIdent(mut &self, mut si: &ast::SubIdentExpr): &Value {
		mut prefix := self.prefix
		self.prefix = nil
		defer { self.prefix = prefix }
		mut v := self.eval1(si.Expr, evalDefault|evalPhysicalMem|evalUnwrapUntyped)
		if v == nil || v.Type == nil {
			ret nil
		}
		if v.Decl {
			ret self.evalTypeStatic(v, si)
		}
		ret self.evalObjSubIdent(v, si)
	}

	fn evalTupleFunc(mut &self, mut tup: &ast::TupleExpr, part: fn(mut &expr: &ast::Expr): &Value): &Value {
		mut tupT := new(Tuple)
		tupT.Types = make([]&Type, 0, len(tup.Expr))

		mut model := &TupleExpr{
			Values: make([]&Value, 0, len(tup.Expr)),
		}

		mut ok := true
		for (_, mut expr) in tup.Expr {
			mut v := part(expr)
			if v == nil {
				ok = false
				continue
			}
			tupT.Types = append(tupT.Types, v.Type)
			model.Values = append(model.Values, v)
		}

		if !ok {
			ret nil
		}

		ret &Value{
			Type: &Type{Kind: tupT},
			Model: model,
		}
	}

	fn evalTuple(mut &self, mut tup: &ast::TupleExpr): &Value {
		ret self.evalTupleFunc(tup, fn(mut &expr: &ast::Expr): &Value {
			ret self.evalExpr(expr, evalDefault|evalPhysicalMem)
		})
	}

	// Map m is the map type of literal.
	// Type t is the actual value type, it may be strict type alias or pure map type.
	fn evalMap(mut &self, mut m: &Map, mut t: &Type, mut lit: &ast::BraceLit): &Value {
		mut model := &MapExpr{
			Kind: m,
		}

		mut prefix := self.prefix
		for (_, mut expr) in lit.Exprs {
			mut pair, ok := expr.Kind.(&ast::KeyValPair)
			if !ok {
				self.pushErr(lit.Token, build::LogMsg.InvalidSyntax)
				ret nil
			}

			self.prefix = model.Kind.Key
			// Do not unwrap untyped literals, type analysis will check overflows.
			mut key := self.evalExpr(pair.Key, evalDefault)
			self.prefix = prefix
			if key == nil {
				ret nil
			}

			self.prefix = model.Kind.Val
			// Do not unwrap untyped literals, type analysis will check overflows.
			mut val := self.evalExpr(pair.Val, evalDefault)
			self.prefix = prefix
			if val == nil {
				ret nil
			}

			const destIsRef = false
			if self.s.checkValidityForInitExpr(self.target.mutable, destIsRef, m.Key, key, pair.Key.Token) {
				_ = self.s.checkAssignType(destIsRef, m.Key, key, pair.Key.Token, self.getOwnerRefers())
			}
			if self.s.checkValidityForInitExpr(self.target.mutable, destIsRef, m.Val, val, pair.Val.Token) {
				_ = self.s.checkAssignType(destIsRef, m.Val, val, pair.Val.Token, self.getOwnerRefers())
			}

			model.Entries = append(model.Entries, &KeyValPairExpr{
				Key: key.Model,
				Val: val.Model,
			})
		}

		ret &Value{
			Mutable: true,
			Type: t,
			Model: model,
		}
	}

	fn evalBraceLit(mut &self, mut lit: &ast::BraceLit): &Value {
		match {
		| self.prefix == nil:
			self.pushErr(lit.Token, build::LogMsg.InvalidSyntax)
			ret nil
		| self.prefix.Map() != nil:
			ret self.evalMap(self.prefix.Map(), self.prefix, lit)
		| self.prefix.Struct() != nil:
			ret self.evalStructLitExplicit(self.prefix.Struct(), self.prefix, lit, lit.Token)
		}
		self.pushErr(lit.Token, build::LogMsg.InvalidSyntax)
		ret nil
	}

	fn evalAnonFunc(mut &self, mut decl: &ast::Func): &Value {
		mut tc := typeChecker{
			s: self.s,
			rootLookup: self.lookup,
			lookup: self.lookup,
		}
		mut ins := tc.buildFunc(decl)
		if ins == nil {
			ret nil
		}
		ins.AsAnon = true
		mut captured := make([]&Var, 0)
		match type self.lookup {
		| &scopeChecker:
			mut sc := self.lookup.(&scopeChecker)
			mut scc := sc.newChildChecker()
			scc.labels = new([]&scopeLabel, nil)
			scc.gotos = new([]&Goto, nil)
			scc.owner = ins
			scc.childIndex = 0
			scc.it = 0
			scc.cse = 0
			scc.captured = unsafe { (&[]&Var)(&captured) }
			self.s.checkFuncInsSc(ins, scc)
		|:
			self.s.checkFuncIns(ins)
		}

		// If we are in global scope and evaluation owner is a global variable,
		// push reference to the anonymous function.
		isGlobal := self.isGlobal()
		if isGlobal && self.owner != nil {
			self.pushReference[&FuncIns](ins)
		}

		ret &Value{
			Type: &Type{Kind: ins},
			Model: &AnonFuncExpr{
				Captured: captured,
				Func: ins,
				Global: isGlobal,
			},
		}
	}

	fn evalBinary(mut &self, mut op: &ast::BinaryExpr): &Value {
		mut bs := binaryEval.newPlain(self)
		// Apply prefix for just numericals.
		if self.prefix != nil {
			prim := self.prefix.Prim()
			if prim == nil || !types::IsNum(prim.Str()) {
				mut prefix := self.prefix
				self.prefix = nil
				defer { self.prefix = prefix }
			}
		}
		ret bs.eval(op)
	}

	fn evalChanRecv(mut &self, mut expr: &ast::ChanRecv): &Value {
		mut v := self.evalExpr(expr.Expr, evalDefault|evalPhysicalMem|evalUnwrapUntyped)
		if v == nil {
			ret nil
		}
		mut ch := v.Type.Chan()
		if ch == nil {
			// Expression type is not channel.
			self.s.pushErr(expr.Expr.Token, build::LogMsg.ExprNotChan)
			self.s.pushSuggestion(build::LogMsg.RArrowOpExpectsChan)
			ret nil
		}
		if !ch.Recv {
			self.s.pushErr(expr.Expr.Token, build::LogMsg.RecvFromSendOnlyChan)
		}
		v.Model = &ChanRecv{
			Token: expr.Expr.Token,
			Expr: new(Value, *v),
		}
		v.Type = ch.Elem
		ret v
	}

	fn evalChanSend(mut &self, mut chs: &ast::ChanSend): &Value {
		mut l := self.evalExpr(chs.Chan, evalDefault|evalPhysicalMem|evalUnwrapUntyped)
		if l == nil {
			ret nil
		}
		mut ch := l.Type.Chan()
		if ch == nil {
			self.s.pushErr(chs.Chan.Token, build::LogMsg.ExprNotChan)
			self.s.pushSuggestion(build::LogMsg.RArrowOpExpectsChan)
			ret nil
		}
		if !ch.Send {
			self.s.pushErr(chs.Chan.Token, build::LogMsg.SendToRecvOnlyChan)
		}
		mut prefix := self.prefix
		mut mutable := self.target.mutable
		mut unsafety := self.unsafety
		self.prefix = ch.Elem
		self.target.mutable = l.Mutable
		self.unsafety = self.isUnsafe()
		// Do not unwrap untyped literals, type analysis will check overflows.
		mut r := self.evalExpr(chs.Data, evalDefault)
		self.prefix = prefix
		self.target.mutable = mutable
		self.unsafety = unsafety
		if r == nil {
			ret nil
		}
		match type self.lookup {
		| &scopeChecker:
			mut sc := self.lookup.(&scopeChecker)
			sc.removeInteriorMutRisk(r)
		}
		if l.Mutable && !r.Mutable && r.Type.Mutable() {
			self.s.pushErr(chs.Data.Token, build::LogMsg.ImmutDataSendViaMutChan, r.Type.Str())
		}
		// Check assignment types and return.
		mut checker := assignTypeChecker{
			s: self.s,
			dest: ch.Elem,
			v: r,
			errorToken: chs.Data.Token,
			refers: self.getOwnerRefers(),
		}
		if !checker.check() {
			ret nil
		}
		mut v := buildVoidValue()
		v.Model = &ChanSend{
			Token: chs.Chan.Token,
			Chan: l,
			Data: r,
		}
		ret v
	}

	fn evalTypeAssertion(mut &self, mut tae: &ast::TypeAssertionExpr): &Value {
		mut t := self.evalType1(tae.Kind)
		if t == nil {
			ret nil
		}
		mut prefix := self.prefix
		self.prefix = nil
		defer { self.prefix = prefix }
		flags := evalDefault | evalPhysicalMem | evalUnwrapUntyped
		mut v := self.evalExpr(tae.Expr, flags)
		if v == nil {
			ret v
		}
		mut errorToken := tae.Expr.Token
		if v != nil && v.Decl {
			self.pushErr(errorToken, build::LogMsg.InvalidExpr)
			ret nil
		}
		if v.Type.Prim() != nil && v.Type.Prim().IsAny() {
			if t.SoftStruct() == nil && t.TypeEnum() != nil {
				self.pushErr(errorToken, build::LogMsg.TypeEnumAssertedFromAny)
				ret nil
			}
		} else if v.Type.TypeEnum() != nil {
			n := len(self.s.errors)
			if !self.s.checkTypeCompatibility(v.Type, t, errorToken) {
				self.s.errors = self.s.errors[:n] // Remove logged errors by checkTypeCompatibility.
				self.pushErr(errorToken, build::LogMsg.TypeNotSupportsTypeAssertionTo, v.Type.Str(), t.Str())
				ret nil
			}
		} else if v.Type.Trait() != nil {
			mut ts := t.SoftStruct()
			if ts == nil {
				if t.Sptr() != nil {
					ts = t.Sptr().Elem.SoftStruct()
				}
			}
			if ts == nil {
				self.pushErr(errorToken, build::LogMsg.TypeNotSupportsTypeAssertionTo, v.Type.Str(), t.Str())
				ret nil
			} else {
				const PreStrict = false
				self.castStruct(t, ts, v, errorToken, PreStrict)
			}
		} else {
			self.pushErr(errorToken, build::LogMsg.TypeNotSupportsTypeAssertion, v.Type.Str())
			ret nil
		}
		mut r := new(Value)
		r.Type = t
		r.Mutable = v.Mutable
		r.Model = &TypeAssertionExpr{
			Token: errorToken,
			Expr: v,
			Type: t,
		}
		ret r
	}

	fn evalExprKind(mut &self, mut kind: ast::ExprData): &Value {
		match type kind {
		| &ast::RangeExpr:
			mut e := kind.(&ast::RangeExpr)
			ret self.evalExprKind(e.Expr.Kind)
		| &ast::LitExpr:
			ret self.evalLit(kind.(&ast::LitExpr))
		| &ast::IdentExpr:
			ret self.evalIdent(kind.(&ast::IdentExpr))
		| &ast::UnaryExpr:
			ret self.evalUnary(kind.(&ast::UnaryExpr))
		| &ast::VariadicExpr:
			ret self.evalVariadic(kind.(&ast::VariadicExpr))
		| &ast::UnsafeExpr:
			ret self.evalUnsafe(kind.(&ast::UnsafeExpr))
		| &ast::SliceExpr:
			ret self.evalSliceExpr(kind.(&ast::SliceExpr))
		| &ast::IndexingExpr:
			ret self.evalIndexing(kind.(&ast::IndexingExpr))
		| &ast::SlicingExpr:
			ret self.evalSlicing(kind.(&ast::SlicingExpr))
		| &ast::CastExpr:
			ret self.evalCast(kind.(&ast::CastExpr))
		| &ast::NamespaceExpr:
			ret self.evalNamespace(kind.(&ast::NamespaceExpr))
		| &ast::TypedBraceLit:
			ret self.evalTypedBraceLit(kind.(&ast::TypedBraceLit))
		| &ast::Type:
			ret self.evalType(kind.(&ast::Type))
		| &ast::FuncCallExpr:
			ret self.evalFuncCall(kind.(&ast::FuncCallExpr))
		| &ast::SubIdentExpr:
			ret self.evalSubIdent(kind.(&ast::SubIdentExpr))
		| &ast::TupleExpr:
			ret self.evalTuple(kind.(&ast::TupleExpr))
		| &ast::BraceLit:
			ret self.evalBraceLit(kind.(&ast::BraceLit))
		| &ast::Func:
			ret self.evalAnonFunc(kind.(&ast::Func))
		| &ast::BinaryExpr:
			ret self.evalBinary(kind.(&ast::BinaryExpr))
		| &ast::ChanRecv:
			ret self.evalChanRecv(kind.(&ast::ChanRecv))
		| &ast::ChanSend:
			ret self.evalChanSend(kind.(&ast::ChanSend))
		| &ast::TypeAssertionExpr:
			ret self.evalTypeAssertion(kind.(&ast::TypeAssertionExpr))
		|:
			ret nil
		}
	}

	// Returns value data of evaluated expression.
	// Returns nil if error occurs.
	fn eval1(mut &self, mut expr: &ast::Expr, flags: int): &Value {
		mut v := self.evalExprKind(expr.Kind)
		if v == nil || v.Type == nil {
			ret nil
		}

		match {
		| v.Type.Func() != nil:
			// Check special cases for functions.
			mut f := v.Type.Func()
			if f.IsBuiltin() {
				self.s.pushErr(expr.Token, build::LogMsg.BuiltinNotInvoked)
				break
			}
			required := len(f.Decl.Generics)
			given := len(f.Generics)
			if !self.s.checkGenericQuantity(required, given, expr.Token) {
				ret nil
			}
			if !f.Decl.Statically && f.Decl.IsMethod() {
				self.s.pushErr(expr.Token, build::LogMsg.MethodNotInvoked)
			} else if findDirective(f.Decl.Directives, build::Directive.Export) != nil {
				self.s.pushErr(expr.Token, build::LogMsg.ExportedUsedAsAnonymous, f.Decl.Ident)
			} else {
				f.AsAnon = true
			}
		| v.Decl:
			// Check evaluated type declarations.
			mut s := v.Type.Struct()
			if s == nil {
				break
			}
			required := len(s.Decl.Generics)
			given := len(s.Generics)
			if !self.s.checkGenericQuantity(required, given, expr.Token) {
				ret nil
			}
		}

		ok := checkValue(v, self.s, expr.Token, flags)
		if !ok {
			v = nil
		}

		ret v
	}

	// Returns value data of evaluated expression.
	// Returns nil if error occurs.
	// Accepts comptime expressions as invalid.
	fn eval(mut &self, mut expr: &ast::Expr, flags: int): &Value {
		mut v := self.eval1(expr, flags)
		if v == nil {
			ret nil
		}
		if (self.owner == nil || !self.owner.Constant) && v.Type.comptime() {
			self.s.pushErr(expr.Token, build::LogMsg.ComptimeAsExpr)
			ret nil
		}
		ret v
	}

	// Returns value data of evaluated expression by eval1.
	// Returns nil if error occurs.
	// Accepts decls as invalid expression.
	fn evalExpr1(mut &self, mut expr: &ast::Expr, flags: int): &Value {
		mut v := self.eval1(expr, flags)
		match {
		| v == nil:
			ret nil
		| v.Decl:
			self.pushErr(expr.Token, build::LogMsg.InvalidExpr)
			ret nil
		|:
			ret v
		}
	}

	// Returns value data of evaluated expression by eval.
	// Returns nil if error occurs.
	// Accepts decls as invalid expression.
	fn evalExpr(mut &self, mut expr: &ast::Expr, flags: int): &Value {
		mut v := self.eval(expr, flags)
		match {
		| v == nil:
			ret nil
		| v.Decl:
			self.pushErr(expr.Token, build::LogMsg.InvalidExpr)
			ret nil
		|:
			ret v
		}
	}
}

struct unaryEval {
	e: &eval
	v: &Value
	u: &ast::UnaryExpr
}

impl unaryEval {
	static fn new(mut e: &eval): unaryEval {
		ret unaryEval{
			e: e,
		}
	}

	fn minus(mut self) {
		match {
		| self.v.Type == nil:
			self.v = nil
			ret
		| self.v.Type.Prim() != nil:
			if !types::IsNum(self.v.Type.Prim().Str()) {
				self.v = nil
				ret
			}
		|:
			self.v = nil
			ret
		}

		self.v.Lvalue = false
		self.v.Mutable = true

		if self.v.IsConst() {
			match {
			| self.v.Constant.IsF64():
				if self.v.Type.Prim().IsF32() {
					self.v.Constant.SetF64(f64(-f32(self.v.Constant.ReadF64())))
				} else {
					self.v.Constant.SetF64(-self.v.Constant.ReadF64())
				}
			| self.v.Constant.IsInt():
				i := self.v.Constant.ReadInt()
				if self.v.untyped {
					self.v.Constant.SetInt(i.Neg())
				} else {
					kind := self.v.Type.Prim().Kind
					sz := types::BitSizeOf(kind)
					match {
					| types::IsSigInt(kind):
						match sz {
						| 8:
							if i.Sign() == -1 {
								self.v.Constant.SetI64(i64(-i8(i.I64())))
							} else {
								self.v.Constant.SetI64(i64(-i8(i.U64())))
							}
						| 16:
							if i.Sign() == -1 {
								self.v.Constant.SetI64(i64(-i16(i.I64())))
							} else {
								self.v.Constant.SetI64(i64(-i16(i.U64())))
							}
						| 32:
							if i.Sign() == -1 {
								self.v.Constant.SetI64(i64(-i32(i.I64())))
							} else {
								self.v.Constant.SetI64(i64(-i32(i.U64())))
							}
						| 64:
							if i.Sign() == -1 {
								self.v.Constant.SetI64(-i.I64())
							} else {
								self.v.Constant.SetI64(-i64(i.U64()))
							}
						|:
							panic("sema: unimplemented bitsize for unaryEval.caret, this panic call should be unreachable")
						}
					| types::IsUnsigInt(kind):
						match sz {
						| 8:
							if i.Sign() == -1 {
								self.v.Constant.SetU64(u64(-u8(i.I64())))
							} else {
								self.v.Constant.SetU64(u64(-u8(i.U64())))
							}
						| 16:
							if i.Sign() == -1 {
								self.v.Constant.SetU64(u64(-u16(i.I64())))
							} else {
								self.v.Constant.SetU64(u64(-u16(i.U64())))
							}
						| 32:
							if i.Sign() == -1 {
								self.v.Constant.SetU64(u64(-u32(i.I64())))
							} else {
								self.v.Constant.SetU64(u64(-u32(i.U64())))
							}
						| 64:
							if i.Sign() == -1 {
								self.v.Constant.SetU64(-u64(i.I64()))
							} else {
								self.v.Constant.SetU64(-i.U64())
							}
						|:
							panic("sema: unimplemented bitsize for unaryEval.caret, this panic call should be unreachable")
						}
					}
				}
			|:
				panic("sema: unimplemented constant type for unaryEval.minus, this panic call should be unreachable")
			}
			if self.v.Constant.IsInt() && self.v.Constant.ReadInt().BitLen() > bitLimit {
				self.e.pushErr(self.u.Op, build::LogMsg.ConstantOverflowResult)
				self.v.Decl = true // Do not log error.
				ret
			}
			// Do not self model for constant expressions. It's a overhead,
			// because model will be changed to constant by following algorithm.
			ret
		}

		self.v.Model = &UnaryExpr{
			Expr: new(Value, *self.v),
			Op: self.u.Op,
		}
	}

	fn plus(mut self) {
		match {
		| self.v.Type == nil:
			self.v = nil
			ret
		| self.v.Type.Prim() != nil:
			if !types::IsNum(self.v.Type.Prim().Str()) {
				self.v = nil
				ret
			}
		|:
			self.v = nil
			ret
		}

		self.v.Lvalue = false
		self.v.Mutable = true

		if self.v.IsConst() {
			match {
			| self.v.Constant.IsF64():
				self.v.Constant.SetF64(+self.v.Constant.ReadF64())
			| self.v.Constant.IsInt():
				// No-op
			|:
				panic("sema: unimplemented constant type for unaryEval.plus, this panic call should be unreachable")
			}
			// Do not update self model for constant expressions. It's a overhead,
			// because model will be changed to constant by following algorithm.
			ret
		}

		self.v.Model = &UnaryExpr{
			Expr: new(Value, *self.v),
			Op: self.u.Op,
		}
	}

	fn caret(mut self) {
		match {
		| self.v.Type == nil:
			self.v = nil
			ret
		| self.v.Type.Prim() != nil:
			if !types::IsInt(self.v.Type.Prim().Str()) {
				self.v = nil
				ret
			}
		|:
			self.v = nil
			ret
		}

		self.v.Lvalue = false
		self.v.Mutable = true

		// If type is "int" or "uint", it should be evaluated by target architecture.
		// Evaluate by bitsize of the target architecture and set as i64 again.
		// Also other types should be evaluated by their own bitsize.
		// So implement this operator by bitsize in general.
		if self.v.IsConst() {
			i := self.v.Constant.ReadInt()
			// If value is untyped and constant have not any kind, set as untyped.
			// Otherwise set by type of value.
			if self.v.untyped && self.v.Constant.Kind == "" {
				self.v.Constant.SetInt(i.Not())
			} else {
				kind := self.v.Type.Prim().Kind
				sz := types::BitSizeOf(kind)
				match {
				| types::IsSigInt(kind):
					match sz {
					| 8:
						if i.Sign() == -1 {
							self.v.Constant.SetI64(i64(^i8(i.I64())))
						} else {
							self.v.Constant.SetI64(i64(^i8(i.U64())))
						}
					| 16:
						if i.Sign() == -1 {
							self.v.Constant.SetI64(i64(^i16(i.I64())))
						} else {
							self.v.Constant.SetI64(i64(^i16(i.U64())))
						}
					| 32:
						if i.Sign() == -1 {
							self.v.Constant.SetI64(i64(^i32(i.I64())))
						} else {
							self.v.Constant.SetI64(i64(^i32(i.U64())))
						}
					| 64:
						if i.Sign() == -1 {
							self.v.Constant.SetI64(^i.I64())
						} else {
							self.v.Constant.SetI64(^i64(i.U64()))
						}
					|:
						panic("sema: unimplemented bitsize for unaryEval.caret, this panic call should be unreachable")
					}
				| types::IsUnsigInt(kind):
					match sz {
					| 8:
						if i.Sign() == -1 {
							self.v.Constant.SetU64(u64(^u8(i.I64())))
						} else {
							self.v.Constant.SetU64(u64(^u8(i.U64())))
						}
					| 16:
						if i.Sign() == -1 {
							self.v.Constant.SetU64(u64(^u16(i.I64())))
						} else {
							self.v.Constant.SetU64(u64(^u16(i.U64())))
						}
					| 32:
						if i.Sign() == -1 {
							self.v.Constant.SetU64(u64(^u32(i.I64())))
						} else {
							self.v.Constant.SetU64(u64(^u32(i.U64())))
						}
					| 64:
						if i.Sign() == -1 {
							self.v.Constant.SetU64(^u64(i.I64()))
						} else {
							self.v.Constant.SetU64(^i.U64())
						}
					|:
						panic("sema: unimplemented bitsize for unaryEval.caret, this panic call should be unreachable")
					}
				|:
					panic("sema: unimplemented constant type for unaryEval.caret, this panic call should be unreachable")
				}
			}
			if self.v.Constant.IsInt() && self.v.Constant.ReadInt().BitLen() > bitLimit {
				self.e.pushErr(self.u.Op, build::LogMsg.ConstantOverflowResult)
				self.v.Decl = true // Do not log error.
				ret
			}
			// Do not update self model for constant expressions. It's a overhead,
			// because model will be changed to constant by following algorithm.
			ret
		}

		self.v.Model = &UnaryExpr{
			Expr: new(Value, *self.v),
			Op: self.u.Op,
		}
	}

	fn excl(mut self) {
		t := self.v.Type.Prim()
		if t == nil || !t.IsBool() {
			self.v = nil
			ret
		}

		self.v.Lvalue = false
		self.v.Mutable = true

		if self.v.IsConst() {
			match {
			| self.v.Constant.IsBool():
				self.v.Constant.SetBool(!self.v.Constant.ReadBool())
			|:
				panic("sema: unimplemented constant type for unaryEval.excl, this panic call should be unreachable")
			}
			// Do not self model for constant expressions. It's a overhead,
			// because model will be changed to constant by following algorithm.
			ret
		}

		self.v.Model = &UnaryExpr{
			Expr: new(Value, *self.v),
			Op: self.u.Op,
		}
	}

	fn star(mut self) {
		self.v.Model = &UnaryExpr{
			Expr: new(Value, *self.v),
			Op: self.u.Op,
		}

		match {
		| self.v.Type.Ptr() != nil:
			if !self.e.isUnsafe() {
				self.e.pushErr(self.u.Op, build::LogMsg.UnsafeBehaviorAtOutOfUnsafeScope)
				self.e.pushSuggestion(build::LogMsg.WriteYourCodeInUnsafeJule)
			}

			mut t := self.v.Type.Ptr()
			if t.IsUnsafe() {
				self.v = nil
				ret
			}
			self.v.Type = t.Elem
			self.v.Mutable = true
		| self.v.Type.Sptr() != nil:
			self.v.Type = self.v.Type.Sptr().Elem
		|:
			self.v = nil
			ret
		}

		self.v.Constant = nil
		self.v.untyped = false
		self.v.Lvalue = true
	}

	fn amper(mut self) {
		match type self.v.Model {
		| &StructLitExpr:
			mut lit := self.v.Model.(&StructLitExpr)
			makeStructLitAlloc(self.v, lit)
		|:
			match {
			| canGetPtr(self.v):
				self.v.Type = &Type{
					Kind: &Ptr{Elem: self.v.Type},
				}
				self.v.Model = &UnaryExpr{
					Expr: new(Value, *self.v),
					Op: self.u.Op,
				}
			|:
				self.v = nil
				ret
			}
		}

		self.v.Constant = nil
		self.v.untyped = false
		self.v.Lvalue = false
		self.v.Mutable = true
	}

	fn typeDecl(mut self) {
		mut tc := typeChecker{
			s: self.e.s,
			rootLookup: self.e.lookup,
			lookup: self.e.lookup,
			errorToken: self.u.Op,
		}
		match self.u.Op.Id {
		| token::Id.Star:
			self.v.Type = &Type{Kind: tc.buildPtrFromType(self.v.Type)}
			self.v.Model = self.v.Type
		| token::Id.Amper:
			self.v.Type = &Type{Kind: tc.buildSptrFromType(self.v.Type)}
			self.v.Model = self.v.Type
		|:
			self.e.pushErr(self.u.Op, build::LogMsg.InvalidExprForUnary, self.u.Op.Kind, self.v.Type.Str())
			self.v = nil
			ret
		}
		self.v.Decl = true
	}

	fn evalData(mut self) {
		match self.u.Op.Id {
		| token::Id.Star
		| token::Id.Amper:
			mut prefix := self.e.prefix
			self.e.prefix = nil
			self.v = self.e.eval(self.u.Expr, evalDefault)
			self.e.prefix = prefix
		|:
			self.v = self.e.eval(self.u.Expr, evalDefault)
		}
	}

	fn eval(mut self, mut u: &ast::UnaryExpr): &Value {
		self.u = u
		self.evalData()
		if self.v == nil {
			ret nil
		}
		if self.v.Decl {
			self.typeDecl()
			ret self.v
		}

		// NOTE
		// The self.v.Decl is false now.
		// Any function may be set to true.
		// For this cases, following algorithm will not log error and
		// returns nil.
		kind := self.v.Type
		match self.u.Op.Id {
		| token::Id.Minus:
			self.minus()
		| token::Id.Plus:
			self.plus()
		| token::Id.Caret:
			self.caret()
		| token::Id.Excl:
			self.excl()
		| token::Id.Star:
			self.star()
		| token::Id.Amper:
			self.amper()
		|:
			self.v = nil
		}

		match {
		| self.v == nil:
			self.e.pushErr(self.u.Op, build::LogMsg.InvalidExprForUnary, self.u.Op.Kind, kind.Str())
			ret nil
		| self.v.Decl:
			self.v = nil
		| self.v.IsConst():
			self.v.Model = self.v.Constant
		}
		ret self.v
	}
}

struct binaryEval {
	e:  &eval
	l:  &Value
	r:  &Value
	op: &token::Token
	lt: &token::Token
	rt: &token::Token
}

impl binaryEval {
	static fn newPlain(mut e: &eval): binaryEval {
		ret binaryEval{
			e: e,
		}
	}

	static fn new(mut e: &eval, mut op: &token::Token,
		mut lt: &token::Token, mut rt: &token::Token): binaryEval {
		ret binaryEval{
			e: e,
			op: op,
			lt: lt,
			rt: rt,
		}
	}

	// Reports whether types are compatible.
	// Also logs error message about incompatibility if types are incompatible.
	fn checkTypeCompatibility(mut self): bool {
		ret self.e.s.checkTypeCompatibility1(self.l.Type, self.r, self.op)
	}

	// Like the checkTypeCompatibility method, but tries to be compatible with
	// constant operands. Such as; "ordinary str" == MyStr("strict typed string")
	fn checkTypeCompatibility1(mut self): bool {
		if self.l.IsConst() && self.l.untyped {
			self.l, self.r = self.r, self.l
		}
		const Ref = false
		ret self.e.s.checkAssignType(Ref, self.l.Type, self.r, self.op, nil)
	}

	fn evalComptimeTypeInfo(mut self): &Value {
		mut r := self.r.Type.comptimeTypeInfo()
		if r == nil {
			self.e.pushErr(self.op, build::LogMsg.IncompatibleTypes, "comptimeTypeInfo", self.r.Type.Str())
			ret nil
		}
		mut l := self.l.Type.comptimeTypeInfo()
		match self.op.Id {
		| token::Id.Eqs:
			mut constant := constant::Const.NewBool(l.base.Equal(r.base))
			ret &Value{
				Type: primBool,
				Constant: constant,
				Model: constant,
			}
		| token::Id.NotEq:
			mut constant := constant::Const.NewBool(!l.base.Equal(r.base))
			ret &Value{
				Type: primBool,
				Constant: constant,
				Model: constant,
			}
		|:
			self.e.pushErr(self.op, build::LogMsg.OperatorNotForJuleType, self.op.Kind, self.l.Type.Str())
			ret nil
		}
	}

	fn evalNil(mut self): &Value {
		if !self.r.Type.NilCompatible() {
			self.e.pushErr(self.op, build::LogMsg.IncompatibleTypes, "nil", self.r.Type.Str())
			ret nil
		}

		match self.op.Id {
		| token::Id.Eqs
		| token::Id.NotEq:
			ret &Value{
				Type: primBool,
			}
		|:
			self.e.pushErr(self.op, build::LogMsg.OperatorNotForJuleType, self.op.Kind, "nil")
			ret nil
		}
	}

	fn evalEnum(mut self): &Value {
		match self.op.Id {
		| token::Id.Eqs
		| token::Id.NotEq:
			mut rkind := self.r.Type
			if self.r.Type.Enum() != nil {
				rkind = self.r.Type.Enum().TypeSym.Type
			}
			mut enm := self.l.Type.Enum()
			if !self.e.s.checkTypeCompatibility(enm.TypeSym.Type, rkind, self.op) {
				ret nil
			}
			ret &Value{
				Type: primBool,
			}
		}

		if !self.checkTypeCompatibility() {
			ret nil
		}

		match self.op.Id {
		| token::Id.Gt
		| token::Id.Lt
		| token::Id.GtEq
		| token::Id.LtEq:
			if !types::IsNum(self.l.Type.Enum().TypeSym.Type.Prim().Str()) {
				self.e.pushErr(self.op, build::LogMsg.OperatorNotForJuleType, self.op.Kind, self.l.Type.Str())
				ret nil
			}
			ret &Value{
				Type: primBool,
			}
		| token::Id.Amper:
			mut first := self.l.Type.Enum().Items[0]
			i := first.ValueSym.Value.Constant.ReadInt()
			match {
			| i.IsI64():
				if i.I64() == 0 {
					goto next
				}
				goto err
			| i.IsU64():
				if i.U64() == 0 {
					goto next
				}
				goto err
			|:
				panic("sema: unimplemented enum type, this panic call should be unreachable")
			}
		err:
			self.e.pushErr(self.op, build::LogMsg.AmperOpForEnum, self.l.Type.Str(), self.op.Kind)
			self.e.pushSuggestion(build::LogMsg.DefineZeroDefaultToUseAmper)
		next:
			fall
		| token::Id.Vline
		| token::Id.Caret:
			mut enm := self.l.Type.Enum()
			if enm.TypeSym.Type.Prim() == nil || !types::IsInt(enm.TypeSym.Type.Prim().Str()) {
				self.e.pushErr(self.op, build::LogMsg.OperatorNotForJuleType, self.op.Kind, self.l.Type.Str())
			}
			ret self.l
		|:
			self.e.pushErr(self.op, build::LogMsg.OperatorNotForJuleType, self.op.Kind, self.l.Type.Str())
			ret nil
		}
	}

	fn evalTypeEnum(mut self): &Value {
		if !self.checkTypeCompatibility() {
			ret nil
		}

		match self.op.Id {
		| token::Id.Eqs
		| token::Id.NotEq:
			ret &Value{
				Type: primBool,
			}
		|:
			self.e.pushErr(self.op, build::LogMsg.OperatorNotForJuleType, self.op.Kind, self.l.Type.Str())
			ret nil
		}
	}

	fn evalChan(mut self): &Value {
		if !self.checkTypeCompatibility() {
			ret nil
		}

		match self.op.Id {
		| token::Id.Eqs
		| token::Id.NotEq:
			ret &Value{
				Type: primBool,
			}
		|:
			self.e.pushErr(self.op, build::LogMsg.OperatorNotForJuleType, self.op.Kind, self.l.Type.Str())
			ret nil
		}
	}

	fn evalSptr(mut self): &Value {
		if !self.checkTypeCompatibility() {
			ret nil
		}

		match self.op.Id {
		| token::Id.Eqs
		| token::Id.NotEq:
			ret &Value{
				Type: primBool,
			}
		|:
			self.e.pushErr(self.op, build::LogMsg.OperatorNotForJuleType, self.op.Kind, self.l.Type.Str())
			ret nil
		}
	}

	fn evalPtr(mut self): &Value {
		match self.op.Id {
		| token::Id.Eqs
		| token::Id.NotEq
		| token::Id.Lt
		| token::Id.Gt
		| token::Id.LtEq
		| token::Id.GtEq:
			if !self.checkTypeCompatibility() {
				ret nil
			}
			ret &Value{
				Type: primBool,
			}
		| token::Id.Plus
		| token::Id.Minus:
			if self.l.Type.Ptr() == nil {
				self.l, self.r = self.r, self.l
			}
			if self.l.Type.Ptr().IsUnsafe() {
				self.e.pushErr(self.op, build::LogMsg.OperatorNotForJuleType, self.op.Kind, self.l.Type.Str())
			}
			if !isPtrArithmeticCompatible(self.l, self.r) {
				self.e.pushErr(self.op, build::LogMsg.IncompatibleTypeForPtrArithmetic, self.r.Type.Str())
				ret nil
			}
			ret self.l
		|:
			self.e.pushErr(self.op, build::LogMsg.OperatorNotForJuleType, self.op.Kind, self.l.Type.Str())
			ret nil
		}
	}

	fn evalArray(mut self): &Value {
		if !self.checkTypeCompatibility() {
			ret nil
		}

		match self.op.Id {
		| token::Id.Eqs
		| token::Id.NotEq:
			// We will not have to check whether array type is comparable.
			// Binary eval already checked comparable special cases, so operands should be comparable.
			if self.e.s.meta.runtime != nil {
				// Add instance to relevant runtime function for array element type if not exist.
				mut f := runtimeFindFunc(self.e.s.meta.runtime, "arrayCmp").instanceForce()
				f.Generics = append(f.Generics, &InsGeneric{Type: self.l.Type.Array().Elem})
				ok, _ := self.e.s.checkGenericFunc(f, self.op)
				if !ok {
					panic("sema: arrayCmp evaluation failed, this is an implementation mistake")
				}
				self.e.pushReference[&FuncIns](f)
			}
			ret &Value{
				Type: primBool,
			}
		|:
			self.e.pushErr(self.op, build::LogMsg.OperatorNotForJuleType, self.op.Kind, self.l.Type.Str())
			ret nil
		}
	}

	fn evalStruct(mut self): &Value {
		match self.op.Id {
		| token::Id.Eqs
		| token::Id.NotEq:
			if !self.checkTypeCompatibility() {
				ret nil
			}
			ret &Value{
				Type: primBool,
			}
		|:
			self.e.pushErr(self.op, build::LogMsg.OperatorNotForJuleType, self.op.Kind, self.l.Type.Str())
			ret nil
		}
	}

	fn evalTrait(mut self): &Value {
		if !self.checkTypeCompatibility() {
			ret nil
		}

		match self.op.Id {
		| token::Id.Eqs
		| token::Id.NotEq:
			ret &Value{
				Type: primBool,
			}
		|:
			self.e.pushErr(self.op, build::LogMsg.OperatorNotForJuleType, self.op.Kind, self.l.Type.Str())
			ret nil
		}
	}

	fn evalAny(mut self): &Value {
		match self.op.Id {
		| token::Id.Eqs
		| token::Id.NotEq:
			applyImplicitCast(self.e.s, self.l.Type, self.r, self.op, self.e.getOwnerRefers())
			ret &Value{
				Type: primBool,
			}
		|:
			self.e.pushErr(self.op, build::LogMsg.OperatorNotForJuleType, self.op.Kind, self.l.Type.Str())
			ret nil
		}
	}

	fn evalBool(mut self): &Value {
		if !self.checkTypeCompatibility1() {
			ret nil
		}

		match self.op.Id {
		| token::Id.Eqs
		| token::Id.NotEq
		| token::Id.DblAmper
		| token::Id.DblVline:
			ret self.l
		|:
			self.e.pushErr(self.op, build::LogMsg.OperatorNotForJuleType, self.op.Kind, self.l.Type.Str())
			ret nil
		}
	}

	fn evalStr(mut self): &Value {
		if !self.checkTypeCompatibility1() {
			ret nil
		}

		match self.op.Id {
		| token::Id.Plus:
			ret self.l
		| token::Id.Eqs
		| token::Id.NotEq
		| token::Id.Lt
		| token::Id.Gt
		| token::Id.GtEq
		| token::Id.LtEq:
			ret &Value{
				Type: primBool,
			}
		|:
			self.e.pushErr(self.op, build::LogMsg.OperatorNotForJuleType, self.op.Kind, self.l.Type.Str())
			ret nil
		}
	}

	fn setTypeToGreater(mut self) {
		lp := self.l.Type.Prim()
		rp := self.r.Type.Prim()
		if self.l.untyped && !self.r.untyped {
			self.l.Type = self.r.Type
			if self.l.IsConst() {
				self.l.Constant.Kind = rp.Kind
			}
			self.l.untyped = false
		} else if !self.l.untyped && self.r.untyped {
			self.r.Type = self.l.Type
			if self.r.IsConst() {
				self.r.Constant.Kind = lp.Kind
			}
			self.r.untyped = false
		} else if self.l.untyped && self.r.untyped {
			ls := getUntypedCmpScore(lp.Kind)
			rs := getUntypedCmpScore(rp.Kind)
			if ls > rs {
				self.r.Type = self.l.Type
				if self.r.IsConst() {
					self.r.Constant.Kind = lp.Kind
				}
				self.l.untyped = false
			} else if ls < rs {
				self.l.Type = self.r.Type
				if self.l.IsConst() {
					self.l.Constant.Kind = rp.Kind
				}
				self.l.untyped = false
			}
		}
	}

	fn checkModData(mut self, mut &v: &Value) {
		if !v.IsConst() {
			if v.Type.Prim() == nil || !types::IsInt(v.Type.Prim().Kind) {
				self.e.pushErr(self.op, build::LogMsg.ModuloWithNotInt)
			}
			ret
		}
		match {
		| sigAssignable(types::I64, v):
			v.Constant.SetI64(v.Constant.AsI64())
		| unsigAssignable(types::U64, v):
			v.Constant.SetU64(v.Constant.AsU64())
		|:
			self.e.pushErr(self.op, build::LogMsg.ModuloWithNotInt)
		}
	}

	fn mod(mut self) {
		self.checkModData(self.l)
		self.checkModData(self.r)
	}

	fn numbersAreCompatible(mut self): bool {
		lk := self.l.Type.Prim().Kind
		rk := self.r.Type.Prim().Kind
		if !types::IsNum(rk) {
			self.e.s.pushCompatibilityError(self.l.Type, self.r, self.op)
			ret false
		}
		if self.l.IsConst() && self.l.untyped {
			if !self.r.untyped && self.r.IsConst() {
				ret castConstByType(self.e.s, self.lt, self.r.Type, self.l)
			}
			ret true
		}
		if lk == types::F32 {
			if self.r.IsConst() && self.r.untyped {
				ret castConstByType(self.e.s, self.rt, self.l.Type, self.r)
			}
			if rk != types::F32 {
				self.e.s.pushCompatibilityError(self.l.Type, self.r, self.op)
				ret false
			}
			ret true
		}
		if lk == types::F64 {
			if self.r.IsConst() && self.r.untyped {
				ret castConstByType(self.e.s, self.rt, self.l.Type, self.r)
			}
			if rk != types::F64 {
				self.e.s.pushCompatibilityError(self.l.Type, self.r, self.op)
				ret false
			}
			ret true
		}
		if self.r.IsConst() && self.r.untyped {
			ret true
		}
		ret self.checkTypeCompatibility()
	}

	// Operator guaranteed to be << or >>.
	// Operands should be guaranteed in original order.
	fn shift(mut self): &Value {
		lk := self.l.Type.Prim()
		if lk == nil {
			self.e.pushErr(self.op, build::LogMsg.OperatorNotForJuleType, self.op.Kind, self.l.Type.Str())
			ret nil
		}
		rk := self.r.Type.Prim()
		if rk == nil {
			self.e.pushErr(self.op, build::LogMsg.OperatorNotForJuleType, self.op.Kind, self.r.Type.Str())
			ret nil
		}
		// primitive guaranteed

		if !types::IsNum(lk.Kind) || !types::IsNum(rk.Kind) {
			self.e.s.pushCompatibilityError(self.l.Type, self.r, self.op)
			ret nil
		}
		// number guaranteed

		if !types::IsInt(lk.Kind) {
			// should be floating-point
			if !self.l.IsConst() || !self.l.untyped {
				self.e.pushErr(self.op, build::LogMsg.IncompatibleTypes, self.l.Type.Str(), self.r.Type.Str())
				ret nil
			} else if intAssignable(types::I64, self.l) {
				self.l.Constant.SetI64(self.l.Constant.AsI64())
				self.l.Type = primI64
			} else if intAssignable(types::U64, self.l) {
				self.l.Constant.SetU64(self.l.Constant.AsU64())
				self.l.Type = primU64
			}
		}
		if !types::IsInt(rk.Kind) {
			// should be floating-point
			if !self.r.IsConst() || !self.l.untyped {
				self.e.pushErr(self.op, build::LogMsg.IncompatibleTypes, self.l.Type.Str(), self.r.Type.Str())
				ret nil
			} else if intAssignable(types::I64, self.r) {
				self.r.Constant.SetI64(self.r.Constant.AsI64())
				self.r.Type = primI64
			} else if intAssignable(types::U64, self.r) {
				self.r.Constant.SetU64(self.r.Constant.AsU64())
				self.r.Type = primU64
			}
		}
		// integer guaranteed

		if !isOkForShifting(self.r) {
			if self.r.untyped {
				self.e.s.pushCompatibilityError(primUint, self.r, self.rt)
			} else {
				self.e.pushErr(self.rt, build::LogMsg.BitShiftMustUnsigned)
			}
			ret nil
		}
		// value is valid guaranteed

		const maxShiftCount = bitLimit
		if self.r.IsConst() {
			if self.r.Constant.IsInt() {
				i := self.r.Constant.ReadInt()
				if i.IsI64() && i.I64() > maxShiftCount ||
					i.IsU64() && i.U64() > maxShiftCount {
					self.e.pushErr(self.rt, build::LogMsg.InvalidShiftCount, i.Str())
					ret nil
				}
			} else if self.r.Constant.IsF64() && self.r.Constant.ReadF64() > maxShiftCount {
				self.e.pushErr(self.rt, build::LogMsg.InvalidShiftCount, self.r.Constant.Str())
				ret nil
			}
		}

		if self.r.untyped || !self.r.Type.Equal(self.l.Type) {
			applyImplicitCast(self.e.s, self.l.Type, self.r, self.rt, self.e.getOwnerRefers())
		}
		// unsigned guaranteed
		ret self.l
	}

	fn evalFloat(mut self): &Value {
		if !self.numbersAreCompatible() {
			ret nil
		}

		// Logicals.
		match self.op.Id {
		| token::Id.Eqs
		| token::Id.NotEq
		| token::Id.Lt
		| token::Id.Gt
		| token::Id.GtEq
		| token::Id.LtEq:
			self.setTypeToGreater()
			ret &Value{
				Type: primBool,
			}
		}

		// Arithmetics.
		match self.op.Id {
		| token::Id.Shl
		| token::Id.Shr:
			panic("sema: binary shifting operator handling failed")
		| token::Id.Plus
		| token::Id.Minus
		| token::Id.Star:
			self.setTypeToGreater()
			ret self.l
		| token::Id.Solidus:
			self.setTypeToGreater()
			ret self.l
		| token::Id.Percent:
			if !types::IsInt(self.r.Type.Prim().Kind) {
				self.e.pushErr(self.op, build::LogMsg.IncompatibleTypes, self.l.Type.Str(), self.r.Type.Str())
				ret nil
			}
			self.mod()
			self.setTypeToGreater()
			ret self.r
		|:
			self.e.pushErr(self.op, build::LogMsg.OperatorNotForFloat, self.op.Kind)
			ret nil
		}
	}

	fn evalInt(mut self): &Value {
		if !self.numbersAreCompatible() {
			ret nil
		}

		// Logicals.
		match self.op.Id {
		| token::Id.Eqs
		| token::Id.NotEq
		| token::Id.Lt
		| token::Id.Gt
		| token::Id.GtEq
		| token::Id.LtEq:
			ret &Value{
				Type: primBool,
			}
		}

		// Arithmetics.
		match self.op.Id {
		| token::Id.Shl
		| token::Id.Shr:
			panic("sema: binary shifting operator handling failed")
		| token::Id.Plus
		| token::Id.Minus
		| token::Id.Star
		| token::Id.Amper
		| token::Id.Vline
		| token::Id.Caret:
			self.setTypeToGreater()
			ret self.l
		| token::Id.Solidus:
			self.setTypeToGreater()
			ret self.l
		| token::Id.Percent:
			self.mod()
			self.setTypeToGreater()
			ret self.l
		|:
			self.e.pushErr(self.op, build::LogMsg.OperatorNotForInt, self.op.Kind)
			ret nil
		}
	}

	fn evalPrim(mut self): &Value {
		prim := self.l.Type.Prim()
		match {
		| prim.IsBool():
			ret self.evalBool()
		| prim.IsStr():
			ret self.evalStr()
		}

		rp := self.r.Type.Prim()
		if rp == nil {
			self.e.pushErr(self.op, build::LogMsg.IncompatibleTypes, prim.Str(), self.r.Type.Str())
			ret nil
		}

		match {
		| types::IsFloat(prim.Kind):
			ret self.evalFloat()
		| types::IsInt(prim.Kind):
			ret self.evalInt()
		|:
			ret nil
		}
	}

	fn checkSpecialCases(mut self): (ok: bool) {
		ok = true
		comparing := self.op.Id == token::Id.Eqs || self.op.Id == token::Id.NotEq
		if !comparing {
			ret
		}
		if !self.l.Type.Comparable() && !self.r.Type.IsNil() {
			self.e.pushErr(self.op, build::LogMsg.TypeIsNotComparable, self.l.Type.Str())
			ok = false
		} else if !self.r.Type.Comparable() && !self.l.Type.IsNil() {
			self.e.pushErr(self.op, build::LogMsg.TypeIsNotComparable, self.r.Type.Str())
			ok = false
		}
		ret ok
	}

	fn evalOp(mut self): &Value {
		ok := self.checkSpecialCases()
		if !ok {
			ret nil
		}

		// Shift operators.
		if self.op.Id == token::Id.Shl || self.op.Id == token::Id.Shr {
			ret self.shift()
		}

		match {
		| self.l.Type.Void():
			self.e.pushErr(self.op, build::LogMsg.OperatorNotForJuleType, self.op.Kind, "void")
			ret nil
		| self.r.Type.comptimeTypeInfo() != nil:
			self.l, self.r = self.r, self.l
			fall
		| self.l.Type.comptimeTypeInfo() != nil:
			ret self.evalComptimeTypeInfo()
		| self.r.Type.Prim() != nil && self.r.Type.Prim().IsAny():
			self.l, self.r = self.r, self.l
			fall
		| self.r.Type.IsNil():
			self.l, self.r = self.r, self.l
			fall
		| self.l.Type.IsNil():
			ret self.evalNil()
		| self.l.Type.Prim() != nil && self.l.Type.Prim().IsAny():
			ret self.evalAny()
		| self.r.Type.TypeEnum() != nil:
			self.l, self.r = self.r, self.l
			fall
		| self.l.Type.TypeEnum() != nil:
			ret self.evalTypeEnum()
		| self.r.Type.Enum() != nil:
			self.l, self.r = self.r, self.l
			fall
		| self.l.Type.Enum() != nil:
			ret self.evalEnum()
		| self.r.Type.Chan() != nil:
			self.l, self.r = self.r, self.l
			fall
		| self.l.Type.Chan() != nil:
			ret self.evalChan()
		| self.r.Type.Sptr() != nil:
			self.l, self.r = self.r, self.l
			fall
		| self.l.Type.Sptr() != nil:
			ret self.evalSptr()
		| self.r.Type.Ptr() != nil:
			self.l, self.r = self.r, self.l
			fall
		| self.l.Type.Ptr() != nil:
			ret self.evalPtr()
		| self.l.Type.Array() != nil:
			ret self.evalArray()
		| self.r.Type.Trait() != nil:
			self.l, self.r = self.r, self.l
			fall
		| self.l.Type.Trait() != nil:
			ret self.evalTrait()
		| self.l.Type.Prim() != nil:
			ret self.evalPrim()
		| self.l.Type.Struct() != nil:
			ret self.evalStruct()
		|:
			self.e.pushErr(self.op, build::LogMsg.OperatorNotForJuleType, self.op.Kind, self.l.Type.Str())
			ret nil
		}
	}

	fn evalConst(mut self, mut &v: &Value) {
		match {
		| v == nil
		| self.l.Model == nil
		| self.r.Model == nil
		| self.l.Type.comptimeTypeInfo() != nil
		| self.r.Type.comptimeTypeInfo() != nil:
			ret
		| !self.l.IsConst()
		| !self.r.IsConst():
			v.Constant = nil
			v.untyped = false
			ret
		}

		match self.op.Id {
		| token::Id.Eqs:
			v.Constant = constant::Const.NewBool(self.l.Constant.Eq(*self.r.Constant))
		| token::Id.NotEq:
			v.Constant = constant::Const.NewBool(!self.l.Constant.Eq(*self.r.Constant))
		| token::Id.DblVline:
			v.Constant = constant::Const.NewBool(self.l.Constant.Or(*self.r.Constant))
		| token::Id.DblAmper:
			v.Constant = constant::Const.NewBool(self.l.Constant.And(*self.r.Constant))
		| token::Id.Gt:
			v.Constant = constant::Const.NewBool(self.l.Constant.Gt(*self.r.Constant))
		| token::Id.Lt:
			v.Constant = constant::Const.NewBool(self.l.Constant.Lt(*self.r.Constant))
		| token::Id.GtEq:
			v.Constant = constant::Const.NewBool(self.l.Constant.GtEq(*self.r.Constant))
		| token::Id.LtEq:
			v.Constant = constant::Const.NewBool(self.l.Constant.LtEq(*self.r.Constant))
		| token::Id.Plus:
			_ = self.l.Constant.Add(*self.r.Constant)
			v.Constant = self.l.Constant
		| token::Id.Minus:
			_ = self.l.Constant.Sub(*self.r.Constant)
			v.Constant = self.l.Constant
		| token::Id.Star:
			_ = self.l.Constant.Mul(*self.r.Constant)
			v.Constant = self.l.Constant
		| token::Id.Solidus:
			ok := self.l.Constant.Div(*self.r.Constant)
			if !ok && self.r.Constant.AsF64() == 0 {
				self.e.pushErr(self.op, build::LogMsg.DivByZero)
			}
			v.Constant = self.l.Constant
		| token::Id.Percent:
			ok := self.l.Constant.Mod(*self.r.Constant)
			if !ok && self.r.Constant.AsF64() == 0 {
				self.e.pushErr(self.op, build::LogMsg.DivByZero)
			}
			v.Constant = self.l.Constant
		| token::Id.Vline:
			_ = self.l.Constant.BitwiseOr(*self.r.Constant)
			v.Constant = self.l.Constant
		| token::Id.Amper:
			_ = self.l.Constant.BitwiseAnd(*self.r.Constant)
			v.Constant = self.l.Constant
		| token::Id.Caret:
			_ = self.l.Constant.Xor(*self.r.Constant)
			v.Constant = self.l.Constant
		| token::Id.Shl:
			_ = self.l.Constant.Lshift(*self.r.Constant)
			v.Constant = self.l.Constant
		| token::Id.Shr:
			_ = self.l.Constant.Rshift(*self.r.Constant)
			v.Constant = self.l.Constant
		}
		// Value is arbitrary large literal.
		// We have to do extra work.
		if v.Constant.IsInt() {
			// If computation result overflows the bitsize limit, log error,
			// and return nil value.
			i := v.Constant.ReadInt()
			if i.BitLen() > bitLimit {
				self.e.pushErr(self.op, build::LogMsg.ConstantOverflowResult)
				v = nil
				ret
			}
			// If value is not untyped, then cast the result to exact type if possible.
			// As far as tested, it should be work for all types with no issue.
			if !v.untyped && (i.IsI64() || i.IsU64()) {
				kind := v.Type.Prim().Kind
				sz := types::BitSizeOf(kind)
				match {
				| types::IsSigInt(kind):
					match sz {
					| 8:
						if i.Sign() == -1 {
							v.Constant.SetI64(i64(i8(i.I64())))
						} else {
							v.Constant.SetI64(i64(i8(i.U64())))
						}
					| 16:
						if i.Sign() == -1 {
							v.Constant.SetI64(i64(i16(i.I64())))
						} else {
							v.Constant.SetI64(i64(i16(i.U64())))
						}
					| 32:
						if i.Sign() == -1 {
							v.Constant.SetI64(i64(i32(i.I64())))
						} else {
							v.Constant.SetI64(i64(i32(i.U64())))
						}
					| 64:
						if i.Sign() == -1 {
							v.Constant.SetI64(i.I64())
						} else {
							v.Constant.SetI64(i64(i.U64()))
						}
					|:
						panic("sema: unimplemented bitsize for unaryEval.caret, this panic call should be unreachable")
					}
				| types::IsUnsigInt(kind):
					match sz {
					| 8:
						if i.Sign() == -1 {
							v.Constant.SetU64(u64(u8(i.I64())))
						} else {
							v.Constant.SetU64(u64(u8(i.U64())))
						}
					| 16:
						if i.Sign() == -1 {
							v.Constant.SetU64(u64(u16(i.I64())))
						} else {
							v.Constant.SetU64(u64(u16(i.U64())))
						}
					| 32:
						if i.Sign() == -1 {
							v.Constant.SetU64(u64(u32(i.I64())))
						} else {
							v.Constant.SetU64(u64(u32(i.U64())))
						}
					| 64:
						if i.Sign() == -1 {
							v.Constant.SetU64(u64(i.I64()))
						} else {
							v.Constant.SetU64(i.U64())
						}
					|:
						panic("sema: unimplemented bitsize for unaryEval.caret, this panic call should be unreachable")
					}
				|:
					panic("sema: unimplemented constant type for unaryEval.caret, this panic call should be unreachable")
				}
			}
		} else {
			castConstByType(self.e.s, nil, v.Type, v)
		}
		v.Model = v.Constant
		applyCastModelByEnum(self.e.s, v, v.Type.Enum(), self.op, self.e.getOwnerRefers())
	}

	fn checkValue(mut self, mut &v: &Value) {
		f := v.Type.Func()
		if f != nil && f.Decl != nil && f.Decl.IsMethod() {
			self.e.pushErr(self.op, build::LogMsg.InvalidExprForBinary)
		}
	}

	fn checkValues(mut self) {
		self.checkValue(self.l)
		self.checkValue(self.r)
	}

	fn setModel(mut self, mut &v: &Value) {
		if v.IsConst() {
			if self.l.IsConst() && self.r.IsConst() ||
				self.l.Type.comptime() || self.r.Type.comptime() {
				// Left and right are pure constant or comptime expression.
				// Do not break this with changing Model.
				ret
			}
		}

		// See developer reference (7).
		mut l, mut r := self.l, self.r
		if !l.GoodOperand(r) {
			l, r = r, l
		}

		v.Model = &BinaryExpr{
			Left: &OperandExpr{
				Type: l.Type,
				Model: l.Model,
			},
			Right: &OperandExpr{
				Type: r.Type,
				Model: r.Model,
			},
			Op: self.op,
		}
	}

	fn postEval(mut self, mut &v: &Value) {
		v.Lvalue = false
		self.setModel(v)
	}

	fn solveExplicit(mut self, mut &l: &Value, mut &r: &Value): &Value {
		self.l, self.r = l, r

		self.checkValues()

		mut v := self.evalOp()

		// Save normal order
		self.l, self.r = l, r

		self.evalConst(v)

		if v != nil {
			v.Mutable = true
			self.postEval(v)
		}

		ret v
	}

	fn eval(mut self, mut &op: &ast::BinaryExpr): &Value {
		if op.Op.Id == token::Id.Eq {
			self.e.pushErr(op.Op, build::LogMsg.AssignInExpr)
			self.e.pushSuggestion(build::LogMsg.UseImperative)
			ret nil
		}

		mut l := self.e.evalExpr1(op.Left, evalDefault)
		if l == nil || l.Type == nil {
			ret nil
		}

		if !l.untyped {
			mut prefix := self.e.prefix
			self.e.prefix = l.Type
			defer { self.e.prefix = prefix }
		}
		mut r := self.e.evalExpr1(op.Right, evalDefault)
		if r == nil || r.Type == nil {
			ret nil
		}

		self.op = op.Op
		self.lt = op.Left.Token
		self.rt = op.Right.Token

		mut v := self.solveExplicit(l, r)

		// Save rune type.
		if v != nil && l.IsRune && r.IsRune {
			v.IsRune = true
		}

		ret v
	}
}

// Returns directive if exist.
fn findDirective(mut &directives: []&ast::Directive, d: build::Directive): &ast::Directive {
	for (_, mut dr) in directives {
		if dr.Tag.Kind == d {
			ret dr
		}
	}
	ret nil
}

fn findBuiltinsImport(&ident: str, imp: &ImportInfo): any {
	ret findPackageBuiltinDef(imp.LinkPath, ident)
}

fn makeStructLitAlloc(mut &v: &Value, mut &lit: &StructLitExpr) {
	v.Type = &Type{
		Kind: &Sptr{
			Elem: &Type{Kind: lit.Strct},
		},
	}
	v.Model = &AllocStructLitExpr{
		Lit: lit,
	}
}

fn buildErrorVar(mut &s: &Scope, mut &fc: &ast::FuncCallExpr): &Var {
	ret &Var{
		Used: true,
		Reference: false,
		Mutable: true,
		Ident: "error",
		Token: fc.Token,
		TypeSym: findBuiltinTypeAlias(types::Any).TypeSym,
		Scope: s,
		ValueSym: &ValueSym{
			Value: new(Value),
		},
	}
}

fn findBuiltinsSema(&ident: str, mut s: &sema): any {
	// If package is std, check for internal builtin defines.
	mut ppath := s.file.File.Dir()
	if strings::HasPrefix(ppath, build::PathStdlib) {
		// Remove STDLIB directory path.
		ppath = ppath[len(build::PathStdlib):]
		// Add "std" to beginning without separator
		// because path has separator at beginning.
		ppath = "std" + strings::ReplaceAll(ppath, str(filepath::Separator), jule::ImportPathSep)
		ret findPackageBuiltinDef(ppath, ident)
	}

	ret nil
}

fn isOkForShifting(mut &v: &Value): bool {
	if !v.untyped || !v.IsConst() {
		prim := v.Type.Prim()
		ret prim != nil && types::IsInt(prim.Str())
	}
	max := types::MaxU(types::Uint)
	match {
	| v.Constant.IsInt():
		i := v.Constant.ReadInt()
		if i.Sign() == -1 {
			ret false
		}
		if !i.IsU64() {
			ret false
		}
		x := i.U64()
		ret x <= max
	| v.Constant.IsF64():
		f := v.Constant.ReadF64()
		if f < 0 {
			ret false
		}
		i, frac := math::Modf(f)
		if frac != 0 {
			ret false
		}
		ret u64(i) <= max
	}
	ret false
}

fn isInstancedStruct(s: &StructIns): bool {
	ret len(s.Decl.Generics) == len(s.Generics)
}

fn isPtrArithmeticCompatible(mut &l: &Value, mut &r: &Value): bool {
	ptr := r.Type.Ptr()
	if ptr != nil {
		ret l.Type.Ptr().Elem.Equal(ptr.Elem)
	}
	if r.IsConst() && r.untyped {
		ret intAssignable(types::Int, r) ||
			intAssignable(types::Uint, r)
	}

	mut tcc := typeCompatibilityChecker{
		dest: primInt,
		src: r.Type,
	}
	if tcc.check() {
		ret true
	}
	tcc.dest = primUint
	ret tcc.check()
}

fn applyRuntimeToStr(mut &s: &sema, mut &from: &Type, mut &to: &Type,
	mut &token: &token::Token, mut refers: &ReferenceStack) {
	prim := to.Prim()
	if prim != nil && prim.IsAny() || to.TypeEnum() != nil || to.Trait() != nil {
		pushRuntimeToStr(s, from, token, refers)
		ret
	}
}

fn applyRuntimeMaphash(mut &s: &sema, mut &from: &Type, mut &to: &Type,
	mut &token: &token::Token, mut refers: &ReferenceStack) {
	if from.Comparable() {
		prim := to.Prim()
		if prim != nil && prim.IsAny() || to.TypeEnum() != nil || to.Trait() != nil {
			pushRuntimeMaphash(s, from, token, refers)
			ret
		}
	}
}

fn applyImplicitCast(mut &s: &sema, mut &dest: &Type, mut &v: &Value,
	mut &token: &token::Token, mut refers: &ReferenceStack) {
	if v.Type.IsNil() {
		ret
	}
	destPrim := dest.Prim()
	if destPrim != nil && destPrim.IsAny() {
		prim := v.Type.Prim()
		if prim == nil || !prim.IsAny() {
			applyCastKind(s, v, dest, token, refers)
		}
		ret
	}

	dt := dest.Trait()
	if dt != nil {
		bt := v.Type.Trait()
		if bt == nil || bt != dt {
			applyCastKind(s, v, dest, token, refers)
			ret
		}
	}

	if dest.TypeEnum() != nil && (v.Type.SoftStruct() != nil || v.Type.TypeEnum() == nil) {
		applyCastKind(s, v, dest, token, refers)
		ret
	}
}

fn applyCastKindModel(mut &s: &sema, mut &v: &Value, mut &t: &Type,
	mut &token: &token::Token, mut refers: &ReferenceStack) {
	applyRuntimeToStr(s, v.Type, t, token, refers)
	applyRuntimeMaphash(s, v.Type, t, token, refers)

	// Add arrayCmp instance if needed.
	if s.meta.runtime != nil {
		mut arr := v.Type.Array()
		if arr != nil && v.Type.Comparable() {
			// Add instance to relevant runtime function for array element type if not exist.
			mut f := runtimeFindFunc(s.meta.runtime, "arrayCmp").instanceForce()
			f.Generics = append(f.Generics, &InsGeneric{Type: arr.Elem})
			ok, _ := s.checkGenericFunc(f, token)
			if !ok {
				panic("sema: arrayCmp evaluation failed, this is an implementation mistake")
			}
			refers.Push(f)
		}
	}

	v.Model = &CastingExpr{
		Token: token,
		Expr: new(Value, *v),
		Type: t,
	}
}

fn applyCastKind(mut &s: &sema, mut &v: &Value, mut &t: &Type,
	mut &token: &token::Token, mut refers: &ReferenceStack) {
	applyCastKindModel(s, v, t, token, refers)
	v.Type = t
}

fn buildVoidValue(): &Value {
	ret &Value{
		Type: primVoid,
	}
}

fn checkDataForIntegerIndexing(mut &s: &sema, mut &v: &Value,
	mut &token: &token::Token, mut refers: &ReferenceStack): (errFmt: build::LogMsg) {
	if v == nil {
		ret build::LogMsg.Empty
	}

	match {
	| v.Type.Prim() == nil:
		ret build::LogMsg.InvalidTypeForIndexing
	| !types::IsInt(v.Type.Prim().Str()):
		ret build::LogMsg.InvalidTypeForIndexing
	| v.IsConst():
		if v.Constant.AsF64() < 0 {
			ret build::LogMsg.OverflowLimits
		}
	| v.Type.Prim() == nil
	| v.IsConst()
	| types::RealKindOf(v.Type.Prim().Str()) != types::RealKindOf(types::Int):
		applyCastKind(s, v, primInt, token, refers)
	}
	ret build::LogMsg.Empty
}

// Applies casting Model: to data by enum.
// This is necessary to keep exact same type of enum's field type.
// The parameter v should be constant data.
fn applyCastModelByEnum(mut &s: &sema, mut &v: &Value, mut e: &Enum,
	mut &token: &token::Token, mut refers: &ReferenceStack) {
	if e == nil {
		ret
	}
	applyCastKindModel(s, v, e.TypeSym.Type, token, refers)
}

fn castConstByType(mut &s: &sema, token: &token::Token, mut t: &Type, mut &v: &Value): (overflow: bool) {
	mut kind := ""
	if t.Prim() != nil {
		kind = t.Prim().Kind
	} else {
		kind = t.Enum().TypeSym.Type.Prim().Kind
	}
	match {
	| types::IsSigInt(kind):
		if v.untyped && token != nil && !sigAssignable(kind, v) {
			s.pushErr(token, build::LogMsg.ConstantOverflowType, v.Constant.Str(), t.Str())
			ret false
		}
		match types::BitSizeOf(types::RealKindOf(kind)) {
		| 64:
			v.Constant.SetI64(v.Constant.AsI64())
		| 32:
			v.Constant.SetI64(i64(i32(v.Constant.AsI64())))
		| 16:
			v.Constant.SetI64(i64(i16(v.Constant.AsI64())))
		| 8:
			v.Constant.SetI64(i64(i8(v.Constant.AsI64())))
		}
		v.Constant.Kind = kind
	| types::IsUnsigInt(kind):
		if v.untyped && token != nil && !unsigAssignable(kind, v) {
			s.pushErr(token, build::LogMsg.ConstantOverflowType, v.Constant.Str(), t.Str())
			ret false
		}
		match types::BitSizeOf(types::RealKindOf(kind)) {
		| 64:
			v.Constant.SetU64(v.Constant.AsU64())
		| 32:
			v.Constant.SetU64(u64(u32(v.Constant.AsU64())))
		| 16:
			v.Constant.SetU64(u64(u16(v.Constant.AsU64())))
		| 8:
			v.Constant.SetU64(u64(u8(v.Constant.AsU64())))
		}
		v.Constant.Kind = kind
	| types::IsFloat(kind):
		if v.untyped && token != nil && !floatAssignable(kind, v) {
			s.pushErr(token, build::LogMsg.ConstantOverflowType, v.Constant.Str(), t.Str())
			ret false
		}
		match types::BitSizeOf(types::RealKindOf(kind)) {
		| 64:
			v.Constant.SetF64(v.Constant.AsF64())
		| 32:
			v.Constant.SetF64(f64(f32(v.Constant.AsF64())))
		}
		v.Constant.Kind = kind
	}
	ret true
}

fn updateModelToGenericIns(mut &m: Expr, mut &f: &FuncIns) {
	match type m {
	| &FuncIns:
		m = f
	| &StructSubIdentExpr:
		m.(&StructSubIdentExpr).Method = f
	| &StructStaticIdentExpr:
		m.(&StructStaticIdentExpr).Method = f
	}
}

fn evalEnumStatic(mut &s: &sema, mut &enm: &Enum, mut &item: &EnumItem,
	mut &token: &token::Token, mut refers: &ReferenceStack): &Value {
	mut v := &Value{
		Type: &Type{
			Kind: enm,
		},
	}
	if item != nil {
		v.Constant = new(constant::Const, *item.ValueSym.Value.Constant)
		v.Model = v.Constant
		applyCastModelByEnum(s, v, enm, token, refers)
	}
	ret v
}

// Reports whether expression model is literal-based.
// Works for literals, sub-idents and castings.
// Returns nil if not, otherwise returns the literal model.
fn isLitBased(mut &m: Expr): &StructLitExpr {
	match type m {
	| &StructLitExpr:
		ret m.(&StructLitExpr)
	| &AllocStructLitExpr:
		ret m.(&AllocStructLitExpr).Lit
	| &StructSubIdentExpr:
		mut ssi := m.(&StructSubIdentExpr)
		ret isLitBased(ssi.Expr.Model)
	| &CastingExpr:
		mut c := m.(&CastingExpr)
		ret isLitBased(c.Expr.Model)
	|:
		ret nil
	}
}

fn makeImplicitDeref(mut &v: &Value, mut baseToken: &token::Token) {
	mut unary := &UnaryExpr{
		Expr: new(Value, *v),
		Op: new(token::Token, *baseToken),
	}
	unary.Op.Id = token::Id.Star
	unary.Op.Kind = token::Kind.Star
	v.Model = unary
}

// Updates ref's old references to new.
fn updateRefer[T](mut ref: &ReferenceStack, &old: T, mut &new: T) {
	for i, sym in ref.buffer {
		if sym == old {
			ref.buffer[i] = new
		}
	}
}

fn makeVariadic(mut &v: &Value, mut elem: &Type) {
	v.Type = &Type{
		Variadic: true,
		Generic: elem.Generic,
		Kind: elem.Kind,
	}
}

// Reports whether variable is captured from parent scope.
// Parameters:
//	- r: root scope of anonymous function
//	- s: current scope which is v accessed from
//	- v: variable to check
fn isVarCaptured(r: &scopeChecker, mut s: &scopeChecker, v: &Var): bool {
	if v.Scope == nil { // Global scope variable.
		ret false
	}
	for {
		if s.scope == v.Scope {
			ret false
		}
		// Break iteration if parent is not exist or scope already reached to root.
		if s.parent == nil || s == r {
			break
		}
		s = s.parent
	}
	ret true
}

fn findNamespace(mut lookup: Lookup, namespace: str): &ImportInfo {
	ret lookup.SelectPackage(fn(imp: &ImportInfo): bool {
		ret imp.Alias == namespace && !isImplicitImport(imp)
	})
}

// Checks value by flags.
fn checkValue(mut v: &Value, mut s: &sema, mut token: &token::Token, flags: int): (ok: bool) {
	// Catch arbitrary integers with no type, they should be fit in int.
	if flags&evalUnwrapUntyped == evalUnwrapUntyped {
		if v.untyped && v.IsConst() && v.Constant.IsInt() {
			i := v.Constant.ReadInt()
			max := types::MaxI(types::RealKindOf(types::Int))
			min := types::MinI(types::RealKindOf(types::Int))
			if i.IsU64() {
				if u64(max) < i.U64() {
					s.pushErr(token, build::LogMsg.ConstantOverflowType, v.Constant.Str(), primInt.Str())
					ret false
				}
			} else if i.IsI64() {
				x := i.I64()
				if x < min || max < x {
					s.pushErr(token, build::LogMsg.ConstantOverflowType, v.Constant.Str(), primInt.Str())
					ret false
				}
			} else {
				s.pushErr(token, build::LogMsg.ConstantOverflowType, v.Constant.Str(), primInt.Str())
				ret false
			}
		}
	}
	// Catch arbitrary integers with no type.
	// In order for this value to be assigned to memory,
	// we need to make sure that it can fit at least the largest integer type.
	if flags&evalPhysicalMem == evalPhysicalMem {
		if v.IsConst() && v.Constant.IsInt() {
			i := v.Constant.ReadInt()
			if !i.IsI64() && !i.IsU64() {
				s.pushErr(token, build::LogMsg.UntypedNumericForPhysical, i.Str())
				ret false
			}
		}
	}
	ret true
}

fn getUntypedCmpScore(k: str): int {
	if types::IsInt(k) {
		ret 1
	}
	if types::IsFloat(k) {
		ret 2
	}
	if k == types::Str {
		ret 3
	}
	ret -1
}
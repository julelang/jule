// Copyright 2023-2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use conv for std::conv
use path for std::fs::path
use ast for std::jule::ast::{
    Expr,
    LitExpr,
    IdentExpr,
    VariadicExpr,
    UnaryExpr,
    UnsafeExpr,
    SliceExpr,
    ExprData,
    FnDecl,
    BinopExpr,
    BraceLit,
    TupleExpr,
    SubIdentExpr,
    IndexingExpr,
    NsSelectionExpr,
    TypeDecl,
    FnCallExpr,
    SlicingExpr,
    CastExpr,
    StructLit,
    KeyValPair,
    IdentTypeDecl,
    NamespaceTypeDecl,
    SubIdentTypeDecl,
    RangeExpr,
    TypeDeclKind,
}
use build for std::jule::build::{
    LogMsg,
    Directive,
    PathStdlib,
    Logf,
}
use std::jule::constant::{Const}
use lit for std::jule::constant::lit
use lex for std::jule::lex::{
    self,
    Token,
    TokenId,
    TokenKind,
    IsStr,
    IsBool,
    IsRune,
    IsRawStr,
    IsIgnoreIdent,
}
use types for std::jule::types
use strings for std::strings

// Value data.
pub struct Data {
    pub Kind:      &TypeKind
    pub Mutable:   bool
    pub Reference: bool
    pub Lvalue:    bool
    pub IsRune:    bool
    pub Model:     ExprModel

    // True if kind is declaration such as:
    //  - &Enum
    //  - &Struct
    //  - int type
    //  - bool type
    pub Decl: bool

    // Constant expression data.
    pub Constant: &Const
}

impl Data {
    // Reports whether Data is nil literal.
    pub fn IsNil(self): bool {
        ret self.Kind.IsNil()
    }

    // Reports whether Data is void.
    pub fn IsVoid(self): bool {
        ret self.Kind.Void()
    }

    // Reports whether Data is constant expression.
    pub fn IsConst(self): bool {
        ret self.Constant != nil
    }

    // Reports left and right operand is good order.
    // If reports false, left and right operand should be swapped.
    // Accepts itself as left operand.
    pub fn GoodOperand(self, mut &other: &Data): bool {
        if other.Kind.TypeEnum() != nil {
            ret false
        }
        ret (other.Kind.Prim() == nil || !other.Kind.Prim().IsAny()) &&
            other.Kind.Trait() == nil &&
            !self.Kind.IsNil()
    }
}

// Value.
pub struct Value {
    pub Expr: &Expr
    pub Data: &Data
}

// Evaluator.
struct Eval {
    s:          &Sema     // Used for error logging.
    lookup:     Lookup
    prefix:     &TypeKind
    unsafety:   bool
    immutable:  bool      // This expression will assigned to immutable memory.
    ignored:    bool      // Evaluated expression is not for assignment or something else.
    disBuiltin: bool      // Disallow/suppress Jule's built-in defines.
    owner:      &Var
    field:      &FieldIns // Field of this default expression. Used for checking cycles.
    arg:        bool      // This expression evaluating for argument.
}

impl Eval {
    fn pushErr(mut self, token: &Token, fmt: LogMsg, args: ...any) {
        self.s.pushErr(token, fmt, args...)
    }

    // Push suggestion to last log.
    fn pushSugggestion(mut self, fmt: LogMsg, args: ...any) {
        self.s.pushSugggestion(fmt, args...)
    }

    fn allowBuiltin(mut self) {
        self.disBuiltin = false
    }

    fn disallowBuiltin(mut self) {
        self.disBuiltin = true
    }

    // Reports whether evaluation in unsafe scope.
    fn isUnsafe(self): bool {
        ret self.unsafety
    }

    // Reports whether evaluated expression is in global scope.
    fn isGlobal(self): bool {
        match type self.lookup {
        | &Sema:
            ret true
        |:
            ret false
        }
    }

    fn applyNumericPrefix(mut self, mut &d: &Data): bool {
        if d == nil ||
            !d.IsConst() ||
            d.Kind.Prim() == nil ||
            self.prefix == nil {
            ret false
        }
        let prim = self.prefix.Prim()
        if prim == nil {
            ret false
        }

        match {
        | types::IsFloat(prim.Str()):
            d.Kind = new(TypeKind, *self.prefix)
            d.Constant.SetF64(d.Constant.AsF64())
        | types::IsSigInt(prim.Str()):
            if !sigAssignable(prim.Str(), d) {
                ret false
            }
            d.Kind = new(TypeKind, *self.prefix)
            d.Constant.SetI64(d.Constant.AsI64())
        | types::IsUnsigInt(prim.Str()):
            if !unsigAssignable(prim.Str(), d) {
                ret false
            }
            d.Kind = new(TypeKind, *self.prefix)
            d.Constant.SetU64(d.Constant.AsU64())
        }
        ret true
    }

    fn litNil(self): &Data {
        // Return new Data with nil kind.
        // Nil kind represents "nil" literal.

        let mut constant = Const.NewNil()
        ret &Data{
            Constant: constant,
            Kind: &TypeKind{Kind: nil},
            Model: constant,
        }
    }

    fn litStr(self, &l: &LitExpr): &Data {
        let mut s = l.Value[1:l.Value.len-1] // Remove quotes.
        if IsRawStr(l.Value) {
            s = lit::ToRawStr([]byte(s))
        } else {
            s = lit::ToStr([]byte(s))
        }
        let mut constant = Const.NewStr(s)

        ret &Data{
            Constant: constant,
            Kind: &TypeKind{
                Kind: buildPrimType(PrimKind.Str),
            },
            Model: constant,
        }
    }

    fn litBool(self, &l: &LitExpr): &Data {
        let mut constant = Const.NewBool(l.Value == TokenKind.True)
        ret &Data{
            Constant: constant,
            Kind: &TypeKind{
                Kind: buildPrimType(PrimKind.Bool),
            },
            Model: constant,
        }
    }

    fn litRune(self, &l: &LitExpr): &Data {
        const BYTE_KIND: str = PrimKind.U8
        const RUNE_KIND: str = PrimKind.I32

        // Remove quotes.
        let lt = l.Value[1:l.Value.len-1]
        let r = lit::ToRune([]byte(lt))
        let mut data = &Data{
            Constant: Const.NewI64(i64(r)),
        }

        let isAscii = lit::IsAscii(r)
        if isAscii {
            data.Kind = &TypeKind{
                Kind: buildPrimType(BYTE_KIND),
            }
        } else {
            data.Kind = &TypeKind{
                Kind: buildPrimType(RUNE_KIND),
            }
        }

        data.Model = &RuneExprModel{Code: r}
        data.IsRune = true
        ret data
    }

    fn litFloat(self, &l: &LitExpr): &Data {
        const FloatKind: str = PrimKind.F64

        let f = conv::ParseFloat(l.Value, 64) else { use f64.MAX }
        let mut constant = Const.NewF64(f)

        ret &Data{
            Constant: constant,
            Kind: &TypeKind{
                Kind: buildPrimType(FloatKind),
            },
            Model: constant,
        }
    }

    fn litInt(mut self, &l: &LitExpr): &Data {
        const BitSize = 1 << 6

        let mut lit = l.Value
        let mut base = 0

        match {
        | strings::HasPrefix(lit, "0x"): // Hexadecimal
            lit = lit[2:]
            base = 1 << 4
        | strings::HasPrefix(lit, "0b"): // Binary
            lit = lit[2:]
            base = 1 << 1
        | strings::HasPrefix(lit, "0o"): // Ocatal
            lit = lit[2:]
            base = 1 << 3
        | lit[0] == '0' && lit.len > 1: // Octal
            lit = lit[1:]
            base = 1 << 3
        |:
            // Decimal
            base = 1 << 3 + 2
        }

        let mut d = new(Data)

        let mut ok = true
        let sig = conv::ParseInt(lit, base, BitSize) else {
            ok = false
            use 0
        }
        if ok {
            d.Constant = Const.NewI64(sig)
            d.Kind = &TypeKind{
                Kind: buildPrimType(PrimKind.Int),
            }
        } else {
            let unsig = conv::ParseUint(lit, base, BitSize) else {
                self.pushErr(l.Token, LogMsg.InvalidNumericRange)
                self.pushSugggestion(LogMsg.TryFloatingPoint)
                use u64.MAX
            }
            d.Constant = Const.NewU64(unsig)
            d.Kind = &TypeKind{
                Kind: buildPrimType(PrimKind.Uint),
            }
        }

        d.Model = d.Constant
        if !self.applyNumericPrefix(d) {
            // If prefix is not implemented, check constant bitsize.
            // Arcihtecture bitsize type might be insufficient to store constant data.
            // If this concern is true, set kind to minimum type that has enough bitsize.
            fitBitsize(d)
        }
        ret d
    }

    fn litNum(mut self, &l: &LitExpr): &Data {
        match {
        | lex::IsFloat(l.Value):
            ret self.litFloat(l)
        |:
            ret self.litInt(l)
        }
    }

    fn evalLit(mut self, lit: &LitExpr): &Data {
        match {
        | lit.IsNil():
            ret self.litNil()
        | IsStr(lit.Value):
            ret self.litStr(lit)
        | IsBool(lit.Value):
            ret self.litBool(lit)
        | IsRune(lit.Value):
            ret self.litRune(lit)
        | lex::IsNum(lit.Value):
            ret self.litNum(lit)
        |:
            ret nil
        }
    }

    fn findBuiltins(mut self, ident: str): any {
        match type self.lookup {
        | &ImportInfo:
            let mut def = findBuiltinsImport(ident, (&ImportInfo)(self.lookup))
            if def != nil {
                ret def
            }
        | &Sema:
            let mut def = findBuiltinsSema(ident, (&Sema)(self.lookup))
            if def != nil {
                ret def
            }
        | &scopeChecker:
            let mut def = findBuiltinsSema(ident, (&scopeChecker)(self.lookup).s)
            if def != nil {
                ret def
            }
        }
        if self.disBuiltin {
            ret nil
        }
        ret findBuiltinDef(ident)
    }

    fn getDef(mut self, ident: str, cppLinked: bool): any {
        if !cppLinked {
            let mut enm = self.lookup.FindEnum(ident)
            if enm != nil {
                ret enm
            }

            let mut tenm = self.lookup.FindTypeEnum(ident)
            if tenm != nil {
                ret tenm
            }
        }

        let mut v = self.lookup.FindVar(ident, cppLinked)
        if v != nil {
            ret v
        }

        let mut f = self.lookup.FindFn(ident, cppLinked)
        if f != nil {
            ret f
        }

        let mut s = self.lookup.FindStruct(ident, cppLinked)
        if s != nil {
            ret s
        }

        let mut ta = self.lookup.FindTypeAlias(ident, cppLinked)
        if ta != nil {
            ret ta
        }

        ret self.findBuiltins(ident)
    }

    fn pushReference[T](mut self, mut &ref: T) {
        match type self.lookup {
        | &scopeChecker:
            let mut sc = (&scopeChecker)(self.lookup).getHardRoot()
            if !sc.owner.Refers.Exist[T](ref) {
                sc.owner.Refers.Push(ref)
            }
        |:
            if self.owner != nil && !self.owner.Refers.Exist[T](ref) {
                self.owner.Refers.Push(ref)
            }
        }
    }

    fn _evalEnum(self, mut enm: &Enum): &Data {
        ret &Data{
            Decl: true,
            Kind: &TypeKind{
                Kind: enm,
            },
        }
    }

    fn evalEnum(mut self, mut enm: &Enum, errorToken: &Token): &Data {
        if !self.s.isAccessibleDefine(enm.Public, enm.Token) {
            self.pushErr(errorToken, LogMsg.IdentIsNotAccessible, enm.Ident)
            self.pushSugggestion(LogMsg.MakePubToAccess)
            ret nil
        }
        ret self._evalEnum(enm)
    }

    fn _evalTypeEnum(self, mut enm: &TypeEnum): &Data {
        ret &Data{
            Decl: true,
            Kind: &TypeKind{
                Kind: enm,
            },
        }
    }

    fn evalTypeEnum(mut self, mut enm: &TypeEnum, errorToken: &Token): &Data {
        if !self.s.isAccessibleDefine(enm.Public, enm.Token) {
            self.pushErr(errorToken, LogMsg.IdentIsNotAccessible, enm.Ident)
            self.pushSugggestion(LogMsg.MakePubToAccess)
            ret nil
        }
        ret self._evalTypeEnum(enm)
    }

    fn _evalStruct(self, mut s: &StructIns): &Data {
        ret &Data{
            Decl: true,
            Kind: &TypeKind{
                Kind: s,
            },
            Model: s,
        }
    }

    fn evalStruct(mut self, mut s: &StructIns, errorToken: &Token): &Data {
        if !self.s.isAccessibleDefine(s.Decl.Public, s.Decl.Token) {
            self.pushErr(errorToken, LogMsg.IdentIsNotAccessible, s.Decl.Ident)
            self.pushSugggestion(LogMsg.MakePubToAccess)
            ret nil
        }
        self.checkDeprecated(s.Decl.Directives, errorToken)
        ret self._evalStruct(s)
    }

    fn evalFnIns(self, mut f: &FnIns): &Data {
        ret &Data{
            Kind: &TypeKind{
                Kind: f,
            },
            Model: f,
        }
    }

    fn checkDeprecated(mut self, mut &directives: []&ast::Directive, tok: &Token) {
        if self.isUnsafe() {
            ret
        }

        let d = findDirective(directives, Directive.Deprecated)
        if d != nil {
            if d.Args.len == 0 {
                self.pushErr(tok, LogMsg.UsingDeprecated, "this code is deprecated")
            } else {
                self.pushErr(tok, LogMsg.UsingDeprecated, d.Args[0].Kind)
            }
            self.pushSugggestion(LogMsg.UseUnsafeForDeprecated)
        }
    }

    fn evalFn(mut self, mut f: &Fn, errorToken: &Token): &Data {
        if !self.s.isAccessibleDefine(f.Public, f.Token) {
            self.pushErr(errorToken, LogMsg.IdentIsNotAccessible, f.Ident)
            self.pushSugggestion(LogMsg.MakePubToAccess)
            ret nil
        }

        self.checkDeprecated(f.Directives, errorToken)

        let mut ins = f.instance()
        self.pushReference[&FnIns](ins)
        ret self.evalFnIns(ins)
    }

    fn pushIllegalCycleError(mut self, &v1: &Var, &v2: &Var, mut &message: str) {
        const Padding = 4
        let refers_to = Logf(LogMsg.RefersTo, v1.Ident, v2.Ident)
        message = strings::Repeat(" ", Padding) + refers_to + "\n" + message
    }

    fn checkCrossCycle(mut self, &v: &Var, mut &message: str): bool {
        for _, d in v.Depends {
            if d == self.owner {
                self.pushIllegalCycleError(v, d, message)
                ret false
            }

            if !self.checkCrossCycle(d, message) {
                self.pushIllegalCycleError(v, d, message)
                ret false
            }
        }

        ret true
    }

    // Checks owner illegal cycles.
    // Appends depend to depends if there is no illegal cycle.
    // Returns true if e.owner is nil.
    fn checkIllegalCycles(mut self, mut &v: &Var, decl_token: &Token): (ok: bool) {
        if self.owner == nil {
            ret true
        }

        // Check illegal cycle for itself.
        // Because refers's owner is ta.
        if self.owner == v {
            self.pushErr(self.owner.Token, LogMsg.IllegalCycleRefersItself, self.owner.Ident)
            ret false
        }

        let mut message = ""

        if !self.checkCrossCycle(v, message) {
            let mut errMsg = message
            message = ""
            self.pushIllegalCycleError(self.owner, v, message)
            errMsg = errMsg + message
            self.pushErr(decl_token, LogMsg.IllegalCrossCycle, errMsg)
            ret false
        }

        self.owner.Depends = append(self.owner.Depends, v)
        ret true
    }

    fn evalVar(mut self, mut v: &Var, errorToken: &Token): &Data {
        if !self.s.isAccessibleDefine(v.Public, v.Token) {
            self.pushErr(errorToken, LogMsg.IdentIsNotAccessible, v.Ident)
            self.pushSugggestion(LogMsg.MakePubToAccess)
            ret nil
        }

        self.checkDeprecated(v.Directives, errorToken)

        v.Used = true

        match type self.lookup {
        | &Sema:
            // Check cycles for global scope.
            let ok = self.checkIllegalCycles(v, errorToken)
            if !ok {
                ret nil
            }
        | &scopeChecker:
            if !v.Reference || self.isUnsafe() {
                break
            }
            let mut s = (&scopeChecker)(self.lookup)
            for s.owner == nil && s.parent != nil {
                s = s.parent
            }
            if s.owner != nil && s.owner.Anon && v.Scope != s.owner.Scope {
                self.pushErr(errorToken, LogMsg.UsedRefInAnonFnFromParentScope, v.Ident)
            }
        }

        // Push reference to global variable.
        if v.Scope == nil {
            self.pushReference[&Var](v)
        }

        if !v.CppLinked && (v.Value == nil || v.Value.Data == nil) {
            if v.Constant {
                // Eval constant dependent variable.
                self.s.checkTypeVar(v, self.s)
                if v.Value.Data == nil {
                    // Skip error.
                    ret nil
                }
            }
        }

        // Kind is nil, no determined.
        // In other word, not analyzed yet.
        // But this variable is dependency, therefore check this for eval.
        if v.Kind == nil || v.Kind.Kind == nil {
            // Just necessary for global scope, therefore
            // execute if only scope is nil aka variable is not in global scope.
            if v.Scope != nil {
                ret nil
            }

            self.s.checkTypeVar(v, self.lookup)

            // Ignore eval, because analyze is failed.
            if v.Kind == nil || v.Kind.Kind == nil {
                ret nil
            }
        }

        let mut d = &Data{
            Lvalue: !v.Constant,
            Mutable: v.Mutable,
            Reference: v.Reference,
            Kind: v.Kind.Kind,
            Model: v,
        }

        if !v.CppLinked && v.IsInitialized() && v.Value.Data != nil {
            d.IsRune = v.Value.Data.IsRune
        }

        if v.Constant && v.Value.Data.Constant != nil {
            d.Constant = new(Const, *v.Value.Data.Constant)
            d.Model = d.Constant
        }

        if d.IsConst() {
            self.applyNumericPrefix(d)
        }

        ret d
    }

    fn evalTypeAlias(mut self, mut ta: &TypeAlias, errorToken: &Token): &Data {
        if !self.s.isAccessibleDefine(ta.Public, ta.Token) {
            self.pushErr(errorToken, LogMsg.IdentIsNotAccessible, ta.Ident)
            self.pushSugggestion(LogMsg.MakePubToAccess)
            ret nil
        }

        ta.Used = true

        let mut kind = ta.Kind.Kind.Kind
        let mut d: &Data = nil
        match type kind {
        | &StructIns:
            d = self._evalStruct((&StructIns)(kind))
        | &Enum:
            d = self._evalEnum((&Enum)(kind))
        | &TypeEnum:
            d = self._evalTypeEnum((&TypeEnum)(kind))
        |:
            d = &Data{
                Decl: true,
                Kind: &TypeKind{
                    Kind: ta.Kind.Kind.Kind,
                },
            }
            if ta.CppLinked {
                d.Kind.CppIdent = ta.Ident
            } else {
                d.Kind.CppIdent = ta.Kind.Kind.CppIdent
            }
            d.Model = d.Kind
        }
        d.Kind.Generic = ta.Generic
        ret d
    }

    fn evalDef(mut self, mut def: any, ident: &Token): &Data {
        match type def {
        | &Var:
            ret self.evalVar((&Var)(def), ident)
        | &Enum:
            ret self.evalEnum((&Enum)(def), ident)
        | &TypeEnum:
            ret self.evalTypeEnum((&TypeEnum)(def), ident)
        | &Struct:
            ret self.evalStruct((&Struct)(def).instance(), ident)
        | &Fn:
            let mut f = (&Fn)(def)
            if f.Ident != build::InitFn {
                ret self.evalFn(f, ident)
            }
        | &FnIns:
            ret self.evalFnIns((&FnIns)(def))
        | &TypeAlias:
            ret self.evalTypeAlias((&TypeAlias)(def), ident)
        }
        self.pushErr(ident, LogMsg.IdentNotExist, ident.Kind)
        ret nil
    }

    fn evalIdent(mut self, ident: &IdentExpr): &Data {
        let mut def = self.getDef(ident.Ident, ident.CppLinked)
        ret self.evalDef(def, ident.Token)
    }

    fn evalUnary(mut &self, mut u: &UnaryExpr): &Data {
        let mut unary = unaryEval.new(self)
        ret unary.eval(u)
    }

    fn evalVariadic(mut &self, mut v: &VariadicExpr): &Data {
        if v.Expr == nil {
            self.pushErr(v.Token, LogMsg.InvalidExpr)
            ret nil
        }

        let mut prefix = self.prefix
        self.prefix = nil
        defer { self.prefix = prefix }

        let mut d = self.evalExprKind(v.Expr.Kind)
        if d == nil {
            ret nil
        }

        if !d.Kind.Variadicable() {
            self.pushErr(v.Token, LogMsg.VariadicWithNonVariadicable, d.Kind.Str())
            ret nil
        }

        let slc = d.Kind.Slc()
        d.Kind = &TypeKind{
            Variadic: true,
            Generic: slc.Elem.Generic,
            CppIdent: slc.Elem.CppIdent,
            Kind: slc.Elem.Kind,
        }
        ret d
    }

    fn evalUnsafe(mut &self, mut u: &UnsafeExpr): &Data {
        let unsafety = self.unsafety
        self.unsafety = true
        let mut d = self.evalExprKind(u.Expr.Kind)
        self.unsafety = unsafety
        ret d
    }

    fn evalArr(mut &self, mut s: &SliceExpr): &Data {
        // Arrays always has type prefixes.
        let mut pt = self.prefix.Arr()

        let mut arr = &Arr{
            Auto: false,
            N: 0,
            Elem: pt.Elem,
        }

        let mut filled = false

        if s.Exprs.len == 2 {
            match type s.Exprs[1].Kind {
            | &VariadicExpr:
                if (&VariadicExpr)(s.Exprs[1].Kind).Expr != nil {
                    break
                }
                // Filled.

                if pt.Auto {
                    self.pushErr(s.Token, LogMsg.AutoSizedArrFilled)
                    ret nil
                }

                filled = true
                s.Exprs = s.Exprs[:1]
            }
        }

        arr.N = s.Exprs.len
        if !pt.Auto {
            if arr.N > pt.N {
                self.pushErr(s.Token, LogMsg.OverflowLimits)
            } else if arr.N < pt.N {
                arr.N = pt.N
            }
        }

        let mut model = &ArrayExprModel{
            Kind: arr,
        }
        if filled {
            model.Elems = make([]ExprModel, 0, 2)
        } else {
            model.Elems = make([]ExprModel, 0, s.Exprs.len)
        }

        let mut prefix = self.prefix
        self.prefix = arr.Elem
        for (_, mut elem) in s.Exprs {
            let mut d = self.evalExprKind(elem.Kind)
            if d == nil {
                continue
            }

            _ = self.s.checkAssignType(false, arr.Elem, d, s.Token)
            model.Elems = append(model.Elems, d.Model)
        }
        self.prefix = prefix

        if filled {
            // Fill mark.
            model.Elems = append(model.Elems, nil)
        }

        ret &Data{
            Mutable: true,
            Kind: &TypeKind{
                Kind: arr,
            },
            Model: model,
        }
    }

    fn evalExpSlc(mut &self, mut s: &SliceExpr, mut t: &TypeKind, mut first: ExprModel): &Data {
        let mut slc = &Slc{
            Elem: t,
        }

        let mut model = &SliceExprModel{
            ElemKind: t,
            Elems: make([]ExprModel, 0, s.Exprs.len),
        }
        if first != nil {
            model.Elems = append(model.Elems, first)
            s.Exprs = s.Exprs[1:]
        }

        let mut prefix = self.prefix
        self.prefix = slc.Elem
        for (_, mut elem) in s.Exprs {
            let mut d = self.evalExprKind(elem.Kind)
            if d == nil {
                continue
            }
            _ = self.s.checkAssignType(false, slc.Elem, d, s.Token)
            model.Elems = append(model.Elems, d.Model)
        }
        self.prefix = prefix

        ret &Data{
            Mutable: true,
            Kind: &TypeKind{
                Kind: slc,
            },
            Model: model,
        }
    }

    fn evalSliceExpr(mut &self, mut s: &SliceExpr): &Data {
        if self.prefix != nil {
            match {
            | self.prefix.Arr() != nil:
                ret self.evalArr(s)
            | self.prefix.Slc() != nil:
                let mut pt = self.prefix.Slc()
                ret self.evalExpSlc(s, pt.Elem, nil)
            }
        }

        let mut prefix = self.prefix
        self.prefix = nil

        if s.Exprs.len == 0 {
            self.pushErr(s.Token, LogMsg.DynamicTypeAnnotationFailed)
            ret nil
        }

        let mut first_elem = self.evalExprKind(s.Exprs[0].Kind)
        if first_elem == nil {
            ret nil
        }

        let mut d = self.evalExpSlc(s, first_elem.Kind, first_elem.Model)

        self.prefix = prefix
        ret d
    }

    fn checkIntegerIndexingByData(mut self, mut &d: &Data, token: &Token) {
        let err_key = checkDataForIntegerIndexing(d)
        match err_key {
        | LogMsg.Empty:
            ret
        | LogMsg.InvalidTypeForIndexing:
            self.pushErr(token, err_key, d.Kind.Str())
        |:
            self.pushErr(token, err_key)
        }
    }

    fn indexingPtr(mut self, mut &d: &Data, mut &index: &Data, &i: &IndexingExpr) {
        self.checkIntegerIndexingByData(index, i.Token)

        let mut ptr = d.Kind.Ptr()
        match {
        | ptr.IsUnsafe():
            self.pushErr(i.Token, LogMsg.UnsafePtrIndexing)
            ret
        | !self.isUnsafe():
            self.pushErr(i.Token, LogMsg.UnsafeBehaviorAtOutOfUnsafeScope)
        }

        d.Kind = ptr.Elem
    }

    fn indexingArr(mut self, mut &d: &Data, mut &index: &Data, &i: &IndexingExpr) {
        let mut arr = d.Kind.Arr()
        d.Kind = arr.Elem
        self.checkIntegerIndexingByData(index, i.Token)
        if index.IsConst() && index.Constant.AsF64() >= f64(arr.N) {
            self.pushErr(i.Token, LogMsg.OverflowLimits)
        }
    }

    fn indexingSlc(mut self, mut &d: &Data, mut &index: &Data, &i: &IndexingExpr) {
        let mut slc = d.Kind.Slc()
        d.Kind = slc.Elem
        self.checkIntegerIndexingByData(index, i.Token)

        // Check compile-time bounds.
        if !index.IsConst() {
            ret
        }
        match type d.Model {
        | &SliceExprModel:
            let mut m = (&SliceExprModel)(d.Model)
            let indx = index.Constant.AsF64()
            if indx >= f64(m.Elems.len) {
                self.pushErr(i.Token, LogMsg.OverflowLimits)
            } else {
                d.Model = m.Elems[u64(indx)]
                d.Decl = true // Set Model: flag.
            }
        }
    }

    fn indexingMap(mut self, mut &d: &Data, mut &index: &Data, mut &i: &IndexingExpr) {
        if index == nil {
            ret
        }
        let mut m = d.Kind.Map()
        let mut atc = assignTypeChecker{
            s: self.s,
            dest: m.Key,
            d: index,
            errorToken: i.Token,
        }
        _ = atc.check()
        d.Kind = m.Val
    }

    fn indexingStr(mut self, mut &d: &Data, mut &index: &Data, &i: &IndexingExpr) {
        const ByteKind: str = PrimKind.U8
        d.Kind = &TypeKind{Kind: buildPrimType(ByteKind)}

        if index == nil {
            ret
        }

        self.checkIntegerIndexingByData(index, i.Token)

        if !index.IsConst() {
            d.Constant = nil
            ret
        }

        if d.IsConst() {
            let errorToken = i.Token
            let j = index.Constant.AsI64()
            let s = d.Constant.ReadStr()
            if int(j) >= s.len {
                self.pushErr(errorToken, LogMsg.OverflowLimits)
            } else {
                d.Constant.SetU64(u64(s[j]))
            }
        }
    }

    fn toIndexing(mut self, mut &d: &Data, mut &index: &Data, mut &i: &IndexingExpr) {
        match {
        | d.Kind.Ptr() != nil:
            self.indexingPtr(d, index, i)
            ret
        | d.Kind.Arr() != nil:
            self.indexingArr(d, index, i)
            ret
        | d.Kind.Slc() != nil:
            self.indexingSlc(d, index, i)
            ret
        | d.Kind.Map() != nil:
            self.indexingMap(d, index, i)
            ret
        | d.Kind.Prim() != nil:
            let prim = d.Kind.Prim()
            match {
            | prim.IsStr():
                self.indexingStr(d, index, i)
                ret
            }
        }
        self.pushErr(i.Token, LogMsg.NotSupportsIndexing, d.Kind.Str())
    }

    fn pushGenericsFromExprSubIdent(mut &self, mut &sexpr: &SubIdentExpr,
        mut &generics: []&TypeDecl, mut &expr: &Expr): bool {
        let mut t = new(SubIdentTypeDecl)
        if !pushSubIdentFromExpr(sexpr, t) {
            self.pushErr(expr.Token, LogMsg.InvalidSyntax)
            ret false
        }
        generics = append(generics, &TypeDecl{Kind: t})
        ret true
    }

    fn pushGenericsFromData(mut &self, mut &generics: []&TypeDecl, mut &expr: &Expr): bool {
        match type expr.Kind {
        | &UnaryExpr:
            // Unary eval catches type declarations.
            // Therefore use unary eval algorithm for eval related type declarations.
            let mut d = self.evalUnary((&UnaryExpr)(expr.Kind))
            if !d.Decl {
                self.pushErr(expr.Token, LogMsg.InvalidSyntax)
                ret false
            }
            generics = append(generics, &TypeDecl{
                Token: expr.Token,
                Kind: unsafe { *(*TypeDeclKind)(&d.Kind.Kind) },
            })
        | &TypeDecl:
            generics = append(generics, (&TypeDecl)(expr.Kind))
        | &SubIdentExpr:
            let mut sexpr = (&SubIdentExpr)(expr.Kind)
            ret self.pushGenericsFromExprSubIdent(sexpr, generics, expr)
        | &IdentExpr:
            let mut ident = (&IdentExpr)(expr.Kind)
            generics = append(generics, &TypeDecl{
                Kind: &IdentTypeDecl{
                    CppLinked: ident.CppLinked,
                    Token: ident.Token,
                    Ident: ident.Ident,
                },
            })
        | &TupleExpr:
            for (_, mut texpr) in (&TupleExpr)(expr.Kind).Expr {
                if !self.pushGenericsFromData(generics, texpr) {
                    ret false
                }
            }
        | &NsSelectionExpr:
            let mut ns = (&NsSelectionExpr)(expr.Kind)
            let mut decl = &IdentTypeDecl{
                Token: ns.Ident,
                Ident: ns.Ident.Kind,
            }
            generics = append(generics, &TypeDecl{
                Token: decl.Token,
                Kind: &NamespaceTypeDecl{
                    Idents: ns.Ns,
                    Kind: &TypeDecl{
                        Token: decl.Token,
                        Kind: decl,
                    },
                }
            })
        |:
            self.pushErr(expr.Token, LogMsg.InvalidSyntax)
            ret false
        }
        ret true
    }

    fn evalIdentDeclFromIndexing(mut &self, mut &i: &IndexingExpr): &Data {
        let mut tdecl = new(TypeDecl)
        let mut decl: &IdentTypeDecl = nil
        match type i.Expr.Kind {
        | &IdentExpr:
            let mut expr = (&IdentExpr)(i.Expr.Kind)
            decl = &IdentTypeDecl{
                CppLinked: expr.CppLinked,
                Token: expr.Token,
                Ident: expr.Ident,
            }
            tdecl.Kind = decl
        | &NsSelectionExpr:
            let mut expr = (&NsSelectionExpr)(i.Expr.Kind)
            decl = &IdentTypeDecl{
                Token: expr.Ident,
                Ident: expr.Ident.Kind,
            }
            tdecl.Kind = &NamespaceTypeDecl{
                Idents: expr.Ns,
                Kind: &TypeDecl{
                    Token: decl.Token,
                    Kind: decl,
                },
            }
        |:
            self.pushErr(i.Token, LogMsg.InvalidSyntax)
            ret nil
        }
        if !self.pushGenericsFromData(decl.Generics, i.Index) {
            ret nil
        }
        ret self.evalType(tdecl)
    }

    // Checks new generics function instance.
    // If instance is already exist, f will point to exist instantantiation.
    fn checkGenericFn(mut &self, mut &f: &FnIns, mut &et: &Token, mut &model: ExprModel): bool {
        let ok = self.s.reloadFnInsTypes(f)
        f.reloaded = true
        if !ok {
            ret false
        }
        let mut existInstance = f.Decl.appendInstance(f)
        // TODO: [check] is possible to optimize here using same environment with reaload_fn_ins_types?
        if !self.s.checkConstraintsFn(f, et, existInstance) {
            ret false
        }
        if existInstance != nil {
            f = existInstance
            // Update Model: by exist function instance.
            // Because generic functions returns always new instance.
            // So, if this absolute instance is already exist, update Model:.
            // In other words, Model:'s instance will be a dangling instance.
            updateModelToGenericIns(model, existInstance)
        } else {
            // Check generic function instance instantly.
            self.s.checkFnInsCaller(f, et)
        }
        ret true
    }

    fn evalFnGenericFromIndexing(mut &self, mut &d: &Data, mut &i: &IndexingExpr) {
        let mut generics = make([]&TypeDecl, 0, 1 << 3)
        if !self.pushGenericsFromData(generics, i.Index) {
            d = nil
            ret
        }

        let mut f = d.Kind.Fn()
        let mut genericsLen = 0
        if f.Decl != nil {
            genericsLen = f.Decl.Generics.len
        }
        if !self.s.checkGenericQuantity(genericsLen, generics.len, i.Expr.Token) {
            d = nil
            ret
        }

        // Build real kinds of generic types.
        f.Generics = make([]&InsGeneric, 0, f.Decl.Generics.len)
        for (_, mut g) in generics {
            let mut k = self.evalType(g)
            if k == nil {
                d = nil
                ret
            }
            f.Generics = append(f.Generics, &InsGeneric{Kind: k.Kind})
        }

        if f.IsBuiltin() {
            ret
        }

        if self.checkGenericFn(f, i.Expr.Token, d.Model) {
            d.Kind.Kind = f
        } else {
            d = nil
        }
    }

    fn evalIndexing(mut &self, mut i: &IndexingExpr): &Data {
        let mut prefix = self.prefix
        self.prefix = nil
        defer { self.prefix = prefix }

        let mut d = self.evalExprKind(i.Expr.Kind)
        if d == nil {
            ret nil
        }

        // Catch types.
        if d.Decl {
            ret self.evalIdentDeclFromIndexing(i)
        }

        if d.Kind.Fn() != nil {
            self.evalFnGenericFromIndexing(d, i)
            ret d
        }

        let mut old_d = *d

        let mut index = self.evalExprKind(i.Index.Kind)
        if index == nil {
            ret nil
        }

        // Set decl to true. It's a kind of flag.
        // If decl is true after indexing eval, do not touch Model:.
        // Setted by indexing eval.
        d.Decl = false

        self.toIndexing(d, index, i)
        if d.IsConst() {
            d.Decl = false
            d.Model = d.Constant
        } else if d.Decl {
            d.Decl = false
        } else {
            d.Model = &IndexingExprModel{
                Token: i.Token,
                Expr: new(Data, old_d),
                Index: index,
            }
        }

        ret d
    }

    // Returns left and right index values.
    // Returns zero integer expression if slicing have not left index.
    // So, left index always represents an expression.
    // Left data is nil if expression eval failed.
    fn evalSlicingExprs(mut &self, mut &s: &SlicingExpr): (&Data, &Data) {
        let mut prefix = self.prefix
        self.prefix = nil
        defer { self.prefix = prefix }

        let mut l: &Data = nil
        let mut r: &Data = nil

        if s.Start != nil {
            l = self.evalExprKind(s.Start.Kind)
            if l != nil {
                self.checkIntegerIndexingByData(l, s.Token)
            } else {
                ret nil, nil
            }
        } else {
            l = &Data{
                Constant: Const.NewI64(0),
                Kind: &TypeKind{Kind: buildPrimType(PrimKind.Int)},
            }
            l.Model = l.Constant
        }

        if s.To != nil {
            r = self.evalExprKind(s.To.Kind)
            if r != nil {
                self.checkIntegerIndexingByData(r, s.Token)
            } else {
                ret nil, nil
            }
        }

        ret l, r
    }

    fn slicingArr(self, mut &d: &Data) {
        let mut elemType = d.Kind.Arr().Elem
        d.Kind = &TypeKind{
            Kind: &Slc{
                Elem: elemType,
            },
        }

        d.Lvalue = false

        // Keep mutability id already mutable.
        // Be mutable, if element is not mutable-type.
        d.Mutable = d.Mutable || !elemType.Mutable()
    }

    fn slicingStr(self, mut &d: &Data, &l: &Data, &r: &Data) {
        d.Lvalue = false
        d.Mutable = true
        if !d.IsConst() {
            ret
        }

        if l == nil || r == nil {
            d.Constant = nil
            ret
        }

        if l.IsConst() && r.IsConst() {
            let left = l.Constant.AsI64()
            if left < 0 {
                ret
            }

            let s = d.Constant.ReadStr()
            let mut right: i64 = 0
            if r == nil {
                right = i64(s.len)
            } else {
                right = r.Constant.AsI64()
            }

            if left > right {
                ret
            }
            d.Constant.SetStr(s[left:right])
            d.Decl = true // Set Model: flag.
        } else {
            d.Constant = nil
        }
    }

    fn checkSlicing(mut self, mut &d: &Data, &l: &Data, &r: &Data, &s: &SlicingExpr) {
        match {
        | d.Kind.Arr() != nil:
            self.slicingArr(d)
            ret
        | d.Kind.Slc() != nil:
            ret
        | d.Kind.Prim() != nil:
            let prim = d.Kind.Prim()
            match {
            | prim.IsStr():
                self.slicingStr(d, l, r)
                ret
            }
        }

        self.pushErr(s.Token, LogMsg.NotSupportsSlicing, d.Kind.Str())
    }

    fn evalSlicing(mut &self, mut s: &SlicingExpr): &Data {
        let mut d = self.evalExprKind(s.Expr.Kind)
        if d == nil {
            ret nil
        }

        let (mut l, mut r) = self.evalSlicingExprs(s)
        if l == nil {
            ret d
        }

        // Set decl to true. It's a kind of flag.
        // If decl is true after indexing eval, do not touch Model:.
        // Setted by indexing eval.
        d.Decl = false

        self.checkSlicing(d, l, r, s)

        if d.IsConst() {
            d.Decl = false
            d.Model = d.Constant
        } else if d.Decl {
            d.Decl = false
        } else {
            let mut model = &SlicingExprModel{
                Token: s.Token,
                Expr: d.Model,
                Left: l.Model,
            }
            if r != nil {
                model.Right = r.Model
            }
            d.Model = model
        }
        ret d
    }

    fn castPtr(mut self, mut t: &TypeKind, mut d: &Data, errorToken: &Token) {
        let sptr = d.Kind.Sptr()
        if sptr != nil {
            if !t.Ptr().Elem.Equals(sptr.Elem) {
                self.pushErr(errorToken, LogMsg.TypeNotSupportsCastingTo, d.Kind.Str(), t.Str())
            }
            ret
        }

        if !self.isUnsafe() {
            self.pushErr(errorToken, LogMsg.UnsafeBehaviorAtOutOfUnsafeScope)
            ret
        }

        let prim = d.Kind.Prim()
        if d.Kind.Ptr() == nil && (prim == nil || !types::IsInt(prim.Str())) {
            self.pushErr(errorToken, LogMsg.TypeNotSupportsCastingTo, d.Kind.Str(), t.Str())
        }

        d.Constant = nil
    }

    fn castStruct(mut self, mut t: &TypeKind, mut d: &Data, errorToken: &Token) {
        let mut tr = d.Kind.Trait()
        if tr == nil {
            self.pushErr(errorToken, LogMsg.TypeNotSupportsCastingTo, d.Kind.Str(), t.Str())
            ret
        }

        let mut s = t.Struct()
        self.pushReference[&StructIns](s)

        if !s.Decl.IsImplements(tr) {
            self.pushErr(errorToken, LogMsg.TypeNotSupportsCastingTo, d.Kind.Str(), t.Str())
        }
    }

    fn castRef(mut self, mut t: &TypeKind, mut d: &Data, errorToken: &Token) {
        let mut sptr = t.Sptr()

        let mut ptr = d.Kind.Ptr()
        if ptr != nil && sptr.Elem.Equals(ptr.Elem) {
            if !self.isUnsafe() {
                self.pushErr(errorToken, LogMsg.UnsafeBehaviorAtOutOfUnsafeScope)
            }
            // Ok.
            ret
        }

        // For traits.
        if sptr.Elem.Struct() != nil {
            self.castStruct(sptr.Elem, d, errorToken)
            ret
        }

        self.pushErr(errorToken, LogMsg.TypeNotSupportsCastingTo, d.Kind.Str(), t.Str())
    }

    fn castSlc(mut self, mut t: &TypeKind, mut d: &Data, errorToken: &Token) {
        if d.Kind.Enum() != nil {
            if d.Kind.Enum().Kind.Kind.Prim() == nil || !d.Kind.Enum().Kind.Kind.Prim().IsStr() {
                self.pushErr(errorToken, LogMsg.TypeNotSupportsCastingTo, d.Kind.Str(), t.Str())
                ret
            }
        } else if d.Kind.Prim() == nil || !d.Kind.Prim().IsStr() {
            self.pushErr(errorToken, LogMsg.TypeNotSupportsCastingTo, d.Kind.Str(), t.Str())
            ret
        }

        t = t.Slc().Elem
        let prim = t.Prim()
        if prim == nil || (!prim.IsU8() && !prim.IsI32()) {
            self.pushErr(errorToken, LogMsg.TypeNotSupportsCastingTo, d.Kind.Str(), t.Str())
        }
    }

    fn castStr(mut self, mut d: &Data, errorToken: &Token) {
        if d.Kind.Enum() != nil {
            let mut e = d.Kind.Enum()
            if e.Kind.Kind.Prim() != nil && e.Kind.Kind.Prim().IsStr() {
                ret
            }
        }

        if d.Kind.Prim() != nil {
            let prim = d.Kind.Prim()
            if !prim.IsU8() && !prim.IsI32() {
                self.pushErr(errorToken, LogMsg.TypeNotSupportsCastingTo, PrimKind.Str, d.Kind.Str())
            }
            ret
        }

        if d.Kind.Slc() == nil {
            self.pushErr(errorToken, LogMsg.TypeNotSupportsCastingTo, PrimKind.Str, d.Kind.Str())
            ret
        }

        let mut t = d.Kind.Slc().Elem
        let prim = t.Prim()
        if prim == nil || (!prim.IsU8() && !prim.IsI32()) {
            self.pushErr(errorToken, LogMsg.TypeNotSupportsCastingTo, PrimKind.Str, d.Kind.Str())
        }
    }

    fn castInt(mut self, mut t: &TypeKind, mut d: &Data, errorToken: &Token) {
        if d.IsConst() {
            let prim = t.Prim()
            match {
            | types::IsSigInt(prim.Kind):
                d.Constant.SetI64(d.Constant.AsI64())
            | types::IsUnsigInt(prim.Kind):
                d.Constant.SetU64(d.Constant.AsU64())
            }
        }

        if d.Kind.Enum() != nil {
            let e = d.Kind.Enum()
            if types::IsNum(e.Kind.Kind.Str()) {
                ret
            }
        }

        if d.Kind.Sptr() != nil {
            let prim = t.Prim()
            if !prim.IsUintptr() {
                self.pushErr(errorToken, LogMsg.TypeNotSupportsCastingTo, d.Kind.Str(), t.Str())
            }
            ret
        }
        if d.Kind.Ptr() != nil {
            let prim = t.Prim()
            if prim.IsUintptr() {
                // Ignore case.
            } else if !self.isUnsafe() {
                self.pushErr(errorToken, LogMsg.UnsafeBehaviorAtOutOfUnsafeScope)
            } else if !prim.IsI32() && !prim.IsI64() && !prim.IsU16() && !prim.IsU32() && !prim.IsU64() {
                self.pushErr(errorToken, LogMsg.TypeNotSupportsCastingTo, d.Kind.Str(), t.Str())
            }
            ret
        }

        let prim = d.Kind.Prim()
        if prim != nil && types::IsNum(prim.Str()) {
            ret
        }

        self.pushErr(errorToken, LogMsg.TypeNotSupportsCastingTo, d.Kind.Str(), t.Str())
    }

    fn castNum(mut self, mut t: &TypeKind, mut d: &Data, errorToken: &Token) {
        if d.IsConst() {
            let prim = t.Prim()
            match {
            | types::IsFloat(prim.Kind):
                d.Constant.SetF64(d.Constant.AsF64())
            | types::IsSigInt(prim.Kind):
                d.Constant.SetI64(d.Constant.AsI64())
            | types::IsUnsigInt(prim.Kind):
                d.Constant.SetU64(d.Constant.AsU64())
            }
        }

        if d.Kind.Enum() != nil {
            let e = d.Kind.Enum()
            if types::IsNum(e.Kind.Kind.Str()) {
                ret
            }
        }

        let prim = d.Kind.Prim()
        if prim != nil && types::IsNum(prim.Str()) {
            ret
        }

        self.pushErr(errorToken, LogMsg.TypeNotSupportsCastingTo, d.Kind.Str(), t.Str())
    }

    fn castPrim(mut self, mut t: &TypeKind, mut d: &Data, errorToken: &Token) {
        let prim = t.Prim()
        match {
        | prim.IsAny():
            // The any type supports casting to any data type.
        | prim.IsStr():
            self.castStr(d, errorToken)
        | types::IsInt(prim.Str()):
            self.castInt(t, d, errorToken)
        | types::IsNum(prim.Str()):
            self.castNum(t, d, errorToken)
        |:
            self.pushErr(errorToken, LogMsg.TypeNotSupportsCasting, t.Str())
        }
    }

    fn castConstant(mut self, mut &t: &TypeKind, mut &d: &Data) {
        if d == nil || !d.IsConst() {
            ret
        }
        let prim = t.Prim()
        castConstByType(prim.Kind, d)
        d.Model = d.Constant
    }

    fn castTypeEnum(mut self, mut &t: &TypeKind, mut &d: &Data, mut &errorToken: &Token) {
        let n = self.s.errors.len
        if !self.s.checkTypeCompatibility(d.Kind, t, errorToken) {
            self.s.errors = self.s.errors[:n]
            self.pushErr(errorToken, LogMsg.TypeNotSupportsCastingTo, d.Kind.Str(), t.Str())
        }
    }

    fn evalCastByTypeNData(mut self, mut t: &TypeKind, mut d: &Data, mut errorToken: &Token): &Data {
        if d != nil && d.Decl {
            self.pushErr(errorToken, LogMsg.InvalidExpr)
            ret nil
        }

        match {
        | d.Kind.Prim() != nil && d.Kind.Prim().IsAny():
            if t.Enum() != nil {
                self.pushErr(errorToken, LogMsg.EnumCastedFromAny)
                self.pushSugggestion(LogMsg.CastToEnumTypeInsteadOfEnum)
            } else if t.TypeEnum() != nil {
                self.pushErr(errorToken, LogMsg.EnumCastedFromAny)
            }
        | d.Kind.TypeEnum() != nil:
            self.castTypeEnum(t, d, errorToken)
        | t.Ptr() != nil:
            self.castPtr(t, d, errorToken)
        | t.Sptr() != nil:
            self.castRef(t, d, errorToken)
        | t.Slc() != nil:
            self.castSlc(t, d, errorToken)
        | t.Struct() != nil:
            self.castStruct(t, d, errorToken)
        | t.Prim() != nil:
            self.castPrim(t, d, errorToken)
            self.castConstant(t, d)
        |:
            self.pushErr(errorToken, LogMsg.TypeNotSupportsCasting, t.Str())
            d = nil
        }

        if d == nil {
            ret nil
        }

        // Keep mutability if data is already mutable.
        // Even if the data is not mutable, set as mutable if the type is not mutable-type.
        d.Mutable = d.Mutable || (!d.Kind.Mutable() && t.Mutable())

        d.Lvalue = false
        d.Decl = false

        if d.Kind.Enum() == nil || !d.Kind.Enum().Kind.Kind.Equals(t) {
            applyCastKind(d, t)
            (&CastingExprModel)(d.Model).Token = errorToken
        } else {
            d.Kind = t
        }

        ret d
    }

    fn evalCastT(mut &self, mut &t: &TypeKind, mut &e: &Expr, mut &et: &Token): &Data {
        let mut prefix = self.prefix
        self.prefix = nil
        defer { self.prefix = prefix }
        if t.Slc() != nil {
            match type e.Kind {
            | &SliceExpr:
                self.prefix = t
            }
        }
        let mut d = self.evalExprKind(e.Kind)
        if d == nil || self.prefix != nil {
            ret d
        }
        ret self.evalCastByTypeNData(t, d, et)
    }

    fn evalCast(mut &self, mut c: &CastExpr): &Data {
        let mut t = buildType(c.Kind)
        let ok = self.s.checkType(t, self.lookup)
        if !ok {
            ret nil
        }
        ret self.evalCastT(t.Kind, c.Expr, c.Kind.Token)
    }

    fn evalNsSelection(mut self, s: &NsSelectionExpr): &Data {
        let path = buildLinkPathByTokens(s.Ns)
        let mut imp = self.lookup.SelectPackage(fn(imp: &ImportInfo): bool {
            if s.Ns.len == 1 && imp.Alias == path {
                ret true
            }
            ret imp.LinkPath == path && imp.isAccessibleViaSelection()
        })

        if imp == nil {
            self.pushErr(s.Ident, LogMsg.NamespaceNotExist, path)
            ret nil
        }

        let mut lookup = self.lookup
        self.lookup = imp

        const CppLinked = false
        self.disallowBuiltin()
        let mut def = self.getDef(s.Ident.Kind, CppLinked)
        self.allowBuiltin()
        self.lookup = lookup
        let mut d = self.evalDef(def, s.Ident)
        ret d
    }

    fn evalStructLitExplicit(mut &self, mut s: &StructIns,
        mut exprs: []&Expr, mut errorToken: &Token): &Data {
        let ok = self.s.checkGenericQuantity(s.Decl.Generics.len, s.Generics.len, errorToken)
        if !ok {
            ret nil
        }
        // NOTICE: Instance already checked (just fields) if generic quantity passes.

        if self.field != nil && self.field.Decl.Owner == s.Decl {
            self.pushErr(errorToken, LogMsg.IllegalCycleRefersItself, s.Decl.Ident)
        }

        self.pushReference[&StructIns](s)
        self.checkDeprecated(s.Decl.Directives, errorToken)

        let mut slc = structLitChecker{
            e: self,
            errorToken: errorToken,
            s: s,
        }
        slc.check(exprs)

        ret &Data{
            Mutable: !self.immutable,
            Kind: &TypeKind{
                Kind: s,
            },
            Model: &StructLitExprModel{
                Strct: s,
                Args: slc.args,
            },
        }
    }

    fn evalStructLit(mut &self, mut lit: &StructLit): &Data {
        let mut t = buildType(lit.Kind)
        let ok = self.s.checkType(t, self.lookup)
        if !ok {
            ret nil
        }

        let mut s = t.Kind.Struct()
        if s == nil {
            if t.Kind.Sptr() != nil {
                s = t.Kind.Sptr().Elem.Struct()
                if s != nil {
                    goto eval
                }
            }
            self.pushErr(lit.Kind.Token, LogMsg.InvalidSyntax)
            ret nil
        }

    eval:
        let mut d = self.evalStructLitExplicit(s, lit.Exprs, lit.Kind.Token)
        if t.Kind.Sptr() != nil {
            let mut model = (&StructLitExprModel)(d.Model)
            makeStructLitAlloc(d, model)
        }
        ret d
    }

    fn evalType(mut self, mut t: &TypeDecl): &Data {
        let mut tk = buildType(t)
        let ok = self.s.checkType(tk, self.lookup)
        if !ok {
            ret nil
        }
        ret &Data{
            Decl: true,
            Kind: tk.Kind,
            Model: tk.Kind,
        }
    }

    fn callTypeFn(mut &self, mut &fc: &FnCallExpr, mut &d: &Data) {
        if fc.Args.len < 1 {
            self.pushErr(fc.Token, LogMsg.MissingExprFor, "v")
        } else if fc.Args.len > 1 {
            self.pushErr(fc.Args[1].Token, LogMsg.ArgumentOverflow)
        }

        if fc.Args.len > 0 {
            let mut arg = fc.Args[0]
            d = self.evalCastT(d.Kind, arg, arg.Token)
            ret
        }

        if d != nil {
            d.Decl = false
        }
    }

    fn callBuiltinFn(mut &self, mut &fc: &FnCallExpr, mut &d: &Data) {
        d = d.Kind.Fn().caller(self, fc, d)
        if d == nil {
            ret
        }
        d.Mutable = true
    }

    fn checkFnOfConcurrentCall(mut self, &f: &FnIns, errorToken: &Token) {
        if self.isUnsafe() {
            ret
        }
        for _, p in f.Params {
            if p.Decl.Reference {
                self.pushErr(errorToken, LogMsg.ConcurrenctCallWithRefParam)
                ret
            }
        }
    }

    fn processExceptionalHandler(mut self, mut &f: &FnIns, mut &fc: &FnCallExpr, mut &d: &Data) {
        let resultNeeded = !f.Decl.IsVoid() && (self.arg || !self.ignored)
        let mut csc: &scopeChecker = nil
        let mut ch: &Scope = nil

        let mut model = (&FnCallExprModel)(d.Model)

        // self.lookup is always scopeChecker because exceptionals are
        // not allowed in global scope.
        let mut sc = (&scopeChecker)(self.lookup)
        csc = sc.newChildChecker()
        if resultNeeded {
            csc.result = f
        }
        ch = sc.getChild()
        fc.Exception.Parent = sc.tree
        csc.table.Vars = append(csc.table.Vars, buildErrorVar(ch, fc))
        sc.checkChildSsc(fc.Exception, ch, csc)

        model.Assigned = resultNeeded
        model.Except = ch

        if resultNeeded && csc.result != nil {
            self.pushErr(fc.Token, LogMsg.MissingAssignRet)
        }
    }

    fn callFn(mut &self, mut &fc: &FnCallExpr, mut &d: &Data) {
        let mut f = d.Kind.Fn()
        if self.isGlobal() && f.Decl.Exceptional {
            self.pushErr(fc.Token, LogMsg.ExceptionalAtGlobalScope)
            self.pushSugggestion(LogMsg.WrapExceptional)
            d = nil
            ret
        }
        if f.IsBuiltin() {
            self.callBuiltinFn(fc, d)
            ret
        }

        if !f.Decl.IsMethod() && hasDirective(f.Decl.Directives, Directive.Test) {
            self.pushErr(fc.Token, LogMsg.TestCalled)
            d = nil
            ret
        }

        if !d.Mutable && f.Decl.IsMethod() && !f.Decl.Statically && f.Decl.Params[0].Mutable {
            self.pushErr(fc.Token, LogMsg.MutOperationOnImmut)
        } else if !self.isUnsafe() && f.Decl.Unsafety {
            self.pushErr(fc.Token, LogMsg.UnsafeBehaviorAtOutOfUnsafeScope)
        }

        let mut dynamicAnnotation = f.Decl.Generics.len > 0 && f.Generics.len == 0 && f.Params.len > 0
        if dynamicAnnotation {
            f.Generics = make([]&InsGeneric, f.Decl.Generics.len)
        } else if f.Generics.len != f.Decl.Generics.len {
            _ = self.s.checkGenericQuantity(f.Decl.Generics.len, f.Generics.len, fc.Token)
            d = nil
            ret
        }

        let mut old = self.s
        if f.Decl.Owner != nil {
            self.s = f.Decl.Owner.sema
        }

        defer {
            if old != self.s {
                old.errors = append(old.errors, self.s.errors...)
                self.s.errors = nil
            }
            self.s = old
        }

        if !dynamicAnnotation {
            if !f.reloaded {
                let ok = self.s.reloadFnInsTypes(f)
                f.reloaded = true
                if !ok {
                    d = nil
                    ret
                }
            }
            let mut existInstance = f.Decl.appendInstance(f)
            if existInstance != nil {
                f = existInstance
            }
        } else {
            self.s.buildFnNonGenericTypeKinds(f)
        }

        let mut fcac = fnCallArgChecker{
            e: self,
            f: f,
            args: fc.Args,
            dynamicAnnotation: dynamicAnnotation,
            errorToken: fc.Token,
        }
        let mut ok = false
        if f.Decl.Owner != nil {
            old, self.s = self.s, old // Save current Sema.
            ok = fcac.check()
            old, self.s = self.s, old // Save owner Sema.
        } else {
            ok = fcac.check()
        }

        if dynamicAnnotation {
            if !ok {
                d = nil
                ret
            }
            if !self.checkGenericFn(f, fc.Token, d.Model) {
                d = nil
                ret
            }
        }

        let mut callModel = d.Model

        if f.Decl.IsVoid() {
            d = buildVoidData()
        } else {
            d.Kind = f.Result
            d.Lvalue = false
        }

        let mut model = &FnCallExprModel{
            Token: fc.Token,
            Func: f,
            Expr: callModel,
            Args: fcac.argModels,
        }
        d.Model = model
        d.Mutable = true

        if f.Decl.Exceptional {
            match {
            | fc.Unhandled():
                self.pushErr(fc.Token, LogMsg.UnhandledExceptional)
                self.pushSugggestion(LogMsg.HandleExceptional)
            | fc.Ignored():
                // Ok.
                break
            |:
                // Handled with scope.
                self.processExceptionalHandler(f, fc, d)
            }
        } else if !fc.Unhandled() {
            self.pushErr(fc.Token, LogMsg.HandledUnexceptional)
        }
    }

    fn evalFnCall(mut &self, mut fc: &FnCallExpr): &Data {
        let mut prefix = self.prefix
        self.prefix = nil
        defer { self.prefix = prefix }

        match type fc.Expr.Kind {
        | &IdentExpr:
            // Use fc.expr.Token.Kind instead of casting.
            // Same thing, but more efficient and performant.
            if fc.Expr.Token.Kind == TokenKind.Error {
                ret builtinCallerError(self, fc)
            }
        }

        let mut d = self.evalExprKind(fc.Expr.Kind)
        if d == nil {
            ret nil
        }

        if d.Decl {
            self.callTypeFn(fc, d)
            ret d
        }

        if d.Kind.Fn() == nil {
            self.pushErr(fc.Token, LogMsg.CallingNonFn)
            ret nil
        }

        self.callFn(fc, d)
        ret d
    }

    fn evalEnumStatic(mut self, mut enm: &Enum, ident: &Token): &Data {
        let mut d = &Data{
            Kind: &TypeKind{
                Kind: enm,
            },
        }

        let mut item = enm.FindItem(ident.Kind)
        if item == nil {
            self.pushErr(ident, LogMsg.ObjHaveNotIdent, enm.Ident, ident.Kind)
        } else {
            d.Constant = new(Const, *item.Value.Data.Constant)
            d.Model = d.Constant
            applyCastModelByEnum(d, enm)
        }

        ret d
    }

    fn evalTypeEnumStatic(mut self, mut enm: &TypeEnum, ident: &Token): &Data {
        let mut item = enm.FindItem(ident.Kind)
        if item == nil {
            self.pushErr(ident, LogMsg.ObjHaveNotIdent, enm.Ident, ident.Kind)
            ret nil
        }
        match {
        | item.Kind.Kind.Enum() != nil:
            ret self._evalEnum(item.Kind.Kind.Enum())
        | item.Kind.Kind.TypeEnum() != nil:
            ret self._evalTypeEnum(item.Kind.Kind.TypeEnum())
        | item.Kind.Kind.Struct() != nil:
            ret self._evalStruct(item.Kind.Kind.Struct())
        |:
            let mut d = &Data{
                Decl: true,
                Kind: item.Kind.Kind,
            }
            d.Model = d.Kind
            ret d
        }
    }

    fn evalStructStatic(mut self, mut s: &StructIns, ident: &Token): &Data {
        let mut d = new(Data)

        // Method.
        const Static = true
        let mut method = s.FindMethod(ident.Kind, Static)
        if method != nil {
            if !self.s.isAccessibleDefine(method.Public, method.Token) {
                self.pushErr(ident, LogMsg.IdentIsNotAccessible, ident.Kind)
                self.pushSugggestion(LogMsg.MakePubToAccess)
            }

            let mut ins = method.instance()
            ins.Owner = s
            self.pushReference[&FnIns](ins)
            d.Model = &StructStaticIdentExprModel{
                Structure: s,
                Expr: d.Model,
                Method: ins,
            }
            d.Kind = &TypeKind{
                Kind: ins,
            }
            ret d
        }

        let mut sttc = s.Decl.FindStatic(ident.Kind)
        if sttc != nil {
            ret self.evalVar(sttc, ident)
        }

        self.pushErr(ident, LogMsg.ObjHaveNotIdent, s.Decl.Ident, ident.Kind)
        ret nil
    }

    fn evalTraitSubIdent(mut self, mut d: &Data, mut trt: &Trait, mut ident: &Token): &Data {
        let mut f = trt.FindMethod(ident.Kind)
        if f == nil {
            self.pushErr(ident, LogMsg.ObjHaveNotIdent, trt.Ident, ident.Kind)
            ret nil
        }
        ret &Data{
            Kind: &TypeKind{
                Kind: f.instance(),
            },
            Model: &TraitSubIdentExprModel{
                Token: ident,
                Expr: d.Model,
                Method: f,
                Trt: trt,
            },
        }
    }

    fn evalStructSubIdent(mut self, mut d: &Data, mut s: &StructIns, mut si: &SubIdentExpr, ref: bool): &Data {
        let mut f = s.FindField(si.Ident.Kind)
        if f != nil {
            if !self.s.isAccessibleDefine(f.Decl.Public, f.Decl.Token) {
                self.pushErr(si.Ident, LogMsg.IdentIsNotAccessible, f.Decl.Ident)
                self.pushSugggestion(LogMsg.MakePubToAccess)
            }

            let mut model = &StructSubIdentExprModel{
                Token: si.Ident,
                ExprKind: d.Kind,
                Expr: new(Data, *d),
                Field: f,
            }
            d.Model = model
            d.Kind = f.Kind
            d.Lvalue = true

            if f.Decl.Mutable && !d.Mutable {
                // Interior mutability.
                match type self.lookup {
                | &scopeChecker:
                    let scope = (&scopeChecker)(self.lookup).getRoot()
                    d.Mutable = scope.owner != nil && scope.owner.Owner == s
                }
            }

            ret d
        }

        const Static = false
        let mut m = s.FindMethod(si.Ident.Kind, Static)
        if m == nil {
            self.pushErr(si.Ident, LogMsg.ObjHaveNotIdent, s.Decl.Ident, si.Ident.Kind)
            ret nil
        }
        if !self.s.isAccessibleDefine(m.Public, m.Token) {
            self.pushErr(si.Ident, LogMsg.IdentIsNotAccessible, m.Ident)
            self.pushSugggestion(LogMsg.MakePubToAccess)
        }

        if m.Params[0].IsRef() && !ref {
            self.pushErr(si.Ident, LogMsg.RefMethodUsedWithNotRefInstance)
        }

        self.checkDeprecated(m.Directives, si.Ident)

        let mut ins = m.instance()
        ins.Owner = s
        self.pushReference[&FnIns](ins)
        let mut model = new(Data, *d)
        d.Model = &StructSubIdentExprModel{
            Token: si.Ident,
            ExprKind: d.Kind,
            Expr: model,
            Method: ins,
        }
        d.Kind = &TypeKind{Kind: ins}
        ret d
    }

    fn evalSliceSubIdent(mut self, mut d: &Data, mut ident: &Token): &Data {
        match ident.Kind {
        | "len":
            ret &Data{
                Mutable: false,
                Kind: &TypeKind{Kind: buildPrimType(PrimKind.Int)},
                Model: &CommonSubIdentExprModel{
                    Token: ident,
                    ExprKind: d.Kind,
                    Expr: d.Model,
                    Ident: "len()",
                },
            }
        | "cap":
            ret &Data{
                Mutable: false,
                Kind: &TypeKind{Kind: buildPrimType(PrimKind.Int)},
                Model: &CommonSubIdentExprModel{
                    Token: ident,
                    ExprKind: d.Kind,
                    Expr: d.Model,
                    Ident: "cap()",
                },
            }
        | "swap":
            ret &Data{
                Mutable: d.Mutable,
                Kind: &TypeKind{
                    Kind: &FnIns{
                        caller: builtinCallerCommonMut,
                        Params: [
                            &ParamIns{
                                Decl: &Param{
                                    Ident: "i",
                                },
                                Kind: &TypeKind{Kind: buildPrimType(PrimKind.Int)},
                            },
                            &ParamIns{
                                Decl: &Param{
                                    Ident: "j",
                                },
                                Kind: &TypeKind{Kind: buildPrimType(PrimKind.Int)},
                            },
                        ],
                    },
                },
                Model: &CommonSubIdentExprModel{
                    Token: ident,
                    ExprKind: d.Kind,
                    Expr: d.Model,
                    Ident: "swap",
                },
            }
        |:
            self.pushErr(ident, LogMsg.ObjHaveNotIdent, d.Kind.Str(), ident.Kind)
            ret nil
        }
    }

    fn evalArraySubIdent(mut self, mut d: &Data, mut ident: &Token): &Data {
        match ident.Kind {
        | "len":
            let mut c = Const.NewI64(i64(d.Kind.Arr().N))
            ret &Data{
                Constant: c,
                Kind: &TypeKind{Kind: buildPrimType(PrimKind.Int)},
                Model: c,
            }
        | "swap":
            ret &Data{
                Mutable: d.Mutable,
                Kind: &TypeKind{
                    Kind: &FnIns{
                        caller: builtinCallerCommonMut,
                        Params: [
                            &ParamIns{
                                Decl: &Param{
                                    Ident: "i",
                                },
                                Kind: &TypeKind{Kind: buildPrimType(PrimKind.Int)},
                            },
                            &ParamIns{
                                Decl: &Param{
                                    Ident: "j",
                                },
                                Kind: &TypeKind{Kind: buildPrimType(PrimKind.Int)},
                            },
                        ],
                    },
                },
                Model: &CommonSubIdentExprModel{
                    Token: ident,
                    ExprKind: d.Kind,
                    Expr: d.Model,
                    Ident: "swap",
                },
            }
        |:
            self.pushErr(ident, LogMsg.ObjHaveNotIdent, d.Kind.Str(), ident.Kind)
            ret nil
        }
    }

    fn evalMapSubIdent(mut self, mut d: &Data, mut ident: &Token): &Data {
        let mut mapKind = d.Kind.Map()

        match ident.Kind {
        | "len":
            ret &Data{
                Kind: &TypeKind{Kind: buildPrimType(PrimKind.Int)},
                Model: &CommonSubIdentExprModel{
                    Token: ident,
                    ExprKind: d.Kind,
                    Expr: d.Model,
                    Ident: "len()",
                },
            }
        | "clear":
            ret &Data{
                Mutable: d.Mutable,
                Kind: &TypeKind{
                    Kind: &FnIns{
                        caller: builtinCallerCommonMut,
                    },
                },
                Model: &CommonSubIdentExprModel{
                    Token: ident,
                    ExprKind: d.Kind,
                    Expr: d.Model,
                    Ident: "clear",
                },
            }
        | "keys":
            ret &Data{
                Mutable: d.Mutable,
                Kind: &TypeKind{
                    Kind: &FnIns{
                        caller: builtinCallerCommonMut,
                        Result: &TypeKind{
                            Kind: &Slc{
                                Elem: mapKind.Key,
                            },
                        },
                    },
                },
                Model: &CommonSubIdentExprModel{
                    Token: ident,
                    ExprKind: d.Kind,
                    Expr: d.Model,
                    Ident: "keys",
                },
            }
        | "values":
            ret &Data{
                Mutable: d.Mutable,
                Kind: &TypeKind{
                    Kind: &FnIns{
                        caller: builtinCallerCommonMut,
                        Result: &TypeKind{
                            Kind: &Slc{
                                Elem: mapKind.Val,
                            },
                        },
                    },
                },
                Model: &CommonSubIdentExprModel{
                    Token: ident,
                    ExprKind: d.Kind,
                    Expr: d.Model,
                    Ident: "values",
                },
            }
        | "has":
            ret &Data{
                Mutable: d.Mutable,
                Kind: &TypeKind{
                    Kind: &FnIns{
                        caller: builtinCallerCommon,
                        Params: [
                            &ParamIns{
                                Decl: &Param{
                                    Ident: "key",
                                },
                                Kind: mapKind.Key,
                            },
                        ],
                        Result: &TypeKind{Kind: buildPrimType(PrimKind.Bool)},
                    },
                },
                Model: &CommonSubIdentExprModel{
                    Token: ident,
                    ExprKind: d.Kind,
                    Expr: d.Model,
                    Ident: "has",
                },
            }
        | "del":
            ret &Data{
                Mutable: d.Mutable,
                Kind: &TypeKind{
                    Kind: &FnIns{
                        caller: builtinCallerCommonMut,
                        Params: [
                            &ParamIns{
                                Decl: &Param{
                                    Ident: "key",
                                },
                                Kind: mapKind.Key,
                            },
                        ],
                    },
                },
                Model: &CommonSubIdentExprModel{
                    Token: ident,
                    ExprKind: d.Kind,
                    Expr: d.Model,
                    Ident: "del",
                },
            }
        |:
            self.pushErr(ident, LogMsg.ObjHaveNotIdent, mapKind.Str(), ident.Kind)
            ret nil
        }
    }

    fn evalStrSubIdent(mut self, mut d: &Data, mut ident: &Token): &Data {
        let mut strKind = &TypeKind{Kind: buildPrimType(PrimKind.Str)}
        match ident.Kind {
        | "len":
            let mut sd = &Data{
                Kind: &TypeKind{Kind: buildPrimType(PrimKind.Int)},
            }
            if d.IsConst() {
                sd.Constant = Const.NewI64(i64(d.Constant.ReadStr().len))
                sd.Model = sd.Constant
            } else {
                sd.Model = &CommonSubIdentExprModel{
                    Token: ident,
                    ExprKind: d.Kind,
                    Expr: d.Model,
                    Ident: "len()",
                }
            }
            ret sd
        | "cap":
            let mut sd = &Data{
                Kind: &TypeKind{Kind: buildPrimType(PrimKind.Int)},
            }
            if d.IsConst() {
                sd.Constant = Const.NewI64(i64(d.Constant.ReadStr().cap))
                sd.Model = sd.Constant
            } else {
                sd.Model = &CommonSubIdentExprModel{
                    Token: ident,
                    ExprKind: d.Kind,
                    Expr: d.Model,
                    Ident: "cap()",
                }
            }
            ret sd
        |:
            self.pushErr(ident, LogMsg.ObjHaveNotIdent, strKind.Str(), ident.Kind)
            ret nil
        }
    }

    fn evalIntTypeStatic(mut self, ident: &Token): &Data {
        const kind: str = PrimKind.Int

        match ident.Kind {
        | "MAX":
            let mut c = Const.NewI64(i64(types::Max(kind)))
            ret &Data{
                Constant: c,
                Model: c,
                Kind: &TypeKind{Kind: buildPrimType(kind)},
            }
        | "MIN":
            let mut c = Const.NewI64(i64(types::Min(kind)))
            ret &Data{
                Constant: c,
                Model: c,
                Kind: &TypeKind{Kind: buildPrimType(kind)},
            }
        |:
            self.pushErr(ident, LogMsg.TypeHaveNotIdent, kind, ident.Kind)
            ret nil
        }
    }

    fn evalUintTypeStatic(mut self, ident: &Token): &Data {
        const kind: str = PrimKind.Uint

        match ident.Kind {
        | "MAX":
            let mut c = Const.NewU64(u64(types::Max(kind)))
            ret &Data{
                Constant: c,
                Model: c,
                Kind: &TypeKind{Kind: buildPrimType(kind)},
            }
        |:
            self.pushErr(ident, LogMsg.TypeHaveNotIdent, kind, ident.Kind)
            ret nil
        }
    }

    fn evalI8TypeStatic(mut self, ident: &Token): &Data {
        const kind: str = PrimKind.I8
        const min = types::MinI8
        const max = types::MaxI8

        match ident.Kind {
        | "MAX":
            let mut c = Const.NewI64(max)
            ret &Data{
                Constant: c,
                Model: c,
                Kind: &TypeKind{Kind: buildPrimType(kind)},
            }
        | "MIN":
            let mut c = Const.NewI64(min)
            ret &Data{
                Constant: c,
                Model: c,
                Kind: &TypeKind{Kind: buildPrimType(kind)},
            }
        |:
            self.pushErr(ident, LogMsg.TypeHaveNotIdent, kind, ident.Kind)
            ret nil
        }
    }

    fn evalI16TypeStatic(mut self, ident: &Token): &Data {
        const kind: str = PrimKind.I16
        const min = types::MinI16
        const max = types::MaxI16

        match ident.Kind {
        | "MAX":
            let mut c = Const.NewI64(max)
            ret &Data{
                Constant: c,
                Model: c,
                Kind: &TypeKind{Kind: buildPrimType(kind)},
            }
        | "MIN":
            let mut c = Const.NewI64(min)
            ret &Data{
                Constant: c,
                Model: c,
                Kind: &TypeKind{Kind: buildPrimType(kind)},
            }
        |:
            self.pushErr(ident, LogMsg.TypeHaveNotIdent, kind, ident.Kind)
            ret nil
        }
    }

    fn evalI32TypeStatic(mut self, ident: &Token): &Data {
        const kind: str = PrimKind.I32
        const min = types::MinI32
        const max = types::MaxI32

        match ident.Kind {
        | "MAX":
            let mut c = Const.NewI64(max)
            ret &Data{
                Constant: c,
                Model: c,
                Kind: &TypeKind{Kind: buildPrimType(kind)},
            }
        | "MIN":
            let mut c = Const.NewI64(min)
            ret &Data{
                Constant: c,
                Model: c,
                Kind: &TypeKind{Kind: buildPrimType(kind)},
            }
        |:
            self.pushErr(ident, LogMsg.TypeHaveNotIdent, kind, ident.Kind)
            ret nil
        }
    }

    fn evalI64TypeStatic(mut self, ident: &Token): &Data {
        const kind: str = PrimKind.I64
        const min = types::MinI64
        const max = types::MaxI64

        match ident.Kind {
        | "MAX":
            let mut c = Const.NewI64(max)
            ret &Data{
                Constant: c,
                Model: c,
                Kind: &TypeKind{Kind: buildPrimType(kind)},
            }
        | "MIN":
            let mut c = Const.NewI64(min)
            ret &Data{
                Constant: c,
                Model: c,
                Kind: &TypeKind{Kind: buildPrimType(kind)},
            }
        |:
            self.pushErr(ident, LogMsg.TypeHaveNotIdent, kind, ident.Kind)
            ret nil
        }
    }

    fn evalU8TypeStatic(mut self, ident: &Token): &Data {
        const kind: str = PrimKind.U8
        const max = types::MaxU8

        match ident.Kind {
        | "MAX":
            let mut c = Const.NewU64(max)
            ret &Data{
                Constant: c,
                Model: c,
                Kind: &TypeKind{Kind: buildPrimType(kind)},
            }
        |:
            self.pushErr(ident, LogMsg.TypeHaveNotIdent, kind, ident.Kind)
            ret nil
        }
    }

    fn evalU16TypeStatic(mut self, ident: &Token): &Data {
        const kind: str = PrimKind.U16
        const max = types::MaxU16

        match ident.Kind {
        | "MAX":
            let mut c = Const.NewU64(max)
            ret &Data{
                Constant: c,
                Model: c,
                Kind: &TypeKind{Kind: buildPrimType(kind)},
            }
        |:
            self.pushErr(ident, LogMsg.TypeHaveNotIdent, kind, ident.Kind)
            ret nil
        }
    }

    fn evalU32TypeStatic(mut self, ident: &Token): &Data {
        const kind: str = PrimKind.U32
        const max = types::MaxU32

        match ident.Kind {
        | "MAX":
            let mut c = Const.NewU64(max)
            ret &Data{
                Constant: c,
                Model: c,
                Kind: &TypeKind{Kind: buildPrimType(kind)},
            }
        |:
            self.pushErr(ident, LogMsg.TypeHaveNotIdent, kind, ident.Kind)
            ret nil
        }
    }

    fn evalU64TypeStatic(mut self, ident: &Token): &Data {
        const kind: str = PrimKind.U64
        const max = types::MaxU64

        match ident.Kind {
        | "MAX":
            let mut c = Const.NewU64(max)
            ret &Data{
                Constant: c,
                Model: c,
                Kind: &TypeKind{Kind: buildPrimType(kind)},
            }
        |:
            self.pushErr(ident, LogMsg.TypeHaveNotIdent, kind, ident.Kind)
            ret nil
        }
    }

    fn evalF32TypeStatic(mut self, ident: &Token): &Data {
        const kind = PrimKind.F32
        const max = types::MaxF32
        const min = types::MinF32
        const smallestNonZero = types::SmallestNonZeroF32

        match ident.Kind {
        | "MAX":
            let mut c = Const.NewF64(max)
            ret &Data{
                Constant: c,
                Model: c,
                Kind: &TypeKind{Kind: buildPrimType(kind)},
            }
        | "MIN":
            let mut c = Const.NewF64(min)
            ret &Data{
                Constant: c,
                Model: c,
                Kind: &TypeKind{Kind: buildPrimType(kind)},
            }
        | "SMALLEST_NON_ZERO":
            let mut c = Const.NewF64(smallestNonZero)
            ret &Data{
                Constant: c,
                Model: c,
                Kind: &TypeKind{Kind: buildPrimType(kind)},
            }
        |:
            self.pushErr(ident, LogMsg.TypeHaveNotIdent, kind, ident.Kind)
            ret nil
        }
    }

    fn evalF64TypeStatic(mut self, ident: &Token): &Data {
        const kind = PrimKind.F64
        const max = types::MaxF64
        const min = types::MinF64
        const smallestNonZero = types::SmallestNonZeroF64

        match ident.Kind {
        | "MAX":
            let mut c = Const.NewF64(max)
            ret &Data{
                Constant: c,
                Model: c,
                Kind: &TypeKind{Kind: buildPrimType(kind)},
            }
        | "MIN":
            let mut c = Const.NewF64(min)
            ret &Data{
                Constant: c,
                Model: c,
                Kind: &TypeKind{Kind: buildPrimType(kind)},
            }
        | "SMALLEST_NON_ZERO":
            let mut c = Const.NewF64(smallestNonZero)
            ret &Data{
                Constant: c,
                Model: c,
                Kind: &TypeKind{Kind: buildPrimType(kind)},
            }
        |:
            self.pushErr(ident, LogMsg.TypeHaveNotIdent, kind, ident.Kind)
            ret nil
        }
    }

    fn evalPrimStatic(mut self, kind: str, ident: &Token): &Data {
        match kind {
        | PrimKind.Int:
            ret self.evalIntTypeStatic(ident)
        | PrimKind.Uint:
            ret self.evalUintTypeStatic(ident)
        | PrimKind.I8:
            ret self.evalI8TypeStatic(ident)
        | PrimKind.I16:
            ret self.evalI16TypeStatic(ident)
        | PrimKind.I32:
            ret self.evalI32TypeStatic(ident)
        | PrimKind.I64:
            ret self.evalI64TypeStatic(ident)
        | PrimKind.U8:
            ret self.evalU8TypeStatic(ident)
        | PrimKind.U16:
            ret self.evalU16TypeStatic(ident)
        | PrimKind.U32:
            ret self.evalU32TypeStatic(ident)
        | PrimKind.U64:
            ret self.evalU64TypeStatic(ident)
        | PrimKind.F32:
            ret self.evalF32TypeStatic(ident)
        | PrimKind.F64:
            ret self.evalF64TypeStatic(ident)
        |:
            self.pushErr(ident, LogMsg.TypeHaveNotIdent, kind, ident.Kind)
            ret nil
        }
    }

    fn evalTypeStatic(mut self, mut d: &Data, mut si: &SubIdentExpr): &Data {
        match {
        | d.Kind.Prim() != nil:
            ret self.evalPrimStatic(d.Kind.Prim().Str(), si.Ident)
        | d.Kind.Enum() != nil:
            ret self.evalEnumStatic(d.Kind.Enum(), si.Ident)
        | d.Kind.TypeEnum() != nil:
            ret self.evalTypeEnumStatic(d.Kind.TypeEnum(), si.Ident)
        | d.Kind.Struct() != nil:
            ret self.evalStructStatic(d.Kind.Struct(), si.Ident)
        |:
            self.pushErr(si.Ident, LogMsg.TypeNotSupportSubFields, d.Kind.Str())
            ret nil
        }
    }

    fn evalObjSubIdent(mut self, mut d: &Data, mut si: &SubIdentExpr): &Data {
        if IsIgnoreIdent(si.Ident.Kind) {
            self.pushErr(si.Ident, LogMsg.InvalidSyntax)
            ret nil
        }

        let mut kind = d.Kind
        match {
        | d.Kind.Ptr() != nil:
            let ptr = d.Kind.Ptr()
            if ptr.IsUnsafe() {
                break
            }
            if !si.IsSelf && !self.isUnsafe() {
                self.pushErr(si.Ident, LogMsg.UnsafeBehaviorAtOutOfUnsafeScope)
            }
            kind = d.Kind.Ptr().Elem
        | d.Kind.Sptr() != nil:
            kind = d.Kind.Sptr().Elem
        }

        match {
        | d.Kind.Trait() != nil:
            ret self.evalTraitSubIdent(d, d.Kind.Trait(), si.Ident)
        | kind.Struct() != nil:
            let s = kind.Struct()
            if isInstancedStruct(s) {
                let mut usedReferenceElem = d.Kind.Sptr() != nil
                ret self.evalStructSubIdent(d, kind.Struct(), si, usedReferenceElem)
            }
        | kind.Slc() != nil:
            ret self.evalSliceSubIdent(d, si.Ident)
        | kind.Arr() != nil:
            ret self.evalArraySubIdent(d, si.Ident)
        | kind.Map() != nil:
            ret self.evalMapSubIdent(d, si.Ident)
        | kind.Prim() != nil:
            let p = kind.Prim()
            match p.Kind {
            | PrimKind.Str:
                ret self.evalStrSubIdent(d, si.Ident)
            }
        }
        self.pushErr(si.Ident, LogMsg.ObjNotSupportSubFields, d.Kind.Str())
        ret nil
    }

    fn evalSubIdent(mut &self, mut si: &SubIdentExpr): &Data {
        let mut prefix = self.prefix
        self.prefix = nil
        defer { self.prefix = prefix }

        let mut d = self.evalExprKind(si.Expr.Kind)
        if d == nil {
            ret nil
        }

        if d.Decl {
            ret self.evalTypeStatic(d, si)
        }

        ret self.evalObjSubIdent(d, si)
    }

    fn evalTuple(mut &self, mut tup: &TupleExpr): &Data {
        let mut tupT = new(Tuple)
        tupT.Types = make([]&TypeKind, 0, tup.Expr.len)

        let mut model = &TupleExprModel{
            Datas: make([]&Data, 0, tup.Expr.len),
        }

        let mut ok = true
        for (_, mut expr) in tup.Expr {
            let mut d = self.evalExprKind(expr.Kind)
            if d == nil {
                ok = false
                continue
            }
            tupT.Types = append(tupT.Types, d.Kind)
            model.Datas = append(model.Datas, d)
        }

        if !ok {
            ret nil
        }

        ret &Data{
            Kind: &TypeKind{Kind: tupT},
            Model: model,
        }
    }

    fn evalMap(mut &self, mut m: &Map, mut lit: &BraceLit): &Data {
        let mut model = &MapExprModel{
            KeyKind: m.Key,
            ValKind: m.Val,
        }

        for (_, mut expr) in lit.Exprs {
            match type expr.Kind {
            | &KeyValPair:
                // Ok.
                break
            |:
                self.pushErr(lit.Token, LogMsg.InvalidSyntax)
                ret nil
            }

            let mut pair = (&KeyValPair)(expr.Kind)

            let mut key = self.evalExprKind(pair.Key.Kind)
            if key == nil {
                ret nil
            }

            let mut val = self.evalExprKind(pair.Val.Kind)
            if val == nil {
                ret nil
            }

            _ = self.s.checkAssignType(false, m.Key, key, pair.Colon)
            _ = self.s.checkAssignType(false, m.Val, val, pair.Colon)

            model.Entries = append(model.Entries, &KeyValPairExprModel{
                Key: key.Model,
                Val: val.Model,
            })
        }

        ret &Data{
            Mutable: true,
            Kind: &TypeKind{Kind: m},
            Model: model,
        }
    }

    fn evalBraceLit(mut &self, mut lit: &BraceLit): &Data {
        match {
        | self.prefix == nil:
            self.pushErr(lit.Token, LogMsg.InvalidSyntax)
            ret nil
        | self.prefix.Map() != nil:
            ret self.evalMap(self.prefix.Map(), lit)
        | self.prefix.Struct() != nil:
            ret self.evalStructLitExplicit(self.prefix.Struct(), lit.Exprs, lit.Token)
        |:
            self.pushErr(lit.Token, LogMsg.InvalidSyntax)
            ret nil
        }
    }

    fn evalAnonFn(mut &self, mut decl: &FnDecl): &Data {
        let mut tc = typeChecker{
            s: self.s,
            lookup: self.lookup,
        }
        let mut ins = tc.buildFn(decl)
        match type self.lookup {
        | &scopeChecker:
            let mut sc = (&scopeChecker)(self.lookup)
            let mut scc = sc.newChildChecker()
            scc.labels = new([]&scopeLabel, nil)
            scc.gotos = new([]&scopeGoto, nil)
            scc.owner = nil
            scc.childIndex = 0
            scc.it = 0
            scc.cse = 0
            scc.owner = ins
            self.s.checkFnInsSc(ins, scc)
        |:
            self.s.checkFnIns(ins)
        }

        ret &Data{
            Kind: &TypeKind{Kind: ins},
            Model: &AnonFnExprModel{
                Func: ins,
                Global: self.isGlobal(),
            },
        }
    }

    fn evalBinop(mut &self, mut op: &BinopExpr): &Data {
        let mut bs = binaryEval.newPlain(self)
        // Apply prefix for just numericals.
        if self.prefix != nil {
            let prim = self.prefix.Prim()
            if prim == nil || !types::IsNum(prim.Str()) {
                let mut prefix = self.prefix
                self.prefix = nil
                defer { self.prefix = prefix }
                ret bs.eval(op)
            }
        }
        ret bs.eval(op)
    }

    fn evalExprKind(mut &self, mut kind: ExprData): &Data {
        match type kind {
        | &RangeExpr:
            let mut e = (&RangeExpr)(kind)
            ret self.evalExprKind(e.Expr.Kind)
        | &LitExpr:
            ret self.evalLit((&LitExpr)(kind))
        | &IdentExpr:
            ret self.evalIdent((&IdentExpr)(kind))
        | &UnaryExpr:
            ret self.evalUnary((&UnaryExpr)(kind))
        | &VariadicExpr:
            ret self.evalVariadic((&VariadicExpr)(kind))
        | &UnsafeExpr:
            ret self.evalUnsafe((&UnsafeExpr)(kind))
        | &SliceExpr:
            ret self.evalSliceExpr((&SliceExpr)(kind))
        | &IndexingExpr:
            ret self.evalIndexing((&IndexingExpr)(kind))
        | &SlicingExpr:
            ret self.evalSlicing((&SlicingExpr)(kind))
        | &CastExpr:
            ret self.evalCast((&CastExpr)(kind))
        | &NsSelectionExpr:
            ret self.evalNsSelection((&NsSelectionExpr)(kind))
        | &StructLit:
            ret self.evalStructLit((&StructLit)(kind))
        | &TypeDecl:
            ret self.evalType((&TypeDecl)(kind))
        | &FnCallExpr:
            ret self.evalFnCall((&FnCallExpr)(kind))
        | &SubIdentExpr:
            ret self.evalSubIdent((&SubIdentExpr)(kind))
        | &TupleExpr:
            ret self.evalTuple((&TupleExpr)(kind))
        | &BraceLit:
            ret self.evalBraceLit((&BraceLit)(kind))
        | &FnDecl:
            ret self.evalAnonFn((&FnDecl)(kind))
        | &BinopExpr:
            ret self.evalBinop((&BinopExpr)(kind))
        |:
            ret nil
        }
    }

    // Returns value data of evaluated expression.
    // Returns nil if error occurs.
    fn eval(mut &self, mut expr: &Expr): &Data {
        let mut d = self.evalExprKind(expr.Kind)
        if d == nil || d.Kind == nil {
            ret nil
        }

        match {
        | d.Kind.Fn() != nil:
            let mut f = d.Kind.Fn()
            if f.IsBuiltin() {
                break
            }
            if f.Generics.len != f.Decl.Generics.len {
                self.s.pushErr(expr.Token, LogMsg.HasGenerics)
            }
            if !f.Decl.Statically && f.Decl.IsMethod() {
                self.s.pushErr(expr.Token, LogMsg.MethodNotInvoked)
            }
        }

        ret d
    }

    // Returns value data of evaluated expression.
    // Returns nil if error occurs.
    // Accepts decls as invalid expression.
    fn evalExpr(mut &self, mut expr: &Expr): &Data {
        let mut d = self.eval(expr)
        match {
        | d == nil:
            ret nil
        | d.Decl:
            self.pushErr(expr.Token, LogMsg.InvalidExpr)
            ret nil
        |:
            ret d
        }
    }
}

struct unaryEval {
    e: &Eval
    d: &Data
    u: &UnaryExpr
}

impl unaryEval {
    static fn new(mut e: &Eval): unaryEval {
        ret unaryEval{
            e: e,
        }
    }

    fn minus(mut self) {
        match {
        | self.d.Kind == nil:
            self.d = nil
            ret
        | self.d.Kind.Prim() != nil:
            if !types::IsNum(self.d.Kind.Str()) {
                self.d = nil
                ret
            }
        | self.d.Kind.Struct() != nil:
            if self.d.Kind.Struct().Operators.Neg == nil {
                self.d = nil
                ret
            }
        |:
            self.d = nil
            ret
        }

        if self.d.IsConst() {
            match {
            | self.d.Constant.IsF64():
                self.d.Constant.SetF64(-self.d.Constant.ReadF64())
            | self.d.Constant.IsI64():
                self.d.Constant.SetI64(-self.d.Constant.ReadI64())
            | self.d.Constant.IsU64():
                self.d.Constant.SetI64(-self.d.Constant.AsI64())
            }
        }

        self.d.Lvalue = false
        self.d.Model = &UnaryExprModel{
            Expr: new(Data, *self.d),
            Op: self.u.Op,
        }
    }

    fn plus(mut self) {
        match {
        | self.d.Kind == nil:
            self.d = nil
            ret
        | self.d.Kind.Prim() != nil:
            if !types::IsNum(self.d.Kind.Str()) {
                self.d = nil
                ret
            }
        | self.d.Kind.Struct() != nil:
            if self.d.Kind.Struct().Operators.Pos == nil {
                self.d = nil
                ret
            }
        |:
            self.d = nil
            ret
        }

        if self.d.IsConst() {
            match {
            | self.d.Constant.IsF64():
                self.d.Constant.SetF64(+self.d.Constant.ReadF64())
            | self.d.Constant.IsI64():
                self.d.Constant.SetI64(+self.d.Constant.ReadI64())
            | self.d.Constant.IsU64():
                self.d.Constant.SetI64(+self.d.Constant.AsI64())
            }
        }

        self.d.Lvalue = false
        self.d.Model = &UnaryExprModel{
            Expr: new(Data, *self.d),
            Op: self.u.Op,
        }
    }

    fn caret(mut self) {
        match {
        | self.d.Kind == nil:
            self.d = nil
            ret
        | self.d.Kind.Prim() != nil:
            if !types::IsInt(self.d.Kind.Str()) {
                self.d = nil
                ret
            }
        | self.d.Kind.Struct() != nil:
            if self.d.Kind.Struct().Operators.BitNot == nil {
                self.d = nil
                ret
            }
        |:
            self.d = nil
            ret
        }

        if self.d.IsConst() {
            match {
            | self.d.Constant.IsI64():
                self.d.Constant.SetI64(^self.d.Constant.ReadI64())
            | self.d.Constant.IsU64():
                self.d.Constant.SetU64(^self.d.Constant.ReadU64())
            }
        }

        self.d.Lvalue = false
        self.d.Model = &UnaryExprModel{
            Expr: new(Data, *self.d),
            Op: self.u.Op,
        }
    }

    fn excl(mut self) {
        let t = self.d.Kind.Prim()
        if t == nil || !t.IsBool() {
            self.d = nil
            ret
        }

        if self.d.IsConst() {
            match {
            | self.d.Constant.IsBool():
                self.d.Constant.SetBool(!self.d.Constant.ReadBool())
            }
        }

        self.d.Lvalue = false
        self.d.Model = &UnaryExprModel{
            Expr: new(Data, *self.d),
            Op: self.u.Op,
        }
    }

    fn star(mut self) {
        self.d.Model = &UnaryExprModel{
            Expr: new(Data, *self.d),
            Op: self.u.Op,
        }

        match {
        | self.d.Kind.Ptr() != nil:
            if !self.e.isUnsafe() {
                self.e.pushErr(self.u.Op, LogMsg.UnsafeBehaviorAtOutOfUnsafeScope)
            }

            let mut t = self.d.Kind.Ptr()
            if t.IsUnsafe() {
                self.d = nil
                ret
            }
            self.d.Kind = t.Elem
        | self.d.Kind.Sptr() != nil:
            self.d.Kind = self.d.Kind.Sptr().Elem
        |:
            self.d = nil
            ret
        }

        self.d.Constant = nil
        self.d.Lvalue = true
    }

    fn amper(mut self) {
        match type self.d.Model {
        | &StructLitExprModel:
            let mut lit = (&StructLitExprModel)(self.d.Model)
            makeStructLitAlloc(self.d, lit)
        |:
            match {
            | canGetPtr(self.d):
                self.d.Kind = &TypeKind{
                    Kind: &Ptr{Elem: self.d.Kind},
                }
                self.d.Model = &UnaryExprModel{
                    Expr: new(Data, *self.d),
                    Op: self.u.Op,
                }
            |:
                self.d = nil
            }
        }

        if self.d != nil {
            self.d.Constant = nil
            self.d.Lvalue = false
        }
    }

    fn typeDecl(mut self) {
        let mut tc = typeChecker{
            s: self.e.s,
            lookup: self.e.lookup,
            errorToken: self.u.Op,
        }
        match self.u.Op.Kind {
        | TokenKind.Star:
            self.d.Kind = &TypeKind{Kind: tc.buildPtrFromType(self.d.Kind)}
        | TokenKind.Amper:
            self.d.Kind = &TypeKind{Kind: tc.buildSptrFromType(self.d.Kind)}
        |:
            self.e.pushErr(self.u.Op, LogMsg.InvalidExprForUnary, self.u.Op.Kind, self.d.Kind.Str())
            self.d = nil
            ret
        }
        self.d.Decl = true
    }

    fn evalData(mut self) {
        match self.u.Op.Kind {
        | TokenKind.Star
        | TokenKind.Amper:
            let mut prefix = self.e.prefix
            self.e.prefix = nil
            self.d = self.e.evalExprKind(self.u.Expr.Kind)
            self.e.prefix = prefix
        |:
            self.d = self.e.evalExprKind(self.u.Expr.Kind)
        }
    }

    fn eval(mut self, mut u: &UnaryExpr): &Data {
        self.u = u
        self.evalData()
        if self.d == nil {
            ret nil
        }
        if self.d.Decl {
            self.typeDecl()
            ret self.d
        }

        let kind = self.d.Kind
        match self.u.Op.Kind {
        | TokenKind.Minus:
            self.minus()
        | TokenKind.Plus:
            self.plus()
        | TokenKind.Caret:
            self.caret()
        | TokenKind.Excl:
            self.excl()
        | TokenKind.Star:
            self.star()
        | TokenKind.Amper:
            self.amper()
        |:
            self.d = nil
        }

        match {
        | self.d == nil:
            self.e.pushErr(self.u.Op, LogMsg.InvalidExprForUnary, self.u.Op.Kind, kind.Str())
            ret nil
        | self.d.IsConst():
            self.d.Model = self.d.Constant
        }
        self.d.Mutable = true
        ret self.d
    }
}

struct binaryEval {
    e:  &Eval
    l:  &Data
    r:  &Data
    op: &Token
}

impl binaryEval {
    static fn newPlain(mut e: &Eval): binaryEval {
        ret binaryEval{
            e: e,
        }
    }

    static fn new(mut e: &Eval, mut op: &Token): binaryEval {
        ret binaryEval{
            e: e,
            op: op,
        }
    }

    // Reports whether types are compatible.
    // Also logs error message about incompatibility if types are incompatible.
    fn checkTypeCompatibility(mut self): bool {
        ret self.e.s.checkTypeCompatibility(self.l.Kind, self.r.Kind, self.op)
    }

    fn checkStructCommonOperatorCompatibility(mut self): bool {
        let mut overload: &FnIns = nil
        match self.op.Kind {
        | TokenKind.Lshift:
            overload = self.l.Kind.Struct().Operators.Shl
        | TokenKind.Rshift:
            overload = self.l.Kind.Struct().Operators.Shr
        | TokenKind.Plus:
            overload = self.l.Kind.Struct().Operators.Add
        | TokenKind.Minus:
            overload = self.l.Kind.Struct().Operators.Sub
        | TokenKind.Solidus:
            overload = self.l.Kind.Struct().Operators.Div
        | TokenKind.Star:
            overload = self.l.Kind.Struct().Operators.Mul
        | TokenKind.Percent:
            overload = self.l.Kind.Struct().Operators.Mod
        | TokenKind.Amper:
            overload = self.l.Kind.Struct().Operators.BitAnd
        | TokenKind.Vline:
            overload = self.l.Kind.Struct().Operators.BitOr
        | TokenKind.Caret:
            overload = self.l.Kind.Struct().Operators.BitXor
        |:
            self.e.pushErr(self.op, LogMsg.OperatorNotForJuleType, self.op.Kind, self.l.Kind.Str())
            ret false
        }

        if overload == nil {
            self.e.pushErr(self.op, LogMsg.OperatorNotForJuleType, self.op.Kind, self.l.Kind.Str())
            ret false
        }

        let mut p = overload.Params[1]
        ret self.e.s.checkAssignType(p.Decl.Reference, p.Kind, self.r, self.op)
    }

    fn evalNil(mut self): &Data {
        if !self.r.Kind.NilCompatible() {
            self.e.pushErr(self.op, LogMsg.IncompatibleTypes, TokenKind.Nil, self.r.Kind.Str())
            ret nil
        }

        match self.op.Kind {
        | TokenKind.Eqs
        | TokenKind.NotEq:
            ret &Data{
                Kind: &TypeKind{
                    Kind: buildPrimType(PrimKind.Bool),
                },
            }
        |:
            self.e.pushErr(self.op, LogMsg.OperatorNotForJuleType, self.op.Kind, TokenKind.Nil)
            ret nil
        }
    }

    fn evalEnum(mut self): &Data {
        let mut enm = self.l.Kind.Enum()
        match self.op.Kind {
        | TokenKind.Eqs
        | TokenKind.NotEq:
            let mut rkind = self.r.Kind
            if self.r.Kind.Enum() != nil {
                rkind = self.r.Kind.Enum().Kind.Kind
            }
            if !self.e.s.checkTypeCompatibility(enm.Kind.Kind, rkind, self.op) {
                ret nil
            }
            ret &Data{
                Kind: &TypeKind{
                    Kind: buildPrimType(PrimKind.Bool),
                },
            }
        }

        if self.r.Kind.Enum() == nil || enm != self.r.Kind.Enum() {
            self.e.pushErr(self.op, LogMsg.IncompatibleTypes, enm.Ident, self.r.Kind.Str())
            ret nil
        }

        match self.op.Kind {
        | TokenKind.Gt
        | TokenKind.Lt
        | TokenKind.GreatEq
        | TokenKind.LessEq:
            if !types::IsNum(enm.Kind.Kind.Str()) {
                self.e.pushErr(self.op, LogMsg.OperatorNotForJuleType, self.op.Kind, enm.Ident)
                ret nil
            }
            ret &Data{
                Kind: &TypeKind{
                    Kind: buildPrimType(PrimKind.Bool),
                },
            }
        | TokenKind.Amper
        | TokenKind.Vline
        | TokenKind.Caret:
            if enm.Kind.Kind.Prim() == nil || !types::IsInt(enm.Kind.Kind.Prim().Str()) {
                self.e.pushErr(self.op, LogMsg.OperatorNotForJuleType, self.op.Kind, enm.Ident)
            }
            ret self.l
        |:
            self.e.pushErr(self.op, LogMsg.OperatorNotForJuleType, self.op.Kind, enm.Ident)
            ret nil
        }
    }

    fn evalTypeEnum(mut self): &Data {
        let mut enm = self.l.Kind.TypeEnum()
        if !self.checkTypeCompatibility() {
            ret nil
        }

        match self.op.Kind {
        | TokenKind.Eqs
        | TokenKind.NotEq:
            ret &Data{
                Kind: &TypeKind{
                    Kind: buildPrimType(PrimKind.Bool),
                },
            }
        |:
            self.e.pushErr(self.op, LogMsg.OperatorNotForJuleType, self.op.Kind, enm.Str())
            ret nil
        }
    }

    fn evalSptr(mut self): &Data {
        if !self.checkTypeCompatibility() {
            ret nil
        }

        match self.op.Kind {
        | TokenKind.Eqs
        | TokenKind.NotEq:
            ret &Data{
                Kind: &TypeKind{
                    Kind: buildPrimType(PrimKind.Bool),
                },
            }
        |:
            self.e.pushErr(self.op, LogMsg.OperatorNotForJuleType, self.op.Kind, self.l.Kind.Str())
            ret nil
        }
    }

    fn evalPtr(mut self): &Data {
        match self.op.Kind {
        | TokenKind.Eqs
        | TokenKind.NotEq
        | TokenKind.Lt
        | TokenKind.Gt
        | TokenKind.LessEq
        | TokenKind.GreatEq:
            if !self.checkTypeCompatibility() {
                ret nil
            }
            ret &Data{
                Kind: &TypeKind{
                    Kind: buildPrimType(PrimKind.Bool),
                },
            }
        | TokenKind.Plus
        | TokenKind.Minus:
            if self.l.Kind.Ptr() == nil {
                self.l, self.r = self.r, self.l
            }
            if self.l.Kind.Ptr().IsUnsafe() {
                self.e.pushErr(self.op, LogMsg.OperatorNotForJuleType, self.op.Kind, self.l.Kind.Str())
            }
            if !isPtrArithmeticCompatibleInt(self.r) {
                self.e.pushErr(self.op, LogMsg.IncompatibleTypeForPtrArithmetic, self.r.Kind.Str())
                ret nil
            }
            ret self.l
        |:
            self.e.pushErr(self.op, LogMsg.OperatorNotForJuleType, self.op.Kind, self.l.Kind.Str())
            ret nil
        }
    }

    fn evalArr(mut self): &Data {
        if !self.checkTypeCompatibility() {
            ret nil
        }

        match self.op.Kind {
        | TokenKind.Eqs
        | TokenKind.NotEq:
            ret &Data{
                Kind: &TypeKind{
                    Kind: buildPrimType(PrimKind.Bool),
                },
            }
        |:
            self.e.pushErr(self.op, LogMsg.OperatorNotForJuleType, self.op.Kind, self.l.Kind.Str())
            ret nil
        }
    }

    fn evalSlc(mut self): &Data {
        if !self.checkTypeCompatibility() {
            ret nil
        }

        match self.op.Kind {
        | TokenKind.Eqs
        | TokenKind.NotEq:
            ret &Data{
                Kind: &TypeKind{
                    Kind: buildPrimType(PrimKind.Bool),
                },
            }
        |:
            self.e.pushErr(self.op, LogMsg.OperatorNotForJuleType, self.op.Kind, self.l.Kind.Str())
            ret nil
        }
    }

    fn evalFn(mut self): &Data {
        if !self.checkTypeCompatibility() {
            ret nil
        }

        match self.op.Kind {
        | TokenKind.Eqs
        | TokenKind.NotEq:
            ret &Data{
                Kind: &TypeKind{
                    Kind: buildPrimType(PrimKind.Bool),
                },
            }
        |:
            self.e.pushErr(self.op, LogMsg.OperatorNotForJuleType, self.op.Kind, self.l.Kind.Str())
            ret nil
        }
    }

    fn evalStruct(mut self): &Data {
        match self.op.Kind {
        | TokenKind.Gt:
            if self.l.Kind.Struct().Operators.Gt == nil {
                self.e.pushErr(self.op, LogMsg.OperatorNotForJuleType, self.op.Kind, self.l.Kind.Str())
                ret nil
            }
            ret &Data{
                Kind: &TypeKind{
                    Kind: buildPrimType(PrimKind.Bool),
                },
            }
        | TokenKind.GreatEq:
            if self.l.Kind.Struct().Operators.GtEq == nil {
                self.e.pushErr(self.op, LogMsg.OperatorNotForJuleType, self.op.Kind, self.l.Kind.Str())
                ret nil
            }
            ret &Data{
                Kind: &TypeKind{
                    Kind: buildPrimType(PrimKind.Bool),
                },
            }
        | TokenKind.Lt:
            if self.l.Kind.Struct().Operators.Lt == nil {
                self.e.pushErr(self.op, LogMsg.OperatorNotForJuleType, self.op.Kind, self.l.Kind.Str())
                ret nil
            }
            ret &Data{
                Kind: &TypeKind{
                    Kind: buildPrimType(PrimKind.Bool),
                },
            }
        | TokenKind.LessEq:
            if self.l.Kind.Struct().Operators.LtEq == nil {
                self.e.pushErr(self.op, LogMsg.OperatorNotForJuleType, self.op.Kind, self.l.Kind.Str())
                ret nil
            }
            ret &Data{
                Kind: &TypeKind{
                    Kind: buildPrimType(PrimKind.Bool),
                },
            }
        | TokenKind.Eqs
        | TokenKind.NotEq:
            if !self.checkTypeCompatibility() {
                ret nil
            }
            ret &Data{
                Kind: &TypeKind{
                    Kind: buildPrimType(PrimKind.Bool),
                },
            }
        }

        if !self.checkStructCommonOperatorCompatibility() {
            ret nil
        }
        ret self.l
    }

    fn evalTrait(mut self): &Data {
        if !self.checkTypeCompatibility() {
            ret nil
        }

        match self.op.Kind {
        | TokenKind.Eqs
        | TokenKind.NotEq:
            ret &Data{
                Kind: &TypeKind{
                    Kind: buildPrimType(PrimKind.Bool),
                },
            }
        |:
            self.e.pushErr(self.op, LogMsg.OperatorNotForJuleType, self.op.Kind, self.l.Kind.Str())
            ret nil
        }
    }

    fn evalAny(mut self): &Data {
        match self.op.Kind {
        | TokenKind.Eqs
        | TokenKind.NotEq:
            ret &Data{
                Kind: &TypeKind{
                    Kind: buildPrimType(PrimKind.Bool),
                },
            }
        |:
            self.e.pushErr(self.op, LogMsg.OperatorNotForJuleType, self.op.Kind, PrimKind.Any)
            ret nil
        }
    }

    fn evalBool(mut self): &Data {
        if !self.checkTypeCompatibility() {
            ret nil
        }

        match self.op.Kind {
        | TokenKind.Eqs
        | TokenKind.NotEq
        | TokenKind.DblAmper
        | TokenKind.DblVline:
            ret self.l
        |:
            self.e.pushErr(self.op, LogMsg.OperatorNotForJuleType, self.op.Kind, self.l.Kind.Str())
            ret nil
        }
    }

    fn evalStr(mut self): &Data {
        let mut rk = self.r.Kind.Str()
        if rk != PrimKind.Str {
            self.e.pushErr(self.op, LogMsg.IncompatibleTypes, PrimKind.Str, rk)
            ret nil
        }

        match self.op.Kind {
        | TokenKind.Plus:
            ret self.l
        | TokenKind.Eqs
        | TokenKind.NotEq
        | TokenKind.Lt
        | TokenKind.Gt
        | TokenKind.GreatEq
        | TokenKind.LessEq:
            ret &Data{
                Kind: &TypeKind{
                    Kind: buildPrimType(PrimKind.Bool),
                },
            }
        |:
            self.e.pushErr(self.op, LogMsg.OperatorNotForJuleType, self.op.Kind, PrimKind.Str)
            ret nil
        }
    }

    fn setTypeToGreater(mut self) {
        if self.l.IsConst() {
            if !self.r.IsConst() {
                self.l.Kind = self.r.Kind
                ret
            }
            goto set
        }
        if self.r.IsConst() {
            ret
        }
    set:
        if types::IsGreater(self.r.Kind.Prim().Kind, self.l.Kind.Prim().Kind) {
            self.l.Kind = self.r.Kind
        }
    }

    fn checkModData(mut self, mut &d: &Data) {
        if !d.IsConst() {
            if d.Kind.Prim() == nil || !types::IsInt(d.Kind.Prim().Kind) {
                self.e.pushErr(self.op, LogMsg.ModuloWithNotInt)
            }
            ret
        }
        match {
        | sigAssignable(PrimKind.I64, d):
            d.Constant.SetI64(d.Constant.AsI64())
        | unsigAssignable(PrimKind.U64, d):
            d.Constant.SetU64(d.Constant.AsU64())
        |:
            self.e.pushErr(self.op, LogMsg.ModuloWithNotInt)
        }
    }

    fn mod(mut self) {
        self.checkModData(self.l)
        self.checkModData(self.r)
    }

    fn numbersAreCompatibile(self, &lk: str, &rk: str): bool {
        if !types::IsNum(rk) {
            ret false
        }

        if self.l.IsConst() {
            ret true
        }

        if lk == types::TypeKind.F32 {
            if self.r.IsConst() {
                ret true
            }
            ret rk == types::TypeKind.F32
        }
        if lk == types::TypeKind.F64 {
            if self.r.IsConst() {
                ret true
            }
            ret rk == types::TypeKind.F64
        }

        if self.r.IsConst() {
            ret true
        }

        ret lk == rk
    }

    fn evalFloat(mut self): &Data {
        let lk = self.l.Kind.Prim().Kind // Float guaranteed.
        let rk = self.r.Kind.Prim().Kind // Primitive guaranteed.
        if !self.numbersAreCompatibile(lk, rk) {
            self.e.pushErr(self.op, LogMsg.IncompatibleTypes, lk, rk)
            ret nil
        }

        match self.op.Kind {
        | TokenKind.Lshift
        | TokenKind.Rshift:
            if !self.l.IsConst() || !intAssignable(PrimKind.I64, self.l) {
                self.e.pushErr(self.op, LogMsg.IncompatibleTypes, lk, rk)
                ret nil
            }
            if !self.r.IsConst() || !intAssignable(PrimKind.U64, self.r) {
                self.e.pushErr(self.op, LogMsg.IncompatibleTypes, lk, rk)
                ret nil
            }
            self.l.Constant.SetI64(self.l.Constant.AsI64())
            self.r.Constant.SetU64(self.r.Constant.AsU64())
            if !isOkForShifting(self.r) {
                self.e.pushErr(self.op, LogMsg.BitShiftMustUnsigned)
                ret nil
            }
            ret self.l
        }

        // Logicals.
        match self.op.Kind {
        | TokenKind.Eqs
        | TokenKind.NotEq
        | TokenKind.Lt
        | TokenKind.Gt
        | TokenKind.GreatEq
        | TokenKind.LessEq:
            ret &Data{
                Kind: &TypeKind{
                    Kind: buildPrimType(PrimKind.Bool),
                },
            }
        }

        // Arithmetics.
        match self.op.Kind {
        | TokenKind.Plus
        | TokenKind.Minus
        | TokenKind.Star
        | TokenKind.Solidus:
            self.setTypeToGreater()
            ret self.l
        | TokenKind.Percent:
            if !types::IsInt(rk) {
                self.e.pushErr(self.op, LogMsg.IncompatibleTypes, lk, rk)
                ret nil
            }
            self.mod()
            ret self.r
        |:
            self.e.pushErr(self.op, LogMsg.OperatorNotForFloat, self.op.Kind)
            ret nil
        }
    }

    fn evalInt(mut self): &Data {
        let lk = self.l.Kind.Prim().Kind // Integer guaranteed.
        let rk = self.r.Kind.Prim().Kind // Primitive guaranteed.

        match self.op.Kind {
        | TokenKind.Lshift
        | TokenKind.Rshift:
            if !types::IsInt(lk) || !types::IsInt(rk) {
                self.e.pushErr(self.op, LogMsg.IncompatibleTypes, lk, rk)
                ret nil
            }
            if !isOkForShifting(self.r) {
                self.e.pushErr(self.op, LogMsg.BitShiftMustUnsigned)
                ret nil
            }
            ret self.l
        }

        if !self.numbersAreCompatibile(lk, rk) {
            self.e.pushErr(self.op, LogMsg.IncompatibleTypes, lk, rk)
            ret nil
        }

        // Logicals.
        match self.op.Kind {
        | TokenKind.Eqs
        | TokenKind.NotEq
        | TokenKind.Lt
        | TokenKind.Gt
        | TokenKind.GreatEq
        | TokenKind.LessEq:
            ret &Data{
                Kind: &TypeKind{
                    Kind: buildPrimType(PrimKind.Bool),
                },
            }
        }

        // Arithmetics.
        match self.op.Kind {
        | TokenKind.Plus
        | TokenKind.Minus
        | TokenKind.Star
        | TokenKind.Solidus
        | TokenKind.Amper
        | TokenKind.Vline
        | TokenKind.Caret:
            self.setTypeToGreater()
            ret self.l
        | TokenKind.Percent:
            self.mod()
            self.setTypeToGreater()
            ret self.l
        |:
            self.e.pushErr(self.op, LogMsg.OperatorNotForInt, self.op.Kind)
            ret nil
        }
    }

    fn evalPrim(mut self): &Data {
        let prim = self.l.Kind.Prim()
        match {
        | prim.IsBool():
            ret self.evalBool()
        | prim.IsStr():
            ret self.evalStr()
        }

        if self.r.Kind.Prim() == nil {
            self.e.pushErr(self.op, LogMsg.IncompatibleTypes, prim.Str(), self.r.Kind.Str())
            ret nil
        }

        match {
        | types::IsFloat(prim.Kind):
            ret self.evalFloat()
        | types::IsInt(prim.Kind):
            ret self.evalInt()
        |:
            ret nil
        }
    }

    fn evalOp(mut self): &Data {
        match {
        | self.l.Kind.Void():
            self.e.pushErr(self.op, LogMsg.OperatorNotForJuleType, self.op.Kind, "void")
            ret nil
        | self.r.Kind.Prim() != nil && self.r.Kind.Prim().IsAny():
            self.l, self.r = self.r, self.l
            fall
        | self.l.Kind.Prim() != nil && self.l.Kind.Prim().IsAny():
            ret self.evalAny()
        | self.r.Kind.TypeEnum() != nil:
            self.l, self.r = self.r, self.l
            fall
        | self.l.Kind.TypeEnum() != nil:
            ret self.evalTypeEnum()
        | self.l.Kind.IsNil():
            ret self.evalNil()
        | self.r.Kind.Enum() != nil:
            self.l, self.r = self.r, self.l
            fall
        | self.l.Kind.Enum() != nil:
            ret self.evalEnum()
        | self.r.Kind.Sptr() != nil:
            self.l, self.r = self.r, self.l
            fall
        | self.l.Kind.Sptr() != nil:
            ret self.evalSptr()
        | self.r.Kind.Ptr() != nil:
            self.l, self.r = self.r, self.l
            fall
        | self.l.Kind.Ptr() != nil:
            ret self.evalPtr()
        | self.l.Kind.Arr() != nil:
            ret self.evalArr()
        | self.l.Kind.Slc() != nil:
            ret self.evalSlc()
        | self.l.Kind.Fn() != nil:
            ret self.evalFn()
        | self.r.Kind.Trait() != nil:
            self.l, self.r = self.r, self.l
            fall
        | self.l.Kind.Trait() != nil:
            ret self.evalTrait()
        | self.l.Kind.Struct() != nil:
            ret self.evalStruct()
        | self.l.Kind.Prim() != nil:
            ret self.evalPrim()
        |:
            ret nil
        }
    }

    fn evalConst(mut self, mut &d: &Data) {
        match {
        | d == nil:
            ret
        | !self.l.IsConst()
        | !self.r.IsConst():
            d.Constant = nil
            ret
        }

        match self.op.Kind {
        | TokenKind.Eqs:
            d.Constant = Const.NewBool(self.l.Constant.Eq(*self.r.Constant))
        | TokenKind.NotEq:
            d.Constant = Const.NewBool(!self.l.Constant.Eq(*self.r.Constant))
        | TokenKind.DblVline:
            d.Constant = Const.NewBool(self.l.Constant.Or(*self.r.Constant))
        | TokenKind.DblAmper:
            d.Constant = Const.NewBool(self.l.Constant.And(*self.r.Constant))
        | TokenKind.Gt:
            d.Constant = Const.NewBool(self.l.Constant.Gt(*self.r.Constant))
        | TokenKind.Lt:
            d.Constant = Const.NewBool(self.l.Constant.Lt(*self.r.Constant))
        | TokenKind.GreatEq:
            d.Constant = Const.NewBool(self.l.Constant.GtEq(*self.r.Constant))
        | TokenKind.LessEq:
            d.Constant = Const.NewBool(self.l.Constant.LtEq(*self.r.Constant))
        | TokenKind.Plus:
            _ = self.l.Constant.Add(*self.r.Constant)
            d.Constant = self.l.Constant
        | TokenKind.Minus:
            _ = self.l.Constant.Sub(*self.r.Constant)
            d.Constant = self.l.Constant
        | TokenKind.Star:
            _ = self.l.Constant.Mul(*self.r.Constant)
            d.Constant = self.l.Constant
        | TokenKind.Solidus:
            let ok = self.l.Constant.Div(*self.r.Constant)
            if !ok && self.r.Constant.AsF64() == 0 {
                self.e.pushErr(self.op, LogMsg.DivByZero)
            }
            d.Constant = self.l.Constant
            let mut prim = d.Kind.Prim()
            match {
            | types::IsSigInt(prim.Kind):
                d.Constant.SetI64(d.Constant.AsI64())
            | types::IsUnsigInt(prim.Kind):
                d.Constant.SetU64(d.Constant.AsU64())
            }
        | TokenKind.Percent:
            let ok = self.l.Constant.Mod(*self.r.Constant)
            if !ok && self.r.Constant.AsF64() == 0 {
                self.e.pushErr(self.op, LogMsg.DivByZero)
            }
            d.Constant = self.l.Constant
        | TokenKind.Vline:
            _ = self.l.Constant.BitwiseOr(*self.r.Constant)
            d.Constant = self.l.Constant
        | TokenKind.Amper:
            _ = self.l.Constant.BitwiseAnd(*self.r.Constant)
            d.Constant = self.l.Constant
        | TokenKind.Caret:
            _ = self.l.Constant.Xor(*self.r.Constant)
            d.Constant = self.l.Constant
        | TokenKind.Lshift:
            _ = self.l.Constant.Lshift(*self.r.Constant)
            d.Constant = self.l.Constant
        | TokenKind.Rshift:
            _ = self.l.Constant.Rshift(*self.r.Constant)
            d.Constant = self.l.Constant
        }

        applyCastModelByEnum(d, d.Kind.Enum())

        let mut prim = d.Kind.Prim()
        if prim == nil || !types::IsNum(prim.Str()) {
            d.Model = d.Constant
            ret
        }
        if self.op.Kind != TokenKind.Lshift && self.op.Kind != TokenKind.Rshift {
            if self.l.Constant == self.l.Model && self.r.Constant != self.r.Model {
                // Right constant is not pure, use type r's type.
                d.Kind = self.r.Kind
                prim = d.Kind.Prim()
            }
        }
        fitBitsize(d)
        castConstByType(prim.Kind, d)
    }

    fn checkData(mut self, mut &d: &Data) {
        let f = d.Kind.Fn()
        if f != nil && f.Decl != nil && f.Decl.IsMethod() {
            self.e.pushErr(self.op, LogMsg.InvalidExprForBinop)
        }
    }

    fn checkDatas(mut self) {
        self.checkData(self.l)
        self.checkData(self.r)
    }

    fn setModel(mut self, mut &d: &Data) {
        if d.IsConst() {
            if self.l.Constant == self.l.Model && self.r.Constant == self.r.Model {
                // Left and right are pure constant.
                // Do not break this with changing Model:.
                ret
            }
        }
        let (mut l, mut r) = self.l, self.r
        if !l.GoodOperand(r) {
            l, r = r, l
        }

        d.Model = &BinopExprModel{
            Left: &OperandExprModel{
                Kind: l.Kind,
                Model: l.Model,
            },
            Right: &OperandExprModel{
                Kind: r.Kind,
                Model: r.Model,
            },
            Op: self.op,
        }
    }

    fn postEval(mut self, mut &d: &Data) {
        d.Lvalue = false
        self.setModel(d)
    }

    fn solveExplicit(mut self, mut &l: &Data, mut &r: &Data): &Data {
        self.l, self.r = l, r

        self.checkDatas()

        let mut d = self.evalOp()

        // Save normal order
        self.l, self.r = l, r

        self.evalConst(d)

        if d != nil {
            d.Mutable = true
            self.postEval(d)
        }

        ret d
    }

    fn eval(mut self, mut &op: &BinopExpr): &Data {
        if op.Op.Kind == TokenKind.Eq {
            self.e.pushErr(op.Op, LogMsg.AssignInExpr)
            self.e.pushSugggestion(LogMsg.UseImperative)
            ret nil
        }

        let mut l = self.e.evalExprKind(op.Left.Kind)
        if l == nil || l.Kind == nil {
            ret nil
        }

        let mut prefix = self.e.prefix
        self.e.prefix = l.Kind
        defer { self.e.prefix = prefix }
        let mut r = self.e.evalExprKind(op.Right.Kind)
        if r == nil || r.Kind == nil {
            ret nil
        }

        self.op = op.Op

        let mut d = self.solveExplicit(l, r)

        // Save rune type.
        if d != nil && l.IsRune && r.IsRune {
            d.IsRune = true
        }

        ret d
    }
}

// Returns directive if exist.
fn findDirective(mut &directives: []&ast::Directive, d: Directive): &ast::Directive {
    for (_, mut dr) in directives {
        if dr.Tag.Kind == d {
            ret dr
        }
    }
    ret nil
}

fn findBuiltinsImport(ident: str, imp: &ImportInfo): any {
    ret findPackageBuiltinDef(imp.LinkPath, ident)
}

// If current type is not enough to store constant data, update to minimum type
// that can store constant data. This function designed for numerical types only.
// Data should be numerical constant of course.
fn fitBitsize(mut &d: &Data) {
    let mut prim = d.Kind.Prim()
    let z = types::BitsizeOf(prim.Str())
    if z == 1<<6 {
        // z is already equals to biggest bitsize.
        ret
    }
    let mut k = 0
    match {
    | d.Constant.IsI64():
        k = types::BitsizeOfInt(d.Constant.ReadI64())
        if k > z {
            prim.Kind = types::IntFromBits(k)
        }
    | d.Constant.IsU64():
        k = types::BitsizeOfUint(d.Constant.ReadU64())
        if k > z {
            prim.Kind = types::UintFromBits(k)
        }
    | d.Constant.IsF64():
        k = types::BitsizeOfFloat(d.Constant.ReadF64())
        if k > z {
            prim.Kind = types::FloatFromBits(k)
        }
    }
}

fn makeStructLitAlloc(mut &d: &Data, mut &lit: &StructLitExprModel) {
    d.Kind = &TypeKind{
        Kind: &Sptr{
            Elem: &TypeKind{Kind: lit.Strct},
        },
    }
    d.Model = &AllocStructLitExprModel{
        Lit: lit,
    }
}

fn buildErrorVar(mut &s: &Scope, mut &fc: &FnCallExpr): &Var {
    ret &Var{
        Used: true,
        Reference: false,
        Mutable: true,
        Ident: "error",
        Token: fc.Token,
        Kind: &TypeSymbol{
            Kind: &TypeKind{
                Kind: buildPrimType(PrimKind.Any),
            },
        },
        Scope: s,
        Value: &Value{
            Data: new(Data),
        },
    }
}

fn findBuiltinsSema(ident: str, mut s: &Sema): any {
    for (_, mut imp) in s.file.Imports {
        if imp.ImportAll || imp.existIdent(ident) {
            let mut def = findBuiltinsImport(ident, imp)
            if def != nil {
                ret def
            }
        }
    }

    // If package is std, check for internal builtin defines.
    let mut ppath = s.file.File.Dir()
    if strings::HasPrefix(ppath, PathStdlib) {
        // Remove STDLIB directory path.
        ppath = ppath[PathStdlib.len:]
        // Add "std" to beginning without separator
        // because path has separator at beginning.
        ppath = "std" + strings::Replace(ppath, str(path::Separator), "::", -1)

        ret findPackageBuiltinDef(ppath, ident)
    }

    ret nil
}

fn isOkForShifting(mut &d: &Data): bool {
    if d.IsConst() {
        match {
        | d.Constant.IsI64():
            ret d.Constant.ReadI64() >= 0
        | d.Constant.IsU64():
            ret true
        | d.Constant.IsF64():
            ret d.Constant.ReadF64() >= 0
        |:
            ret false
        }
    }
    let prim = d.Kind.Prim()
    ret prim != nil && types::IsInt(prim.Str())
}

fn isInstancedStruct(s: &StructIns): bool {
    ret s.Decl.Generics.len == s.Generics.len
}

fn isPtrArithmeticCompatibleInt(mut &d: &Data): bool {
    if d.IsConst() {
        ret intAssignable(types::TypeKind.Int, d)
    }
    let mut tcc = typeCompatibilityChecker{
        dest: &TypeKind{
            Kind: buildPrimType(types::TypeKind.Int),
        },
        src: d.Kind,
    }
    ret tcc.check()
}

fn applyCastKindModel(mut &d: &Data, mut &t: &TypeKind) {
    d.Model = &CastingExprModel{
        Expr: d.Model,
        Kind: t,
        ExprKind: d.Kind,
    }
}

fn applyCastKind(mut &d: &Data, mut &t: &TypeKind) {
    applyCastKindModel(d, t)
    d.Kind = t
}

fn buildVoidData(): &Data {
    ret &Data{
        Kind: &TypeKind{
            Kind: buildPrimType("void"),
        },
    }
}

fn checkDataForIntegerIndexing(mut &d: &Data): (err_fmt: LogMsg) {
    if d == nil {
        ret LogMsg.Empty
    }

    match {
    | d.Kind.Prim() == nil:
        ret LogMsg.InvalidTypeForIndexing
    | !types::IsInt(d.Kind.Prim().Str()):
        ret LogMsg.InvalidTypeForIndexing
    | d.IsConst():
        if d.Constant.AsF64() < 0 {
            ret LogMsg.OverflowLimits
        }
    | d.Kind.Prim() == nil
    | d.IsConst()
    | types::RealKindOf(d.Kind.Prim().Str()) != types::RealKindOf(PrimKind.Int):
        let mut t = &TypeKind{Kind: buildPrimType(PrimKind.Int)}
        applyCastKind(d, t)
    }
    ret LogMsg.Empty
}

// Applies casting Model: to data by enum.
// This is necessary to keep exact same type of enum's field type.
// The parameter d should be constant data.
fn applyCastModelByEnum(mut &d: &Data, mut e: &Enum) {
    if e == nil {
        ret
    }
    let p = e.Kind.Kind.Prim()
    if p.IsStr() {
        ret
    }
    applyCastKindModel(d, e.Kind.Kind)
}

fn castConstByType(&t: str, mut &d: &Data) {
    match {
    | types::IsSigInt(t):
        match types::BitsizeOf(types::RealKindOf(t)) {
        | 1 << 6:
            d.Constant.SetI64(d.Constant.AsI64())
        | 1 << 5:
            d.Constant.SetI64(i64(i32(d.Constant.AsI64())))
        | 1 << 4:
            d.Constant.SetI64(i64(i16(d.Constant.AsI64())))
        | 1 << 3:
            d.Constant.SetI64(i64(i8(d.Constant.AsI64())))
        }
    | types::IsUnsigInt(t):
        match types::BitsizeOf(types::RealKindOf(t)) {
        | 1 << 6:
            d.Constant.SetU64(d.Constant.AsU64())
        | 1 << 5:
            d.Constant.SetU64(u64(u32(d.Constant.AsU64())))
        | 1 << 4:
            d.Constant.SetU64(u64(u16(d.Constant.AsU64())))
        | 1 << 3:
            d.Constant.SetU64(u64(u8(d.Constant.AsU64())))
        }
    | types::IsFloat(t):
        match types::BitsizeOf(types::RealKindOf(t)) {
        | 1 << 6:
            d.Constant.SetF64(d.Constant.AsF64())
        | 1 << 5:
            d.Constant.SetF64(f64(f32(d.Constant.AsF64())))
        }
    }
}

fn updateModelToGenericIns(mut &m: ExprModel, mut &f: &FnIns) {
    match type m {
    | &FnIns:
        m = f
    | &StructSubIdentExprModel:
        (&StructSubIdentExprModel)(m).Method = f
    | &StructStaticIdentExprModel:
        (&StructStaticIdentExprModel)(m).Method = f
    }
}

fn pushSubIdentFromExpr(mut expr: ExprData, mut &t: &SubIdentTypeDecl): bool {
    match type expr {
    | &IdentExpr:
        let mut e = (&IdentExpr)(expr)
        t.Idents = append(t.Idents, &IdentTypeDecl{
            Token: e.Token,
            Ident: e.Ident,
        })
    | &SubIdentExpr:
        let mut e = (&SubIdentExpr)(expr)
        if !pushSubIdentFromExpr(e.Expr.Kind, t) {
            ret false
        }
        t.Idents = append(t.Idents, &IdentTypeDecl{
            Token: e.Ident,
            Ident: e.Ident.Kind,
        })
    |:
        ret false
    }
    ret true
}
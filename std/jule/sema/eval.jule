// Copyright 2023-2025 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/conv"
use "std/jule"
use "std/jule/ast"
use "std/jule/build"
use "std/jule/constant"
use "std/jule/constant/lit"
use "std/jule/directive"
use "std/jule/internal/mod"
use "std/jule/log"
use "std/jule/token"
use "std/jule/types"
use "std/math"
use "std/math/big"
use "std/os/filepath"
use "std/strings"
use "std/unsafe"

// Bitsize limit of comptime arbitrary large literals.
const bitLimit = 256

// Value.
struct Value {
	// Means data is have not any exact strict type. Possibly constant.
	// For most untyped data, it probably a numeric.
	untyped: bool

	Type:      &Type
	Mutable:   bool
	Reference: bool
	Lvalue:    bool
	IsRune:    bool
	Model:     Expr

	// True if kind is declaration such as:
	//	- &Enum
	//	- &Struct
	//	- int type
	//	- bool type
	// If this is true, Model might be nil or something.
	// Use the Type field to handle declaration type.
	Decl: bool

	// Constant expression data.
	Constant: &constant::Const
}

impl Value {
	// Reports whether Value is nil literal.
	fn IsNil(*self): bool {
		ret self.Type.IsNil()
	}

	// Reports whether Value is void.
	fn IsVoid(*self): bool {
		ret self.Type.Void()
	}

	// Reports whether Value is constant expression.
	fn IsConst(*self): bool {
		ret self.Constant != nil
	}

	// See developer reference (9.2).
	// Reports left and right operand is good order.
	// If reports false, left and right operand should be swapped.
	// Accepts itself as left operand.
	fn GoodOperand(*self, mut other: &Value): bool {
		if other.Type.TypeEnum() != nil {
			ret false
		}
		ret (other.Type.Prim() == nil || !other.Type.Prim().IsAny()) &&
			other.Type.Trait() == nil &&
			!self.Type.IsNil()
	}
}

// Value.
struct ValueSym {
	Expr:  &ast::Expr
	Value: &Value
}

// Information about expressions that evaluating for assignments.
struct target {
	ignored: bool // whether the destination ignores the evaluated expression.
	mutable: bool // Will be assigned to the mutable storage.
}

// Eval flags.
const (
	evalDefault       = 0         // Default evaluation mode.
	evalPhysicalMem   = 1 << iota // Checks whether the value is sutaible for physical memory.
	evalUnwrapUntyped             // Unwraps untyped literal value to physical memory with default type.
	evalExceptional               // Allows calling exceptional functions.
	evalRefptr                    // Eval for reference pointer memory.
)

struct eval {
	s:          &sema // Used for error logging.
	lookup:     Lookup
	prefix:     &Type
	unsafety:   bool
	disBuiltin: bool      // Disallow/suppress Jule's built-in defines.
	owner:      &Var      // Global variable, which is owner of this evaluation.
	field:      &FieldIns // Field of this default expression. Used for checking cycles and dependency collection.
	target:     target

	// The built-in iota variable.
	// The Used field is also a flag whether the iota variable used,
	// therefore it should be set to the false to catch use cases.
	// The default state is false for both flags.
	varIota: &Var
}

impl eval {
	fn pushErr(mut *self, token: &token::Token, fmt: str, args: ...any) {
		self.s.pushErr(token, fmt, args...)
	}

	// Push suggestion to last log.
	fn pushSuggestion(mut *self, fmt: str, args: ...any) {
		self.s.pushSuggestion(fmt, args...)
	}

	fn allowBuiltin(mut *self) {
		self.disBuiltin = false
	}

	fn disallowBuiltin(mut *self) {
		self.disBuiltin = true
	}

	// Reports whether evaluation in unsafe scope.
	fn isUnsafe(*self): bool {
		ret self.unsafety
	}

	// Reports whether evaluated expression is in global scope.
	fn isGlobal(*self): bool {
		_, ok := self.lookup.(&sema)
		ret ok
	}

	fn applyNumericPrefix(mut *self, mut v: &Value): bool {
		if v == nil ||
			!v.IsConst() ||
			v.Type.Prim() == nil ||
			self.prefix == nil {
			ret false
		}
		prim := self.prefix.Prim()
		if prim == nil {
			ret false
		}

		match {
		| types::IsFloat(prim.Str()):
			v.Type = new(Type, *self.prefix)
			v.Constant.SetF64(v.Constant.AsF64())
			v.Constant.Kind = prim.Kind
		| types::IsSigInt(prim.Str()):
			if !sigAssignable(prim.Str(), v) {
				ret false
			}
			v.Type = new(Type, *self.prefix)
			v.Constant.SetI64(v.Constant.AsI64())
			v.Constant.Kind = prim.Kind
		| types::IsUnsigInt(prim.Str()):
			if !unsigAssignable(prim.Str(), v) {
				ret false
			}
			v.Type = new(Type, *self.prefix)
			v.Constant.SetU64(v.Constant.AsU64())
			v.Constant.Kind = prim.Kind
		}
		ret true
	}

	fn litStr(mut *self, l: &ast::LitExpr): &Value {
		mut s := ""
		if l.Value[0] == '`' {
			s = lit::ToRawStr(l.Value)
		} else {
			mut errors := []lit::Error(nil)
			s, errors = lit::ToStr(l.Value)
			if len(errors) != 0 {
				self.s.pushErrorsFromLitErrors(l.Token, errors)
				ret nil
			}
		}
		mut constant := constant::Const.NewStr(s)

		ret &Value{
			untyped: true,
			Mutable: true,
			Constant: constant,
			Type: primStr,
			Model: constant,
		}
	}

	fn litRune(mut *self, l: &ast::LitExpr): &Value {
		r, errors := lit::ToRune(l.Value)
		if len(errors) != 0 {
			self.s.pushErrorsFromLitErrors(l.Token, errors)
			ret nil
		}
		mut data := &Value{
			Constant: constant::Const.NewI64(i64(r)),
		}

		if r <= 255 {
			data.Type = findBuiltinTypeAlias("byte").TypeSym.Type
		} else {
			data.Type = findBuiltinTypeAlias("rune").TypeSym.Type
		}

		data.Model = &RuneExpr{Code: r}
		data.Mutable = true
		data.IsRune = true
		data.untyped = true
		ret data
	}

	fn litFloat(mut *self, l: &ast::LitExpr): &Value {
		f := conv::ParseFloat(l.Value, 64) else {
			self.pushErr(l.Token, log::ConstantOverflow)
			ret nil
		}
		mut constant := constant::Const.NewF64(f)
		ret &Value{
			untyped: true,
			Mutable: true,
			Constant: constant,
			Type: primF64,
			Model: constant,
		}
	}

	fn litImag(mut *self, l: &ast::LitExpr): &Value {
		f := conv::ParseFloat(l.Value[:len(l.Value)-1], 64) else {
			self.pushErr(l.Token, log::ConstantOverflow)
			ret nil
		}
		mut constant := constant::Const.NewCmplx128(0, f)
		ret &Value{
			untyped: true,
			Mutable: true,
			Constant: constant,
			Type: primCmplx128,
			Model: constant,
		}
	}

	fn litInt(mut *self, l: &ast::LitExpr): &Value {
		// Maximum value of bitLimit integer.
		const (
			maxbinary  = "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
			maxoctal   = "17777777777777777777777777777777777777777777777777777777777777777777777777777777777777"
			maxdecimal = "115792089237316195423570985008687907853269984665640564039457584007913129639935"
			maxhex     = "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
		)
		match {
		| strings::HasPrefix(l.Value, "0x"): // Hexadecimal
			lit := l.Value[2:]
			n := len(lit) - strings::Count(lit, "_")
			if n > len(maxhex) {
				self.pushErr(l.Token, log::ConstantOverflow)
				ret nil
			}
		| strings::HasPrefix(l.Value, "0b"): // Binary
			lit := l.Value[2:]
			n := len(lit) - strings::Count(lit, "_")
			if n > len(maxbinary) {
				self.pushErr(l.Token, log::ConstantOverflow)
				ret nil
			}
		| strings::HasPrefix(l.Value, "0o"): // Ocatal
			lit := l.Value[2:]
			n := len(lit) - strings::Count(lit, "_")
			if n > len(maxoctal) {
				self.pushErr(l.Token, log::ConstantOverflow)
				ret nil
			}
		| l.Value[0] == '0' && len(l.Value) > 1: // Octal
			lit := l.Value[1:]
			n := len(lit) - strings::Count(lit, "_")
			if n > len(maxoctal) {
				self.pushErr(l.Token, log::ConstantOverflow)
				ret nil
			}
		|:
			// Decimal
			lit := l.Value[1:]
			n := len(lit) - strings::Count(lit, "_")
			if n > len(maxdecimal) {
				self.pushErr(l.Token, log::ConstantOverflow)
				ret nil
			}
		}

		mut v := new(Value)
		i, _ := big::Int.Parse(l.Value, 0)
		if i.BitLen() > bitLimit {
			self.pushErr(l.Token, log::ConstantOverflow)
			ret nil
		}
		v.Constant = constant::Const.NewInt(i)
		v.Type = primInt // Default type for unwrap.
		v.Model = v.Constant
		v.untyped = true
		_ = self.applyNumericPrefix(v)
		ret v
	}

	fn evalLit(mut *self, lit: &ast::LitExpr): &Value {
		match lit.Token.ID {
		| token::STR:
			ret self.litStr(lit)
		| token::RUNE:
			ret self.litRune(lit)
		| token::FLOAT:
			ret self.litFloat(lit)
		| token::INT:
			ret self.litInt(lit)
		| token::IMAG:
			ret self.litImag(lit)
		|:
			panic("unreachable")
		}
	}

	fn findBuiltins(mut *self, name: str): any {
		if mod::IsPub(name) {
			match type self.lookup {
			| &ImportInfo:
				mut def := findBuiltinsImport(name, self.lookup.(&ImportInfo))
				if def != nil {
					ret def
				}
			| &sema:
				mut def := findBuiltinsSema(name, self.lookup.(&sema))
				if def != nil {
					ret def
				}
			| &scopeChecker:
				mut def := findBuiltinsSema(name, self.lookup.(&scopeChecker).s)
				if def != nil {
					ret def
				}
			}
			ret nil
		}
		if self.disBuiltin {
			ret nil
		}
		ret findBuiltinDef(name)
	}

	fn getDef(mut *self, name: str, _bind: bool): any {
		// Return nil for blank identifiers.
		if jule::IsBlank(name) {
			ret nil
		}

		// Find variables and type aliases first.
		// Because self.lookup might be a scopeChecker, and shadowing may occurred.
		// If any variable or type aliases is shadowing other declarations such us structure,
		// it will result as wrong expression evaluation.
		mut v := self.lookup.FindVar(name, _bind)
		if v != nil {
			ret v
		}

		mut ta := self.lookup.FindTypeAlias(name, _bind)
		if ta != nil {
			ret ta
		}

		if !_bind {
			mut t := self.lookup.FindTrait(name)
			if t != nil {
				ret t
			}

			mut enm := self.lookup.FindEnum(name)
			if enm != nil {
				ret enm
			}

			mut tenm := self.lookup.FindTypeEnum(name)
			if tenm != nil {
				ret tenm
			}
		}

		mut f := self.lookup.FindFunc(name, _bind)
		if f != nil {
			ret f
		}

		mut s := self.lookup.FindStruct(name, _bind)
		if s != nil {
			ret s
		}

		// Special variables.
		match name {
		| "iota":
			if self.varIota == nil {
				ret nil
			}
			ret self.varIota
		}

		ret self.findBuiltins(name)
	}

	fn getOwnerRefers(mut *self): &ReferenceStack {
		match type self.lookup {
		| &scopeChecker:
			ret self.lookup.(&scopeChecker).getOwnerRefers()
		|:
			// Push reference to owner if global.
			if self.owner != nil &&
				self.owner.Scope == nil {
				ret self.owner.Refers
			}
			// If field exist, push reference to struct.
			if self.field != nil {
				ret self.field.Owner.Refers
			}
		}
		ret nil
	}

	fn pushReference[T](mut *self, mut ref: &T) {
		mut refers := self.getOwnerRefers()
		if refers != nil && !refers.Exist(ref) {
			refers.Push(ref)
		}
	}

	fn _evalEnum(*self, mut enm: &Enum): &Value {
		ret &Value{
			Decl: true,
			Type: &Type{
				Kind: enm,
			},
		}
	}

	fn evalEnum(mut *self, mut enm: &Enum, errorToken: &token::Token): &Value {
		if !self.s.isAccessibleDefine(enm.Public, enm.Token) {
			self.pushErr(errorToken, log::IdentIsNotAccessible, enm.Name)
			self.pushSuggestion(log::MakePubToAccess)
			ret nil
		}
		ret self._evalEnum(enm)
	}

	fn _evalTypeEnum(*self, mut enm: &TypeEnum): &Value {
		ret &Value{
			Decl: true,
			Type: &Type{
				Kind: enm,
			},
		}
	}

	fn evalTypeEnum(mut *self, mut enm: &TypeEnum, errorToken: &token::Token): &Value {
		if !self.s.isAccessibleDefine(enm.Public, enm.Token) {
			self.pushErr(errorToken, log::IdentIsNotAccessible, enm.Name)
			self.pushSuggestion(log::MakePubToAccess)
			ret nil
		}
		ret self._evalTypeEnum(enm)
	}

	fn _evalStruct(*self, mut s: &StructIns): &Value {
		mut v := &Value{
			Decl: true,
			Type: &Type{
				Kind: s,
			},
			Model: s,
		}
		ret v
	}

	fn evalStruct(mut *self, mut s: &Struct, mut errorToken: &token::Token): &Value {
		if !self.s.isAccessibleDefine(s.Public, s.Token) {
			self.pushErr(errorToken, log::IdentIsNotAccessible, s.Name)
			self.pushSuggestion(log::MakePubToAccess)
			ret nil
		}

		mut ins := s.instance()
		if len(s.Generics) == 0 {
			// For generics; it is safe. Because compiler should disallow using
			// genericed structures without instantiation. So, structures should be
			// instantiated. But, there is no generics, structure may have different
			// instances. So, append instance to structure if not exist, use
			// the existing instance if exist already.
			mut exist := s.appendInstance(ins)
			if exist != nil {
				ins = exist
			} else {
				// If this is a new instance; precheck structure instance to make ready.
				if !self.s.precheckStructIns(ins, nil, errorToken) {
					ret nil
				}
			}
		}
		self.pushReference(ins)
		ret self._evalStruct(ins)
	}

	fn evalFuncIns(*self, mut f: &FuncIns): &Value {
		ret &Value{
			Type: &Type{
				Kind: f,
			},
			Model: f,
		}
	}

	fn evalFunc(mut *self, mut f: &Func, errorToken: &token::Token): &Value {
		if !self.s.isAccessibleDefine(f.Public, f.Token) {
			self.pushErr(errorToken, log::IdentIsNotAccessible, f.Name)
			self.pushSuggestion(log::MakePubToAccess)
			ret nil
		}

		mut ins := f.instance()
		if len(f.Generics) == 0 {
			// For generics; it is safe. Because compiler should disallow using
			// genericed functions without instantiation. So, functions should be
			// instantiated. But, there is no generics, function may have different
			// instances. So, append instance to function if not exist, use
			// the existing instance if exist already.
			mut exist := f.appendInstance(ins)
			if exist != nil {
				ins = exist
			}
		}
		self.pushReference(ins)
		ret self.evalFuncIns(ins)
	}

	fn evalVar(mut *self, mut v: &Var, errorToken: &token::Token): &Value {
		// Do not check accessibility if variable is scope-based.
		// If this variable is available, it should be defined in the scope.
		// Then, it is accessible.
		if v.Scope == nil && !self.s.isAccessibleDefine(v.Public, v.Token) {
			self.pushErr(errorToken, log::IdentIsNotAccessible, v.Name)
			self.pushSuggestion(log::MakePubToAccess)
			ret nil
		}

		if v.Token == nil {
			// Variable is built-in.
			v.Used = true
			goto data
		}

		match type self.lookup {
		| &scopeChecker:
			mut s := self.lookup.(&scopeChecker)
			mut root := s.getRoot()
			if v.Scope != nil && !v.Constant && root.captured != nil && isVarCaptured(root, s, v) {
				// Push variable if it is not constant and global.
				// Only capture scope variables.
				root.pushCaptured(v)
			}
			if !v.Reference || self.isUnsafe() {
				break
			}
			for s.owner == nil && s.parent != nil {
				s = s.parent
			}
			// If scope owner is an anonymous function, it may be a closure.
			// But closures performs risky memory handling for references. So catch them.
			// Just one exception: deferred scope functions safe for references.
			if s.owner != nil && !s.owner.Scope.Deferred && s.owner.Anon && v.Scope != s.owner.Scope {
				self.pushErr(errorToken, log::UsedRefInAnonFuncFromParentScope, v.Name)
			}
		}

		// Push reference to global variable.
		if v.Scope == nil {
			self.pushReference(v)
		}

		// Value is nil, kind is not determined.
		// In other word, not analyzed yet.
		// But this variable is dependency, therefore check this for eval.
		// Do not check if v.Used is true. It means it already analyzed.
		// If variable is global, it should be have initialize expression.
		// So, nil value means something may be wrong.
		if !v.Checked && !v.Bind && v.Scope == nil && (v.ValueSym == nil || v.ValueSym.Value == nil) {
			// Save source file of global variable.
			// Use it for evaluation and checking for correct analysis.
			// Otherwise, evaluation problems may occur.
			// Especially if variable uses use declaration namespaces in expression.
			mut varfile := findVarFileInPackage(self.s.files, v)
			mut file := self.s.getCurrentFile()
			self.s.setCurrentFile(varfile)

			// Variable is in global scope.
			// Use sema for lookup.
			self.s.checkVar(v, self.s)

			// Save the original file.
			self.s.setCurrentFile(file)
		}
		// variable guaranteed to be checked
		// any missing information means analysis failed
		// kind should not be nil because each variable must have a valid type
		// we also have to check the value for enum variables
		v.Used = true
		if v.TypeSym == nil || v.TypeSym.Type == nil ||
			v.IsEnumField() && (v.ValueSym == nil || v.ValueSym.Value == nil) {
			ret nil
		}

	data:
		mut val := &Value{
			Lvalue: !v.Constant,
			Mutable: v.Mutable,
			Reference: v.Reference,
			Type: v.TypeSym.Type,
			Model: v,
		}
		if v.ValueSym != nil && v.ValueSym.Value != nil {
			if !v.Bind && v.IsInitialized() {
				val.IsRune = v.ValueSym.Value.IsRune
			}
			if v.Constant && v.ValueSym.Value.Constant != nil {
				val.Constant = new(constant::Const, *v.ValueSym.Value.Constant)
				val.Model = val.Constant
				if v.untypedConstant() {
					val.untyped = true
					self.applyNumericPrefix(val)
				}
			}
		}

		ret val
	}

	fn evalTypeAlias(mut *self, mut ta: &TypeAlias, errorToken: &token::Token): &Value {
		if !self.s.isAccessibleDefine(ta.Public, ta.Token) {
			self.pushErr(errorToken, log::IdentIsNotAccessible, ta.Name)
			self.pushSuggestion(log::MakePubToAccess)
			ret nil
		}

		ta.Used = true

		mut kind := ta.TypeSym.Type.Kind
		let mut v: &Value = nil
		match type kind {
		| &StructIns:
			// Eval structure instance directly.
			// No risk for instantiation because type aliases always points to
			// valid instance even with generics.
			//
			// For strict type aliases, their type structure may be not checked.
			// So, there is possible risk for type analysis and other semantics.
			// For example:
			//	The "std/comptime" package provides the TypeOf function,
			//	which is returns type information. This function may take
			//	type alias as argument. Like: comptime::TypeOf(Type)
			//	In this case, any method examination may cause crash or
			//	something like that. Because methods are may not be checked yet.
			//	But, comptime type information structure do not provides
			//	method interface directly. So, to examine types of method,
			//	developer should use the comptime::ValueOf function for the
			//	Method method to get a type information for a method.
			//	And comptime::ValueOf always takes checked type alias structs,
			//	So there is no way to occur such a fatal analysis issue,
			//	as far as tested.
			//
			// But, as far as tested, there is no risk for current implementation.
			// Future implementations should pay attention for here.
			mut s := kind.(&StructIns)
			self.pushReference(s)
			v = self._evalStruct(s)
		| &Enum:
			v = self._evalEnum(kind.(&Enum))
		| &TypeEnum:
			v = self._evalTypeEnum(kind.(&TypeEnum))
		|:
			v = &Value{
				Decl: true,
				Type: &Type{
					Kind: ta.TypeSym.Type.Kind,
				},
			}
			v.Model = v.Type
		}
		v.Type.Generic = ta.Generic
		v.Type.Provider = ta.Name
		ret v
	}

	fn evalTrait(mut *self, mut t: &Trait): &Value {
		ret &Value{
			Decl: true,
			Type: &Type{
				Kind: t,
			},
		}
	}

	fn evalDef(mut *self, mut def: any, mut name: &token::Token): &Value {
		match type def {
		| &Var:
			ret self.evalVar(def.(&Var), name)
		| &Enum:
			ret self.evalEnum(def.(&Enum), name)
		| &TypeEnum:
			ret self.evalTypeEnum(def.(&TypeEnum), name)
		| &Struct:
			ret self.evalStruct(def.(&Struct), name)
		| &Func:
			mut f := def.(&Func)
			if f.Name != jule::InitFunc {
				ret self.evalFunc(f, name)
			}
		| &FuncIns:
			ret self.evalFuncIns(def.(&FuncIns))
		| &TypeAlias:
			ret self.evalTypeAlias(def.(&TypeAlias), name)
		| &Trait:
			ret self.evalTrait(def.(&Trait))
		}
		self.pushErr(name, log::IdentNotExist, name.Kind)
		ret nil
	}

	fn evalName(mut *self, mut name: &ast::NameExpr): &Value {
		mut def := self.getDef(name.Name, name.Bind)
		ret self.evalDef(def, name.Token)
	}

	fn evalUnary(mut &self, mut u: &ast::UnaryExpr, evalRefptr: bool): &Value {
		mut unary := unaryEval.new(self)
		unary.evalRefptr = evalRefptr
		ret unary.eval(u)
	}

	fn evalVariadic(mut &self, mut v: &ast::VariadicExpr): &Value {
		if v.X == nil {
			self.pushErr(v.Token, log::InvalidExpr)
			ret nil
		}

		mut prefix := self.prefix
		self.prefix = nil
		defer { self.prefix = prefix }

		mut val := self.evalExpr(v.X, evalDefault|evalPhysicalMem|evalUnwrapUntyped)
		if val == nil {
			ret nil
		}
		if !val.Type.Variadicable() {
			self.pushErr(v.Token, log::VariadicWithNonVariadicable, val.Type.Str())
			ret nil
		}
		makeVariadic(val, val.Type.Slice().Value)
		ret val
	}

	fn evalUnsafe(mut &self, mut u: &ast::UnsafeExpr): &Value {
		unsafety := self.unsafety
		self.unsafety = true
		mut v := self.evalExpr(u.X, evalDefault)
		self.unsafety = unsafety
		ret v
	}

	fn evalArray(mut &self, mut s: &ast::SliceExpr): &Value {
		// Arrays always has type prefixes.
		mut pt := self.prefix.Array()

		mut arr := &Array{
			Auto: false,
			N: 0,
			Value: pt.Value,
		}

		mut filled := false

		if len(s.X) == 2 {
			vr, ok := s.X[1].Data.(&ast::VariadicExpr)
			if ok && vr.X == nil {
				// Filled.
				if pt.Auto {
					self.pushErr(s.Token, log::AutoSizedArrFilled)
					ret nil
				}
				filled = true
				s.X = s.X[:1]
			}
		}

		arr.N = len(s.X)
		if !pt.Auto {
			if arr.N > pt.N {
				self.pushErr(s.Token, log::OverflowLimits)
			} else if arr.N < pt.N {
				arr.N = pt.N
			}
		}

		mut model := &ArrayExpr{
			Kind: arr,
		}
		if filled {
			model.Elems = make([]&Value, 0, 2)
		} else {
			model.Elems = make([]&Value, 0, len(s.X))
		}

		mut prefix := self.prefix
		self.prefix = arr.Value
		for (_, mut x) in s.X {
			// Do not unwrap untyped literals, type analysis will check overflows.
			mut v := self.evalExpr(x, evalDefault)
			if v == nil {
				continue
			}
			const destIsRef = false
			const firstAssignToDest = false
			if self.s.checkValidityForInitExpr(self.target.mutable, destIsRef, arr.Value, v, x.Token) {
				_ = self.s.checkAssignType(destIsRef, firstAssignToDest, arr.Value, v, x.Token, self.getOwnerRefers())
			}
			model.Elems = append(model.Elems, v)
		}
		self.prefix = prefix

		if filled {
			// Fill mark.
			model.Elems = append(model.Elems, nil)
		}

		ret &Value{
			Mutable: true,
			Type: &Type{
				Kind: arr,
			},
			Model: model,
		}
	}

	fn evalExpSlice(mut &self, mut s: &ast::SliceExpr, mut t: &Type, mut first: &Value): &Value {
		mut slc := &Slice{
			Value: t,
		}

		mut i := 0
		mut model := &SliceExpr{
			ElemType: t,
			Elems: make([]&Value, 0, len(s.X)),
		}
		if first != nil {
			model.Elems = append(model.Elems, first)
			i = 1
		}

		mut prefix := self.prefix
		self.prefix = slc.Value
		for (_, mut x) in s.X[i:] {
			// Do not unwrap untyped literals, type analysis will check overflows.
			mut v := self.evalExpr(x, evalDefault)
			if v != nil {
				const destIsRef = false
				const firstAssignToDest = false
				if self.s.checkValidityForInitExpr(self.target.mutable, destIsRef, slc.Value, v, x.Token) {
					_ = self.s.checkAssignType(destIsRef, firstAssignToDest, slc.Value, v, x.Token, self.getOwnerRefers())
				}
				model.Elems = append(model.Elems, v)
			}
		}
		self.prefix = prefix

		ret &Value{
			Mutable: true,
			Type: &Type{
				Kind: slc,
			},
			Model: model,
		}
	}

	fn evalSliceExpr(mut &self, mut s: &ast::SliceExpr): (v: &Value) {
		if self.prefix != nil {
			match {
			| self.prefix.Array() != nil:
				v = self.evalArray(s)
			| self.prefix.Slice() != nil:
				mut pt := self.prefix.Slice()
				v = self.evalExpSlice(s, pt.Value, nil)
			|:
				goto autoDetermine
			}
			// If prefix type is a strict type alias, we have to use its
			// underlying structure type for the value.
			if v != nil {
				mut strct := self.prefix.SoftStruct()
				if strct != nil && strct.Source != nil {
					v.Type = &Type{Kind: strct}
				}
			}
			ret
		}
	autoDetermine:
		mut prefix := self.prefix
		self.prefix = nil

		if len(s.X) == 0 {
			self.pushErr(s.Token, log::DynamicTypeAnnotationFailed)
			ret nil
		}

		mut firstExpr := s.X[0]
		mut firstElem := self.evalExpr(firstExpr, evalDefault|evalPhysicalMem|evalUnwrapUntyped)
		if firstElem == nil {
			ret nil
		}
		if self.s.checkDataForTypeInference(firstElem, firstExpr.Token) {
			// Check mutability for first element.
			const destIsRef = false
			self.s.checkValidityForInitExpr(self.target.mutable, destIsRef,
				firstElem.Type, firstElem, firstExpr.Token)

			v = self.evalExpSlice(s, firstElem.Type, firstElem)
		}
		self.prefix = prefix
		ret v
	}

	fn checkIntegerIndexByData(mut *self, mut v: &Value, mut token: &token::Token): bool {
		errKey := checkDataForIntegerIndex(self.s, v, token, self.getOwnerRefers())
		match errKey {
		| "":
			ret true
		| log::InvalidTypeForIndexing:
			self.pushErr(token, errKey, v.Type.Str())
		|:
			self.pushErr(token, errKey)
		}
		ret false
	}

	fn indexPtr(mut *self, mut v: &Value, mut index: &Value, mut i: &ast::IndexExpr) {
		self.checkIntegerIndexByData(index, i.Token)
		v.Lvalue = true

		if isRef(v) {
			self.pushErr(i.Token, "index is not supported by reference type @", v.Type.Str())
			self.pushSuggestion("try deference the reference pointer like: *x")
			ret
		}

		mut ptr := v.Type.Ptr()
		match {
		| ptr.IsUnsafe():
			self.pushErr(i.Token, log::UnsafePtrIndexing)
			ret
		| !self.isUnsafe():
			self.pushErr(i.Token, log::UnsafeBehaviorAtOutOfUnsafeScope)
			self.pushSuggestion(log::WriteYourCodeInUnsafeJule)
		}

		v.Type = ptr.Value
	}

	fn indexArr(mut *self, mut v: &Value, mut index: &Value, mut i: &ast::IndexExpr) {
		mut arr := v.Type.Array()
		v.Type = arr.Value
		self.checkIntegerIndexByData(index, i.Token)
		v.Lvalue = true
		if index.IsConst() && index.Constant.AsF64() >= f64(arr.N) {
			self.pushErr(i.Token, log::OverflowLimits)
		}
	}

	fn indexSlice(mut *self, mut v: &Value, mut index: &Value, mut i: &ast::IndexExpr) {
		mut slc := v.Type.Slice()
		v.Type = slc.Value
		self.checkIntegerIndexByData(index, i.Token)
		v.Lvalue = true
	}

	fn indexMap(mut *self, mut v: &Value, mut index: &Value, mut i: &ast::IndexExpr) {
		v.Lvalue = false
		if index == nil {
			ret
		}
		mut m := v.Type.Map()
		mut atc := assignTypeChecker{
			s: self.s,
			dest: m.Key,
			v: index,
			errorToken: i.Token,
			refers: self.getOwnerRefers(),
		}
		_ = atc.check()
		v.Type = m.Value
	}

	fn indexStr(mut *self, mut v: &Value, mut index: &Value, mut i: &ast::IndexExpr) {
		v.Type = findBuiltinTypeAlias("byte").TypeSym.Type
		v.Mutable = false
		v.Lvalue = true

		if index == nil {
			ret
		}

		self.checkIntegerIndexByData(index, i.Token)

		v.untyped = v.IsConst()
		if !index.IsConst() {
			v.Constant = nil
			v.untyped = false
			ret
		}

		if v.untyped {
			j := index.Constant.AsI64()
			s := v.Constant.ReadStr()
			if int(j) >= len(s) {
				self.pushErr(i.Token, log::OverflowLimits)
			} else {
				v.Constant.SetU64(u64(s[j]))
			}
		}
	}

	fn comptimeRange(mut *self, mut &v: *&Value, mut index: &Value, mut i: &ast::IndexExpr) {
		if index == nil {
			*v = nil
			ret
		}
		if !self.checkIntegerIndexByData(index, i.Index.Token) {
			*v = nil
			ret
		}
		if !index.IsConst() {
			*v = nil
			self.pushErr(i.Index.Token, log::ExprNotConst)
			ret
		}
		// guaranteed: index >= 0
		j := int(index.Constant.AsI64())
		mut ci := (*v).Type.comptimeRange()
		if j >= ci.kind.len() {
			*v = nil
			self.pushErr(i.Index.Token, log::OverflowLimits)
			ret
		}
		ci.kind.index(*v, j)
	}

	fn toIndex(mut *self, mut &v: *&Value, mut index: &Value, mut i: &ast::IndexExpr) {
		match {
		| (*v).Type.Ptr() != nil:
			self.indexPtr(*v, index, i)
			ret
		| (*v).Type.Array() != nil:
			self.indexArr(*v, index, i)
			ret
		| (*v).Type.Slice() != nil:
			self.indexSlice(*v, index, i)
			ret
		| (*v).Type.Map() != nil:
			self.indexMap(*v, index, i)
			ret
		| (*v).Type.Prim() != nil:
			prim := (*v).Type.Prim()
			match {
			| prim.IsStr():
				self.indexStr(*v, index, i)
				ret
			}
		| (*v).Type.comptimeRange() != nil:
			self.comptimeRange(v, index, i)
			ret
		}
		self.pushErr(i.Token, log::NotSupportsIndexing, (*v).Type.Str())
	}

	fn pushGenericsFromData(mut &self, mut &generics: *[]&InsGeneric, mut indx: &ast::IndexExpr): (ok: bool) {
		mut tc := self.typeChecker()
		ok = true
		match type indx.Index.Data {
		| &ast::TupleExpr:
			mut tup := indx.Index.Data.(&ast::TupleExpr)
			*generics = make([]&InsGeneric, 0, len(tup.X))
			for (_, mut typDecl) in tup.X {
				mut typ := tc.checkDecl(typDecl)
				if typ == nil {
					ok = false
				} else {
					*generics = append(*generics, &InsGeneric{Type: typ})
				}
			}
		|:
			mut typ := tc.checkDecl(indx.Index)
			if typ == nil {
				ok = false
			} else {
				*generics = append(*generics, &InsGeneric{Type: typ})
			}
		}
		ret
	}

	fn evalIdentDeclFromIndex(mut &self, mut &v: *&Value, mut i: &ast::IndexExpr) {
		mut s := (*v).Type.Struct()
		if s == nil {
			self.pushErr(i.X.Token, log::TypeNotSupportsGenerics, (*v).Type.Str())
			*v = nil
			ret
		}
		s, _ = self.typeChecker().buildStructInsWithGenerics(s, i)
		if s == nil {
			*v = nil
			ret
		}
		(*v).Type.Kind = s
	}

	// Checks new generics function instance.
	// If instance is already exist, f will point to exist instantantiation.
	// If recheckNeed is not nil, function will checked with recheck strategy.
	fn checkGenericFunc(mut &self, mut &f: *&FuncIns, mut et: &token::Token,
		mut &model: *Expr, mut recheckNeed: []recheckableType): (ok: bool, exist: bool) {
		mut old := *f
		if recheckNeed == nil {
			ok, exist = self.s.checkGenericFunc(f, et)
		} else {
			ok, exist = self.s.checkGenericFuncRecheck(f, et, recheckNeed)
		}
		if ok && exist {
			// Update model by exist function instance.
			// Generic functions returns always new instance, because might be
			// generics are inferred. Therefore, always returns new instance for requests.
			// So, if this absolute instance is already exist, update model.
			// Otherwise, model's instance will be a dangling, because it never
			// be appended into instances of function declaration since already exist.
			updateModelToGenericIns(model, *f)
			updateRefer(self.getOwnerRefers(), old, *f)
		}
		ret
	}

	fn evalFuncGenericFromIndex(mut &self, mut &v: *&Value, mut i: &ast::IndexExpr) {
		mut f := (*v).Type.Func()
		if !self.pushGenericsFromData(&f.Generics, i) {
			*v = nil
			ret
		}

		mut genericsLen := 0
		if f.Decl != nil {
			genericsLen = len(f.Decl.Generics)
		}
		if !self.s.checkGenericQuantity(genericsLen, len(f.Generics), i.X.Token) {
			*v = nil
			ret
		}

		if f.IsBuiltin() {
			(*v).Type.Kind = f
			ret
		}

		ok, _ := self.checkGenericFunc(&f, i.X.Token, &(*v).Model, nil)
		if ok {
			(*v).Type.Kind = f
		} else {
			*v = nil
		}
	}

	fn evalIndex(mut &self, mut i: &ast::IndexExpr): &Value {
		mut prefix := self.prefix
		self.prefix = nil
		defer { self.prefix = prefix }

		mut v := self.evalExprPlain(i.X)
		if v == nil {
			ret nil
		}

		// Catch types.
		if v.Decl {
			self.evalIdentDeclFromIndex(&v, i)
			ret v
		}

		if v.Type.Func() != nil {
			self.evalFuncGenericFromIndex(&v, i)
			ret v
		}

		mut oldValue := *v

		// If indexing a map value, use key type of map as the prefix.
		mut m := v.Type.Map()
		if m != nil {
			self.prefix = m.Key
		}

		mut index := self.evalExpr(i.Index, evalDefault|evalPhysicalMem|evalUnwrapUntyped)
		self.prefix = nil
		if index == nil {
			ret nil
		}

		// caught comptime indexing expressions
		makeComptimeRange(v, true)

		// Set decl to true. It's a kind of flag.
		// If decl is true after indexing eval, do not touch Model:.
		// Set by indexing eval.
		v.Decl = false

		self.toIndex(&v, index, i)
		if v == nil {
			ret nil
		}
		if v.IsConst() {
			v.Decl = false
			v.Model = v.Constant
		} else if v.Decl {
			v.Decl = false
		} else {
			v.Model = &IndexingExpr{
				Token: i.Token,
				Expr: new(Value, oldValue),
				Index: index,
			}
		}

		ret v
	}

	// Returns left and right index values.
	// Returns zero integer expression if slicing have not left index.
	// So, left index always represents an expression.
	// Left data is nil if expression eval failed.
	fn evalSlicingExprs(mut &self, mut s: &ast::SlicingExpr): (l: &Value, r: &Value, c: &Value) {
		mut prefix := self.prefix
		self.prefix = nil
		defer { self.prefix = prefix }

		if s.Low != nil {
			l = self.evalExpr(s.Low, evalDefault|evalPhysicalMem|evalUnwrapUntyped)
			if l != nil {
				self.checkIntegerIndexByData(l, s.Token)
			} else {
				ret nil, nil, nil
			}
		} else {
			l = &Value{
				Constant: constant::Const.NewI64(0),
				Type: primInt,
			}
			l.Constant.Kind = types::Int
			l.Model = l.Constant
		}

		if s.High != nil {
			r = self.evalExpr(s.High, evalDefault|evalPhysicalMem|evalUnwrapUntyped)
			if r != nil {
				self.checkIntegerIndexByData(r, s.Token)
			} else {
				ret nil, nil, nil
			}
		}

		if s.Max != nil {
			c = self.evalExpr(s.Max, evalDefault|evalPhysicalMem|evalUnwrapUntyped)
			if r != nil {
				self.checkIntegerIndexByData(r, s.Token)
			} else {
				ret nil, nil, nil
			}
		}

		ret
	}

	fn slicingArr(mut *self, s: &ast::SlicingExpr, mut v: &Value, c: &Value) {
		if c != nil {
			self.pushErr(s.Token, log::UnsupportedTypeIndex3Slice, v.Type.Str())
		}

		mut valueTyp := v.Type.Array().Value
		v.Type = &Type{
			Kind: &Slice{
				Value: valueTyp,
			},
		}

		v.Lvalue = false

		// Keep mutability id already mutable.
		// Be mutable, if element is not mutable-type.
		v.Mutable = v.Mutable || !valueTyp.Mutable()
	}

	fn slicingStr(mut *self, s: &ast::SlicingExpr, mut v: &Value, l: &Value, c: &Value, r: &Value) {
		v.Lvalue = false
		v.Mutable = true
		if !v.IsConst() {
			ret
		}

		if l == nil || r == nil {
			v.Constant = nil
			v.untyped = false
			ret
		}

		if c != nil {
			self.pushErr(s.Token, log::UnsupportedTypeIndex3Slice, v.Type.Str())
		}

		if l.IsConst() && r.IsConst() {
			left := l.Constant.AsI64()
			if left < 0 {
				ret
			}

			sconst := v.Constant.ReadStr()
			mut right := i64(0)
			if r == nil {
				right = i64(len(sconst))
			} else {
				right = r.Constant.AsI64()
			}

			if left > right {
				ret
			}
			v.Constant.SetStr(sconst[left:right])
			v.Decl = true // Set Model: flag.
		} else {
			v.Constant = nil
			v.untyped = false
		}
	}

	fn checkSlicing(mut *self, mut v: &Value, l: &Value, r: &Value, c: &Value, s: &ast::SlicingExpr) {
		// NOTE: catch 3-index slicing expressions if type does not support it.
		match {
		| v.Type.Array() != nil:
			self.slicingArr(s, v, c)
			ret
		| v.Type.Slice() != nil:
			ret
		| v.Type.Prim() != nil:
			prim := v.Type.Prim()
			match {
			| prim.IsStr():
				self.slicingStr(s, v, l, c, r)
				ret
			}
		}

		self.pushErr(s.Token, log::NotSupportsSlicing, v.Type.Str())
	}

	fn evalSlicing(mut &self, mut s: &ast::SlicingExpr): &Value {
		mut v := self.evalExpr(s.X, evalDefault|evalPhysicalMem|evalUnwrapUntyped)
		if v == nil {
			ret nil
		}

		mut l, mut r, mut c := self.evalSlicingExprs(s)
		if l == nil {
			ret v
		}

		// Set decl to true. It's a kind of flag.
		// If decl is true after indexing eval, do not touch Model:.
		// Set by indexing eval.
		v.Decl = false

		// Store original copy of v, we need it for expression modelling.
		mut base := new(Value, *v)

		self.checkSlicing(v, l, r, c, s)

		if v.IsConst() {
			v.Decl = false
			v.Model = v.Constant
		} else if v.Decl {
			v.Decl = false
		} else {
			mut model := &SlicingExpr{
				Token: s.Token,
				Expr: base,
				Left: l.Model,
			}
			if r != nil {
				model.Right = r.Model
			}
			if c != nil {
				model.Cap = c.Model
			}
			v.Model = model
		}
		ret v
	}

	fn castPtr(mut *self, mut t: &Type, mut v: &Value, errorToken: &token::Token) {
		v.Constant = nil
		v.untyped = false
		sptr := v.Type.Sptr()
		if sptr != nil {
			if !t.Ptr().Value.Equal(sptr.Value) {
				self.pushErr(errorToken, log::TypeNotSupportsCastingTo, v.Type.Str(), t.Str())
			}
			ret
		}

		if !self.isUnsafe() {
			self.pushErr(errorToken, log::UnsafeBehaviorAtOutOfUnsafeScope)
			self.pushSuggestion(log::WriteYourCodeInUnsafeJule)
			ret
		}

		prim := v.Type.Prim()
		if v.Type.Ptr() == nil && (prim == nil || !types::IsInt(prim.Str())) {
			self.pushErr(errorToken, log::TypeNotSupportsCastingTo, v.Type.Str(), t.Str())
		}
	}

	// Casts struct type. If preStrict mode is not enabled,
	// it will log error about casting failed for pre type check phase.
	// Reports whether pre type check phase completed.
	// The preStrict mode is useful to checking type and value is suitable for
	// struct casting. It returns with no error and checked as false, if not suitable.
	// Otherwise, logs errors and returns checked as true.
	fn castStruct(mut *self, mut t: &Type, mut s: &StructIns, mut v: &Value, errorToken: &token::Token, preStrict: bool): (checked: bool) {
		mut tr := v.Type.Trait()
		if tr == nil {
			if !preStrict {
				self.pushErr(errorToken, log::TypeNotSupportsTypeAssertionTo, v.Type.Str(), t.Str())
			}
			ret false
		}

		v.Constant = nil
		v.untyped = false
		self.pushReference(s)

		if !s.Decl.IsImplements(tr) {
			// Log error but do not return false.
			// We know type is trait, casting is not possible.
			self.pushErr(errorToken, log::TypeNotSupportsTypeAssertionTo, v.Type.Str(), t.Str())
		}
		ret true
	}

	fn castSptr(mut *self, mut t: &Type, mut v: &Value, errorToken: &token::Token) {
		v.Constant = nil
		v.untyped = false
		mut sptr := t.Sptr()

		mut ptr := v.Type.Ptr()
		if ptr != nil && sptr.Value.Equal(ptr.Value) {
			if !self.isUnsafe() {
				self.pushErr(errorToken, log::UnsafeBehaviorAtOutOfUnsafeScope)
				self.pushSuggestion(log::WriteYourCodeInUnsafeJule)
			}
			// Ok.
			ret
		}

		self.pushErr(errorToken, log::TypeNotSupportsCastingTo, v.Type.Str(), t.Str())
	}

	fn castSlice(mut *self, mut t: &Type, mut v: &Value, errorToken: &token::Token) {
		c := v.Constant
		v.Constant = nil
		v.untyped = false

		if v.Type.Enum() != nil {
			if v.Type.Enum().TypeSym.Type.Prim() == nil || !v.Type.Enum().TypeSym.Type.Prim().IsStr() {
				self.pushErr(errorToken, log::TypeNotSupportsCastingTo, v.Type.Str(), t.Str())
				ret
			}
		} else if v.Type.Prim() == nil || !v.Type.Prim().IsStr() {
			self.pushErr(errorToken, log::TypeNotSupportsCastingTo, v.Type.Str(), t.Str())
			ret
		}

		t = t.Slice().Value
		mut prim := t.Prim()
		if prim == nil || (!prim.IsU8() && !prim.IsI32()) {
			self.pushErr(errorToken, log::TypeNotSupportsCastingTo, v.Type.Str(), t.Str())
			ret
		}

		// Cast constant expressions.
		if c != nil {
			match {
			| prim.IsU8():
				s := c.ReadStr()
				mut model := &SliceExpr{
					ElemType: t,
					Elems: make([]&Value, 0, len(s)),
				}
				for _, b in []byte(s) {
					mut bc := constant::Const.NewU64(u64(b))
					bc.Kind = prim.Kind
					model.Elems = append(model.Elems, &Value{
						Type: &Type{Kind: prim},
						Constant: bc,
						Model: bc,
					})
				}
				v.Model = model
				v.Decl = true // Prevent model changing.
			| prim.IsI32():
				s := c.ReadStr()
				mut model := &SliceExpr{
					ElemType: t,
					Elems: make([]&Value, 0, len(s)),
				}
				for _, r in s {
					mut rc := constant::Const.NewI64(i64(r))
					rc.Kind = prim.Kind
					model.Elems = append(model.Elems, &Value{
						Type: &Type{Kind: prim},
						Constant: rc,
						Model: rc,
					})
				}
				v.Model = model
				v.Decl = true // Prevent model changing.
			}
		}
	}

	fn castBool(mut *self, mut t: &Type, mut v: &Value, errorToken: &token::Token) {
		prim := v.Type.Prim()
		if prim == nil || !prim.IsBool() {
			self.pushErr(errorToken, log::TypeNotSupportsCastingTo, t.Str(), v.Type.Str())
		}
	}

	fn castStr(mut *self, mut t: &Type, mut v: &Value, errorToken: &token::Token) {
		if v.Type.Enum() != nil {
			mut e := v.Type.Enum()
			if e.TypeSym.Type.Prim() != nil && e.TypeSym.Type.Prim().IsStr() {
				ret
			}
		}

		c := v.Constant
		v.Constant = nil
		v.untyped = false
		mut prim := v.Type.Prim()
		if prim != nil {
			if prim.IsStr() {
				ret
			}
			if !prim.IsU8() && !prim.IsI32() {
				self.pushErr(errorToken, log::TypeNotSupportsCastingTo, t.Str(), v.Type.Str())
				ret
			}
			// Cast constant expressions.
			if c != nil {
				match {
				| prim.IsU8():
					v.Constant = constant::Const.NewStr(str(byte(c.AsU64())))
					v.Model = v.Constant
					v.Decl = true // Prevent model changing.
				| prim.IsI32():
					v.Constant = constant::Const.NewStr(str(rune(c.AsI64())))
					v.Model = v.Constant
					v.Decl = true // Prevent model changing.
				}
			}
			ret
		}

		mut s := v.Type.Slice()
		if s == nil {
			self.pushErr(errorToken, log::TypeNotSupportsCastingTo, t.Str(), v.Type.Str())
			ret
		}

		t = s.Value
		prim = t.Prim()
		if prim == nil || (!prim.IsU8() && !prim.IsI32()) {
			self.pushErr(errorToken, log::TypeNotSupportsCastingTo, t.Str(), v.Type.Str())
			ret
		}
	}

	fn castCmplx(mut *self, mut t: &Type, mut v: &Value, errorToken: &token::Token) {
		if v.IsConst() {
			castConstByType(self.s, errorToken, t, v)
			v.Decl = true // Do not use casting model. See developer reference (11).
		} else {
			v.Constant = nil
			v.untyped = false
		}

		if v.Type.Enum() != nil {
			if v.IsConst() {
				ret
			}
			mut e := v.Type.Enum()
			if types::IsCmplx(e.TypeSym.Type.Prim().Str()) {
				ret
			}
		}

		prim := v.Type.Prim()
		if prim != nil && (v.IsConst() && types::IsNum(prim.Str()) || types::IsCmplx(prim.Str())) {
			ret
		}

		self.pushErr(errorToken, log::TypeNotSupportsCastingTo, v.Type.Str(), t.Str())
	}

	fn castInt(mut *self, mut t: &Type, mut v: &Value, errorToken: &token::Token) {
		if v.IsConst() {
			castConstByType(self.s, errorToken, t, v)
			v.Decl = true // Do not use casting model. See developer reference (11).
		} else {
			v.Constant = nil
			v.untyped = false
		}

		if v.Type.Enum() != nil {
			mut e := v.Type.Enum()
			if types::IsNum(e.TypeSym.Type.Prim().Str()) {
				ret
			}
		}

		if v.Type.Sptr() != nil {
			prim := t.Prim()
			if !prim.IsUintptr() {
				self.pushErr(errorToken, log::TypeNotSupportsCastingTo, v.Type.Str(), t.Str())
			}
			ret
		}
		if v.Type.Ptr() != nil {
			prim := t.Prim()
			if prim.IsUintptr() {
				// Ignore case.
			} else if !self.isUnsafe() {
				self.pushErr(errorToken, log::UnsafeBehaviorAtOutOfUnsafeScope)
				self.pushSuggestion(log::WriteYourCodeInUnsafeJule)
			}
			ret
		}

		prim := v.Type.Prim()
		if prim != nil && types::IsNum(prim.Str()) {
			ret
		}

		self.pushErr(errorToken, log::TypeNotSupportsCastingTo, v.Type.Str(), t.Str())
	}

	fn castNum(mut *self, mut t: &Type, mut v: &Value, errorToken: &token::Token) {
		if v.IsConst() {
			castConstByType(self.s, errorToken, t, v)
			v.Decl = true // Do not use casting model. See developer reference (11).
		} else {
			v.Constant = nil
			v.untyped = false
		}

		if v.Type.Enum() != nil {
			mut e := v.Type.Enum()
			if types::IsNum(e.TypeSym.Type.Prim().Str()) {
				ret
			}
		}

		prim := v.Type.Prim()
		if prim != nil && types::IsNum(prim.Str()) {
			ret
		}

		self.pushErr(errorToken, log::TypeNotSupportsCastingTo, v.Type.Str(), t.Str())
	}

	fn castPrim(mut *self, mut t: &Type, mut v: &Value, errorToken: &token::Token) {
		prim := t.Prim()
		match {
		| prim.IsAny():
			panic("sema: castPrim: any case should be unreachable in this routine")
		| prim.IsStr():
			self.castStr(t, v, errorToken)
		| prim.IsBool():
			self.castBool(t, v, errorToken)
		| types::IsCmplx(prim.Kind):
			self.castCmplx(t, v, errorToken)
		| types::IsInt(prim.Str()):
			self.castInt(t, v, errorToken)
		| types::IsNum(prim.Str()):
			self.castNum(t, v, errorToken)
		|:
			self.pushErr(errorToken, log::TypeNotSupportsCasting, t.Str())
		}
	}

	fn castTypeEnumT(mut *self, mut t: &Type, mut v: &Value, mut errorToken: &token::Token) {
		n := len(self.s.errors)
		// quick check: if type t and value type comparable.
		if !self.s.checkTypeCompatibility(t, v.Type, errorToken, typeCompDefault) {
			self.s.errors = self.s.errors[:n] // Remove logged errors by checkTypeCompatibility.
			self.pushErr(errorToken, log::TypeNotSupportsCastingTo, v.Type.Str(), t.Str())
		}
		v.Constant = nil
		v.untyped = false
	}

	fn castTrait(mut *self, mut t: &Type, mut v: &Value, mut errorToken: &token::Token) {
		n := len(self.s.errors)
		if !self.s.checkTypeCompatibility(t, v.Type, errorToken, typeCompDefault) {
			self.s.errors = self.s.errors[:n] // Remove logged errors by checkTypeCompatibility.
			self.pushErr(errorToken, log::TypeNotSupportsCastingTo, v.Type.Str(), t.Str())
		}
		v.Constant = nil
		v.untyped = false
	}

	fn castChan(mut *self, mut t: &Type, mut v: &Value, mut errorToken: &token::Token) {
		vc := v.Type.Chan()
		if vc == nil {
			self.pushErr(errorToken, log::TypeNotSupportsCastingTo, v.Type.Str(), t.Str())
			ret
		}
		c := t.Chan()
		if !vc.Value.Equal(c.Value) {
			self.pushErr(errorToken, log::TypeNotSupportsCastingTo, v.Type.Str(), t.Str())
			ret
		}
		if c.Recv && !vc.Recv || c.Send && !vc.Send {
			self.pushErr(errorToken, log::TypeNotSupportsCastingTo, v.Type.Str(), t.Str())
			ret
		}
	}

	fn evalCastByTypeNData(mut *self, mut t: &Type, mut v: &Value, mut errorToken: &token::Token): &Value {
		if v != nil && v.Decl {
			self.pushErr(errorToken, log::InvalidExpr)
			ret nil
		}

		// if actual types are equal, allow casting
		// otherwise check casting in more detail
		if !v.Type.deepActualEqual(t) {
			match {
			| v.IsNil():
				if !t.NilCompatible() {
					self.pushErr(errorToken, log::TypeNotSupportsCastingTo, "<nil>", t.Str())
				}
				v.Constant = nil // Remove nil constant.
				v.untyped = false
			|:
				match {
				| t.Prim() != nil && t.Prim().IsAny():
					// The any type supports casting to any data type.
					v.Constant = nil
					v.untyped = false
				| t.TypeEnum() != nil:
					// We have to evaluate the type for type enum cases.
					// If destination type is enum, we can cast correctly.
					// Otherwise, value type-enum case evaluated first.
					// But in this case, it may be casted to type-enum.
					// But type checker only performs type-enum analysis if
					// the destination type is type-enum. So casting will be faliled
					// even for supported types.
					//
					// For example:
					//
					//	enum Bar: type {
					//		str,
					//	}
					//	enum Foo: type {
					//		Bar,
					//		int,
					//	}
					//	fn main() {
					//		let x: Bar = ""
					//		let y: Foo = str(x)
					//		let z: Foo = Foo(x)
					//		_ = y, z
					//	}
					//
					//	In the example code above will be failed if value case
					//	evaluated first. Because type destination will be str.
					//	So type checker will expect the variable |x| should be
					//	equal to any compatible type with str, which is not type-enum Bar.
					self.castTypeEnumT(t, v, errorToken)
				| t.Ptr() != nil:
					self.castPtr(t, v, errorToken)
				| t.Sptr() != nil:
					self.castSptr(t, v, errorToken)
				| t.Slice() != nil:
					self.castSlice(t, v, errorToken)
				| t.Prim() != nil:
					self.castPrim(t, v, errorToken)
				| t.Trait() != nil:
					self.castTrait(t, v, errorToken)
				| t.Chan() != nil:
					self.castChan(t, v, errorToken)
				|:
					self.pushErr(errorToken, log::TypeNotSupportsCasting, t.Str())
					v = nil
				}
			}
		}

		if v == nil {
			ret nil
		}
		// casting applied successfully

		if t.Bind() || v.Type.Bind() {
			// if destination or expression type is binded, it requires Unsafe Jule for this.
			// Push error if Unsafe Jule is not available. But do not return nil data,
			// casting is valid, just Unsafe Jule is missing. Push only information error for that.
			// Allow untyped constant literals for casting with no Unsafe Jule.
			if !self.isUnsafe() && (!v.IsConst() || !v.untyped) {
				self.pushErr(errorToken, log::UnsafeBehaviorAtOutOfUnsafeScope)
				self.pushSuggestion(log::CastingBindedTypesRequiresUnsafeJule)
			}
		}

		// Keep mutability if data is already mutable.
		// Even if the data is not mutable, set as mutable if the type is not mutable-type.
		v.Mutable = v.Mutable || !v.Type.Mutable()

		if !v.Decl && (v.Type.Enum() == nil || !v.Type.Enum().TypeSym.Type.Equal(t)) {
			applyCastKind(self.s, v, t, errorToken, self.getOwnerRefers())
			v.Model.(&CastingExpr).Token = errorToken
		} else {
			v.Type = t
		}

		// Remove flag.
		// The variable v cannot be v.Decl true because of checked already.
		// Therefore this field used as flag to say "do not touch to expression model".
		// So, if v.Decl is true, model will not be changed.
		v.Decl = false

		v.Lvalue = false
		v.untyped = false

		if v.IsConst() {
			mut prim := t.Prim()
			if prim != nil {
				v.Constant.Kind = prim.Kind
			} else {
				mut enm := t.Enum()
				if enm != nil {
					v.Constant.Kind = enm.TypeSym.Type.Prim().Kind
				}
			}
		}

		ret v
	}

	fn evalCastT(mut &self, mut t: &Type, mut e: &ast::Expr, mut et: &token::Token): &Value {
		mut prefix := self.prefix
		self.prefix = nil
		defer { self.prefix = prefix }
		if t.Slice() != nil || t.Array() != nil {
			_, isSlice := e.Data.(&ast::SliceExpr)
			if isSlice {
				self.prefix = t
			}
		} else if t.Map() != nil {
			_, isBrace := e.Data.(&ast::BraceLit)
			if isBrace {
				self.prefix = t
			}
		}
		// Do not allow arbitrary large literals for casting.
		// Because casting will result as a valid memory type.
		// If we do not eval with the physical memory constraint,
		// arbitrary large literals may overflow largest bitsize of any actual type.
		// So we need to make sure that the value can fit at least the largest type.
		//
		// For numeric types; do not eval with physical memory constraint or unwrap.
		// Casting analysis will check the overflows for the corresponding type.
		mut flags := evalDefault
		if t.Prim() == nil || !types::IsNum(t.Prim().Kind) {
			flags |= evalPhysicalMem | evalUnwrapUntyped
		}
		mut v := self.evalExpr(e, flags)
		if v == nil || self.prefix != nil {
			ret v
		}
		ret self.evalCastByTypeNData(t, v, et)
	}

	fn evalNamespace(mut *self, mut s: &ast::NamespaceExpr): &Value {
		mut imp := findNamespace(self.lookup, s.Namespace.Kind)
		if imp == nil {
			self.pushErr(s.Namespace, log::NamespaceNotExist, s.Namespace.Kind)
			ret nil
		}

		mut lookup := self.lookup
		self.lookup = imp

		const Binded = false
		self.disallowBuiltin()
		mut def := self.getDef(s.Name.Kind, Binded)
		self.allowBuiltin()
		self.lookup = lookup
		ret self.evalDef(def, s.Name)
	}

	// StructIns s is the struct type of literal.
	// Type t is the actual value type, it may be strict type alias or pure struct type.
	fn evalStructLitExplicit(mut &self, mut s: &StructIns, mut t: &Type,
		mut lit: &ast::BraceLit, mut errorToken: &token::Token): &Value {
		ok := self.s.checkGenericQuantity(len(s.Decl.Generics), len(s.Generics), errorToken)
		if !ok {
			ret nil
		}
		// NOTICE: Instance already checked (just fields) if generic quantity passes.

		if self.field != nil && self.field.Decl.Owner == s.Decl {
			self.pushErr(errorToken, log::IllegalCycleRefersItself, s.Decl.Name)
		}

		self.pushReference(s)

		mut slc := structLitChecker{
			e: self,
			errorToken: errorToken,
			s: s,
		}
		slc.check(lit.X)

		ret &Value{
			Mutable: self.target.mutable,
			Type: t,
			Model: &StructLitExpr{
				Strct: s,
				Args: slc.args,
			},
		}
	}

	fn evalTypedBraceLit(mut &self, mut lit: &ast::TypedBraceLit): &Value {
		mut t := self.evalType1(lit.Type)
		if t == nil {
			ret nil
		}

		mut s := t.Struct()
		if s == nil {
			if t.Sptr() != nil {
				s = t.Sptr().Value.Struct()
				if s != nil {
					goto eval
				}
			}
			mut m := t.Map()
			if m != nil {
				ret self.evalMap(m, t, lit.Lit)
			}
			self.pushErr(lit.Type.Token, log::InvalidSyntax)
			ret nil
		}

	eval:
		mut v := self.evalStructLitExplicit(s, t, lit.Lit, lit.Type.Token)
		match type t.Kind {
		| &Sptr:
			mut model := v.Model.(&StructLitExpr)
			makeStructLitAlloc(v, model)
		}

		if v != nil {
			mut strct := t.SoftStruct()
			if strct != nil && strct.Source != nil {
				v.Model.(&StructLitExpr).Strct = strct
				v.Type = &Type{Kind: strct}
			}
		}

		ret v
	}

	fn typeChecker(mut *self): &typeChecker {
		mut tc := new(typeChecker)
		tc.s = self.s
		tc.refers = self.getOwnerRefers()
		tc.lookup = self.lookup
		tc.rootLookup = self.lookup
		// Push reference to owner if global.
		if self.owner != nil && self.owner.Scope == nil {
			tc.referencer = &referencer{
				name: self.owner.Name,
				owner: self.owner,
			}
		}
		// If field exist, push reference to struct.
		if self.field != nil {
			tc.referencer = &referencer{
				name: self.field.Owner.Decl.Name,
				owner: self.field.Owner,
			}
		}
		ret tc
	}

	fn evalType1(mut *self, mut t: &ast::Expr): &Type {
		ret self.typeChecker().checkDecl(t)
	}

	fn evalType(mut *self, mut t: &ast::Expr): &Value {
		mut t1 := self.evalType1(t)
		if t1 == nil {
			ret nil
		}
		ret &Value{
			Decl: true,
			Type: t1,
			Model: t1,
		}
	}

	fn callTypeFunc(mut &self, mut fc: &ast::CallExpr, mut &v: *&Value) {
		if len(fc.Args) < 1 {
			self.pushErr(fc.Token, log::MissingExprFor, "v")
		} else if len(fc.Args) > 1 {
			self.pushErr(fc.Args[1].Token, log::ArgumentOverflow, (*v).Type.Str())
		} else if fc.IsCo {
			self.pushErr(fc.Token, log::CoForCastingCall)
			*v = nil
			ret
		} else if fc.Exception != nil {
			self.pushErr(fc.Token, log::TypeCallWithExceptional)
			*v = nil
			ret
		}

		if len(fc.Args) > 0 {
			mut arg := fc.Args[0]
			*v = self.evalCastT((*v).Type, arg, arg.Token)
			ret
		}

		if *v != nil {
			(*v).Decl = false
		}
	}

	fn callBuiltinFunc(mut &self, mut fc: &ast::CallExpr, mut &v: *&Value) {
		if !fc.Unhandled() { // Exceptional handled?
			// Built-in functions are not exceptional.
			self.pushErr(fc.Token, log::HandledUnexceptional)
		}
		*v = (*v).Type.Func().caller(self, fc, *v)
		if *v == nil {
			ret
		}
		(*v).Mutable = true
	}

	fn checkFuncOfConcurrentCall(mut *self, f: &FuncIns, errorToken: &token::Token) {
		if self.isUnsafe() {
			ret
		}
		for _, p in f.Params {
			if p.Decl.IsSelf() {
				if !p.Decl.IsSmartptr() {
					self.pushErr(errorToken, log::ConcurrentCallWithSelfParam)
					self.pushSuggestion(log::UseUnsafeJuleToCallCoSelf)
				}
			}
			if p.Decl.Reference {
				self.pushErr(errorToken, log::ConcurrentCallWithRefParam)
				self.pushSuggestion(log::UseUnsafeJuleToCallCo)
				ret
			}
		}
	}

	fn processExceptionalHandler(mut *self, mut f: &FuncIns, mut fc: &ast::CallExpr, mut v: &Value) {
		resultNeeded := !self.target.ignored && !f.Decl.IsVoid()
		let mut csc: &scopeChecker = nil
		let mut ch: &Scope = nil

		mut fcValue := v.Model.(&FuncCallExpr)

		// self.lookup is always scopeChecker because exceptionals are
		// not allowed in global scope due to static variables are not allowed.
		// Therefore, if lookup is not scopeChecker, return immediately.
		mut sc, ok := self.lookup.(&scopeChecker)
		if !ok {
			ret
		}
		csc = sc.newChildChecker()
		if resultNeeded {
			csc.result = &result{func: f, mutable: self.target.mutable}
		}
		ch = sc.getChild()
		fc.Exception.Parent = sc.tree
		csc.table.Vars = append(csc.table.Vars, buildErrorVar(ch, fc))
		sc.checkChildSsc(fc.Exception, ch, csc)

		fcValue.Assigned = resultNeeded
		fcValue.Except = ch

		if resultNeeded && csc.result != nil {
			self.pushErr(fc.Token, log::MissingAssignRet)
		}
	}

	fn callFunc(mut &self, mut fc: &ast::CallExpr, mut &v: *&Value) {
		mut f := (*v).Type.Func()
		if f.IsBuiltin() {
			self.callBuiltinFunc(fc, v)
			ret
		}

		if !f.Decl.IsMethod() && hasDirective(f.Decl.Directives, directive::Test) {
			self.pushErr(fc.Token, log::TestCalled)
			*v = nil
			ret
		}

		if !(*v).Mutable && f.Decl.IsMethod() && !f.Decl.Static && f.Decl.Params[0].Mutable {
			if self.target.mutable {
				self.pushErr(fc.Token, log::MutOperationOnImmut)
			} else {
				// Caught mutability risk of immutable literals.
				// Literal will not be assigned to immutable memory,
				// used to call method with mutable receiver.
				// Assume literal as mutable and check accordingly.
				lit := isLitBased((*v).Model)
				if lit == nil {
					// Expression is not literal based, so data is strictly immutable.
					self.pushErr(fc.Token, log::MutOperationOnImmut)
				} else {
					checkMutRiskOfStructLit(self.s, lit)
				}
			}
		} else if !self.isUnsafe() && f.Decl.Unsafe {
			self.pushErr(fc.Token, log::UnsafeBehaviorAtOutOfUnsafeScope)
			self.pushSuggestion(log::WriteYourCodeInUnsafeJule)
		}

		mut dynamicAnnotation := len(f.Decl.Generics) > 0 && len(f.Generics) == 0 && len(f.Params) > 0
		if dynamicAnnotation {
			f.Generics = make([]&InsGeneric, len(f.Decl.Generics))
		} else if len(f.Generics) != len(f.Decl.Generics) {
			_ = self.s.checkGenericQuantity(len(f.Decl.Generics), len(f.Generics), fc.Token)
			*v = nil
			ret
		}

		mut old := self.s
		if f.Decl.Owner != nil {
			self.s = f.Decl.Owner.sema
		}

		defer {
			if old != self.s {
				old.errors = append(old.errors, self.s.errors...)
				self.s.errors = nil
			}
			self.s = old
		}

		mut fcac := fnCallArgChecker{
			e: self,
			args: fc.Args,
			dynamicAnnotation: dynamicAnnotation,
			errorToken: fc.Token,
		}

		// This will be used to collect recheck-needed types if dynamic annotation enabled.
		// See developer reference (15).
		let mut recheckNeed: []recheckableType

		if !dynamicAnnotation {
			if !f.reloaded {
				ok := self.s.reloadFuncInsTypes(f)
				f.reloaded = true
				if !ok {
					*v = nil
					ret
				}
			}
			mut existInstance := f.Decl.appendInstance(f)
			if existInstance != nil {
				f = existInstance
			}
		} else {
			// Use non-nil slice for dynamic type annotation.
			// Thus we can use recheck strategy even for zero recheck-need cases.
			recheckNeed = make([]recheckableType, 0, len(f.Params)/2)
			if !self.s.buildFuncNonGenericTypes(f, &fcac.ignored, &recheckNeed) {
				*v = nil
				ret
			}
		}

		fcac.f = f

		mut ok := false
		if f.Decl.Owner != nil {
			old, self.s = self.s, old // Save current sema.
			ok = fcac.check()
			old, self.s = self.s, old // Save owner sema.
		} else {
			ok = fcac.check()
		}

		if dynamicAnnotation {
			if !ok {
				*v = nil
				ret
			}
			// Clear generic type cache to catch inferred types.
			// Cache of functions will be nil already, because of dynamimc annotation.
			// But methods (functions associated with a structure) may have generics in cache.
			// When the owner struct have generic types, method's cache may not be empty.
			// In such case, generics of the method will not be cached.
			// Because algorithm will not re-cache if cache is not empty.
			// As a result, generic type aliases may be missing during analysis.
			// To avoid this, clear the cache of generic type aliases.
			f.env.generics = nil
			ok, _ = self.checkGenericFunc(&f, fc.Token, &(*v).Model, recheckNeed)
			if !ok {
				*v = nil
				ret
			}
		}

		mut callModel := (*v).Model

		if f.Decl.IsVoid() {
			*v = buildVoidValue()
		} else {
			(*v).Type = f.Result
			(*v).Lvalue = false
		}

		mut model := &FuncCallExpr{
			Token: fc.Token,
			Func: f,
			Expr: callModel,
			Args: fcac.argModels,
			IsCo: fc.IsCo,
		}
		(*v).Model = model
		(*v).Mutable = true

		if f.Decl.Exceptional {
			if fc.IsCo {
				self.s.pushErr(fc.Token, log::CoForExceptional)
				self.s.pushSuggestion(log::HandleInFunc)
			}
			match {
			| fc.Unhandled():
				self.pushErr(fc.Token, log::UnhandledExceptional)
				self.pushSuggestion(log::HandleExceptional)
			| fc.Exception == ast::Ignored:
				model.Except = nil
			| fc.Exception == ast::Forwarded:
				mut s, (ok) := self.lookup.(&scopeChecker)
				if ok {
					if s.isDeferred() {
						self.s.pushErr(fc.Token, "function call forwards exception in a deferred scope")
					} else {
						mut root := s.getRoot()
						if root.owner.Decl.Exceptional {
							model.Except = s.getChild()
							mut ec := buildVoidValue()
							ec.Model = &BuiltinErrorCallExpr{
								Func: root.owner,
								Err: self.evalVar(buildErrorVar(model.Except, fc), fc.Token),
							}
							model.Except.Stmts = append(model.Except.Stmts, ec)
							break
						}
					}
				}
				self.s.pushErr(fc.Token, "function call forwards exceptional in non-exceptional scope")
				self.s.pushSuggestion("make the function exceptional to forward")
			|:
				// Handled with scope.
				self.processExceptionalHandler(f, fc, *v)
			}
		} else if !fc.Unhandled() {
			self.pushErr(fc.Token, log::HandledUnexceptional)
		}

		if fc.IsCo {
			model.Func.AsAnon = true
			model.Func.CalledCo = true
			self.checkFuncOfConcurrentCall(model.Func, fc.Token)
		}
	}

	fn evalCall(mut &self, mut fc: &ast::CallExpr): &Value {
		mut prefix := self.prefix
		self.prefix = nil
		defer { self.prefix = prefix }

		_, isName := fc.Func.Data.(&ast::NameExpr)
		if isName {
			// Use fc.expr.Token.Kind instead of casting.
			// Same thing, but more efficient and performant.
			if fc.Func.Token.ID == token::ERROR {
				ret builtinCallerError(self, fc)
			}
		}

		mut _func := self.evalExprPlain(fc.Func)
		if _func == nil {
			ret nil
		}

		if _func.Decl {
			self.callTypeFunc(fc, &_func)
			ret _func
		}

		if _func.Type.Func() == nil {
			self.pushErr(fc.Token, log::CallingNonFunc)
			ret nil
		}

		self.callFunc(fc, &_func)
		ret _func
	}

	fn evalEnumStatic(mut *self, mut enm: &Enum, mut name: &token::Token): &Value {
		mut item := enm.FindItem(name.Kind)
		if item == nil {
			self.pushErr(name, log::ObjHaveNotIdent, enm.Name, name.Kind)
			ret nil
		}
		mut v := self.evalVar(item, name)
		if v != nil {
			v.Type = &Type{Kind: enm}
		}
		ret v
	}

	fn evalStructStatic(mut *self, mut s: &StructIns, name: &token::Token): &Value {
		mut v := new(Value)
		const Static = true
		mut method := s.FindMethod(name.Kind, Static)
		if method != nil {
			if !self.s.isAccessibleDefine(method.Public, method.Token) {
				self.pushErr(name, log::IdentIsNotAccessible, name.Kind)
				self.pushSuggestion(log::MakePubToAccess)
			}

			mut ins := method.instance()
			ins.Owner = s
			self.pushReference(ins)
			v.Model = &StructStaticIdentExpr{
				Structure: s,
				Expr: v.Model,
				Method: ins,
			}
			v.Type = &Type{
				Kind: ins,
			}
			ret v
		}
		self.pushErr(name, log::ObjHaveNotIdent, s.Decl.Name, name.Kind)
		ret nil
	}

	fn evalTraitSelector(mut *self, mut v: &Value, mut trt: &Trait, mut name: &token::Token): &Value {
		mut f := trt.FindMethod(name.Kind)
		if f == nil {
			self.pushErr(name, log::ObjHaveNotIdent, trt.Name, name.Kind)
			ret nil
		}
		ret &Value{
			Mutable: v.Mutable,
			Type: &Type{
				Kind: f.instance(),
			},
			Model: &TraitSubIdentExpr{
				Token: name,
				Expr: v.Model,
				Method: f,
				Trt: trt,
			},
		}
	}

	// This method evaluates expressions, will not check public availability.
	// The tok parameter should be identifier to accessed.
	fn evalStructSelectorField(mut *self, mut v: &Value, mut s: &StructIns, mut tok: &token::Token, mut f: &FieldIns): &Value {
		mut model := &StructSubIdentExpr{
			Token: tok,
			Expr: new(Value, *v),
			Field: f,
			Owner: s,
		}
		v.Model = model
		v.Type = f.Type
		v.Lvalue = true
		if f.Decl.Mutable && !v.Mutable {
			// Interior mutability.
			match type self.lookup {
			| &scopeChecker:
				// Use hard root scope to handle interior mutability.
				// To handle anonymous functions and closures too.
				scope := self.lookup.(&scopeChecker).getHardRoot()
				v.Mutable = scope.owner != nil && scope.owner.Owner == s
			}
		}
		ret v
	}

	// Like evalStructSelector, but checks only for fields.
	fn evalStructSelectorFieldOnly(mut *self, mut v: &Value, mut s: &StructIns, mut si: &ast::SelectorExpr): (&Value, found: bool) {
		mut f := s.FindField(si.Name.Kind)
		if f != nil {
			if !self.s.isAccessibleDefine(f.Decl.Public, f.Decl.Token) {
				self.pushErr(si.Name, log::IdentIsNotAccessible, f.Decl.Name)
				self.pushSuggestion(log::MakePubToAccess)
			}
			ret self.evalStructSelectorField(v, s, si.Name, f), true
		}
		ret nil, false
	}

	// This method evaluates expressions, will not check public availability.
	// The tok parameter should be identifier to accessed.
	fn evalStructSelectorMethod(mut *self, mut v: &Value, mut s: &StructIns, mut tok: &token::Token, mut m: &Func, ref: bool): &Value {
		if m.Params[0].IsSmartptr() && !ref {
			self.pushErr(tok, log::RefMethodUsedWithNotRefInstance)
		}

		mut ins := m.instance()
		ins.Owner = s
		self.pushReference(ins)
		mut model := new(Value, *v)
		v.Model = &StructSubIdentExpr{
			Token: tok,
			Expr: model,
			Method: ins,
			Owner: s,
		}
		v.Type = &Type{Kind: ins}
		ret v
	}

	fn evalStructSelector(mut *self, mut v: &Value, mut s: &StructIns, mut si: &ast::SelectorExpr, ref: bool): &Value {
		{
			mut tempS := s
			if s.Source != nil {
				tempS = s.Source.Struct()
			}
			if tempS != nil {
				mut r, found := self.evalStructSelectorFieldOnly(v, tempS, si)
				if found {
					ret r
				}
			}
		}

		const Static = false
		mut m := s.FindMethod(si.Name.Kind, Static)
		if m == nil {
			self.pushErr(si.Name, log::ObjHaveNotIdent, s.Decl.Name, si.Name.Kind)
			ret nil
		}
		if !self.s.isAccessibleDefine(m.Public, m.Token) {
			self.pushErr(si.Name, log::IdentIsNotAccessible, m.Name)
			self.pushSuggestion(log::MakePubToAccess)
		}

		ret self.evalStructSelectorMethod(v, s, si.Name, m, ref)
	}

	fn evalIntTypeStatic(mut *self, name: &token::Token): &Value {
		const kind: str = types::Int
		match name.Kind {
		| "Max":
			mut c := constant::Const.NewI64(types::MaxI(kind))
			c.Kind = kind
			ret &Value{
				Constant: c,
				Model: c,
				Type: primInt,
				untyped: true,
			}
		| "Min":
			mut c := constant::Const.NewI64(i64(types::Min(kind)))
			c.Kind = kind
			ret &Value{
				Constant: c,
				Model: c,
				Type: primInt,
				untyped: true,
			}
		|:
			self.pushErr(name, log::TypeHaveNotIdent, kind, name.Kind)
			ret nil
		}
	}

	fn evalUintTypeStatic(mut *self, name: &token::Token): &Value {
		const kind: str = types::Uint
		match name.Kind {
		| "Max":
			mut c := constant::Const.NewU64(types::MaxU(kind))
			c.Kind = kind
			ret &Value{
				Constant: c,
				Model: c,
				Type: primUint,
				untyped: true,
			}
		|:
			self.pushErr(name, log::TypeHaveNotIdent, kind, name.Kind)
			ret nil
		}
	}

	fn evalI8TypeStatic(mut *self, name: &token::Token): &Value {
		const (
			kind: str = types::I8
			min       = types::MinI8
			max       = types::MaxI8
		)
		match name.Kind {
		| "Max":
			mut c := constant::Const.NewI64(max)
			c.Kind = kind
			ret &Value{
				Constant: c,
				Model: c,
				Type: primI8,
				untyped: true,
			}
		| "Min":
			mut c := constant::Const.NewI64(min)
			c.Kind = kind
			ret &Value{
				Constant: c,
				Model: c,
				Type: primI8,
				untyped: true,
			}
		|:
			self.pushErr(name, log::TypeHaveNotIdent, kind, name.Kind)
			ret nil
		}
	}

	fn evalI16TypeStatic(mut *self, name: &token::Token): &Value {
		const (
			kind: str = types::I16
			min       = types::MinI16
			max       = types::MaxI16
		)
		match name.Kind {
		| "Max":
			mut c := constant::Const.NewI64(max)
			c.Kind = kind
			ret &Value{
				Constant: c,
				Model: c,
				Type: primI16,
				untyped: true,
			}
		| "Min":
			mut c := constant::Const.NewI64(min)
			c.Kind = kind
			ret &Value{
				Constant: c,
				Model: c,
				Type: primI16,
				untyped: true,
			}
		|:
			self.pushErr(name, log::TypeHaveNotIdent, kind, name.Kind)
			ret nil
		}
	}

	fn evalI32TypeStatic(mut *self, name: &token::Token): &Value {
		const (
			kind: str = types::I32
			min       = types::MinI32
			max       = types::MaxI32
		)
		match name.Kind {
		| "Max":
			mut c := constant::Const.NewI64(max)
			c.Kind = kind
			ret &Value{
				Constant: c,
				Model: c,
				Type: primI32,
				untyped: true,
			}
		| "Min":
			mut c := constant::Const.NewI64(min)
			c.Kind = kind
			ret &Value{
				Constant: c,
				Model: c,
				Type: primI32,
				untyped: true,
			}
		|:
			self.pushErr(name, log::TypeHaveNotIdent, kind, name.Kind)
			ret nil
		}
	}

	fn evalI64TypeStatic(mut *self, name: &token::Token): &Value {
		const (
			kind: str = types::I64
			min       = types::MinI64
			max       = types::MaxI64
		)
		match name.Kind {
		| "Max":
			mut c := constant::Const.NewI64(max)
			c.Kind = kind
			ret &Value{
				Constant: c,
				Model: c,
				Type: primI64,
				untyped: true,
			}
		| "Min":
			mut c := constant::Const.NewI64(min)
			c.Kind = kind
			ret &Value{
				Constant: c,
				Model: c,
				Type: primI64,
				untyped: true,
			}
		|:
			self.pushErr(name, log::TypeHaveNotIdent, kind, name.Kind)
			ret nil
		}
	}

	fn evalU8TypeStatic(mut *self, name: &token::Token): &Value {
		const (
			kind: str = types::U8
			max       = types::MaxU8
		)
		match name.Kind {
		| "Max":
			mut c := constant::Const.NewU64(max)
			c.Kind = kind
			ret &Value{
				Constant: c,
				Model: c,
				Type: primU8,
				untyped: true,
			}
		|:
			self.pushErr(name, log::TypeHaveNotIdent, kind, name.Kind)
			ret nil
		}
	}

	fn evalU16TypeStatic(mut *self, name: &token::Token): &Value {
		const (
			kind: str = types::U16
			max       = types::MaxU16
		)
		match name.Kind {
		| "Max":
			mut c := constant::Const.NewU64(max)
			c.Kind = kind
			ret &Value{
				Constant: c,
				Model: c,
				Type: primU16,
				untyped: true,
			}
		|:
			self.pushErr(name, log::TypeHaveNotIdent, kind, name.Kind)
			ret nil
		}
	}

	fn evalU32TypeStatic(mut *self, name: &token::Token): &Value {
		const (
			kind: str = types::U32
			max       = types::MaxU32
		)
		match name.Kind {
		| "Max":
			mut c := constant::Const.NewU64(max)
			c.Kind = kind
			ret &Value{
				Constant: c,
				Model: c,
				Type: primU32,
				untyped: true,
			}
		|:
			self.pushErr(name, log::TypeHaveNotIdent, kind, name.Kind)
			ret nil
		}
	}

	fn evalU64TypeStatic(mut *self, name: &token::Token): &Value {
		const (
			kind: str = types::U64
			max       = types::MaxU64
		)
		match name.Kind {
		| "Max":
			mut c := constant::Const.NewU64(max)
			c.Kind = kind
			ret &Value{
				Constant: c,
				Model: c,
				Type: primU64,
				untyped: true,
			}
		|:
			self.pushErr(name, log::TypeHaveNotIdent, kind, name.Kind)
			ret nil
		}
	}

	fn evalF32TypeStatic(mut *self, name: &token::Token): &Value {
		const (
			kind: str       = types::F32
			max             = types::MaxF32
			min             = types::MinF32
			smallestNonzero = types::SmallestNonzeroF32
		)
		match name.Kind {
		| "Max":
			mut c := constant::Const.NewF64(max)
			c.Kind = kind
			ret &Value{
				Constant: c,
				Model: c,
				Type: primF32,
				untyped: true,
			}
		| "Min":
			mut c := constant::Const.NewF64(min)
			c.Kind = kind
			ret &Value{
				Constant: c,
				Model: c,
				Type: primF32,
				untyped: true,
			}
		| "SmallestNonzero":
			mut c := constant::Const.NewF64(smallestNonzero)
			c.Kind = kind
			ret &Value{
				Constant: c,
				Model: c,
				Type: primF32,
				untyped: true,
			}
		|:
			self.pushErr(name, log::TypeHaveNotIdent, kind, name.Kind)
			ret nil
		}
	}

	fn evalF64TypeStatic(mut *self, name: &token::Token): &Value {
		const (
			kind: str       = types::F64
			max             = types::MaxF64
			min             = types::MinF64
			smallestNonzero = types::SmallestNonzeroF64
		)
		match name.Kind {
		| "Max":
			mut c := constant::Const.NewF64(max)
			c.Kind = kind
			ret &Value{
				Constant: c,
				Model: c,
				Type: primF64,
				untyped: true,
			}
		| "Min":
			mut c := constant::Const.NewF64(min)
			c.Kind = kind
			ret &Value{
				Constant: c,
				Model: c,
				Type: primF64,
				untyped: true,
			}
		| "SmallestNonzero":
			mut c := constant::Const.NewF64(smallestNonzero)
			c.Kind = kind
			ret &Value{
				Constant: c,
				Model: c,
				Type: primF64,
				untyped: true,
			}
		|:
			self.pushErr(name, log::TypeHaveNotIdent, kind, name.Kind)
			ret nil
		}
	}

	fn evalPrimStatic(mut *self, mut t: &Type, name: &token::Token): (v: &Value) {
		kind := t.Prim().Kind
		match kind {
		| types::Int:
			v = self.evalIntTypeStatic(name)
		| types::Uint:
			v = self.evalUintTypeStatic(name)
		| types::I8:
			v = self.evalI8TypeStatic(name)
		| types::I16:
			v = self.evalI16TypeStatic(name)
		| types::I32:
			v = self.evalI32TypeStatic(name)
		| types::I64:
			v = self.evalI64TypeStatic(name)
		| types::U8:
			v = self.evalU8TypeStatic(name)
		| types::U16:
			v = self.evalU16TypeStatic(name)
		| types::U32:
			v = self.evalU32TypeStatic(name)
		| types::U64:
			v = self.evalU64TypeStatic(name)
		| types::F32:
			v = self.evalF32TypeStatic(name)
		| types::F64:
			v = self.evalF64TypeStatic(name)
		|:
			self.pushErr(name, log::TypeHaveNotIdent, kind, name.Kind)
			ret nil
		}
		if v != nil && t.Kind != t.ActualKind() {
			// Type is not actual, return as non-actual typed.
			v.Type = t
		}
		ret
	}

	fn evalTypeStatic(mut *self, mut v: &Value, mut si: &ast::SelectorExpr): &Value {
		match {
		| v.Type.SoftStruct() != nil:
			// Eval soft structures first, because strict type aliases may
			// jump into other cases. So caught they here.
			ret self.evalStructStatic(v.Type.SoftStruct(), si.Name)
		| v.Type.Prim() != nil:
			ret self.evalPrimStatic(v.Type, si.Name)
		| v.Type.Enum() != nil:
			ret self.evalEnumStatic(v.Type.Enum(), si.Name)
		|:
			self.pushErr(si.Name, log::TypeNotSupportSubFields, v.Type.Str())
			ret nil
		}
	}

	fn comptimeObjSelector[ComptimeType](mut *self, mut ct: &ComptimeType, v: &Value, si: &ast::SelectorExpr): &Value {
		mut cd := ct.subIdent(si.Name.Kind)
		if cd == nil {
			self.pushErr(si.Name, log::ObjHaveNotIdent, v.Type.Str(), si.Name.Kind)
		}
		ret cd
	}

	fn tryComptimeObjSelector(mut *self, mut v: &Value, mut si: &ast::SelectorExpr): (&Value, bool) {
		match {
		| v.Type.comptimeTypeInfo() != nil:
			mut ct := v.Type.comptimeTypeInfo()
			ret self.comptimeObjSelector(ct, v, si), true
		| v.Type.comptimeStructField() != nil:
			mut ct := v.Type.comptimeStructField()
			ret self.comptimeObjSelector(ct, v, si), true
		| v.Type.comptimeEnumField() != nil:
			mut ct := v.Type.comptimeEnumField()
			ret self.comptimeObjSelector(ct, v, si), true
		| v.Type.comptimeParam() != nil:
			mut ct := v.Type.comptimeParam()
			ret self.comptimeObjSelector(ct, v, si), true
		| v.Type.comptimeStatic() != nil:
			mut ct := v.Type.comptimeStatic()
			ret self.comptimeObjSelector(ct, v, si), true
		| v.Type.comptimeValue() != nil:
			mut ct := v.Type.comptimeValue()
			ret self.comptimeObjSelector(ct, v, si), true
		| v.Type.comptimeFile() != nil:
			mut ct := v.Type.comptimeFile()
			ret self.comptimeObjSelector(ct, v, si), true
		| v.Type.comptimeDecl() != nil:
			mut ct := v.Type.comptimeDecl()
			ret self.comptimeObjSelector(ct, v, si), true
		|:
			ret nil, false
		}
	}

	fn evalObjSelector(mut *self, mut v: &Value, mut si: &ast::SelectorExpr): &Value {
		if jule::IsBlank(si.Name.Kind) {
			self.pushErr(si.Name, log::InvalidSyntax)
			ret nil
		}
		{
			mut compData, ok := self.tryComptimeObjSelector(v, si)
			if ok {
				ret compData
			}
		}
		mut kind := v.Type
		match type v.Type.Kind {
		| &Ptr:
			mut ptr := v.Type.Kind.(&Ptr)
			if ptr.IsUnsafe() {
				break
			}
			if !isRef(v) && !self.isUnsafe() {
				self.pushErr(si.Name, log::UnsafeBehaviorAtOutOfUnsafeScope)
				self.pushSuggestion(log::WriteYourCodeInUnsafeJule)
			}
			kind = ptr.Value
			makeImplicitDeref(v, si.Name)
		| &Sptr:
			mut sptr := v.Type.Kind.(&Sptr)
			kind = sptr.Value
			makeImplicitDeref(v, si.Name)
		}

		match type kind.Kind {
		| &StructIns:
			mut s := kind.Kind.(&StructIns)
			if s.Source != nil || isInstancedStruct(s) {
				mut usedReferenceElem := false
				match type v.Type.Kind {
				| &Sptr:
					usedReferenceElem = true
				}
				ret self.evalStructSelector(v, s, si, usedReferenceElem)
			}
		}
		if v.Type.Trait() != nil {
			ret self.evalTraitSelector(v, v.Type.Trait(), si.Name)
		}
		self.pushErr(si.Name, log::ObjNotSupportSubFields, v.Type.Str())
		ret nil
	}

	fn evalSelector(mut &self, mut si: &ast::SelectorExpr): &Value {
		mut prefix := self.prefix
		self.prefix = nil
		defer { self.prefix = prefix }
		mut v := self.eval1(si.X, evalDefault|evalPhysicalMem|evalUnwrapUntyped)
		if v == nil || v.Type == nil {
			ret nil
		}
		if v.Decl {
			ret self.evalTypeStatic(v, si)
		}
		ret self.evalObjSelector(v, si)
	}

	fn evalTupleFunc(mut &self, mut tup: &ast::TupleExpr, part: fn(mut expr: &ast::Expr): &Value): &Value {
		mut tupT := new(Tuple)
		tupT.Types = make([]&Type, 0, len(tup.X))

		mut model := &TupleExpr{
			Values: make([]&Value, 0, len(tup.X)),
		}

		mut ok := true
		for (_, mut x) in tup.X {
			mut v := part(x)
			if v == nil {
				ok = false
				continue
			}
			tupT.Types = append(tupT.Types, v.Type)
			model.Values = append(model.Values, v)
		}

		if !ok {
			ret nil
		}

		ret &Value{
			Type: &Type{Kind: tupT},
			Model: model,
		}
	}

	fn evalTuple(mut &self, mut tup: &ast::TupleExpr): &Value {
		ret self.evalTupleFunc(tup,
			fn|mut expr| self.evalExpr(expr, evalDefault|evalPhysicalMem))
	}

	// Map m is the map type of literal.
	// Type t is the actual value type, it may be strict type alias or pure map type.
	fn evalMap(mut &self, mut m: &Map, mut t: &Type, mut lit: &ast::BraceLit): &Value {
		mut model := &MapExpr{
			Kind: m,
		}

		mut prefix := self.prefix
		for (_, mut expr) in lit.X {
			mut pair, ok := expr.Data.(&ast::KeyValueExpr)
			if !ok {
				self.pushErr(lit.Token, log::InvalidSyntax)
				ret nil
			}

			self.prefix = model.Kind.Key
			// Do not unwrap untyped literals, type analysis will check overflows.
			mut key := self.evalExpr(pair.Key, evalDefault)
			self.prefix = prefix
			if key == nil {
				ret nil
			}

			self.prefix = model.Kind.Value
			// Do not unwrap untyped literals, type analysis will check overflows.
			mut value := self.evalExpr(pair.Value, evalDefault)
			self.prefix = prefix
			if value == nil {
				ret nil
			}

			const destIsRef = false
			const firstAssignToDest = false
			if self.s.checkValidityForInitExpr(self.target.mutable, destIsRef, m.Key, key, pair.Key.Token) {
				_ = self.s.checkAssignType(destIsRef, firstAssignToDest, m.Key, key, pair.Key.Token, self.getOwnerRefers())
			}
			if self.s.checkValidityForInitExpr(self.target.mutable, destIsRef, m.Value, value, pair.Value.Token) {
				_ = self.s.checkAssignType(destIsRef, firstAssignToDest, m.Value, value, pair.Value.Token, self.getOwnerRefers())
			}

			model.Entries = append(model.Entries, &KeyValueExpr{
				Key: key.Model,
				Value: value.Model,
			})
		}

		ret &Value{
			Mutable: true,
			Type: t,
			Model: model,
		}
	}

	fn evalBraceLit(mut &self, mut lit: &ast::BraceLit): &Value {
		match {
		| self.prefix == nil:
			self.pushErr(lit.Token, log::InvalidSyntax)
			ret nil
		| self.prefix.Map() != nil:
			ret self.evalMap(self.prefix.Map(), self.prefix, lit)
		| self.prefix.Struct() != nil:
			ret self.evalStructLitExplicit(self.prefix.Struct(), self.prefix, lit, lit.Token)
		}
		self.pushErr(lit.Token, log::InvalidSyntax)
		ret nil
	}

	fn evalAnonFuncIns(mut &self, mut decl: &ast::Func): (ins: &FuncIns) {
		if decl.IsShort() {
			if self.prefix == nil {
				self.s.pushErr(decl.Token, "type of the inferred anonymous function is unknown")
				ret nil
			}
			mut f := self.prefix.Func()
			if f == nil {
				self.s.pushErr(decl.Token, "type @ is invalid for the inferred anonymous function", self.prefix.Str())
				ret nil
			}
			if len(f.Params) != len(decl.Params) {
				self.s.pushErr(decl.Token, "unexpected parameter count for inferred anonymous function, expected @, found @", len(f.Params), len(decl.Params))
				ret nil
			}
			ins = f.Decl.instanceForce()
			ins.Decl = buildFunc(decl)
			ins.Decl.Result = f.Decl.Result
			ins.Decl.Exceptional = f.Decl.Exceptional
			ins.Decl.sema = self.s
			ins.Result = f.Result
			for (i, mut param) in ins.Params {
				param.Type = f.Params[i].Type
				param.Decl = ins.Decl.Params[i]
				param.Decl.TypeSym = f.Params[i].Decl.TypeSym
				param.Decl.Reference = f.Params[i].Decl.Reference
				param.Decl.Variadic = f.Params[i].Decl.Variadic
			}
			// Function body is one-line.
			if ins.Decl.Scope.Deferred {
				ins.Decl.Scope.Deferred = false // Remove mark of the one-line block.
				ins.oneliner = true
			}
		} else {
			ins = self.typeChecker().buildFunc(decl)
		}
		if ins != nil {
			ins.Anon = true
			ins.AsAnon = true
			ins.reloaded = true
		}
		ret
	}

	fn evalAnonFunc(mut &self, mut decl: &ast::Func): &Value {
		mut ins := self.evalAnonFuncIns(decl)
		if ins == nil {
			ret nil
		}
		// Function is type declaration.
		if decl.IsDecl() {
			ret &Value{
				Decl: true,
				Type: &Type{
					Kind: ins,
				},
			}
		}
		mut captured := make([]&Var, 0)
		match type self.lookup {
		| &scopeChecker:
			ins.fillEnviron(true)
			mut sc := self.lookup.(&scopeChecker)
			mut scc := sc.newChildChecker()
			scc.labels = new([]&scopeLabel, nil)
			scc.gotos = new([]&Goto, nil)
			scc.owner = ins
			scc.childIndex = 0
			scc.it = 0
			scc.cse = 0
			scc.captured = unsafe { (&[]&Var)(&captured) }
			self.s.checkFuncInsSc(ins, scc)
		|:
			self.s.checkFuncIns(ins)
		}

		// If we are in global scope and evaluation owner is a global variable,
		// push reference to the anonymous function.
		isGlobal := self.isGlobal()
		if isGlobal && self.owner != nil {
			self.pushReference(ins)
		}

		ret &Value{
			Type: &Type{Kind: ins},
			Model: &AnonFuncExpr{
				Captured: captured,
				Func: ins,
				Global: isGlobal,
			},
		}
	}

	fn evalBinary(mut &self, mut op: &ast::BinaryExpr): &Value {
		mut bs := binaryEval.newPlain(self)
		// Apply prefix for just numericals.
		if self.prefix != nil {
			prim := self.prefix.Prim()
			if prim == nil || !types::IsNum(prim.Str()) {
				mut prefix := self.prefix
				self.prefix = nil
				defer { self.prefix = prefix }
			}
		}
		ret bs.eval(op)
	}

	fn evalChanSend(mut &self, mut chs: &ast::ChanSend): &Value {
		mut l := self.evalExpr(chs.Chan, evalDefault|evalPhysicalMem|evalUnwrapUntyped)
		if l == nil {
			ret nil
		}
		mut ch := l.Type.Chan()
		if ch == nil {
			self.s.pushErr(chs.Chan.Token, log::ExprNotChan)
			self.s.pushSuggestion(log::RArrowOpExpectsChan)
			ret nil
		}
		if !ch.Send {
			self.s.pushErr(chs.Chan.Token, log::SendToRecvOnlyChan)
		}
		mut prefix := self.prefix
		mut mutable := self.target.mutable
		mut unsafety := self.unsafety
		self.prefix = ch.Value
		self.target.mutable = l.Mutable
		self.unsafety = self.isUnsafe()
		// Do not unwrap untyped literals, type analysis will check overflows.
		mut r := self.evalExpr(chs.X, evalDefault)
		self.prefix = prefix
		self.target.mutable = mutable
		self.unsafety = unsafety
		if r == nil {
			ret nil
		}
		match type self.lookup {
		| &scopeChecker:
			mut sc := self.lookup.(&scopeChecker)
			sc.removeInteriorMutRisk(r)
		}
		if l.Mutable && !r.Mutable && r.Type.Mutable() {
			self.s.pushErr(chs.X.Token, log::ImmutDataSendViaMutChan, r.Type.Str())
		}
		// Check assignment types and return.
		mut checker := assignTypeChecker{
			s: self.s,
			dest: ch.Value,
			v: r,
			errorToken: chs.X.Token,
			refers: self.getOwnerRefers(),
		}
		if !checker.check() {
			ret nil
		}
		mut v := buildVoidValue()
		v.Model = &ChanSend{
			Token: chs.Chan.Token,
			Chan: l,
			Data: r,
		}
		ret v
	}

	fn evalTypeAssertion(mut &self, mut tae: &ast::TypeAssertionExpr): &Value {
		mut t := self.evalType1(tae.Type)
		if t == nil {
			ret nil
		}
		mut prefix := self.prefix
		self.prefix = nil
		defer { self.prefix = prefix }
		flags := evalDefault | evalPhysicalMem | evalUnwrapUntyped
		mut v := self.evalExpr(tae.X, flags)
		if v == nil {
			ret v
		}
		mut errorToken := tae.X.Token
		if v != nil && v.Decl {
			self.pushErr(errorToken, log::InvalidExpr)
			ret nil
		}
		if v.Type.Prim() != nil && v.Type.Prim().IsAny() {
			if t.SoftStruct() == nil && t.TypeEnum() != nil {
				self.pushErr(errorToken, log::TypeEnumAssertedFromAny)
				ret nil
			}
		} else if v.Type.TypeEnum() != nil {
			n := len(self.s.errors)
			if !self.s.checkTypeCompatibility(v.Type, t, errorToken, typeCompDefault) {
				self.s.errors = self.s.errors[:n] // Remove logged errors by checkTypeCompatibility.
				self.pushErr(errorToken, log::TypeNotSupportsTypeAssertionTo, v.Type.Str(), t.Str())
				ret nil
			}
		} else if v.Type.Trait() != nil {
			mut ts := t.SoftStruct()
			if ts == nil {
				if t.Sptr() != nil {
					ts = t.Sptr().Value.SoftStruct()
				}
			}
			if ts == nil {
				self.pushErr(errorToken, log::TypeNotSupportsTypeAssertionTo, v.Type.Str(), t.Str())
				ret nil
			} else {
				const PreStrict = false
				self.castStruct(t, ts, v, errorToken, PreStrict)
			}
		} else {
			self.pushErr(errorToken, log::TypeNotSupportsTypeAssertion, v.Type.Str())
			ret nil
		}
		mut r := new(Value)
		r.Type = t
		r.Mutable = v.Mutable
		r.Model = &TypeAssertionExpr{
			Token: errorToken,
			Expr: v,
			Type: t,
		}
		ret r
	}

	fn evalExprData(mut &self, mut kind: ast::ExprData): &Value {
		match type kind {
		| &ast::RangeExpr:
			mut e := kind.(&ast::RangeExpr)
			ret self.evalExprPlain(e.X)
		| &ast::LitExpr:
			ret self.evalLit(kind.(&ast::LitExpr))
		| &ast::NameExpr:
			ret self.evalName(kind.(&ast::NameExpr))
		| &ast::VariadicExpr:
			ret self.evalVariadic(kind.(&ast::VariadicExpr))
		| &ast::UnsafeExpr:
			ret self.evalUnsafe(kind.(&ast::UnsafeExpr))
		| &ast::SliceExpr:
			ret self.evalSliceExpr(kind.(&ast::SliceExpr))
		| &ast::IndexExpr:
			ret self.evalIndex(kind.(&ast::IndexExpr))
		| &ast::SlicingExpr:
			ret self.evalSlicing(kind.(&ast::SlicingExpr))
		| &ast::NamespaceExpr:
			ret self.evalNamespace(kind.(&ast::NamespaceExpr))
		| &ast::TypedBraceLit:
			ret self.evalTypedBraceLit(kind.(&ast::TypedBraceLit))
		| &ast::CallExpr:
			ret self.evalCall(kind.(&ast::CallExpr))
		| &ast::SelectorExpr:
			ret self.evalSelector(kind.(&ast::SelectorExpr))
		| &ast::TupleExpr:
			ret self.evalTuple(kind.(&ast::TupleExpr))
		| &ast::BraceLit:
			ret self.evalBraceLit(kind.(&ast::BraceLit))
		| &ast::Func:
			ret self.evalAnonFunc(kind.(&ast::Func))
		| &ast::BinaryExpr:
			ret self.evalBinary(kind.(&ast::BinaryExpr))
		| &ast::ChanSend:
			ret self.evalChanSend(kind.(&ast::ChanSend))
		| &ast::TypeAssertionExpr:
			ret self.evalTypeAssertion(kind.(&ast::TypeAssertionExpr))
		|:
			ret nil
		}
	}

	// Like evalExprData, but it handles type declarations.
	fn evalExprPlain(mut &self, mut expr: &ast::Expr): &Value {
		match type expr.Data {
		| &ast::ArrayType
		| &ast::SliceType
		| &ast::ChanType
		| &ast::MapType:
			ret self.evalType(expr)
		| &ast::UnaryExpr:
			mut u := expr.Data.(&ast::UnaryExpr)
			// Catch unsafe pointer types.
			if u.IsUnsafePtr() {
				ret self.evalType(expr)
			}
			ret self.evalUnary(u, false)
		|:
			ret self.evalExprData(expr.Data)
		}
	}

	// Returns value data of evaluated expression.
	// Returns nil if error occurs.
	fn eval1(mut &self, mut expr: &ast::Expr, flags: int): &Value {
		let mut v: &Value
		// If refptr eval mode enabled, check for unary expression.
		// Because destination memory is reference pointer.
		// It can take only raw-pointer, so unary.
		// Check this special case for this mode.
		if flags&evalRefptr == evalRefptr {
			mut unary, _ := expr.Data.(&ast::UnaryExpr)
			if unary != nil {
				v = self.evalUnary(unary, true)
				goto AfterEval
			}
		}
		// Use ordinary expression eval.
		v = self.evalExprPlain(expr)
	AfterEval:
		if v == nil || v.Type == nil {
			ret nil
		}

		match {
		| v.Type.Func() != nil:
			// Check special cases for functions.
			mut f := v.Type.Func()
			if f.IsBuiltin() {
				self.s.pushErr(expr.Token, log::BuiltinNotInvoked)
				break
			}
			required := len(f.Decl.Generics)
			given := len(f.Generics)
			if !self.s.checkGenericQuantity(required, given, expr.Token) {
				ret nil
			}
			if !f.Decl.Static && f.Decl.IsMethod() {
				self.s.pushErr(expr.Token, log::MethodNotInvoked)
			} else if findDirective(f.Decl.Directives, directive::Export) != nil {
				self.s.pushErr(expr.Token, log::ExportedUsedAsAnonymous, f.Decl.Name)
			} else {
				f.AsAnon = true
			}
		| v.Decl:
			// Check evaluated type declarations.
			mut s := v.Type.Struct()
			if s == nil {
				break
			}
			required := len(s.Decl.Generics)
			given := len(s.Generics)
			if !self.s.checkGenericQuantity(required, given, expr.Token) {
				ret nil
			}
		}

		ok := checkValue(v, self.s, expr.Token, flags)
		if !ok {
			v = nil
		}

		ret v
	}

	// Returns value data of evaluated expression.
	// Returns nil if error occurs.
	// Accepts comptime expressions as invalid.
	fn eval(mut &self, mut expr: &ast::Expr, flags: int): &Value {
		mut v := self.eval1(expr, flags)
		if v == nil {
			ret nil
		}
		if (self.owner == nil || !self.owner.Constant) && v.Type.comptime() {
			self.s.pushErr(expr.Token, log::ComptimeAsExpr)
			ret nil
		}
		ret v
	}

	// Returns value data of evaluated expression by eval1.
	// Returns nil if error occurs.
	// Accepts decls as invalid expression.
	fn evalExpr1(mut &self, mut expr: &ast::Expr, flags: int): &Value {
		mut v := self.eval1(expr, flags)
		match {
		| v == nil:
			ret nil
		| v.Decl:
			self.pushErr(expr.Token, log::InvalidExpr)
			ret nil
		|:
			ret v
		}
	}

	// Returns value data of evaluated expression by eval.
	// Returns nil if error occurs.
	// Accepts decls as invalid expression.
	fn evalExpr(mut &self, mut expr: &ast::Expr, flags: int): &Value {
		mut v := self.eval(expr, flags)
		match {
		| v == nil:
			ret nil
		| v.Decl:
			self.pushErr(expr.Token, log::InvalidExpr)
			ret nil
		|:
			ret v
		}
	}
}

struct unaryEval {
	e: &eval
	v: &Value
	u: &ast::UnaryExpr

	evalRefptr: bool
}

impl unaryEval {
	fn new(mut e: &eval): unaryEval {
		ret unaryEval{
			e: e,
		}
	}

	fn minus(mut *self) {
		match {
		| self.v.Type == nil:
			self.v = nil
			ret
		| self.v.Type.Prim() != nil:
			if !types::IsNum(self.v.Type.Prim().Str()) {
				self.v = nil
				ret
			}
		|:
			self.v = nil
			ret
		}

		self.v.Lvalue = false
		self.v.Mutable = true

		if self.v.IsConst() {
			match {
			| self.v.Constant.IsCmplx128():
				a := self.v.Constant.ReadCmplx128()
				if self.v.Type.Prim().IsCmplx64() {
					self.v.Constant.SetCmplx128(f64(-f32(a.Real)), f64(-f32(a.Imag)))
				} else {
					self.v.Constant.SetCmplx128(a.Real, -a.Imag)
				}
			| self.v.Constant.IsF64():
				if self.v.Type.Prim().IsF32() {
					self.v.Constant.SetF64(f64(-f32(self.v.Constant.ReadF64())))
				} else {
					self.v.Constant.SetF64(-self.v.Constant.ReadF64())
				}
			| self.v.Constant.IsInt():
				i := self.v.Constant.ReadInt()
				if self.v.untyped {
					self.v.Constant.SetInt(i.Neg())
				} else {
					kind := self.v.Type.Prim().Kind
					sz := types::BitSizeOf(kind)
					match {
					| types::IsSigInt(kind):
						match sz {
						| 8:
							if i.Sign() == -1 {
								self.v.Constant.SetI64(i64(-i8(i.I64())))
							} else {
								self.v.Constant.SetI64(i64(-i8(i.U64())))
							}
						| 16:
							if i.Sign() == -1 {
								self.v.Constant.SetI64(i64(-i16(i.I64())))
							} else {
								self.v.Constant.SetI64(i64(-i16(i.U64())))
							}
						| 32:
							if i.Sign() == -1 {
								self.v.Constant.SetI64(i64(-i32(i.I64())))
							} else {
								self.v.Constant.SetI64(i64(-i32(i.U64())))
							}
						| 64:
							if i.Sign() == -1 {
								self.v.Constant.SetI64(-i.I64())
							} else {
								self.v.Constant.SetI64(-i64(i.U64()))
							}
						|:
							panic("sema: unimplemented bitsize for unaryEval.caret, this panic call should be unreachable")
						}
					| types::IsUnsigInt(kind):
						match sz {
						| 8:
							if i.Sign() == -1 {
								self.v.Constant.SetU64(u64(-u8(i.I64())))
							} else {
								self.v.Constant.SetU64(u64(-u8(i.U64())))
							}
						| 16:
							if i.Sign() == -1 {
								self.v.Constant.SetU64(u64(-u16(i.I64())))
							} else {
								self.v.Constant.SetU64(u64(-u16(i.U64())))
							}
						| 32:
							if i.Sign() == -1 {
								self.v.Constant.SetU64(u64(-u32(i.I64())))
							} else {
								self.v.Constant.SetU64(u64(-u32(i.U64())))
							}
						| 64:
							if i.Sign() == -1 {
								self.v.Constant.SetU64(-u64(i.I64()))
							} else {
								self.v.Constant.SetU64(-i.U64())
							}
						|:
							panic("sema: unimplemented bitsize for unaryEval.caret, this panic call should be unreachable")
						}
					}
				}
			|:
				panic("sema: unimplemented constant type for unaryEval.minus, this panic call should be unreachable")
			}
			if self.v.Constant.IsInt() && self.v.Constant.ReadInt().BitLen() > bitLimit {
				self.e.pushErr(self.u.Op, log::ConstantOverflowResult)
				self.v.Decl = true // Do not log error.
				ret
			}
			// Do not self model for constant expressions. It's a overhead,
			// because model will be changed to constant by following algorithm.
			ret
		}

		self.v.Model = &UnaryExpr{
			Expr: new(Value, *self.v),
			Op: self.u.Op,
		}
	}

	fn plus(mut *self) {
		match {
		| self.v.Type == nil:
			self.v = nil
			ret
		| self.v.Type.Prim() != nil:
			if !types::IsNum(self.v.Type.Prim().Str()) {
				self.v = nil
				ret
			}
		|:
			self.v = nil
			ret
		}

		self.v.Lvalue = false
		self.v.Mutable = true

		if self.v.IsConst() {
			match {
			| self.v.Constant.IsF64():
				self.v.Constant.SetF64(+self.v.Constant.ReadF64())
			| self.v.Constant.IsCmplx128():
				// No-op.
			| self.v.Constant.IsInt():
				// No-op
			|:
				panic("sema: unimplemented constant type for unaryEval.plus, this panic call should be unreachable")
			}
			// Do not update self model for constant expressions. It's a overhead,
			// because model will be changed to constant by following algorithm.
			ret
		}

		self.v.Model = &UnaryExpr{
			Expr: new(Value, *self.v),
			Op: self.u.Op,
		}
	}

	fn caret(mut *self) {
		match {
		| self.v.Type == nil:
			self.v = nil
			ret
		| self.v.Type.Prim() != nil:
			if !types::IsInt(self.v.Type.Prim().Str()) {
				self.v = nil
				ret
			}
		|:
			self.v = nil
			ret
		}

		self.v.Lvalue = false
		self.v.Mutable = true

		// If type is "int" or "uint", it should be evaluated by target architecture.
		// Evaluate by bitsize of the target architecture and set as i64 again.
		// Also other types should be evaluated by their own bitsize.
		// So implement this operator by bitsize in general.
		if self.v.IsConst() {
			i := self.v.Constant.ReadInt()
			// If value is untyped and constant have not any kind, set as untyped.
			// Otherwise set by type of value.
			if self.v.untyped && self.v.Constant.Kind == "" {
				self.v.Constant.SetInt(i.Not())
			} else {
				kind := self.v.Type.Prim().Kind
				sz := types::BitSizeOf(kind)
				match {
				| types::IsSigInt(kind):
					match sz {
					| 8:
						if i.Sign() == -1 {
							self.v.Constant.SetI64(i64(^i8(i.I64())))
						} else {
							self.v.Constant.SetI64(i64(^i8(i.U64())))
						}
					| 16:
						if i.Sign() == -1 {
							self.v.Constant.SetI64(i64(^i16(i.I64())))
						} else {
							self.v.Constant.SetI64(i64(^i16(i.U64())))
						}
					| 32:
						if i.Sign() == -1 {
							self.v.Constant.SetI64(i64(^i32(i.I64())))
						} else {
							self.v.Constant.SetI64(i64(^i32(i.U64())))
						}
					| 64:
						if i.Sign() == -1 {
							self.v.Constant.SetI64(^i.I64())
						} else {
							self.v.Constant.SetI64(^i64(i.U64()))
						}
					|:
						panic("sema: unimplemented bitsize for unaryEval.caret, this panic call should be unreachable")
					}
				| types::IsUnsigInt(kind):
					match sz {
					| 8:
						if i.Sign() == -1 {
							self.v.Constant.SetU64(u64(^u8(i.I64())))
						} else {
							self.v.Constant.SetU64(u64(^u8(i.U64())))
						}
					| 16:
						if i.Sign() == -1 {
							self.v.Constant.SetU64(u64(^u16(i.I64())))
						} else {
							self.v.Constant.SetU64(u64(^u16(i.U64())))
						}
					| 32:
						if i.Sign() == -1 {
							self.v.Constant.SetU64(u64(^u32(i.I64())))
						} else {
							self.v.Constant.SetU64(u64(^u32(i.U64())))
						}
					| 64:
						if i.Sign() == -1 {
							self.v.Constant.SetU64(^u64(i.I64()))
						} else {
							self.v.Constant.SetU64(^i.U64())
						}
					|:
						panic("sema: unimplemented bitsize for unaryEval.caret, this panic call should be unreachable")
					}
				|:
					panic("sema: unimplemented constant type for unaryEval.caret, this panic call should be unreachable")
				}
			}
			if self.v.Constant.IsInt() && self.v.Constant.ReadInt().BitLen() > bitLimit {
				self.e.pushErr(self.u.Op, log::ConstantOverflowResult)
				self.v.Decl = true // Do not log error.
				ret
			}
			// Do not update self model for constant expressions. It's a overhead,
			// because model will be changed to constant by following algorithm.
			ret
		}

		self.v.Model = &UnaryExpr{
			Expr: new(Value, *self.v),
			Op: self.u.Op,
		}
	}

	fn excl(mut *self) {
		t := self.v.Type.Prim()
		if t == nil || !t.IsBool() {
			self.v = nil
			ret
		}

		self.v.Lvalue = false
		self.v.Mutable = true

		if self.v.IsConst() {
			match {
			| self.v.Constant.IsBool():
				self.v.Constant.SetBool(!self.v.Constant.ReadBool())
			|:
				panic("sema: unimplemented constant type for unaryEval.excl, this panic call should be unreachable")
			}
			// Do not self model for constant expressions. It's a overhead,
			// because model will be changed to constant by following algorithm.
			ret
		}

		self.v.Model = &UnaryExpr{
			Expr: new(Value, *self.v),
			Op: self.u.Op,
		}
	}

	fn star(mut *self) {
		isRef := isRef(self.v)
		self.v.Model = &UnaryExpr{
			Expr: new(Value, *self.v),
			Op: self.u.Op,
		}

		match {
		| self.v.Type.Ptr() != nil:
			if !isRef && !self.e.isUnsafe() {
				self.e.pushErr(self.u.Op, log::UnsafeBehaviorAtOutOfUnsafeScope)
				self.e.pushSuggestion(log::WriteYourCodeInUnsafeJule)
			}

			mut t := self.v.Type.Ptr()
			if t.IsUnsafe() {
				self.v = nil
				ret
			}
			self.v.Type = t.Value
		| self.v.Type.Sptr() != nil:
			self.v.Type = self.v.Type.Sptr().Value
		|:
			self.v = nil
			ret
		}

		self.v.Constant = nil
		self.v.untyped = false
		self.v.Lvalue = true
	}

	fn amper(mut *self) {
		// Getting raw-pointer returns mutable pointer by default.
		// But if we are eval for refptr memory, use the value's mutability.
		mut mutable := true
		if self.evalRefptr {
			mutable = self.v.Mutable
		}

		match type self.v.Model {
		| &StructLitExpr:
			mut lit := self.v.Model.(&StructLitExpr)
			makeStructLitAlloc(self.v, lit)
		|:
			match {
			| canGetPtr(self.v):
				self.v.Type = &Type{
					Kind: &Ptr{Value: self.v.Type},
				}
				self.v.Model = &UnaryExpr{
					Expr: new(Value, *self.v),
					Op: self.u.Op,
				}
			|:
				self.v = nil
				ret
			}
		}

		self.v.Constant = nil
		self.v.untyped = false
		self.v.Lvalue = false
		self.v.Mutable = mutable
	}

	fn chanRecv(mut *self): &Value {
		mut v := self.e.evalExpr(self.u.X, evalDefault|evalPhysicalMem|evalUnwrapUntyped)
		if v == nil {
			ret nil
		}
		mut ch := v.Type.Chan()
		if ch == nil {
			// Expression type is not channel.
			self.e.pushErr(self.u.X.Token, log::ExprNotChan)
			self.e.pushSuggestion(log::RArrowOpExpectsChan)
			ret nil
		}
		if !ch.Recv {
			self.e.pushErr(self.u.X.Token, log::RecvFromSendOnlyChan)
		}
		v.Model = &ChanRecv{
			Token: self.u.X.Token,
			Expr: new(Value, *v),
		}
		v.Type = ch.Value
		ret v
	}

	fn typeDecl(mut *self) {
		mut tc := self.e.typeChecker()
		match self.u.Op.ID {
		| token::MUL:
			self.v.Type = &Type{Kind: tc.buildPtrFromType(self.v.Type)}
			self.v.Model = self.v.Type
		| token::AND:
			self.v.Type = &Type{Kind: tc.buildSptrFromType(self.v.Type)}
			self.v.Model = self.v.Type
		|:
			self.e.pushErr(self.u.Op, log::InvalidExprForUnary, self.u.Op.Kind, self.v.Type.Str())
			self.v = nil
			ret
		}
		self.v.Decl = true
	}

	fn evalData(mut *self) {
		match self.u.Op.ID {
		| token::MUL
		| token::AND:
			mut prefix := self.e.prefix
			self.e.prefix = nil
			self.v = self.e.eval(self.u.X, evalDefault)
			self.e.prefix = prefix
		|:
			self.v = self.e.eval(self.u.X, evalDefault)
		}
	}

	fn eval(mut *self, mut u: &ast::UnaryExpr): &Value {
		self.u = u
		// Special case: channel receive expression.
		if self.u.Op.ID == token::ARROW {
			ret self.chanRecv()
		}
		self.evalData()
		if self.v == nil {
			ret nil
		}
		if self.v.Decl {
			self.typeDecl()
			ret self.v
		}

		// NOTE
		// The self.v.Decl is false now.
		// Any function may be set to true.
		// For this cases, following algorithm will not log error and
		// returns nil.
		kind := self.v.Type
		match self.u.Op.ID {
		| token::SUB:
			self.minus()
		| token::ADD:
			self.plus()
		| token::XOR:
			self.caret()
		| token::NOT:
			self.excl()
		| token::MUL:
			self.star()
		| token::AND:
			self.amper()
		|:
			self.v = nil
		}

		match {
		| self.v == nil:
			self.e.pushErr(self.u.Op, log::InvalidExprForUnary, self.u.Op.Kind, kind.Str())
			ret nil
		| self.v.Decl:
			self.v = nil
		| self.v.IsConst():
			self.v.Model = self.v.Constant
		}
		ret self.v
	}
}

struct binaryEval {
	e:  &eval
	l:  &Value
	r:  &Value
	op: &token::Token
	lt: &token::Token
	rt: &token::Token
}

impl binaryEval {
	fn newPlain(mut e: &eval): binaryEval {
		ret binaryEval{
			e: e,
		}
	}

	fn new(mut e: &eval, mut op: &token::Token,
		mut lt: &token::Token, mut rt: &token::Token): binaryEval {
		ret binaryEval{
			e: e,
			op: op,
			lt: lt,
			rt: rt,
		}
	}

	// Reports whether types are compatible.
	// Also logs error message about incompatibility if types are incompatible.
	fn checkTypeCompatibility(mut *self): bool {
		ret self.e.s.checkTypeCompatibility1(self.l.Type, self.r, self.op, typeCompDefault)
	}

	// Like the checkTypeCompatibility method, but tries to be compatible with
	// constant operands. Such as; "ordinary str" == MyStr("strict typed string")
	fn checkTypeCompatibility1(mut *self): bool {
		if self.l.IsConst() && self.l.untyped {
			self.l, self.r = self.r, self.l
		}
		const Reference = false
		const FirstAssignToDest = false
		ret self.e.s.checkAssignType(Reference, FirstAssignToDest, self.l.Type, self.r, self.op, nil)
	}

	fn evalComptimeTypeInfo(mut *self): &Value {
		mut r := self.r.Type.comptimeTypeInfo()
		if r == nil {
			self.e.pushErr(self.op, log::IncompatibleTypes, "comptimeTypeInfo", self.r.Type.Str())
			ret nil
		}
		mut l := self.l.Type.comptimeTypeInfo()
		match self.op.ID {
		| token::EQL:
			mut constant := constant::Const.NewBool(l.base.Equal(r.base))
			ret &Value{
				untyped: true,
				Type: primBool,
				Constant: constant,
				Model: constant,
			}
		| token::NEQ:
			mut constant := constant::Const.NewBool(!l.base.Equal(r.base))
			ret &Value{
				untyped: true,
				Type: primBool,
				Constant: constant,
				Model: constant,
			}
		|:
			self.e.pushErr(self.op, log::OperatorNotForJuleType, self.op.Kind, self.l.Type.Str())
			ret nil
		}
	}

	fn evalNil(mut *self): &Value {
		if !self.r.Type.NilCompatible() {
			self.e.pushErr(self.op, log::IncompatibleTypes, "nil", self.r.Type.Str())
			ret nil
		}

		match self.op.ID {
		| token::EQL
		| token::NEQ:
			ret &Value{
				untyped: true,
				Type: primBool,
			}
		|:
			self.e.pushErr(self.op, log::OperatorNotForJuleType, self.op.Kind, "nil")
			ret nil
		}
	}

	fn evalEnum(mut *self): &Value {
		match self.op.ID {
		| token::EQL
		| token::NEQ:
			mut rkind := self.r.Type
			if self.r.Type.Enum() != nil {
				rkind = self.r.Type.Enum().TypeSym.Type
			}
			mut enm := self.l.Type.Enum()
			if !self.e.s.checkTypeCompatibility(enm.TypeSym.Type, rkind, self.op, typeCompDefault) {
				ret nil
			}
			ret &Value{
				untyped: true,
				Type: primBool,
			}
		}

		if !self.checkTypeCompatibility() {
			ret nil
		}

		match self.op.ID {
		| token::GTR
		| token::LSS
		| token::GEQ
		| token::LEQ:
			if !types::IsNum(self.l.Type.Enum().TypeSym.Type.Prim().Str()) {
				self.e.pushErr(self.op, log::OperatorNotForJuleType, self.op.Kind, self.l.Type.Str())
				ret nil
			}
			ret &Value{
				untyped: true,
				Type: primBool,
			}
		| token::AND:
			mut first := self.l.Type.Enum().Items[0]
			i := first.ValueSym.Value.Constant.ReadInt()
			match {
			| i.IsI64():
				if i.I64() == 0 {
					goto next
				}
				goto err
			| i.IsU64():
				if i.U64() == 0 {
					goto next
				}
				goto err
			|:
				panic("sema: unimplemented enum type, this panic call should be unreachable")
			}
		err:
			self.e.pushErr(self.op, log::AmperOpForEnum, self.l.Type.Str(), self.op.Kind)
			self.e.pushSuggestion(log::DefineZeroDefaultToUseAmper)
		next:
			fall
		| token::OR
		| token::XOR:
			mut enm := self.l.Type.Enum()
			if enm.TypeSym.Type.Prim() == nil || !types::IsInt(enm.TypeSym.Type.Prim().Str()) {
				self.e.pushErr(self.op, log::OperatorNotForJuleType, self.op.Kind, self.l.Type.Str())
			}
			ret self.l
		|:
			self.e.pushErr(self.op, log::OperatorNotForJuleType, self.op.Kind, self.l.Type.Str())
			ret nil
		}
	}

	fn evalTypeEnum(mut *self): &Value {
		if !self.checkTypeCompatibility() {
			ret nil
		}

		match self.op.ID {
		| token::EQL
		| token::NEQ:
			ret &Value{
				untyped: true,
				Type: primBool,
			}
		|:
			self.e.pushErr(self.op, log::OperatorNotForJuleType, self.op.Kind, self.l.Type.Str())
			ret nil
		}
	}

	fn evalChan(mut *self): &Value {
		if !self.checkTypeCompatibility() {
			ret nil
		}

		match self.op.ID {
		| token::EQL
		| token::NEQ:
			ret &Value{
				untyped: true,
				Type: primBool,
			}
		|:
			self.e.pushErr(self.op, log::OperatorNotForJuleType, self.op.Kind, self.l.Type.Str())
			ret nil
		}
	}

	fn evalSptr(mut *self): &Value {
		if !self.checkTypeCompatibility() {
			ret nil
		}

		match self.op.ID {
		| token::EQL
		| token::NEQ:
			ret &Value{
				untyped: true,
				Type: primBool,
			}
		|:
			self.e.pushErr(self.op, log::OperatorNotForJuleType, self.op.Kind, self.l.Type.Str())
			ret nil
		}
	}

	fn evalPtr(mut *self): &Value {
		if isRef(self.l) {
			match self.op.ID {
			| token::EQL | token::NEQ:
				if !self.checkTypeCompatibility() {
					ret nil
				}
				ret &Value{
					untyped: true,
					Type: primBool,
				}
			|:
				self.e.pushErr(self.op, "operator @ is not defined for reference type @", self.op.Kind, self.l.Type.Str())
				self.e.pushSuggestion("try deference the reference pointer like: *x")
				ret nil
			}
		}

		match self.op.ID {
		| token::EQL
		| token::NEQ
		| token::LSS
		| token::GTR
		| token::LEQ
		| token::GEQ:
			if !self.checkTypeCompatibility() {
				ret nil
			}
			ret &Value{
				untyped: true,
				Type: primBool,
			}
		| token::ADD
		| token::SUB:
			if self.l.Type.Ptr() == nil {
				self.l, self.r = self.r, self.l
			}
			if self.l.Type.Ptr().IsUnsafe() {
				self.e.pushErr(self.op, log::OperatorNotForJuleType, self.op.Kind, self.l.Type.Str())
			}
			if !isPtrArithmeticCompatible(self.l, self.r) {
				self.e.pushErr(self.op, log::IncompatibleTypeForPtrArithmetic, self.r.Type.Str())
				ret nil
			}
			ret self.l
		|:
			self.e.pushErr(self.op, log::OperatorNotForJuleType, self.op.Kind, self.l.Type.Str())
			ret nil
		}
	}

	fn evalArray(mut *self): &Value {
		if !self.checkTypeCompatibility() {
			ret nil
		}

		match self.op.ID {
		| token::EQL
		| token::NEQ:
			// We will not have to check whether array type is comparable.
			// Binary eval already checked comparable special cases, so operands should be comparable.
			if self.e.s.meta.runtime != nil {
				// Add instance to relevant runtime function for array element type if not exist.
				mut f := runtimeFindFunc(self.e.s.meta.runtime, "arrayCmp").instanceForce()
				f.Generics = append(f.Generics, &InsGeneric{Type: self.l.Type.Array().Value})
				ok, _ := self.e.s.checkGenericFunc(&f, self.op)
				if !ok {
					panic("sema: arrayCmp evaluation failed, this is an implementation mistake")
				}
				self.e.pushReference(f)
			}
			ret &Value{
				untyped: true,
				Type: primBool,
			}
		|:
			self.e.pushErr(self.op, log::OperatorNotForJuleType, self.op.Kind, self.l.Type.Str())
			ret nil
		}
	}

	fn evalStruct(mut *self): &Value {
		match self.op.ID {
		| token::EQL
		| token::NEQ:
			if !self.checkTypeCompatibility() {
				ret nil
			}
			ret &Value{
				untyped: true,
				Type: primBool,
			}
		|:
			self.e.pushErr(self.op, log::OperatorNotForJuleType, self.op.Kind, self.l.Type.Str())
			ret nil
		}
	}

	fn evalTrait(mut *self): &Value {
		if !self.checkTypeCompatibility() {
			ret nil
		}

		match self.op.ID {
		| token::EQL
		| token::NEQ:
			ret &Value{
				untyped: true,
				Type: primBool,
			}
		|:
			self.e.pushErr(self.op, log::OperatorNotForJuleType, self.op.Kind, self.l.Type.Str())
			ret nil
		}
	}

	fn evalAny(mut *self): &Value {
		match self.op.ID {
		| token::EQL
		| token::NEQ:
			applyImplicitCast(self.e.s, self.l.Type, self.r, self.op, self.e.getOwnerRefers())
			ret &Value{
				untyped: true,
				Type: primBool,
			}
		|:
			self.e.pushErr(self.op, log::OperatorNotForJuleType, self.op.Kind, self.l.Type.Str())
			ret nil
		}
	}

	fn evalBool(mut *self): &Value {
		if !self.checkTypeCompatibility1() {
			ret nil
		}

		match self.op.ID {
		| token::EQL
		| token::NEQ
		| token::LAND
		| token::LOR:
			ret self.l
		|:
			self.e.pushErr(self.op, log::OperatorNotForJuleType, self.op.Kind, self.l.Type.Str())
			ret nil
		}
	}

	fn evalStr(mut *self): &Value {
		if !self.checkTypeCompatibility1() {
			ret nil
		}

		match self.op.ID {
		| token::ADD:
			ret self.l
		| token::EQL
		| token::NEQ
		| token::LSS
		| token::GTR
		| token::GEQ
		| token::LEQ:
			ret &Value{
				untyped: true,
				Type: primBool,
			}
		|:
			self.e.pushErr(self.op, log::OperatorNotForJuleType, self.op.Kind, self.l.Type.Str())
			ret nil
		}
	}

	fn setTypeToGreater(mut *self) {
		lp := self.l.Type.Prim()
		rp := self.r.Type.Prim()

		// Special case: complex numbers.
		// Always use complex number type of the operand.
		if lp.IsCmplx64() || lp.IsCmplx128() {
			self.r.Type = self.l.Type
			if self.r.IsConst() {
				self.r.Constant.Kind = lp.Kind
			}
			ret
		}

		if self.l.untyped && !self.r.untyped {
			self.l.Type = self.r.Type
			if self.l.IsConst() {
				self.l.Constant.Kind = rp.Kind
			}
			self.l.untyped = false
		} else if !self.l.untyped && self.r.untyped {
			self.r.Type = self.l.Type
			if self.r.IsConst() {
				self.r.Constant.Kind = lp.Kind
			}
			self.r.untyped = false
		} else if self.l.untyped && self.r.untyped {
			ls := getUntypedCmpScore(lp.Kind)
			rs := getUntypedCmpScore(rp.Kind)
			if ls > rs {
				self.r.Type = self.l.Type
				if self.r.IsConst() {
					self.r.Constant.Kind = lp.Kind
				}
				self.l.untyped = false
			} else if ls < rs {
				self.l.Type = self.r.Type
				if self.l.IsConst() {
					self.l.Constant.Kind = rp.Kind
				}
				self.l.untyped = false
			}
		}
	}

	fn checkModData(mut *self, mut v: &Value) {
		if !v.IsConst() {
			if v.Type.Prim() == nil || !types::IsInt(v.Type.Prim().Kind) {
				self.e.pushErr(self.op, log::ModuloWithNotInt)
			}
			ret
		}
		match {
		| sigAssignable(types::I64, v):
			v.Constant.SetI64(v.Constant.AsI64())
		| unsigAssignable(types::U64, v):
			v.Constant.SetU64(v.Constant.AsU64())
		|:
			self.e.pushErr(self.op, log::ModuloWithNotInt)
		}
	}

	fn mod(mut *self) {
		self.checkModData(self.l)
		self.checkModData(self.r)
	}

	fn numbersAreCompatible(mut *self): bool {
		lk := self.l.Type.Prim().Kind
		rk := self.r.Type.Prim().Kind
		if !types::IsNum(rk) {
			self.e.s.pushCompatibilityError(self.l.Type, self.r, self.op)
			ret false
		}

		// Special case: complex numbers.
		// They always needs extra effort to handle implicit castings.
		if lk == types::Cmplx64 {
			if self.r.IsConst() && self.r.untyped {
				ret castConstByType(self.e.s, self.rt, self.l.Type, self.r)
			}
			if rk != types::Cmplx64 {
				self.e.s.pushCompatibilityError(self.l.Type, self.r, self.op)
				ret false
			}
			ret true
		}
		if lk == types::Cmplx128 {
			if self.r.IsConst() && self.r.untyped {
				ret castConstByType(self.e.s, self.rt, self.l.Type, self.r)
			}
			if rk != types::Cmplx128 {
				self.e.s.pushCompatibilityError(self.l.Type, self.r, self.op)
				ret false
			}
			ret true
		}

		if self.l.IsConst() && self.l.untyped {
			if !self.r.untyped && self.r.IsConst() {
				ret castConstByType(self.e.s, self.lt, self.r.Type, self.l)
			}
			ret true
		}
		if lk == types::F32 {
			if self.r.IsConst() && self.r.untyped {
				ret castConstByType(self.e.s, self.rt, self.l.Type, self.r)
			}
			if rk != types::F32 {
				self.e.s.pushCompatibilityError(self.l.Type, self.r, self.op)
				ret false
			}
			ret true
		}
		if lk == types::F64 {
			if self.r.IsConst() && self.r.untyped {
				ret castConstByType(self.e.s, self.rt, self.l.Type, self.r)
			}
			if rk != types::F64 {
				self.e.s.pushCompatibilityError(self.l.Type, self.r, self.op)
				ret false
			}
			ret true
		}
		if self.r.IsConst() && self.r.untyped {
			ret true
		}
		ret self.checkTypeCompatibility()
	}

	// Operator guaranteed to be << or >>.
	// Operands should be guaranteed in original order.
	fn shift(mut *self): &Value {
		lk := self.l.Type.Prim()
		if lk == nil {
			self.e.pushErr(self.op, log::OperatorNotForJuleType, self.op.Kind, self.l.Type.Str())
			ret nil
		}
		rk := self.r.Type.Prim()
		if rk == nil {
			self.e.pushErr(self.op, log::OperatorNotForJuleType, self.op.Kind, self.r.Type.Str())
			ret nil
		}
		// primitive guaranteed

		if !types::IsNum(lk.Kind) || !types::IsNum(rk.Kind) {
			self.e.s.pushCompatibilityError(self.l.Type, self.r, self.op)
			ret nil
		}
		// number guaranteed

		if !types::IsInt(lk.Kind) {
			// should be floating-point
			if !self.l.IsConst() || !self.l.untyped {
				self.e.pushErr(self.op, log::IncompatibleTypes, self.l.Type.Str(), self.r.Type.Str())
				ret nil
			} else if intAssignable(types::I64, self.l) {
				self.l.Constant.SetI64(self.l.Constant.AsI64())
				self.l.Type = primI64
			} else if intAssignable(types::U64, self.l) {
				self.l.Constant.SetU64(self.l.Constant.AsU64())
				self.l.Type = primU64
			}
		}
		if !types::IsInt(rk.Kind) {
			// should be floating-point
			if !self.r.IsConst() || !self.l.untyped {
				self.e.pushErr(self.op, log::IncompatibleTypes, self.l.Type.Str(), self.r.Type.Str())
				ret nil
			} else if intAssignable(types::I64, self.r) {
				self.r.Constant.SetI64(self.r.Constant.AsI64())
				self.r.Type = primI64
			} else if intAssignable(types::U64, self.r) {
				self.r.Constant.SetU64(self.r.Constant.AsU64())
				self.r.Type = primU64
			}
		}
		// integer guaranteed

		if !isOkForShifting(self.r) {
			if self.r.untyped {
				self.e.s.pushCompatibilityError(primUint, self.r, self.rt)
			} else {
				self.e.pushErr(self.rt, log::BitShiftMustUnsigned)
			}
			ret nil
		}
		// value is valid guaranteed

		const maxShiftCount = bitLimit
		if self.r.IsConst() {
			if self.r.Constant.IsInt() {
				i := self.r.Constant.ReadInt()
				if i.IsI64() && i.I64() > maxShiftCount ||
					i.IsU64() && i.U64() > maxShiftCount {
					self.e.pushErr(self.rt, log::InvalidShiftCount, i.Str())
					ret nil
				}
			} else if self.r.Constant.IsF64() && self.r.Constant.ReadF64() > maxShiftCount {
				self.e.pushErr(self.rt, log::InvalidShiftCount, self.r.Constant.Str())
				ret nil
			}
		}

		if self.r.untyped || !self.r.Type.Equal(self.l.Type) {
			applyImplicitCast(self.e.s, self.l.Type, self.r, self.rt, self.e.getOwnerRefers())
		}
		// unsigned guaranteed
		ret self.l
	}

	fn evalCmplx(mut *self): &Value {
		if !self.numbersAreCompatible() {
			ret nil
		}

		// Logicals.
		match self.op.ID {
		| token::EQL
		| token::NEQ:
			self.setTypeToGreater()
			ret &Value{
				untyped: true,
				Type: primBool,
			}
		}

		// Arithmetics.
		match self.op.ID {
		| token::ADD
		| token::SUB
		| token::MUL
		| token::QUO:
			self.setTypeToGreater()
			ret self.l
		|:
			self.e.pushErr(self.op, log::OperatorNotForFloat, self.op.Kind)
			ret nil
		}
	}

	fn evalFloat(mut *self): &Value {
		if !self.numbersAreCompatible() {
			ret nil
		}

		// Logicals.
		match self.op.ID {
		| token::EQL
		| token::NEQ
		| token::LSS
		| token::GTR
		| token::GEQ
		| token::LEQ:
			self.setTypeToGreater()
			ret &Value{
				untyped: true,
				Type: primBool,
			}
		}

		// Arithmetics.
		match self.op.ID {
		| token::SHL
		| token::SHR:
			panic("sema: binary shifting operator handling failed")
		| token::ADD
		| token::SUB
		| token::MUL:
			self.setTypeToGreater()
			ret self.l
		| token::QUO:
			self.setTypeToGreater()
			ret self.l
		| token::REM:
			if !types::IsInt(self.r.Type.Prim().Kind) {
				self.e.pushErr(self.op, log::IncompatibleTypes, self.l.Type.Str(), self.r.Type.Str())
				ret nil
			}
			self.mod()
			self.setTypeToGreater()
			ret self.r
		|:
			self.e.pushErr(self.op, log::OperatorNotForFloat, self.op.Kind)
			ret nil
		}
	}

	fn evalInt(mut *self): &Value {
		if !self.numbersAreCompatible() {
			ret nil
		}

		// Logicals.
		match self.op.ID {
		| token::EQL
		| token::NEQ
		| token::LSS
		| token::GTR
		| token::GEQ
		| token::LEQ:
			ret &Value{
				untyped: true,
				Type: primBool,
			}
		}

		// Arithmetics.
		match self.op.ID {
		| token::SHL
		| token::SHR:
			panic("sema: binary shifting operator handling failed")
		| token::ADD
		| token::SUB
		| token::MUL
		| token::AND
		| token::OR
		| token::XOR:
			self.setTypeToGreater()
			ret self.l
		| token::QUO:
			self.setTypeToGreater()
			ret self.l
		| token::REM:
			self.mod()
			self.setTypeToGreater()
			ret self.l
		|:
			self.e.pushErr(self.op, log::OperatorNotForInt, self.op.Kind)
			ret nil
		}
	}

	fn evalPrim(mut *self): &Value {
		prim := self.l.Type.Prim()
		match {
		| prim.IsBool():
			ret self.evalBool()
		| prim.IsStr():
			ret self.evalStr()
		}

		rp := self.r.Type.Prim()
		if rp == nil {
			self.e.pushErr(self.op, log::IncompatibleTypes, prim.Str(), self.r.Type.Str())
			ret nil
		}

		match {
		| types::IsCmplx(prim.Kind):
			ret self.evalCmplx()
		| types::IsCmplx(rp.Kind):
			// Do not fall statement here for the case above.
			// To handle both complex operand cases, this is needed.
			//	In such expressions; r != 10+6i
			//	If we swap operands, constant part comes first.
			//	If type of r is cmplx64, type mismatch error appears.
			//	Because 10+6i literal is untyped cmplx128 by default.
			//	To handle properly, always check the left operand first.
			self.l, self.r = self.r, self.l
			ret self.evalCmplx()
		| types::IsFloat(prim.Kind):
			ret self.evalFloat()
		| types::IsInt(prim.Kind):
			ret self.evalInt()
		|:
			ret nil
		}
	}

	fn checkSpecialCases(mut *self): (ok: bool) {
		ok = true
		comparing := self.op.ID == token::EQL || self.op.ID == token::NEQ
		if !comparing {
			ret
		}
		if !self.l.Type.Comparable() && !self.r.Type.IsNil() {
			self.e.pushErr(self.op, log::TypeIsNotComparable, self.l.Type.Str())
			ok = false
		} else if !self.r.Type.Comparable() && !self.l.Type.IsNil() {
			self.e.pushErr(self.op, log::TypeIsNotComparable, self.r.Type.Str())
			ok = false
		}
		ret ok
	}

	fn evalOp(mut *self): &Value {
		ok := self.checkSpecialCases()
		if !ok {
			ret nil
		}

		// Shift operators.
		if self.op.ID == token::SHL || self.op.ID == token::SHR {
			ret self.shift()
		}

		match {
		| self.l.Type.Void():
			self.e.pushErr(self.op, log::OperatorNotForJuleType, self.op.Kind, "void")
			ret nil
		| self.r.Type.comptimeTypeInfo() != nil:
			self.l, self.r = self.r, self.l
			fall
		| self.l.Type.comptimeTypeInfo() != nil:
			ret self.evalComptimeTypeInfo()
		| self.r.Type.Prim() != nil && self.r.Type.Prim().IsAny():
			self.l, self.r = self.r, self.l
			fall
		| self.r.Type.IsNil():
			self.l, self.r = self.r, self.l
			fall
		| self.l.Type.IsNil():
			ret self.evalNil()
		| self.l.Type.Prim() != nil && self.l.Type.Prim().IsAny():
			ret self.evalAny()
		| self.r.Type.TypeEnum() != nil:
			self.l, self.r = self.r, self.l
			fall
		| self.l.Type.TypeEnum() != nil:
			ret self.evalTypeEnum()
		| self.r.Type.Enum() != nil:
			self.l, self.r = self.r, self.l
			fall
		| self.l.Type.Enum() != nil:
			ret self.evalEnum()
		| self.r.Type.Chan() != nil:
			self.l, self.r = self.r, self.l
			fall
		| self.l.Type.Chan() != nil:
			ret self.evalChan()
		| self.r.Type.Sptr() != nil:
			self.l, self.r = self.r, self.l
			fall
		| self.l.Type.Sptr() != nil:
			ret self.evalSptr()
		| self.r.Type.Ptr() != nil:
			self.l, self.r = self.r, self.l
			fall
		| self.l.Type.Ptr() != nil:
			ret self.evalPtr()
		| self.l.Type.Array() != nil:
			ret self.evalArray()
		| self.r.Type.Trait() != nil:
			self.l, self.r = self.r, self.l
			fall
		| self.l.Type.Trait() != nil:
			ret self.evalTrait()
		| self.l.Type.Prim() != nil:
			ret self.evalPrim()
		| self.l.Type.Struct() != nil:
			ret self.evalStruct()
		|:
			self.e.pushErr(self.op, log::OperatorNotForJuleType, self.op.Kind, self.l.Type.Str())
			ret nil
		}
	}

	fn evalConst(mut *self, mut &v: *&Value) {
		match {
		| *v == nil
		| self.l.Model == nil
		| self.r.Model == nil
		| self.l.Type.comptimeTypeInfo() != nil
		| self.r.Type.comptimeTypeInfo() != nil:
			ret
		| !self.l.IsConst()
		| !self.r.IsConst():
			(*v).Constant = nil
			(*v).untyped = false
			ret
		}

		match self.op.ID {
		| token::EQL:
			(*v).Constant = constant::Const.NewBool(self.l.Constant.Eq(*self.r.Constant))
		| token::NEQ:
			(*v).Constant = constant::Const.NewBool(!self.l.Constant.Eq(*self.r.Constant))
		| token::LOR:
			(*v).Constant = constant::Const.NewBool(self.l.Constant.Or(*self.r.Constant))
		| token::LAND:
			(*v).Constant = constant::Const.NewBool(self.l.Constant.And(*self.r.Constant))
		| token::GTR:
			(*v).Constant = constant::Const.NewBool(self.l.Constant.Gt(*self.r.Constant))
		| token::LSS:
			(*v).Constant = constant::Const.NewBool(self.l.Constant.Lt(*self.r.Constant))
		| token::GEQ:
			(*v).Constant = constant::Const.NewBool(self.l.Constant.GtEq(*self.r.Constant))
		| token::LEQ:
			(*v).Constant = constant::Const.NewBool(self.l.Constant.LtEq(*self.r.Constant))
		| token::ADD:
			_ = self.l.Constant.Add(*self.r.Constant)
			(*v).Constant = self.l.Constant
		| token::SUB:
			_ = self.l.Constant.Sub(*self.r.Constant)
			(*v).Constant = self.l.Constant
		| token::MUL:
			_ = self.l.Constant.Mul(*self.r.Constant)
			(*v).Constant = self.l.Constant
		| token::QUO:
			ok := self.l.Constant.Div(*self.r.Constant)
			if !ok && self.r.Constant.AsF64() == 0 {
				self.e.pushErr(self.op, log::DivByZero)
			}
			(*v).Constant = self.l.Constant
		| token::REM:
			ok := self.l.Constant.Mod(*self.r.Constant)
			if !ok && self.r.Constant.AsF64() == 0 {
				self.e.pushErr(self.op, log::DivByZero)
			}
			(*v).Constant = self.l.Constant
		| token::OR:
			_ = self.l.Constant.BitwiseOr(*self.r.Constant)
			(*v).Constant = self.l.Constant
		| token::AND:
			_ = self.l.Constant.BitwiseAnd(*self.r.Constant)
			(*v).Constant = self.l.Constant
		| token::XOR:
			_ = self.l.Constant.Xor(*self.r.Constant)
			(*v).Constant = self.l.Constant
		| token::SHL:
			_ = self.l.Constant.Lshift(*self.r.Constant)
			(*v).Constant = self.l.Constant
		| token::SHR:
			_ = self.l.Constant.Rshift(*self.r.Constant)
			(*v).Constant = self.l.Constant
		}
		// Value is arbitrary large literal.
		// We have to do extra work.
		if (*v).Constant.IsInt() {
			// If computation result overflows the bitsize limit, log error,
			// and return nil value.
			i := (*v).Constant.ReadInt()
			if i.BitLen() > bitLimit {
				self.e.pushErr(self.op, log::ConstantOverflowResult)
				*v = nil
				ret
			}
			// If value is not untyped, then cast the result to exact type if possible.
			// As far as tested, it should be work for all types with no issue.
			if !(*v).untyped && (i.IsI64() || i.IsU64()) {
				kind := (*v).Type.Prim().Kind
				sz := types::BitSizeOf(kind)
				match {
				| types::IsSigInt(kind):
					match sz {
					| 8:
						if i.Sign() == -1 {
							(*v).Constant.SetI64(i64(i8(i.I64())))
						} else {
							(*v).Constant.SetI64(i64(i8(i.U64())))
						}
					| 16:
						if i.Sign() == -1 {
							(*v).Constant.SetI64(i64(i16(i.I64())))
						} else {
							(*v).Constant.SetI64(i64(i16(i.U64())))
						}
					| 32:
						if i.Sign() == -1 {
							(*v).Constant.SetI64(i64(i32(i.I64())))
						} else {
							(*v).Constant.SetI64(i64(i32(i.U64())))
						}
					| 64:
						if i.Sign() == -1 {
							(*v).Constant.SetI64(i.I64())
						} else {
							(*v).Constant.SetI64(i64(i.U64()))
						}
					|:
						panic("sema: unimplemented bitsize for unaryEval.caret, this panic call should be unreachable")
					}
				| types::IsUnsigInt(kind):
					match sz {
					| 8:
						if i.Sign() == -1 {
							(*v).Constant.SetU64(u64(u8(i.I64())))
						} else {
							(*v).Constant.SetU64(u64(u8(i.U64())))
						}
					| 16:
						if i.Sign() == -1 {
							(*v).Constant.SetU64(u64(u16(i.I64())))
						} else {
							(*v).Constant.SetU64(u64(u16(i.U64())))
						}
					| 32:
						if i.Sign() == -1 {
							(*v).Constant.SetU64(u64(u32(i.I64())))
						} else {
							(*v).Constant.SetU64(u64(u32(i.U64())))
						}
					| 64:
						if i.Sign() == -1 {
							(*v).Constant.SetU64(u64(i.I64()))
						} else {
							(*v).Constant.SetU64(i.U64())
						}
					|:
						panic("sema: unimplemented bitsize for unaryEval.caret, this panic call should be unreachable")
					}
				|:
					panic("sema: unimplemented constant type for unaryEval.caret, this panic call should be unreachable")
				}
			}
		} else {
			castConstByType(self.e.s, nil, (*v).Type, *v)
		}
		(*v).Model = (*v).Constant
		applyCastModelByEnum(self.e.s, *v, (*v).Type.Enum(), self.op, self.e.getOwnerRefers())
	}

	fn checkValue(mut *self, mut v: &Value, token: &token::Token) {
		f := v.Type.Func()
		if f != nil && f.Decl != nil && f.Decl.IsMethod() {
			self.e.pushErr(token, log::InvalidExprForBinary)
		}
	}

	fn checkValues(mut *self) {
		self.checkValue(self.l, self.lt)
		self.checkValue(self.r, self.rt)
	}

	fn setModel(mut *self, mut v: &Value) {
		if v.IsConst() {
			if self.l.IsConst() && self.r.IsConst() ||
				self.l.Type.comptime() || self.r.Type.comptime() {
				// Left and right are pure constant or comptime expression.
				// Do not break this with changing Model.
				ret
			}
		}

		// See developer reference (7).
		mut l, mut r := self.l, self.r
		if !l.GoodOperand(r) {
			l, r = r, l
		}

		v.Model = &BinaryExpr{
			Left: &OperandExpr{
				Type: l.Type,
				Model: l.Model,
			},
			Right: &OperandExpr{
				Type: r.Type,
				Model: r.Model,
			},
			Op: self.op,
		}
	}

	fn postEval(mut *self, mut v: &Value) {
		v.Lvalue = false
		self.setModel(v)
	}

	fn solveExplicit(mut *self, mut l: &Value, mut r: &Value): &Value {
		self.l, self.r = l, r

		self.checkValues()

		mut v := self.evalOp()

		// Save normal order
		self.l, self.r = l, r

		self.evalConst(&v)

		if v != nil {
			v.Mutable = true
			self.postEval(v)
		}

		ret v
	}

	fn eval(mut *self, mut op: &ast::BinaryExpr): &Value {
		if op.Op.ID == token::ASSIGN {
			self.e.pushErr(op.Op, log::AssignInExpr)
			self.e.pushSuggestion(log::UseImperative)
			ret nil
		}

		mut l := self.e.evalExpr1(op.X, evalDefault)
		if l == nil || l.Type == nil {
			ret nil
		}

		if !l.untyped {
			mut prefix := self.e.prefix
			self.e.prefix = l.Type
			defer { self.e.prefix = prefix }
		}
		mut r := self.e.evalExpr1(op.Y, evalDefault)
		if r == nil || r.Type == nil {
			ret nil
		}

		self.op = op.Op
		self.lt = op.X.Token
		self.rt = op.Y.Token

		mut v := self.solveExplicit(l, r)

		// Save rune type.
		if v != nil && l.IsRune && r.IsRune {
			v.IsRune = true
		}

		ret v
	}
}

// Returns directive if exist.
fn findDirective(mut directives: []&ast::Directive, d: str): &ast::Directive {
	for (_, mut dr) in directives {
		if dr.Tag.Kind == d {
			ret dr
		}
	}
	ret nil
}

fn findBuiltinsImport(name: str, imp: &ImportInfo): any {
	ret findPackageBuiltinDef(imp.LinkPath, name)
}

fn makeStructLitAlloc(mut v: &Value, mut lit: &StructLitExpr) {
	v.Type = &Type{
		Kind: &Sptr{
			Value: &Type{Kind: lit.Strct},
		},
	}
	v.Model = &AllocStructLitExpr{
		Lit: lit,
	}
}

fn buildErrorVar(mut s: &Scope, mut fc: &ast::CallExpr): &Var {
	ret &Var{
		Used: true,
		Reference: false,
		Mutable: true,
		Name: "error",
		Token: fc.Token,
		TypeSym: findBuiltinTypeAlias(types::Any).TypeSym,
		Scope: s,
		ValueSym: &ValueSym{
			Value: new(Value),
		},
	}
}

fn findBuiltinsSema(name: str, mut s: &sema): any {
	// If package is std, check for internal builtin defines.
	mut ppath := s.file.File.Dir()
	stdlib := build::PathStdlib()
	if strings::HasPrefix(ppath, stdlib) {
		// Remove STDLIB directory path.
		ppath = ppath[len(stdlib):]
		// Add "std" to beginning without separator
		// because path has separator at beginning.
		ppath = "std" + strings::ReplaceAll(ppath, str(filepath::Separator), jule::ImportPathSep)
		ret findPackageBuiltinDef(ppath, name)
	}

	ret nil
}

fn isOkForShifting(mut v: &Value): bool {
	if !v.untyped || !v.IsConst() {
		prim := v.Type.Prim()
		ret prim != nil && types::IsInt(prim.Str())
	}
	max := types::MaxU(types::Uint)
	match {
	| v.Constant.IsInt():
		i := v.Constant.ReadInt()
		if i.Sign() == -1 {
			ret false
		}
		if !i.IsU64() {
			ret false
		}
		x := i.U64()
		ret x <= max
	| v.Constant.IsF64():
		f := v.Constant.ReadF64()
		if f < 0 {
			ret false
		}
		i, frac := math::Modf(f)
		if frac != 0 {
			ret false
		}
		ret u64(i) <= max
	}
	ret false
}

fn isInstancedStruct(s: &StructIns): bool {
	ret len(s.Decl.Generics) == len(s.Generics)
}

fn isPtrArithmeticCompatible(mut l: &Value, mut r: &Value): bool {
	ptr := r.Type.Ptr()
	if ptr != nil {
		ret l.Type.Ptr().Value.Equal(ptr.Value)
	}
	if r.IsConst() && r.untyped {
		ret intAssignable(types::Int, r) ||
			intAssignable(types::Uint, r)
	}

	mut tcc := typeCompatibilityChecker{
		dest: primInt,
		src: r.Type,
	}
	if tcc.check() {
		ret true
	}
	tcc.dest = primUint
	ret tcc.check()
}

fn applyRuntimeToStr(mut s: &sema, mut from: &Type, mut to: &Type,
	mut token: &token::Token, mut refers: &ReferenceStack) {
	prim := to.Prim()
	if prim != nil && prim.IsAny() || to.TypeEnum() != nil || to.Trait() != nil {
		pushRuntimeToStr(s, from, token, refers)
		ret
	}
}

fn applyRuntimeMaphash(mut s: &sema, mut from: &Type, mut to: &Type,
	mut token: &token::Token, mut refers: &ReferenceStack) {
	if from.Comparable() {
		prim := to.Prim()
		if prim != nil && prim.IsAny() || to.TypeEnum() != nil || to.Trait() != nil {
			pushRuntimeMaphash(s, from, token, refers)
			ret
		}
	}
}

fn applyImplicitCast(mut s: &sema, mut dest: &Type, mut v: &Value,
	mut token: &token::Token, mut refers: &ReferenceStack) {
	if v.Type.IsNil() {
		ret
	}
	destPrim := dest.Prim()
	if destPrim != nil && destPrim.IsAny() {
		prim := v.Type.Prim()
		if prim == nil || !prim.IsAny() {
			applyCastKind(s, v, dest, token, refers)
		}
		ret
	}

	dt := dest.Trait()
	if dt != nil {
		bt := v.Type.Trait()
		if bt == nil || bt != dt {
			applyCastKind(s, v, dest, token, refers)
			ret
		}
	}

	if dest.TypeEnum() != nil && (v.Type.SoftStruct() != nil || v.Type.TypeEnum() == nil) {
		applyCastKind(s, v, dest, token, refers)
		ret
	}
}

fn applyCastKindModel(mut s: &sema, mut v: &Value, mut t: &Type,
	mut token: &token::Token, mut refers: &ReferenceStack) {
	applyRuntimeToStr(s, v.Type, t, token, refers)
	applyRuntimeMaphash(s, v.Type, t, token, refers)

	// Add arrayCmp instance if needed.
	if s.meta.runtime != nil {
		mut arr := v.Type.Array()
		if arr != nil && v.Type.Comparable() {
			// Add instance to relevant runtime function for array element type if not exist.
			mut f := runtimeFindFunc(s.meta.runtime, "arrayCmp").instanceForce()
			f.Generics = append(f.Generics, &InsGeneric{Type: arr.Value})
			ok, _ := s.checkGenericFunc(&f, token)
			if !ok {
				panic("sema: arrayCmp evaluation failed, this is an implementation mistake")
			}
			refers.Push(f)
		}
	}

	v.Model = &CastingExpr{
		Token: token,
		Expr: new(Value, *v),
		Type: t,
	}
}

fn applyCastKind(mut s: &sema, mut v: &Value, mut t: &Type,
	mut token: &token::Token, mut refers: &ReferenceStack) {
	applyCastKindModel(s, v, t, token, refers)
	v.Type = t
}

fn buildVoidValue(): &Value {
	ret &Value{
		Type: primVoid,
	}
}

fn checkDataForIntegerIndex(mut s: &sema, mut v: &Value,
	mut token: &token::Token, mut refers: &ReferenceStack): (errFmt: str) {
	if v == nil {
		ret ""
	}

	match {
	| v.Type.Prim() == nil:
		ret log::InvalidTypeForIndexing
	| !types::IsInt(v.Type.Prim().Str()):
		ret log::InvalidTypeForIndexing
	| v.IsConst():
		if v.Constant.AsF64() < 0 {
			ret log::OverflowLimits
		}
	| v.Type.Prim() == nil
	| v.IsConst()
	| types::RealKindOf(v.Type.Prim().Str()) != types::RealKindOf(types::Int):
		applyCastKind(s, v, primInt, token, refers)
	}
	ret ""
}

// Applies casting Model: to data by enum.
// This is necessary to keep exact same type of enum's field type.
// The parameter v should be constant data.
fn applyCastModelByEnum(mut s: &sema, mut v: &Value, mut e: &Enum,
	mut token: &token::Token, mut refers: &ReferenceStack) {
	if e == nil {
		ret
	}
	applyCastKindModel(s, v, e.TypeSym.Type, token, refers)
}

fn castConstByType(mut s: &sema, token: &token::Token, mut t: &Type, mut v: &Value): (overflow: bool) {
	mut kind := ""
	if t.Prim() != nil {
		kind = t.Prim().Kind
	} else {
		kind = t.Enum().TypeSym.Type.Prim().Kind
	}
	match {
	| types::IsSigInt(kind):
		if v.untyped && token != nil && !sigAssignable(kind, v) {
			s.pushErr(token, log::ConstantOverflowType, v.Constant.Str(), t.Str())
			ret false
		}
		match types::BitSizeOf(types::RealKindOf(kind)) {
		| 64:
			v.Constant.SetI64(v.Constant.AsI64())
		| 32:
			v.Constant.SetI64(i64(i32(v.Constant.AsI64())))
		| 16:
			v.Constant.SetI64(i64(i16(v.Constant.AsI64())))
		| 8:
			v.Constant.SetI64(i64(i8(v.Constant.AsI64())))
		}
		v.Constant.Kind = kind
	| types::IsUnsigInt(kind):
		if v.untyped && token != nil && !unsigAssignable(kind, v) {
			s.pushErr(token, log::ConstantOverflowType, v.Constant.Str(), t.Str())
			ret false
		}
		match types::BitSizeOf(types::RealKindOf(kind)) {
		| 64:
			v.Constant.SetU64(v.Constant.AsU64())
		| 32:
			v.Constant.SetU64(u64(u32(v.Constant.AsU64())))
		| 16:
			v.Constant.SetU64(u64(u16(v.Constant.AsU64())))
		| 8:
			v.Constant.SetU64(u64(u8(v.Constant.AsU64())))
		}
		v.Constant.Kind = kind
	| types::IsFloat(kind):
		if v.untyped && token != nil && !floatAssignable(kind, v) {
			s.pushErr(token, log::ConstantOverflowType, v.Constant.Str(), t.Str())
			ret false
		}
		match types::BitSizeOf(types::RealKindOf(kind)) {
		| 64:
			v.Constant.SetF64(v.Constant.AsF64())
		| 32:
			v.Constant.SetF64(f64(f32(v.Constant.AsF64())))
		}
		v.Constant.Kind = kind
	| types::IsCmplx(kind):
		if v.untyped && token != nil && !cmplxAssignable(kind, v) {
			s.pushErr(token, log::ConstantOverflowType, v.Constant.Str(), t.Str())
			ret false
		}
		if !v.Constant.IsCmplx128() {
			match types::BitSizeOf(types::RealKindOf(kind)) {
			| 128:
				v.Constant.SetCmplx128(v.Constant.AsF64(), 0)
			| 64:
				v.Constant.SetCmplx128(f64(f32(v.Constant.AsF64())), 0)
			}
		}
		v.Constant.Kind = kind
	}
	ret true
}

fn updateModelToGenericIns(mut &m: *Expr, mut f: &FuncIns) {
	match type *m {
	| &FuncIns:
		*m = f
	| &StructSubIdentExpr:
		(*m).(&StructSubIdentExpr).Method = f
	| &StructStaticIdentExpr:
		(*m).(&StructStaticIdentExpr).Method = f
	|:
		// no-op for other types
	}
}

// Reports whether expression model is literal-based.
// Works for literals, sub-idents and castings.
// Returns nil if not, otherwise returns the literal model.
fn isLitBased(mut m: Expr): &StructLitExpr {
	match type m {
	| &StructLitExpr:
		ret m.(&StructLitExpr)
	| &AllocStructLitExpr:
		ret m.(&AllocStructLitExpr).Lit
	| &StructSubIdentExpr:
		mut ssi := m.(&StructSubIdentExpr)
		ret isLitBased(ssi.Expr.Model)
	| &CastingExpr:
		mut c := m.(&CastingExpr)
		ret isLitBased(c.Expr.Model)
	|:
		ret nil
	}
}

fn makeImplicitDeref(mut v: &Value, mut baseToken: &token::Token) {
	mut unary := &UnaryExpr{
		Expr: new(Value, *v),
		Op: new(token::Token, *baseToken),
	}
	unary.Op.ID = token::MUL
	unary.Op.Kind = "*"
	v.Model = unary
}

// Updates ref's old references to new.
fn updateRefer[T](mut ref: &ReferenceStack, old: &T, mut new: &T) {
	for i, sym in ref.buffer {
		if sym == old {
			ref.buffer[i] = new
		}
	}
}

fn makeVariadic(mut v: &Value, mut elem: &Type) {
	v.Type = &Type{
		Variadic: true,
		Generic: elem.Generic,
		Kind: elem.Kind,
	}
}

// Reports whether variable is captured from parent scope.
// Parameters:
//	- r: root scope of anonymous function
//	- s: current scope which is v accessed from
//	- v: variable to check
fn isVarCaptured(r: &scopeChecker, mut s: &scopeChecker, v: &Var): bool {
	if v.Scope == nil { // Global scope variable.
		ret false
	}
	for {
		if s.scope == v.Scope {
			ret false
		}
		// Break iteration if parent is not exist or scope already reached to root.
		if s.parent == nil || s == r {
			break
		}
		s = s.parent
	}
	ret true
}

fn findNamespace(mut lookup: Lookup, namespace: str): &ImportInfo {
	ret lookup.SelectPackage(fn|imp| imp.Alias == namespace && !isImplicitImport(imp))
}

// Checks value by flags.
fn checkValue(mut v: &Value, mut s: &sema, mut token: &token::Token, flags: int): (ok: bool) {
	if flags&evalExceptional != evalExceptional {
		fc, (ok) := v.Model.(&FuncCallExpr)
		if ok && fc.Func.Decl.Exceptional {
			s.pushErr(token, log::ExceptionalNotPlain)
			s.pushSuggestion(log::AssignExceptionalResultToVariable)
			ret false
		}
	}
	// Catch arbitrary integers with no type, they should be fit in int.
	if flags&evalUnwrapUntyped == evalUnwrapUntyped {
		if v.untyped && v.IsConst() && v.Constant.IsInt() {
			i := v.Constant.ReadInt()
			max := types::MaxI(types::RealKindOf(types::Int))
			min := types::MinI(types::RealKindOf(types::Int))
			if i.IsU64() {
				if u64(max) < i.U64() {
					s.pushErr(token, log::ConstantOverflowType, v.Constant.Str(), primInt.Str())
					ret false
				}
			} else if i.IsI64() {
				x := i.I64()
				if x < min || max < x {
					s.pushErr(token, log::ConstantOverflowType, v.Constant.Str(), primInt.Str())
					ret false
				}
			} else {
				s.pushErr(token, log::ConstantOverflowType, v.Constant.Str(), primInt.Str())
				ret false
			}
		}
	}
	// Catch arbitrary integers with no type.
	// In order for this value to be assigned to memory,
	// we need to make sure that it can fit at least the largest integer type.
	if flags&evalPhysicalMem == evalPhysicalMem {
		if v.IsConst() && v.Constant.IsInt() {
			i := v.Constant.ReadInt()
			if !i.IsI64() && !i.IsU64() {
				s.pushErr(token, log::UntypedNumericForPhysical, i.Str())
				ret false
			}
		}
	}
	ret true
}

fn getUntypedCmpScore(k: str): int {
	if types::IsInt(k) {
		ret 1
	}
	if types::IsFloat(k) {
		ret 2
	}
	if k == types::Str {
		ret 3
	}
	ret -1
}

fn _isRef(mut v: &Value): (isRef: bool, mutable: bool) {
	mut variable, _ := v.Model.(&Var)
	if variable != nil && variable.Reference {
		ret true, variable.Mutable
	}
	ret false, false
}

// Reports whether the value is reference based.
fn isRef(mut v: &Value): bool {
	isRef, _ := _isRef(v)
	ret isRef
}

// Reports whether the value is reference based and reference memory is mutable.
// Works like isRef, but checks deeply.
fn deepIsRef(mut v: &Value): (isRef: bool, mutable: bool) {
	isRef, mutable = _isRef(v)
	if isRef {
		ret
	}
	mut unary, _ := v.Model.(&UnaryExpr)
	if unary == nil || unary.Op.ID != token::MUL {
		ret false, false
	}
	ret deepIsRef(unary.Expr)
}
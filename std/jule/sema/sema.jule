// Copyright 2023-2025 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/conv"
use "std/internal/jule/mod"
use "std/jule"
use "std/jule/ast"
use "std/jule/build"
use "std/jule/constant"
use "std/jule/constant/lit"
use "std/jule/directive"
use "std/jule/log"
use "std/jule/token"
use "std/jule/types"
use "std/slices"
use "std/strings"
use "std/unicode/utf8"

fn isValidModelForRef(mut m: Expr): bool {
	for {
		match type m {
		| &Var:
			// We found a variable, so the expression based on a variable.
			ret true
		| &StructSubIdentExpr:
			mut model := m.(&StructSubIdentExpr)
			if model.Field == nil {
				ret false
			}
			m = model.Expr.Model
			continue
		| &UnaryExpr:
			mut unary := m.(&UnaryExpr)
			if unary.Op.ID != token::MUL {
				ret false
			}
			// Return true because of raw-pointer dereferencing is an Unsafe Jule feature.
			if unary.Expr.Type.Ptr() != nil {
				// No extra effor for the mutability.
				// Unary eval algorithm will use mutable state of dereferenced
				// reference pointers, so mutability will always be fine.
				ret true
			}
			// Dereferencing should use smart-pointer, otherwise return false.
			if unary.Expr.Type.Sptr() == nil {
				ret false
			}
			m = unary.Expr.Model
			continue
		| &IndexingExpr:
			mut index := m.(&IndexingExpr)
			if index.Expr.Type.Array() == nil {
				// allow only arrays, slice allocations will may be deallocated at runtime
				// arrays always guaranteed to be have fixed size at runtime
				ret false
			}
			m = index.Expr.Model
			continue
		|:
			ret false
		}
	}
}

fn compilerErr(token: &token::Token, line: bool, fmt: str, args: ...any): log::Log {
	mut log := log::Log{
		Kind: log::Error,
		Row: token.Row,
		Column: token.Column,
		Path: token.File.Path,
		Text: log::Logf(fmt, args...),
	}
	if line {
		log.Line = token.File.GetRow(token.Row)
	}
	ret log
}

// Appends return variables to dest.
// If variable is exist, updates it.
// Assumes return variable part of dest is dest[i:].
fn updateRetVars(mut &dest: *[]&Var, mut f: &FuncIns, mut i: int) {
	if f.Decl.IsVoid() || f.Result == nil || len(f.Decl.Result.Names) == 0 {
		ret
	}
	mut rst := RetState.Single
	// There is more than one return type, it is tuple.
	if len(f.Decl.Result.Names) > 1 {
		rst = RetState.Tuple
	}
	mut types := f.Types()
	for (j, mut name) in f.Decl.Result.Names {
		if jule::IsBlank(name.Kind) || jule::IsAnon(name.Kind) {
			continue
		}
		// If variable is not exist in the dest, append it.
		// Otherwise update it.
		let mut v: &Var
		if i < len(*dest) {
			v = (*dest)[i]
		} else {
			v = &Var{
				Used: true,
				Mutable: true,
				Name: name.Kind,
				Token: name,
				Scope: f.Scope,
				TypeSym: new(TypeSym),
				ValueSym: &ValueSym{
					Value: new(Value),
				},
				RetState: rst,
				RetOrder: j,
			}
			*dest = append(*dest, v)
		}
		v.TypeSym.Type = types[j]
		i++
	}
}

// Appends parameter variables to dest.
// If parameter is exist, updates it.
// Returns count of parameter variables.
fn updateParamVars(mut &dest: *[]&Var, mut f: &FuncIns): (n: int) {
	if len(f.Params) == 0 {
		ret
	}

	for (i, mut p) in f.Params {
		if jule::IsBlank(p.Decl.Name) || jule::IsAnon(p.Decl.Name) {
			continue
		}
		n++

		// If variable is not exist in the dest, append it.
		// Otherwise update it.
		let mut v: &Var
		if i < len(*dest) {
			v = (*dest)[i]
		} else {
			v = &Var{
				Checked: true,
				Used: true,
				Reference: p.Decl.Reference,
				Mutable: p.Decl.Mutable,
				Name: p.Decl.Name,
				Token: p.Decl.Token,
				TypeSym: new(TypeSym),
				Scope: f.Scope,
				ValueSym: new(ValueSym),
			}
			*dest = append(*dest, v)
		}

		match {
		| p.Decl.IsSelf():
			v.TypeSym.Type = &Type{
				Variadic: false,
				Kind: f.Owner,
			}
			match {
			| p.Decl.IsSmartptr():
				v.Name = v.Name[1:] // Remove smartptr sign.
				v.TypeSym.Type.Kind = &Sptr{
					Value: &Type{
						Kind: f.Owner,
					},
				}
			| p.Decl.IsRefptr():
				v.Name = v.Name[1:] // Remove refptr sign.
				v.Reference = true
				v.TypeSym.Type.Kind = &Ptr{
					Value: &Type{
						Kind: f.Owner,
					},
				}
			|:
				panic("unreachable")
			}
		| p.Decl.Variadic:
			v.TypeSym.Type = &Type{
				Variadic: false,
				Kind: &Slice{
					Value: &Type{
						Kind: p.Type.Kind,
					},
				},
			}
		|:
			v.TypeSym.Type = p.Type
		}
	}
	ret
}

// Builds type aliases for generic types of scope.
// See developer reference (1), and (2).
fn appendGenericTypeAliases(mut &dest: *[]&TypeAlias, mut f: &FuncIns) {
	mut size := len(f.Generics)
	if f.Decl.Owner != nil {
		size += len(f.Decl.Owner.Generics)
	}

	if size == 0 {
		ret
	}

	for (i, mut g) in f.Generics {
		if g == nil {
			continue
		}
		mut decl := f.Decl.Generics[i]
		*dest = append(*dest, &TypeAlias{
			Used: true,
			Generic: true,
			Scope: f.Decl.Scope,
			Name: decl.Name,
			Token: decl.Token,
			TypeSym: &TypeSym{Type: g.Type},
		})
	}

	if f.Decl.Owner != nil {
		mut owner := f.Owner
		for (i, mut g) in owner.Generics {
			mut decl := owner.Decl.Generics[i]
			*dest = append(*dest, &TypeAlias{
				Used: true,
				Generic: true,
				Scope: f.Decl.Scope,
				Name: decl.Name,
				Token: decl.Token,
				TypeSym: &TypeSym{Type: g.Type},
			})
		}
	}
}

fn findFile(mut files: []&SymTab, handler: &token::FileSet): &SymTab {
	for (_, mut fl) in files {
		if fl.File == handler {
			ret fl
		}
	}
	ret nil
}

unsafe fn pushSuggestion(mut log: *log::Log, fmt: str, args: ...any) {
	log.Suggestion = log::Logf(fmt, args...)
}

// Semantic analysis environment for defines.
struct environ {
	sema: &sema
	file: &SymTab

	// Generics of type.
	// For structures, it contains type aliases for the all generics of struct.
	// For functions, it contains type aliases for the all generics of
	// function and owner struct if exist.
	generics: []&TypeAlias

	// Function only.
	// There is two parts in the single allocation.
	// The first part is parameter variables of function.
	// Trailing variables after parameters are return variables.
	// The first return variable can be determine with Var.RetState!=RetState.NA.
	vars: []&Var
}

// Flags for commonSemaMeta flag.
const (
	semametaGstruct = 1 << iota // Adds generic structures to gstructs.
)

struct commonSemaMeta {
	flags:             int          // General flags.
	gstructs:          []&StructIns // Generic structs waiting to be checked.
	comptimeTypeInfos: []&comptimeTypeInfo
	runtime:           &ImportInfo       // Implicitly imported "std/runtime" package.
	mrc:               missingRetChecker // General missing return statement checker.
}

impl commonSemaMeta {
	fn pushComptimeTypeInfo(mut *self, mut t: &Type): &comptimeTypeInfo {
		for (_, mut t2) in self.comptimeTypeInfos {
			if t2.base.Equal(t) {
				ret t2
			}
		}
		mut t1 := &comptimeTypeInfo{base: t}
		self.comptimeTypeInfos = append(self.comptimeTypeInfos, t1)
		ret t1
	}
}

// Semantic analysis step flags.
const (
	stepImplsImplemented = 1 << iota
	stepDeclsChecked
	stepDone
)

// Semantic analyzer for tables.
// Accepts tables as files of package.
struct sema {
	errors: []log::Log
	files:  []&SymTab // Package files.
	file:   &SymTab   // Current package file.
	flags:  int
	meta:   &commonSemaMeta
	step:   int
}

impl Lookup for sema {
	// Returns imported package by selector.
	// Returns nil if selector returns false for all packages.
	// Returns nil if selector is nil.
	//
	// Lookups:
	//	- Current file's imported packages.
	fn SelectPackage(mut *self, selector: fn(&ImportInfo): bool): &ImportInfo {
		ret self.file.SelectPackage(selector)
	}

	// Returns variable by identifier and bind state.
	// Returns nil if not exist any variable in this identifier.
	//
	// Lookups:
	//	- Package file's symbol table.
	//	- Current file's public denifes of imported packages.
	fn FindVar(mut *self, name: str, _bind: bool): &Var {
		// Lookup package files.
		mut v := findVarInPackage(self.files, name, _bind)
		if v != nil {
			ret v
		}
		ret nil
	}

	// Returns type alias by identifier and bind state.
	// Returns nil if not exist any type alias in this identifier.
	//
	// Lookups:
	//	- Package file's symbol table.
	//	- Current file's public denifes of imported packages.
	fn FindTypeAlias(mut *self, name: str, _bind: bool): &TypeAlias {
		// Lookup package files.
		mut ta := findTypeAliasInPackage(self.files, name, _bind)
		if ta != nil {
			ret ta
		}
		ret nil
	}

	// Returns struct by identifier and bind state.
	// Returns nil if not exist any struct in this identifier.
	//
	// Lookups:
	//	- Package file's symbol table.
	//	- Current file's public denifes of imported packages.
	fn FindStruct(mut *self, name: str, _bind: bool): &Struct {
		// Lookup package files.
		mut s := findStructInPackage(self.files, name, _bind)
		if s != nil {
			ret s
		}
		ret nil
	}

	// Returns function by identifier and bind state.
	// Returns nil if not exist any function in this identifier.
	//
	// Lookups:
	//	- Package file's symbol table.
	//	- Current file's public denifes of imported packages.
	fn FindFunc(mut *self, name: str, _bind: bool): &Func {
		// Lookup package files.
		mut f := findFuncInPackage(self.files, name, _bind)
		if f != nil {
			ret f
		}
		ret nil
	}

	// Returns trait by identifier.
	// Returns nil if not exist any trait in this identifier.
	//
	// Lookups:
	//	- Package file's symbol table.
	//	- Current file's public denifes of imported packages.
	fn FindTrait(mut *self, name: str): &Trait {
		// Lookup package files.
		mut t := findTraitInPackage(self.files, name)
		if t != nil {
			ret t
		}
		ret nil
	}

	// Returns enum by identifier.
	// Returns nil if not exist any enum in this identifier.
	//
	// Lookups:
	//	- Package file's symbol table.
	//	- Current file's public denifes of imported packages.
	fn FindEnum(mut *self, name: str): &Enum {
		// Lookup package files.
		mut e := findEnumInPackage(self.files, name)
		if e != nil {
			ret e
		}
		ret nil
	}

	// Returns type enum by identifier.
	// Returns nil if not exist any type enum in this identifier.
	//
	// Lookups:
	//	- Package file's symbol table.
	//	- Current file's public denifes of imported packages.
	fn FindTypeEnum(mut *self, name: str): &TypeEnum {
		// Lookup package files.
		mut e := findTypeEnumInPackage(self.files, name)
		if e != nil {
			ret e
		}
		ret nil
	}
}

impl sema {
	// Reports whether flags has given flag.
	fn isFlag(*self, flags: int): bool { ret self.flags&flags == flags }

	fn getCurrentFile(mut *self): &SymTab { ret self.file }
	fn setCurrentFile(mut *self, mut f: &SymTab) { self.file = f }

	fn pushErr(mut *self, token: &token::Token, fmt: str, args: ...any) {
		self.errors = append(self.errors, compilerErr(token, true, fmt, args...))
	}

	fn pushErrorFromLitError(mut *self, t: &token::Token, err: lit::Error) {
		self.errors = append(self.errors, log::Log{
			Kind: log::Error,
			Row: t.Row,
			Column: t.Column + err.Offset,
			Path: t.File.Path,
			Text: err.Text,
			Line: t.File.GetRow(t.Row),
		})
	}

	fn pushErrorsFromLitErrors(mut *self, t: &token::Token, errors: []lit::Error) {
		for _, err in errors {
			self.pushErrorFromLitError(t, err)
		}
	}

	// Push suggestion to last log.
	fn pushSuggestion(mut *self, fmt: str, args: ...any) {
		unsafe { pushSuggestion(&self.errors[len(self.errors)-1], fmt, args...) }
	}

	// Reports whether define is accessible in the current package.
	// The public and token parameters belongs to define which is accessed.
	fn isAccessibleDefine(*self, public: bool, token: &token::Token): bool {
		if public || token.File == nil {
			// public or built-in
			ret true
		}
		selfDir := self.file.File.Dir()
		tokenDir := token.File.Dir()
		if selfDir == tokenDir {
			// define is in the same package
			ret true
		}
		// define is not public or in-package define
		// but it may come from the runtime package
		// so allow access if standard library package tries
		if isStdPackage(tokenDir, "runtime") && isStdPackage(selfDir, "") {
			ret true
		}
		ret false
	}

	// Reports this identifier duplicated in package's global scope.
	// The "self" parameter represents address of exception identifier.
	// If founded identifier address equals to self, will be skipped.
	fn isDuplicatedName(*self, itself: uintptr, name: str, _bind: bool): bool {
		for _, f in self.files {
			if f.isDuplicatedName(itself, name, _bind) {
				ret true
			}
		}
		ret false
	}

	fn checkDirectives(mut &self, mut d: []&ast::Directive, mut o: any) {
		mut dc := directiveChecker{
			s: self,
			d: unsafe { (&[]&ast::Directive)(&d) },
			o: o,
		}
		dc.check()
	}

	fn checkGenericQuantity(mut *self, required: int, given: int, token: &token::Token): (ok: bool) {
		match {
		| required == 0 && given > 0:
			self.pushErr(token, "type has no generics but instantiated with generics")
			ret false
		| required > 0 && given == 0:
			self.pushErr(token, "type has generics but not instantiated with generics")
			ret false
		| required < given:
			self.pushErr(token, "passed types to generics more than expected, expected @, passed @", conv::Itoa(required), conv::Itoa(given))
			ret false
		| required > given:
			self.pushErr(token, "passed types to generics less than expected, expected @, passed @", conv::Itoa(required), conv::Itoa(given))
			ret false
		|:
			ret true
		}
	}

	fn getImportDef(*self, name: str, mut imp: &ImportInfo): any {
		if findPackageBuiltinDef(imp.LinkPath, name) != nil {
			ret true
		}
		for (_, mut f) in imp.Package.Files {
			// Binded defines can't export.
			const Bind = false
			mut def := f.defByIdent(name, Bind)
			if def != nil {
				ret def
			}
		}
		ret nil
	}

	fn isUseAliasDuplication(mut *self, imp: &ImportInfo): bool {
		for (_, mut imp2) in self.file.Imports {
			if imp == imp2 {
				break
			}
			if imp2.Alias == imp.Alias {
				ret true
			}
		}
		ret false
	}

	fn checkAutoAlias(mut *self, mut imp: &ImportInfo): bool {
		if imp.LinkPath == "std/unsafe" {
			// the "std/unsafe" package is able to use the "unsafe" keyword as alias
			ret true
		}
		valid := isValidImpAlias(imp.Alias)
		if valid {
			if self.isUseAliasDuplication(imp) {
				self.pushErr(imp.Decl.Path, "duplicated use declaration alias: "+conv::Quote(imp.Alias))
				self.pushSuggestion("give an alias to use it properly")
			}
		} else {
			self.pushErr(imp.Decl.Path, "auto aliasing failing for use declaration")
			self.pushSuggestion("give an alias to use it properly")
		}
		ret valid
	}

	fn checkImport(mut *self, mut imp: &ImportInfo): bool {
		if imp.Bind {
			ret true
		}

		if imp.Decl.Alias != nil { // custom alias found
			if jule::IsBlank(imp.Alias) {
				self.pushErr(imp.Decl.Token, "blank identifier cannot be used as an identifier for this declaration")
				ret false
			} else if self.isUseAliasDuplication(imp) {
				self.pushErr(imp.Decl.Alias, "duplicated use declaration alias: "+conv::Quote(imp.Alias))
				self.pushSuggestion("rename to avoid duplications")
				ret false
			}

			// Check special cases for the "std/unsafe" package.
			if imp.LinkPath == "std/unsafe" {
				self.pushErr(imp.Decl.Alias, `expected plain use declaration for the package (e.g. use "std/unsafe")`)
				ret false
			}
		} else if !isImplicitImport(imp) && !self.checkAutoAlias(imp) {
			ret false
		}
		ret true
	}

	fn checkImports(mut *self) {
		for (_, mut file) in self.files {
			self.setCurrentFile(file)
			for (_, mut imp) in self.file.Imports {
				ok := self.checkImport(imp)
				// Break checking if package has error.
				if !ok {
					ret
				}
			}
		}
	}

	// Checks all imports.
	// Assumes imports comes from Importer.AllPackages().
	fn checkPackages(mut &self, mut imports: []&ImportInfo): (ok: bool) {
		mut semas := make([]&sema, len(imports))
		for (i, mut imp) in imports {
			if !imp.Bind {
				mut s := &sema{
					files: imp.Package.Files,
					flags: self.flags,
					meta: self.meta,
				}
				s.setSemaFields()
				semas[i] = s
			}
		}
		for (i, mut imp) in imports {
			if !imp.Bind {
				mut sema := semas[i]
				sema.check()
				if len(sema.errors) != 0 {
					self.errors = append(self.errors, sema.errors...)
					sema.errors = nil
					ret false
				}
			}
		}
		ret true
	}

	fn implFileImpls(mut &self) {
		for (_, mut imp) in self.file.Impls {
			self.implImpl(imp)
		}
	}

	fn implImpls(mut &self) {
		for (_, mut file) in self.files {
			self.setCurrentFile(file)
			self.implFileImpls()
		}
	}

	fn checkEnums(mut &self) {
		for (_, mut file) in self.files {
			self.setCurrentFile(file)
			match {
			| !self.checkEnumDecls():
			| !self.checkTypeEnumDecls():
			}
		}
	}

	fn checkFileInherits(mut &self) {
		for (_, mut t) in self.file.Traits {
			ok := self._checkTraitDeclInherits(t)
			if !ok {
				ret
			}
		}
	}

	fn checkInherits(mut &self) {
		for (_, mut file) in self.files {
			self.setCurrentFile(file)
			self.checkFileInherits()
		}
	}

	fn typeChecker(mut &self, mut l: Lookup, mut generics: []&TypeAlias,
		mut referencer: &referencer): typeChecker {
		mut tc := typeChecker{
			s: self,
			rootLookup: l,
			lookup: l,
			referencer: referencer,
			useGenerics: generics,
		}
		match type l {
		| &scopeChecker:
			mut hard := l.(&scopeChecker).getHardRoot()
			tc.refers = hard.owner.Refers
		}
		ret tc
	}

	// Builds type, builds result as kind and collects referred type aliases.
	fn buildTypeWithRefers(mut &self, mut t: &ast::Expr, mut l: Lookup,
		mut generics: []&TypeAlias, mut referencer: &referencer): &Type {
		ret self.typeChecker(l, generics, referencer).checkDecl(t)
	}

	// Checks TypeSYm, builds result as Type and collects referred type aliases.
	// Skips already checked types.
	// See also developer reference (9).
	fn checkTypeSymWithRefers(mut &self, mut t: &TypeSym, mut l: Lookup, mut generics: []&TypeAlias, mut referencer: &referencer): (ok: bool) {
		mut ta := false // Referencer owner is type alias.
		if t.checked() {
			match type referencer.owner {
			| &TypeAlias:
				ta = true
			}
			if !ta {
				ret true
			}
		}
		mut tt := self.buildTypeWithRefers(t.Decl, l, generics, referencer)
		if tt == nil || !ta {
			t.Type = tt
		} else {
			t.Type.Kind.(&StructIns).setSource(tt)
		}
		ret t.checked()
	}

	fn constraintChecker(mut &self): &constraintChecker {
		ret &constraintChecker{s: self}
	}

	// Checks type and builds result as Type.
	// Skips already checked types.
	fn checkTypeSym(mut &self, mut t: &TypeSym, mut l: Lookup): bool {
		ret self.checkTypeSymWithRefers(t, l, nil, nil)
	}

	// Same as the checkTypeSym but takes referencer.
	fn checkTypeSymRefers(mut &self, mut t: &ast::Expr, mut l: Lookup, mut refers: &ReferenceStack): &Type {
		mut tc := &typeChecker{
			s: self,
			rootLookup: l,
			lookup: l,
			refers: refers,
		}
		ret tc.checkDecl(t)
	}

	// Builds type with type aliases for generics.
	// Returns nil if error occur or failed.
	fn buildTypeWithGenerics(mut &self, mut t: &ast::Expr,
		mut generics: []&TypeAlias, mut refers: &ReferenceStack): &Type {
		mut tc := &typeChecker{
			s: self,
			rootLookup: self,
			lookup: self,
			useGenerics: generics,
			refers: refers,
		}
		ret tc.checkDecl(t)
	}

	// Same as self.buildTypeWithGenerics but not uses any generics.
	fn buildType(mut &self, mut t: &ast::Expr): &Type {
		ret self.buildTypeWithGenerics(t, nil, nil)
	}

	// Select type with name selection.
	fn selectType(mut &self, mut t: &ast::Expr): &Type {
		mut tc := &typeChecker{
			s: self,
			rootLookup: self,
			lookup: self,
			selection: true,
		}
		ret tc.checkDecl(t)
	}

	// Returns eval instance for configuration with
	// type prefix and checks var dependencies.
	fn evalpd(mut &self, mut l: Lookup, mut p: &Type, mut owner: &Var): &eval {
		mut e := &eval{
			s: self,
			lookup: l,
			owner: owner,
		}
		match type l {
		| &scopeChecker:
			e.unsafety = l.(&scopeChecker).isUnsafe()
		}
		e.prefix = p
		ret e
	}

	// Returns eval instance for configuration with type prefix.
	fn evalp(mut &self, mut l: Lookup, mut p: &Type): &eval {
		ret self.evalpd(l, p, nil)
	}

	// Returns eval instance for configuration.
	fn eval(mut &self, mut l: Lookup): &eval {
		ret self.evalp(l, nil)
	}

	// Do not checks mutability.
	fn checkAssignType(mut &self, destIsRef: bool, firstAssignToDest: bool, mut dest: &Type,
		mut v: &Value, mut errorToken: &token::Token, mut refers: &ReferenceStack): bool {
		if v.Decl {
			self.pushErr(errorToken, "invalid expression")
			ret false
		}

		if destIsRef {
			if firstAssignToDest {
				if !v.IsNil() && !dest.Equal(v.Type) {
					self.pushErr(errorToken, "mismatched types: @ and @", dest.Str(), v.Type.Str())
					ret false
				}
			} else if !v.IsNil() {
				self.pushErr(errorToken, "reference pointer type @ can only assign to nil", dest.Str())
				ret false
			}
		} else {
			mut atc := &assignTypeChecker{
				s: self,
				errorToken: errorToken,
				dest: dest,
				v: v,
				refers: refers,
			}
			ok := atc.check()
			if !ok {
				ret false
			}
		}

		if !v.IsConst() || dest.Prim() == nil {
			ret true
		}

		mut kind := dest.Prim().Kind

		match {
		| types::IsSigInt(kind):
			v.Constant.SetI64(v.Constant.AsI64())
		| types::IsUnsigInt(kind):
			v.Constant.SetU64(v.Constant.AsU64())
		| types::IsFloat(kind):
			v.Constant.SetF64(v.Constant.AsF64())
		}

		ret true
	}

	fn _checkTypeCompatibility(mut &self, mut dest: &Type, mut src: &Type,
		mut errorToken: &token::Token, flags: int): bool {
		if src == nil {
			ret false
		}
		// Tuple to single type, always fails.
		if src.Tuple() != nil {
			ret false
		}
		mut tcc := typeCompatibilityChecker{
			s: self,
			errorToken: errorToken,
			dest: dest,
			src: src,
			flags: flags,
		}
		ret tcc.check()
	}

	fn checkTypeCompatibility(mut &self, mut dest: &Type,
		mut src: &Type, mut errorToken: &token::Token, flags: int): bool {
		if self._checkTypeCompatibility(dest, src, errorToken, flags) {
			ret true
		}
		self.pushErr(errorToken, "mismatched types: @ and @", dest.Str(), src.Str())
		ret false
	}

	fn pushCompatibilityError(mut *self, mut dest: &Type, mut src: &Value,
		mut errorToken: &token::Token) {
		if src.untyped && src.IsConst() {
			match {
			| src.Constant.IsInt():
				self.pushErr(errorToken, "mismatched types: @ and @", dest.Str(), "untyped integer ("+src.Constant.Str()+")")
				ret
			| src.Constant.IsF64():
				self.pushErr(errorToken, "mismatched types: @ and @", dest.Str(), "untyped float ("+src.Constant.Str()+")")
				ret
			}
		}
		self.pushErr(errorToken, "mismatched types: @ and @", dest.Str(), src.Type.Str())
	}

	fn checkTypeCompatibility1(mut &self, mut dest: &Type, mut src: &Value,
		mut errorToken: &token::Token, flags: int): bool {
		if self._checkTypeCompatibility(dest, src.Type, errorToken, flags) {
			ret true
		}
		self.pushCompatibilityError(dest, src, errorToken)
		ret false
	}

	// Builds non-generic types but skips generic types.
	// Builds generic identifiers as primitive type.
	//
	// Useful:
	//	- For non-generic type parsed string type kinds.
	//	- For checking non-generic types.
	fn buildNonGenericType(mut &self, mut ast: &ast::Expr,
		mut useGenerics: []&TypeAlias, mut ignoreGenerics: []&ast::Generic, mut &ignored: *[]&Type, mut &recheckNeed: *[]recheckableType): &Type {
		mut tc := &typeChecker{
			s: self,
			rootLookup: self,
			lookup: self,
			useGenerics: useGenerics,
			ignoreGenerics: ignoreGenerics,
			ignoredGenerics: ignored,
			recheckNeed: recheckNeed,
		}
		ret tc.checkDecl(ast)
	}

	fn buildFuncNonGenericTypes(mut &self, mut f: &FuncIns, mut &ignored: *[]&Type, mut &recheckNeed: *[]recheckableType): (ok: bool) {
		n := len(self.errors)
		// Check with funcEnvironment, we need to generics of owner, if any.
		// If owner generics are ignored, we cannot resolve them with type inference.
		// Resolve owner generics in time, only ignore generics of the function.
		ok = self.funcEnvironment(f, fn|mut sema, mut generics| {
			ok = true
			for (_, mut p) in f.Params {
				if !p.Decl.IsSelf() {
					p.Type = sema.buildNonGenericType(p.Decl.TypeSym.Decl, generics, f.Decl.Generics, unsafe { ignored }, unsafe { recheckNeed })
					ok = ok && p.Type != nil
				}
			}
			if !f.Decl.IsVoid() {
				f.Result = sema.buildNonGenericType(f.Decl.Result.TypeSym.Decl, generics, f.Decl.Generics, unsafe { ignored }, unsafe { recheckNeed })
				ok = ok && f.Result != nil
			}
			ret ok
		})
		ret ok && len(self.errors) == n
	}

	fn getTraitCheckFuncKind(mut &self, mut f: &Func): &FuncIns {
		if len(f.Instances) == 1 {
			ret f.Instances[0]
		}
		mut ins := f.instanceForce()

		mut tc := &typeChecker{
			s: self,
			rootLookup: self,
			lookup: self,
		}
		for (_, mut p) in ins.Params {
			if !p.Decl.IsSelf() {
				p.Type = tc.checkDecl(p.Decl.TypeSym.Decl)
				if p.Type == nil {
					ret nil
				}
			}
		}
		if !f.IsVoid() {
			ins.Result = tc.checkDecl(f.Result.TypeSym.Decl)
			if ins.Result == nil {
				ret nil
			}
		}

		ret ins
	}

	fn checkConstraintsFunc(mut &self, mut f: &FuncIns, mut et: &token::Token, mut exist: &FuncIns): bool {
		mut cc := self.constraintChecker()
		cc.et = et
		cc.fi = f
		if exist != nil {
			for (i, mut g) in exist.Generics {
				f.Generics[i].Constraint = g.Constraint
			}
		} else {
			cc.uniq = true
		}
		ret cc.check()
	}

	fn checkConstraintsStruct(mut &self, mut s: &StructIns, mut et: &token::Token, mut exist: &StructIns): bool {
		mut cc := self.constraintChecker()
		cc.et = et
		cc.si = s
		if exist != nil {
			for (i, mut g) in exist.Generics {
				s.Generics[i].Constraint = g.Constraint
			}
		} else {
			cc.uniq = true
		}
		ret cc.check()
	}

	// Calls algo in the function's native environment.
	// Errors will be handled.
	// Returns result of algo.
	fn basicFuncEnvironment(mut &self, mut f: &FuncIns, algo: fn(mut sema: &sema): bool): bool {
		f.fillEnviron(false)

		if f.env.file != nil {
			mut old := f.env.sema.getCurrentFile()
			defer { f.env.sema.setCurrentFile(old) }
			f.env.sema.setCurrentFile(f.env.file)
		}

		ok := algo(f.env.sema)

		if f.env.sema != self {
			self.errors = append(self.errors, f.env.sema.errors...)
			f.env.sema.errors = nil
		}

		ret ok
	}

	// Calls basicFuncEnvironment internally but handles generics.
	fn funcEnvironment(mut &self, mut f: &FuncIns, algo: fn(mut sema: &sema, mut generics: []&TypeAlias): bool): bool {
		// Needs to f.environ(), but the basicFuncEnviron will handle it.
		ret self.basicFuncEnvironment(f, fn|mut sema| algo(f.env.sema, f.env.generics))
	}

	// Calls algo in the struct's native environment.
	// Errors will be handled.
	// Returns result of algo.
	fn basicStructEnvironment(mut &self, mut s: &StructIns, algo: fn(mut sema: &sema): bool): bool {
		s.fillEnviron()

		if s.env.file != nil {
			mut old := s.env.sema.getCurrentFile()
			defer { s.env.sema.setCurrentFile(old) }
			s.env.sema.setCurrentFile(s.env.file)
		}

		ok := algo(s.env.sema)

		if s.env.sema != self {
			self.errors = append(self.errors, s.env.sema.errors...)
			s.env.sema.errors = nil
		}

		ret ok
	}

	fn checkFuncParamKind(mut &self, mut p: &ParamIns) {
		p.Type.Variadic = p.Decl.Variadic
		if p.Decl.Reference {
			checkTypeForRef(self, p.Type, p.Decl.Token)
		}
	}

	// Reload type of function's self (receiver) parameter.
	fn reloadSelf(mut &self, mut f: &FuncIns) {
		if f.Owner == nil {
			// Trait methods have not owner yet. Skip them.
			ret
		}
		// No parameters, no receiver.
		if len(f.Params) == 0 {
			ret
		}
		mut p := f.Params[0]
		// Receiver parameter already have a type, return immediately.
		if p.Type != nil {
			ret
		}
		match {
		| p.Decl.IsSmartptr():
			p.Type = &Type{
				Kind: &Sptr{
					Value: &Type{
						Kind: f.Owner,
					},
				},
			}
		| p.Decl.IsRefptr():
			p.Type = &Type{
				Kind: &Ptr{
					Value: &Type{
						Kind: f.Owner,
					},
				},
			}
		|:
			// no-op: first parameter is not a receiver
		}
	}

	fn reloadFuncInsTypes(mut &self, mut f: &FuncIns): bool {
		if f.IsBuiltin() || f.IsAnon() {
			ret true
		}
		n := len(self.errors)
		ok := self.funcEnvironment(f, fn|mut sema, mut generics| {
			self.reloadSelf(f)
			mut ok := true
			for (_, mut p) in f.Params {
				if p.Decl.IsSelf() {
					continue
				}
				p.Type = sema.buildTypeWithGenerics(p.Decl.TypeSym.Decl, generics, f.Refers)
				if p.Type != nil {
					self.checkFuncParamKind(p)
				} else {
					ok = false
				}
			}
			if !f.Decl.IsVoid() {
				f.Result = sema.buildTypeWithGenerics(f.Decl.Result.TypeSym.Decl, generics, f.Refers)
				ok = f.Result != nil && ok
			}
			ret ok
		})
		ret ok && n == len(self.errors)
	}

	fn checkRefValidityForInitExpr(mut &self, leftMut: bool, mut v: &Value, mut errorToken: &token::Token): bool {
		// If value is nil-literal, there is nothing to do.
		// Report true, passed nil pointer to the reference.
		if v.IsNil() {
			ret true
		}

		_v, _ := v.Model.(&Var)
		if _v != nil && v.Reference {
			// No extra effort needed.
			// We point to another reference pointer.
		} else {
			// Check if the expression model is suitable to initialize a reference pointer.
			// Since reference pointers are use raw-pointers, initialize expression must be unary.
			// For a quick return, check whether the expression is unary.
			// The isValidModelForRef function checks expression more deeply.
			mut unary, _ := v.Model.(&UnaryExpr)
			if unary == nil || !isValidModelForRef(unary.Expr.Model) {
				self.pushErr(errorToken, "references requires variable based pointer expression for initialization")
				ret false
			}
		}

		// Check mutability for the reference pointer.
		if leftMut && !v.Mutable {
			self.pushErr(errorToken, "mutable reference points to immutable memory")
			ret false
		}

		ret true
	}

	// Reports whether struct is risky for mutability.
	// Designed for copy assignments.
	// It will not check mutability risk of the internal mutable data or etc.
	// It will check interior mutability risk of the new copy.
	// Assumes the assigned memory is mutable.
	fn isMutRiskyStruct(*self, s: &StructIns): bool {
		for _, f in s.Fields {
			// Inerior mutability enables to copy internal mutable data with safety.
			// If field is interior mutable and their kind is mutable,
			// check whether the field accessible. If field is not accessible,
			// there is no problem, because no risk for mutability.
			//
			// For example:
			//	We have a Foo struct. The Foo struct have the x field which is
			//	interior mutable with mutable kind. So the following code is risky:
			//
			//	a := Foo{}
			//	mut b := a
			//
			//	The example code above will create new copy of variable a, which is
			//	instance of struct Foo. If the field x is accessible, the variable
			//	b can mutate it, since it is mutable and can access to field x.
			//	Therefore, copying interior mutable fields with mutable kind
			//	must be disallowed if field is accessible for safety reasons.
			if f.Decl.Mutable && f.Type.Mutable() &&
				self.isAccessibleDefine(f.Decl.Public, f.Decl.Token) {
				ret true
			}
		}
		ret false
	}

	fn checkValidityForInitExpr(mut &self, leftMut: bool, leftRef: bool,
		leftKind: &Type, mut v: &Value, mut errorToken: &token::Token): bool {
		// Check value for reference pointers if value will be assigned to a reference pointer.
		// The checkRefValidityForInitExpr will update mutability of the value, if necessary.
		// See documentation of the checkRefValidityForInitExpr function.
		if leftRef {
			if !self.checkRefValidityForInitExpr(leftMut, v, errorToken) {
				ret false
			}
		} else if leftMut && !v.Mutable {
			// This case is an "else if", because if the destination memory
			// is a reference pointer, the checkRefValidityForInitExpr function
			// will check the mutability.

			// Check classical assignment mutability.
			if v.Type.Mutable() || v.Type.Variadic {
				self.pushErr(errorToken, "immutable data cannot be assigned to a mutable memory because of type @, which is mutable", v.Type.Str())
				ret false
			}
			// Check interior mutability risk for the struct copy.
			s := v.Type.Struct()
			if s != nil && self.isMutRiskyStruct(s) {
				self.pushErr(errorToken, "type @ cannot be copied to the mutable memory, due to it is mutable", v.Type.Str())
				ret false
			}
		}
		mut atc := &assignTypeChecker{
			s: self,
			v: v,
			errorToken: errorToken,
		}
		ret atc.checkValidity()
	}

	fn checkTypeAliasDeclKind(mut &self, mut ta: &TypeAlias, mut generics: []&TypeAlias, mut prev: &referencer, mut l: Lookup): (ok: bool) {
		mut old := self.file
		defer {
			self.setCurrentFile(old)
		}
		if ta.Token != nil {
			mut file := findFile(self.files, ta.Token.File)
			if file != nil {
				self.setCurrentFile(file)
			}
		}
		mut referencer := &referencer{
			name: ta.Name,
			owner: ta,
			prev: prev,
		}
		if prev != nil {
			prev.next = referencer
			defer { prev.next = nil }
		}
		referencer.tains = ta.Strict
		ok = self.checkTypeSymWithRefers(ta.TypeSym, l, generics, referencer)
		if ok && ta.TypeSym.Type.Array() != nil && ta.TypeSym.Type.Array().Auto {
			self.pushErr(ta.TypeSym.Decl.Token, "auto-sized arrays are not allowed as value type")
			ok = false
		}
		ret
	}

	fn checkTypeAliasDecl(mut &self, mut ta: &TypeAlias, mut prev: &referencer, mut l: Lookup): (ok: bool) {
		if jule::IsBlank(ta.Name) {
			self.pushErr(ta.Token, "blank identifier cannot be used as an identifier for this declaration")
		}
		if ta.TypeSym.Type != nil {
			// already checked
			ret true
		}
		// Type alias is strict, make strict type alias analysis.
		// See developer reference (9).
		if ta.Strict {
			mut s := initNewStructType(ta.Name, pseudoSource)
			s.Decl.sema = self
			s.Decl.Bind = ta.Bind
			s.Decl.Token = ta.Token
			s.Decl.Public = ta.Public
			ta.TypeSym.Type = &Type{Kind: s}
			if len(ta.Generics) > 0 {
				if ta.Bind {
					self.pushErr(ta.Token, "bind strict type alias cannot have generics")
					ret false
				}
				ok = self.checkDeclGenerics(ta.Generics)
				if !ok {
					ret false
				}
				// Remove instances for generic type alias.
				// This instance will be placeholder for the declaration.
				// Generic type aliases handled like structs.
				s.Decl.Instances = nil
				// Assign type alias generics to underlying structure.
				// This enables generic type analysis and support for the struct type.
				// Also assign the type alias to the struct.
				// See developer reference (3).
				s.Decl.Generics = ta.Generics
				s.Decl.alias = ta
				ret true
			}
		} else if len(ta.Generics) > 0 {
			self.pushErr(ta.Token, "soft type alias cannot have generics")
			self.pushSuggestion("define as strict type alias, like; type @[Generics]: Type", ta.Name)
			ret false
		}
		ok = self.checkTypeAliasDeclKind(ta, nil, prev, l)
		if !ok {
			ret false
		}
		if !ta.Strict && ta.Bind {
			self.pushErr(ta.Token, "bind types cannot be soft type alias")
			self.pushSuggestion("define as strict type alias, like; type @: Type", ta.Name)
		}
		ret true
	}

	// Checks type alias declaration with duplicated identifiers.
	fn checkTypeAliasDeclDup(mut &self, mut ta: &TypeAlias) {
		if self.isDuplicatedName(uintptr(ta), ta.Name, ta.Bind) {
			self.pushErr(ta.Token, "identifier @ is duplicated in this scope", ta.Name)
		}
		self.checkTypeAliasDecl(ta, nil, self)
	}

	// Checks current package file's type alias declarations.
	fn checkTypeAliasDecls(mut &self): (ok: bool) {
		for (_, mut ta) in self.file.TypeAliases {
			self.checkTypeAliasDeclDup(ta)

			// Break checking if type alias has error.
			if len(self.errors) > 0 {
				ret false
			}
		}
		ret true
	}

	fn checkTypeEnumItemType(mut &self, mut e: &TypeEnum, mut item: &TypeEnumItem): (ok: bool) {
		mut old := self.file
		defer {
			self.setCurrentFile(old)
		}
		if e.Token != nil {
			mut file := findFile(self.files, e.Token.File)
			if file != nil {
				self.setCurrentFile(file)
			}
		}
		ok = self.checkTypeSym(item.TypeSym, self)
		if ok && item.TypeSym.Type.Array() != nil && item.TypeSym.Type.Array().Auto {
			self.pushErr(item.TypeSym.Decl.Token, "auto-sized arrays are not allowed as value type")
			ok = false
		}
		if ok {
			checkTypeEnumRefCycle(self, e, item)
		}
		ret
	}

	fn checkTypeEnumDecl(mut &self, mut e: &TypeEnum) {
		if jule::IsBlank(e.Name) {
			self.pushErr(e.Token, "blank identifier cannot be used as an identifier for this declaration")
		} else if self.isDuplicatedName(uintptr(e), e.Name, false) {
			self.pushErr(e.Token, "identifier @ is duplicated in this scope", e.Name)
		}

		if len(e.Items) == 0 {
			self.pushErr(e.Token, "enum @ have not any member", conv::Quote(e.Name))
			ret
		}

		for (_, mut item) in e.Items {
			if item.TypeSym == nil {
				self.pushErr(item.Token, "missing type")
				continue
			}
			ok := self.checkTypeEnumItemType(e, item)
			if !ok {
				continue
			}
			// Disallow plain <any> type, but allow strict type aliases to type <any>.
			p := item.TypeSym.Type.Prim()
			if item.TypeSym.Type.SoftStruct() == nil && p != nil && p.IsAny() {
				self.pushErr(item.Token, "type any does not makes sense in type-enum")
			}
		}
	}

	// Checks current package file's type enum declarations.
	fn checkTypeEnumDecls(mut &self): (ok: bool) {
		for (_, mut e) in self.file.TypeEnums {
			self.checkTypeEnumDecl(e)
			// Break checking if type alias has error.
			if len(self.errors) > 0 {
				ret false
			}
		}
		ret true
	}

	fn checkEnumItemsDup(mut *self, items: []&Var) {
		for _, item in items {
			// The last item is nil.
			// See developer reference (14).
			if item == nil {
				continue
			}
			if item.Name == "" {
				continue
			} else if jule::IsBlank(item.Name) {
				self.pushErr(item.Token, "blank identifier cannot be used as an identifier for this declaration")
			} else {
				for _, citem in items {
					if item == citem {
						break
					} else if item.Name == citem.Name {
						self.pushErr(item.Token, "identifier @ is duplicated in this scope", item.Name)
						break
					}
				}
			}
		}
	}

	fn precheckEnumDecl(mut &self, mut e: &Enum) {
		if jule::IsBlank(e.Name) {
			self.pushErr(e.Token, "blank identifier cannot be used as an identifier for this declaration")
		} else if self.isDuplicatedName(uintptr(e), e.Name, false) {
			self.pushErr(e.Token, "identifier @ is duplicated in this scope", e.Name)
		}

		if len(e.Items) == 0 {
			self.pushErr(e.Token, "enum @ have not any member", conv::Quote(e.Name))
			ret
		}

		self.checkEnumItemsDup(e.Items)

		if e.TypeSym != nil {
			if !self.checkTypeSym(e.TypeSym, self) {
				ret
			}
		} else {
			// Set to default type.
			e.TypeSym = findBuiltinTypeAlias(types::Int).TypeSym
		}

		mut t := e.TypeSym.Type.Prim()
		if t == nil {
			self.pushErr(e.Token, "invalid type for enum: "+t.Str())
			ret
		}

		supportsIota := types::IsInt(t.Str())
		if !t.IsStr() && !supportsIota {
			self.pushErr(e.Token, "invalid type for enum: "+t.Str())
			ret
		}
		for (_, mut item) in e.Items {
			// The last item is nil.
			// See developer reference (14).
			if item == nil {
				continue
			}
			item.TypeSym = new(TypeSym, *e.TypeSym)
			if e.TypeSym.Decl != nil {
				item.TypeSym.Decl = new(ast::Expr, *e.TypeSym.Decl)
				item.TypeSym.Decl.Token = item.Token
			}
		}
	}

	fn checkEnumDecl(mut &self, mut e: &Enum) {
		for (_, mut item) in e.Items {
			// The last item is nil.
			// See developer reference (14).
			if item == nil {
				continue
			}
			self.checkVar(item, self)
		}
	}

	// Checks current package file's enum declarations.
	fn checkEnumDecls(mut &self): (ok: bool) {
		// Do "pre-check" explained in the developer reference (5).
		// This part is mandatory, but the "check" phase does not have to be done here.
		for (_, mut e) in self.file.Enums {
			self.precheckEnumDecl(e)
			// Break checking if type alias has error.
			if len(self.errors) > 0 {
				ret false
			}
		}
		for (_, mut e) in self.file.Enums {
			self.checkEnumDecl(e)
			// Break checking if type alias has error.
			if len(self.errors) > 0 {
				ret false
			}
		}
		ret true
	}

	fn checkDeclGenerics(mut *self, generics: []&ast::Generic): (ok: bool) {
		ok = true
		for i, g in generics {
			if jule::IsBlank(g.Name) {
				self.pushErr(g.Token, "blank identifier cannot be used as an identifier for this declaration")
				ok = false
				continue
			}

			// Check duplications.
		duplicationLookup:
			for j, ct in generics {
				match {
				| j >= i:
					// Skip current and following generics.
					break duplicationLookup
				| g.Name == ct.Name:
					self.pushErr(g.Token, "identifier @ is duplicated in this scope", g.Name)
					ok = false
					break duplicationLookup
				}
			}
		}
		ret
	}

	fn checkFuncDeclParamsDup(mut *self, f: &Func): (ok: bool) {
		ok = true
	check:
		for i, p in f.Params {
			// Lookup in generics.
			for _, g in f.Generics {
				if p.Name == g.Name {
					ok = false
					self.pushErr(p.Token, "identifier @ is duplicated in this scope", p.Name)
					continue check
				}
			}

		paramsLookup:
			for j, jp in f.Params {
				match {
				| j >= i:
					// Skip current and following parameters.
					break paramsLookup
				| jule::IsBlank(p.Name)
				| jule::IsBlank(jp.Name)
				| jule::IsAnon(p.Name)
				| jule::IsAnon(jp.Name):
					// Skip anonymous parameters.
					break paramsLookup
				| p.Name == jp.Name:
					ok = false
					self.pushErr(p.Token, "identifier @ is duplicated in this scope", p.Name)
					continue check
				}
			}
		}
		ret
	}

	fn checkFuncDeclResultDup(mut *self, mut f: &Func): (ok: bool) {
		ok = true
		if f.IsVoid() {
			ret
		}

		// Check duplications.
		for i, v in f.Result.Names {
			if jule::IsBlank(v.Kind) || jule::IsAnon(v.Kind) {
				continue // Skip anonymous return variables.
			}
			// Lookup in generics.
			for _, g in f.Generics {
				if v.Kind == g.Name {
					goto exist
				}
			}
			// Lookup in parameters.
			for _, p in f.Params {
				if v.Kind == p.Name {
					goto exist
				}
			}

			// Lookup in return identifiers.
		itselfLookup:
			for j, jv in f.Result.Names {
				match {
				| j >= i:
					// Skip current and following identifiers.
					break itselfLookup
				| jv.Kind == v.Kind:
					goto exist
				}
			}
			continue
		exist:
			self.pushErr(v, "identifier @ is duplicated in this scope", v.Kind)
			ok = false
		}

		ret
	}

	fn checkFuncVariadicParam(mut &self, mut f: &Func): bool {
		if len(f.Params) == 0 {
			ret false
		}
		mut param := f.Params[len(f.Params)-1]
		if param.Variadic && param.Reference {
			self.pushErr(param.Token, "reference parameter cannot be variadic")
		}
		ret true
	}

	// Checks generics, parameters and return type.
	// Not checks scope, and other things.
	fn checkFuncDeclPrototype(mut &self, mut f: &Func) {
		if f.Exceptional && f.Bind {
			self.pushErr(f.Token, "bind functions cannot be exceptional")
			ret
		}

		// Check special cases for reserved functions, ignore method ones.
		if f.IsEntryPoint() && f.Owner == nil {
			if !FuncPattern.Main(f) {
				self.pushErr(f.Token, "invalid entry point function")
				self.pushSuggestion("expected; fn main()")
			}
		} else if f.IsInit() && f.Owner == nil {
			if !FuncPattern.Init(f) {
				self.pushErr(f.Token, "invalid initializer function")
				self.pushSuggestion("expected; fn init()")
			}
		}

		match {
		| !self.checkDeclGenerics(f.Generics):
		| !self.checkFuncDeclParamsDup(f):
		| !self.checkFuncDeclResultDup(f):
		| !self.checkFuncVariadicParam(f):
		}
	}

	fn catchTraitInheritCycle(mut &self, t1: &Trait, mut t2: &Trait, mut &message: *strings::Builder): (ok: bool) {
		ok = true
		for (_, mut i) in t2.Inherits {
			if i.Type == nil {
				continue
			}
			mut t3 := i.Type.Trait()
			if t1 == t3 {
				self.pushCycleError(t2.Name, t3.Name, message)
				ret false
			}
			if !self.catchTraitInheritCycle(t1, t3, message) {
				self.pushCycleError(t2.Name, t3.Name, message)
				ret false
			}
		}
		ret
	}

	fn _checkTraitDeclInherits(mut &self, mut t: &Trait): (ok: bool) {
		ok = true
		for (i, mut it) in t.Inherits {
			if !self.checkTypeSym(it, self) {
				ok = false
				continue
			}
			mut t2 := it.Type.Trait()
			if t2 == nil {
				self.pushErr(it.Decl.Token, "trait @ cannot inherit @, type should be trait", t.Name, it.Type.Str())
				ok = false
				continue
			}
			for j, it2 in t.Inherits {
				if j >= i {
					break
				}
				if it2.Type != nil && it.Type.Equal(it2.Type) {
					self.pushErr(it.Decl.Token, "identifier @ is duplicated in this scope", t2.Name)
					ok = false
					break
				}
			}
			if t == t2 {
				self.pushErr(it.Decl.Token, "illegal cycle in declaration: @ refers to itself", t.Name)
				ok = false
			} else {
				mut message := strings::Builder{}
				message.Grow(1 << 6)
				ok = ok && self.catchTraitInheritCycle(t, t2, &message)
				if message.Len() > 0 {
					mut errMsg := message.Str()
					message.Clear()
					self.pushCycleError(t.Name, t2.Name, &message)
					errMsg += message.Str()
					self.pushErr(it.Decl.Token, "illegal cross cycle in declaration:\n"+errMsg)
				}
			}
		}
		ret ok
	}

	fn checkTraitDeclInherits(mut &self, mut t: &Trait) {
		for (i, mut it) in t.Inherits {
			mut t1 := it.Type.Trait()
			for (j, mut it2) in t.Inherits {
				if j == i {
					continue
				}
				mut t2 := it2.Type.Trait()
				for (_, mut t1m) in t1.Methods {
					mut t2m := t2.FindMethod(t1m.Name)
					if t2m == nil {
						continue
					}
					t1f := self.getTraitCheckFuncKind(t1m)
					t2f := self.getTraitCheckFuncKind(t2m)
					if !t1f.equalTrait(t2f) {
						self.pushErr(it.Decl.Token, "trait @ inherits trait @, but the same identifiers are implemented different:\n       @\n       @",
							t.Name, t2.Name, t1f.GetKindStr(true), t2f.GetKindStr(true))
						ret
					}
				}
			}
		}
	}

	fn checkTraitDeclMethod(mut &self, mut f: &Func) {
		if jule::IsBlank(f.Name) {
			self.pushErr(f.Token, "blank identifier cannot be used as an identifier for this declaration")
		} else if jule::IsAnon(f.Name) {
			self.pushErr(f.Token, "anonymous functions are not allowed in this scope")
		}
		f.sema = self
		self.checkFuncDeclPrototype(f)
		mut ins := f.instance()
		_ = self.reloadFuncInsTypes(ins)
		ins.reloaded = true
		f.appendInstance(ins)
	}

	fn checkTraitDeclMethods(mut &self, mut t: &Trait) {
		for (i, mut f) in t.Methods {
			self.checkTraitDeclMethod(f)

			// Break checking if type alias has error.
			if len(self.errors) > 0 {
				ret
			}

			if t.findMethodInherit(f.Name) != nil {
				self.pushErr(f.Token, "identifier @ is duplicated in this scope", f.Name)
				continue
			}

			// Check duplications.
		duplicateLookup:
			for j, jf in t.Methods {
				// NOTE:
				//	Ignore identifier checking is unnecessary here.
				//	Because ignore identifiers logs error.
				//	Errors breaks checking, so here is unreachable code for
				//	ignore identified methods.
				match {
				| j >= i:
					// Skip current and following methods.
					break duplicateLookup
				| f.Name == jf.Name:
					self.pushErr(f.Token, "identifier @ is duplicated in this scope", f.Name)
					break duplicateLookup
				}
			}
		}
	}

	fn checkTraitDecl(mut &self, mut t: &Trait) {
		if jule::IsBlank(t.Name) {
			self.pushErr(t.Token, "blank identifier cannot be used as an identifier for this declaration")
		} else if self.isDuplicatedName(uintptr(t), t.Name, false) {
			self.pushErr(t.Token, "identifier @ is duplicated in this scope", t.Name)
		}

		self.checkTraitDeclInherits(t)
		self.checkTraitDeclMethods(t)
	}

	// Checks current package file's trait declarations.
	fn checkTraitDecls(mut &self): (ok: bool) {
		for (_, mut t) in self.file.Traits {
			self.checkTraitDecl(t)
			// Break checking if type alias has error.
			if len(self.errors) > 0 {
				ret false
			}
		}
		ret true
	}

	fn checkTraitImplMethods(mut *self, mut base: &Trait, ipl: &Impl): (ok: bool) {
		ok = true
		for _, f in ipl.Methods {
			if base.FindMethod(f.Name) == nil {
				self.pushErr(f.Token, "undefined name for trait @: @", conv::Quote(base.Name), conv::Quote(f.Name))
				ok = false
			}
		}
		ret
	}

	fn implToStruct(mut &self, mut dest: &Struct, mut ipl: &Impl): (ok: bool) {
		ok = true

		// Methods.
		for (_, mut f) in ipl.Methods {
			if dest.FindMethod(f.Name, f.Static) != nil || dest.FindField(f.Name) != nil {
				self.pushErr(f.Token, "identifier @ is duplicated in scope of struct", dest.Name, f.Name)
				ok = false
				continue
			}

			if len(dest.Generics) > 0 && len(f.Generics) > 0 {
				for _, fg in f.Generics {
					for _, dg in dest.Generics {
						if fg.Name == dg.Name {
							self.pushErr(fg.Token, "methods cannot have the same generic identifier as owner: "+conv::Quote(fg.Name))
							ok = false
						}
					}
				}
			}

			self.checkDirectives(f.Directives, f)

			f.sema = self
			f.Owner = dest
			dest.Methods = append(dest.Methods, f)
		}

		if len(dest.Instances) == 1 {
			// We have an instance. It's should be impossible if structure is not
			// constructed by a strict type alias. If so, update data of the instance.
			mut s := dest.Instances[0]
			if s.Source != nil {
				s.Methods = dest.Methods
			}
		}

		ret
	}

	// Implement trait to destination.
	fn implTrait(mut &self, mut decl: &Impl) {
		mut baseT := self.selectType(decl.Base)
		if baseT == nil {
			ret
		}
		mut base := baseT.Trait()
		if base == nil {
			self.pushErr(decl.Base.Token, "base type @ is invalid for impl statement", baseT.Str())
			self.pushSuggestion("expected trait type")
			ret
		}

		mut destT := self.selectType(decl.Dest)
		if destT == nil {
			ret
		}
		mut destS := destT.SoftStruct()
		if destS == nil {
			self.pushErr(decl.Dest.Token, "destination type @ is invalid for impl statement", destT.Str())
			self.pushSuggestion("expected structure type")
			ret
		}

		mut dest := destS.Decl

		if dest.Token.File.Dir() != self.file.File.Dir() {
			self.pushErr(decl.Dest.Token, "illegal implementation to structure comes from different package")
			ret
		}

		pushImplemented(base, dest)
		pushImplements(dest, base)

		match {
		| !self.checkTraitImplMethods(base, decl):
		| !self.implToStruct(dest, decl):
		}
	}

	fn implStruct(mut &self, mut decl: &Impl) {
		mut destT := self.selectType(decl.Dest)
		if destT == nil {
			ret
		}
		mut destS := destT.SoftStruct()
		if destS == nil {
			self.pushErr(decl.Dest.Token, "destination type @ is invalid for impl statement", destT.Str())
			self.pushSuggestion("expected structure type")
			ret
		}

		mut dest := destS.Decl
		if dest.Token.File.Dir() != self.file.File.Dir() {
			self.pushErr(decl.Dest.Token, "illegal implementation to structure comes from different package")
			ret
		}

		match {
		| !self.implToStruct(dest, decl):
		}
	}

	// Implement implementation.
	fn implImpl(mut &self, mut decl: &Impl) {
		match {
		| decl.IsTraitImpl():
			self.implTrait(decl)
		| decl.IsStructImpl():
			self.implStruct(decl)
		}
	}

	// Checks variable declaration.
	// Will not check duplicated identifiers.
	fn checkVarDecl(mut &self, mut decl: &Var, mut l: Lookup) {
		// If declaration is constant and have not a group, complain for initialize expression.
		// Otherwise do not. Because it may be enumerated.
		// It will be checked by the [checkVarValue] method.
		// But if it has type annotation, complain, because enumerators
		// should be plain, only identifier.
		groupError := decl.Constant && (decl.Group == nil || !decl.IsTypeInferred())

		if decl.IsTypeInferred() {
			if !decl.IsInitialized() && groupError {
				self.pushErr(decl.Token, "variable needs to be initialized for type inference")
			}
		} else {
			mut refers := (&ReferenceStack)(nil)
			match type l {
			| &sema:
				refers = decl.Refers
			| &scopeChecker:
				refers = l.(&scopeChecker).getOwnerRefers()
			|:
				panic("sema: checkVarDecl: unimplemented referencer")
			}
			decl.TypeSym.Type = self.checkTypeSymRefers(decl.TypeSym.Decl, l, refers)
		}

		if decl.Reference {
			if decl.Constant {
				self.pushErr(decl.Token, "constant variable cannot be reference")
			}
			if decl.Static {
				self.pushErr(decl.Token, "static variables cannot be reference")
			}
		}

		if !decl.IsInitialized() {
			if groupError {
				self.pushErr(decl.Token, "constant variable must be initialized explicitly")
			}
			if !decl.Bind && decl.Static {
				self.pushErr(decl.Token, "static variable must be initialized explicitly")
			}
			if decl.Reference {
				self.pushErr(decl.Token, "reference variable must be initialized explicitly")
			}
		}
	}

	// Checks variable declaration for global scope.
	// Checks duplicated identifiers by Sema.
	fn checkGlobalVarDecl(mut &self, mut decl: &Var) {
		if self.isDuplicatedName(uintptr(decl), decl.Name, decl.Bind) {
			self.pushErr(decl.Token, "identifier @ is duplicated in this scope", decl.Name)
		}
		if decl.Bind && decl.Constant {
			self.pushErr(decl.Token, "bind variable cannot be constant")
		}
		if !decl.Bind && !decl.Constant && !decl.Static {
			self.pushErr(decl.Token, "global variable must be static")
		}
		self.checkDirectives(decl.Directives, decl)
		self.checkVarDecl(decl, self)
	}

	// Checks current package file's global variable declarations.
	fn checkGlobalDecls(mut &self): (ok: bool) {
		for (_, mut decl) in self.file.Vars {
			self.checkGlobalVarDecl(decl)
			// Break checking if type alias has error.
			if len(self.errors) > 0 {
				ret false
			}
		}
		ret true
	}

	fn checkStructTraitImpl(mut &self, mut strct: &Struct, mut trt: &Trait): (ok: bool) {
		ok = true
		for (_, mut tf) in trt.Methods {
			mut exist := false
			mut sf := strct.FindMethod(tf.Name, tf.Static)
			tfK := self.getTraitCheckFuncKind(tf)
			if sf != nil {
				mut sfK := self.getTraitCheckFuncKind(sf)
				if sfK != nil {
					exist = tfK.equalTrait(sfK)
				}
			}
			if !exist {
				const Name = true
				self.pushErr(strct.Token, "trait @ implements but structure @ does not; @", trt.Name, strct.Name, tfK.GetKindStr(Name))
				ok = false
			}
		}
		ret
	}

	fn checkStructImpls(mut &self, mut s: &Struct): (ok: bool) {
		ok = true
		for (_, mut trt) in s.Implements {
			ok = self.checkStructTraitImpl(s, trt) && ok
		}
		ret ok
	}

	fn checkStructFields(mut &self, mut st: &Struct): (ok: bool) {
		ok = true
		for (_, mut f) in st.Fields {
			f.Owner = st
			if jule::IsBlank(f.Name) {
				continue
			}
			// Check duplicated identifiers for fields.
			for _, cf in st.Fields {
				if f == cf {
					break
				} else if f.Name == cf.Name {
					self.pushErr(f.Token, "identifier @ is duplicated in this scope", f.Name)
					ok = false
				}
			}
		}
		ret ok
	}

	fn checkStructFieldTags(mut &self, mut s: &Struct): (ok: bool) {
		ok = true
		mut tc := tagChecker{
			s: self,
		}
		for (_, mut f) in s.Fields {
			if f.Tag != nil {
				tc.f = f
				ok = tc.check() && ok
			}
		}
		ret
	}

	fn checkStructDecl(mut &self, mut s: &Struct) {
		if jule::IsBlank(s.Name) {
			self.pushErr(s.Token, "blank identifier cannot be used as an identifier for this declaration")
		} else if self.isDuplicatedName(uintptr(s), s.Name, s.Bind) {
			self.pushErr(s.Token, "identifier @ is duplicated in this scope", s.Name)
		}

		self.checkDirectives(s.Directives, s)

		match {
		| !self.checkDeclGenerics(s.Generics):
		| !self.checkStructFields(s):
		| !self.checkStructFieldTags(s):
		| !self.checkStructImpls(s):
		| !self.checkFuncDeclsBy(s.Methods):
		}

		// Here, we need to dispatch the methods again.
		// At this point, all `impl` statements should already be implemented.
		// During this process, some instances might have been created without
		// having the methods. To prevent this from causing errors,
		// the missing methods added with the `impl` statements must be dispatched
		// to the instances that have not have these methods.
		s.dispatchMethods()
	}

	// Checks current package file's structure declarations.
	fn checkStructDecls(mut &self): (ok: bool) {
		for (_, mut s) in self.file.Structs {
			self.checkStructDecl(s)
			// Break checking if type alias has error.
			if len(self.errors) > 0 {
				ret false
			}
		}
		for (_, mut ta) in self.file.TypeAliases {
			if !ta.Strict {
				continue
			}
			mut s := ta.TypeSym.Type.Kind.(&StructIns).Decl
			match {
			| !self.checkStructImpls(s):
			| !self.checkFuncDeclsBy(s.Methods):
			}
			// Break checking if type alias has error.
			if len(self.errors) > 0 {
				ret false
			}
		}
		ret true
	}

	fn checkAnonFuncDecl(mut &self, mut f: &Func) {
		f.sema = self
		self.checkFuncDeclPrototype(f)
	}

	fn checkFuncDecl(mut &self, mut f: &Func) {
		if jule::IsBlank(f.Name) {
			self.pushErr(f.Token, "blank identifier cannot be used as an identifier for this declaration")
		} else if f.IsAnon() {
			self.pushErr(f.Token, "anonymous functions are not allowed in this scope")
		}

		self.checkDirectives(f.Directives, f)
		self.checkAnonFuncDecl(f)

		if f.Owner == nil && self.isDuplicatedName(uintptr(f), f.Name, f.Bind) {
			if f.Name == jule::InitFunc {
				init := self.FindFunc(jule::InitFunc, false)
				if init != nil {
					ret
				}
			}
			self.pushErr(f.Token, "identifier @ is duplicated in this scope", f.Name)
		}
	}

	fn checkFuncDeclsBy(mut &self, mut funcs: []&Func): bool {
		for (_, mut f) in funcs {
			self.checkFuncDecl(f)
			// Break checking if error occurs.
			if len(self.errors) > 0 {
				ret false
			}
		}
		ret true
	}

	// Checks current package file's function declarations.
	fn checkFuncDecls(mut &self): (ok: bool) {
		ret self.checkFuncDeclsBy(self.file.Funcs)
	}

	fn pushCycleError(*self, st1: str, st2: str, mut &message: *strings::Builder) {
		const Padding = 7
		refersTo := log::Logf("@ refers to @", st1, st2)
		m := message.Str()
		message.WriteStr(strings::Repeat(" ", Padding))!
		message.WriteStr(refersTo)!
		message.WriteByte('\n')!
		message.WriteStr(m)!
	}

	// Checks declarations of all package files.
	// Breaks checking if checked file failed.
	fn checkPackageDecls(mut &self) {
		for (_, mut f) in self.files {
			self.setCurrentFile(f)
			if !self.checkTypeAliasDecls() {
				ret
			}
		}

		for (_, mut f) in self.files {
			self.setCurrentFile(f)
			if !self.checkTraitDecls() {
				ret
			}
		}

		for (_, mut f) in self.files {
			self.setCurrentFile(f)
			if !self.checkGlobalDecls() {
				ret
			}
		}

		for (_, mut f) in self.files {
			self.setCurrentFile(f)
			match {
			| !self.checkFuncDecls():
			| !self.checkStructDecls():
			|:
				continue
			}
			ret
		}
	}

	fn checkDataForTypeInference(mut *self, v: &Value, errToken: &token::Token): bool {
		match {
		| v.IsNil():
			self.pushErr(errToken, "value \"nil\" cannot be type inferred")
			ret false
		| v.IsVoid():
			self.pushErr(errToken, "value \"void\" cannot be type inferred")
			ret false
		| v.Type.Variadic:
			self.pushErr(errToken, "variadic value cannot be type inferred")
			ret false
		|:
			ret true
		}
	}

	// Checks value of variable.
	fn checkVarValue(mut &self, mut v: &Var) {
		// Catch the exceptional function calls for initialization value if variable static.
		// If variable is constant, no need for extra attention.
		// An exceptional function cannot return a constant value.
		if v.Static && v.ValueSym != nil && v.ValueSym.Value != nil {
			fc, isFuncCall := v.ValueSym.Value.Model.(&FuncCallExpr)
			if isFuncCall && fc.Func.Decl != nil && fc.Func.Decl.Exceptional {
				self.pushErr(v.ValueSym.Expr.Token, "using of exceptional function disallowed in this scope")
				self.pushSuggestion("wrap the exceptional with a non-exceptional function")
			}
		}

		if v.IsTypeInferred() {
			// Build new TypeSym because auto-type symbols are nil.
			v.TypeSym = &TypeSym{Type: v.ValueSym.Value.Type}

			if v.Reference {
				checkTypeForRef(self, v.TypeSym.Type, v.Token)
			}

			// Check value for unwrap and physical memory constraint.
			if !v.Constant && v.ValueSym.Value.untyped {
				_ = checkValue(v.ValueSym.Value, self, v.ValueSym.Expr.Token, evalDefault|evalPhysicalMem|evalUnwrapUntyped)
			}

			self.checkDataForTypeInference(v.ValueSym.Value, v.ValueSym.Expr.Token)
			self.checkValidityForInitExpr(
				v.Mutable,
				v.Reference,
				v.TypeSym.Type,
				v.ValueSym.Value,
				v.ValueSym.Expr.Token)
		} else {
			if v.Reference {
				checkTypeForRef(self, v.TypeSym.Type, v.Token)
			}

			// Set the size of the array if it is auto-sized.
			mut arr := v.TypeSym.Type.Array()
			if arr != nil {
				if arr.Auto {
					dataArr := v.ValueSym.Value.Type.Array()
					if dataArr != nil {
						arr.N = dataArr.N
					}
				}
			}

			const FirstAssignToDest = true // The variable takes first assignment with the initializer value.
			if self.checkAssignType(v.Reference, FirstAssignToDest, v.TypeSym.Type, v.ValueSym.Value, v.ValueSym.Expr.Token, v.Refers) {
				self.checkValidityForInitExpr(
					v.Mutable,
					v.Reference,
					v.TypeSym.Type,
					v.ValueSym.Value,
					v.ValueSym.Expr.Token)
			}
		}

		if v.Constant {
			if !v.ValueSym.Value.IsConst() && !v.ValueSym.Value.Type.comptime() {
				self.pushErr(v.ValueSym.Expr.Token, "expression must be constant")
			}
		} else {
			v.ValueSym.Value.Constant = nil
			v.ValueSym.Value.untyped = false
		}

		// Remove kind for avoid more tuple-type errors.
		if v.TypeSym.Type.Tuple() != nil {
			v.TypeSym.Type = nil
		}
	}

	// Evaluates value of variable if initialized.
	// Reports if value-check needed.
	fn evalVarValue(mut &self, mut v: &Var, mut l: Lookup): (valCheck: bool) {
		// Determine with v.Scope=nil condition because scope analysis may
		// reserve group members with trailing nil members, which is a mark for
		// enum declaration members. Therefore, make sure variable is not defined
		// in the scope.
		if !v.IsInitialized() {
			// If variable is constant and grouped, we have to check previous
			// constants due to possible enumeration.
			if v.Constant && v.Group != nil {
				isEnumField := v.Scope == nil && v.IsEnumField()
				if v.GroupIndex == 0 {
					if isEnumField {
						v.ValueSym = new(ValueSym)
						v.ValueSym.Expr = new(ast::Expr)
						v.ValueSym.Expr.Token = v.Token
						prim := v.TypeSym.Type.Prim() // Enum fields must be primitive.
						match {
						| prim.IsStr():
							v.ValueSym.Expr.Data = &ast::LitExpr{
								Token: v.Token,
								Value: "\"" + v.Name + "\"",
							}
						| types::IsNum(prim.Str()):
							v.ValueSym.Expr.Data = &ast::NameExpr{
								Token: v.Token,
								Name: "iota",
							}
						|:
							panic("unreachable")
						}
						goto Eval
					} else {
						self.pushErr(v.Token, "first member of the variable group must be initialized")
					}
					ret false
				}
				mut dv := v.Group[v.GroupIndex-1]
				if !dv.Checked {
					self.checkVar(dv, l)
				}
				if dv.ValueSym == nil || dv.ValueSym.Value == nil {
					ret false
				}
				v.TypeSym = new(TypeSym, *dv.TypeSym)
				// If type is not declared explicitly, remove the derived type.
				// Type should be inferred like the previous member. Otherwise,
				// use the same type declaration. Note that if variable is an enum field,
				// it may have not type declaration (used the implicit type) but
				// they always have an exact type.
				if isEnumField {
					// no-op
				} else if dv.TypeSym.Decl != nil {
					v.TypeSym.Decl = new(ast::Expr, *dv.TypeSym.Decl)
					v.TypeSym.Decl.Token = v.Token
				} else {
					v.TypeSym.Type = nil
				}
				v.ValueSym = new(ValueSym)
				if dv.Iota {
					v.ValueSym.Expr = new(ast::Expr, *dv.ValueSym.Expr)
					v.ValueSym.Expr.Token = v.Token
					goto Eval
				} else {
					v.ValueSym.Value = dv.ValueSym.Value
				}
			}
			ret false
		}

	Eval:
		mut eval := (&eval)(nil)
		if v.TypeSym != nil {
			eval = self.evalpd(l, v.TypeSym.Type, v)
		} else {
			eval = self.evalpd(l, nil, v)
		}
		eval.target.mutable = v.Mutable

		allowIota := len(v.Group) > 0
		if allowIota {
			eval.varIota = buildIota(i64(v.GroupIndex))
			defer {
				v.Iota = v.Iota || eval.varIota.Used
			}
		}

		// Do not unwrap untyped literals, type analysis will check overflows.
		mut evalFlags := evalDefault | evalExceptional
		if v.Reference {
			evalFlags |= evalRefptr
		}
		v.ValueSym.Value = eval.evalExpr(v.ValueSym.Expr, evalFlags)
		ret true
	}

	// Evaluateds value of variable and checks.
	// Assumes the variable is global.
	fn checkVar(mut &self, mut v: &Var, mut l: Lookup) {
		if v.Checked {
			ret
		}
		v.Checked = true
		valCheck := self.evalVarValue(v, l)
		if !valCheck || v.IsInitialized() && v.ValueSym.Value == nil {
			ret // Skip checks if error occurs.
		}
		self.checkVarValue(v)
	}

	// Checks current package file's global variables.
	fn checkGlobals(mut &self) {
		for (_, mut decl) in self.file.Vars {
			// Skip if variable is binded or already used.
			// If it is already used, should already analyzed.
			if decl.Bind || decl.Used {
				continue
			}
			self.checkVar(decl, self)
		}
	}

	// Returns new FuncIns as ready-to-analysis.
	// If function already has a instance, returns existing instance.
	// Returns nil if have a problem.
	fn readyToCheckFunc(mut &self, mut s: &StructIns, mut f: &Func): &FuncIns {
		mut ins := f.instance()
		if len(f.Instances) != 0 {
			ret ins
		}
		ins.Owner = s
		f.appendInstance(ins)
		ins.reloaded = true
		if self.reloadFuncInsTypes(ins) {
			ret ins
		}
		ret nil
	}

	fn recheckType(mut &self, mut t: recheckableType, mut errorToken: &token::Token,
		mut refers: &ReferenceStack): (ok: bool) {
		mut tc := &typeChecker{
			s: self,
			rootLookup: self,
			lookup: self,
			refers: refers,
		}
		ret tc.recheck(t, errorToken)
	}

	// Basically same as the checkGenericFunc,
	// but checks the function with the recheck strategy.
	// See developer reference (15).
	fn checkGenericFuncRecheck(mut &self, mut &f: *&FuncIns, mut et: &token::Token,
		mut recheckNeed: []recheckableType): (ok: bool, exist: bool) {
		// If len(recheckNeed)>0, check the types before handling function.
		if len(recheckNeed) > 0 {
			n := len(self.errors)
			ok = true
			for (_, mut t) in recheckNeed {
				ok = self.recheckType(t, et, (*f).Refers) && ok
			}
			if !ok || n != len(self.errors) {
				ret false, false
			}
		}
		mut existInstance := (*f).Decl.appendInstance(*f)
		// If instance already exist with same generics, return immediately.
		// This function should be already checked, or it will be.
		if existInstance != nil {
			// Set f to exist one.
			*f = existInstance
			ret true, true
		}
		// We still need to check self parameter.
		self.reloadSelf(*f)
		// Check parameter types.
		for (_, mut p) in (*f).Params {
			self.checkFuncParamKind(p)
		}
		if !self.checkConstraintsFunc(*f, et, existInstance) {
			ret false, false
		}
		// Check generic function instance instantly.
		self.checkFuncInsCaller(*f, et)
		ok = true
		ret
	}

	// Checks new generics function instance.
	// If instance is already exist, f will point to exist instantantiation.
	fn checkGenericFunc(mut &self, mut &f: *&FuncIns, mut et: &token::Token): (ok: bool, exist: bool) {
		mut existInstance := (*f).Decl.appendInstance(*f)
		// If instance already exist with same generics, return immediately.
		// This function should be already checked, or it will be.
		if existInstance != nil {
			// Set f to exist one.
			*f = existInstance
			ret true, true
		}
		ok = self.reloadFuncInsTypes(*f)
		(*f).reloaded = true
		if !ok {
			ret false, false
		}
		if !self.checkConstraintsFunc(*f, et, existInstance) {
			ret false, false
		}
		// Check generic function instance instantly.
		self.checkFuncInsCaller(*f, et)
		ok = true
		ret
	}

	fn checkTypeMethod(mut &self, mut f: &Func) {
		for (_, mut ins) in f.Instances {
			self.checkFuncIns(ins)
		}
	}

	// Checks environment-dependent parts of structure instance.
	// Which is contains fields and generic-type constraints.
	// If generic instance will be check, errorToken should be passed.
	fn checkStructEnv(mut &self, mut s: &StructIns, mut prev: &referencer, mut errorToken: &token::Token): (ok: bool) {
		s.fillEnviron()

		// If source is not nil, do not check.
		// This is unnecessary process for strict type alias structure instances.
		if s.Source != nil {
			ret true
		}
		mut tc := typeChecker{
			s: s.env.sema,
			rootLookup: s.env.sema,
			lookup: s.env.sema,
			referencer: &referencer{
				name: s.Decl.Name,
				owner: s,
				prev: prev,
			},
			refers: s.Refers,
			useGenerics: s.env.generics,
		}
		if prev != nil {
			prev.next = tc.referencer
			defer { prev.next = nil }
		}

		if s.env.file != nil && self.file != s.env.file {
			mut oldFile := self.file
			defer { self.setCurrentFile(oldFile) }
			self.setCurrentFile(s.env.file)
		}

		if len(s.Generics) > 0 {
			mut cc := self.constraintChecker()
			cc.et = errorToken
			cc.si = s
			cc.genericsA = tc.useGenerics
			cc.uniq = true
			if !cc.check() {
				ret
			}
		}

		ok = true
		s.Comparable = !s.Decl.Bind
		for (_, mut f) in s.Fields {
			// Set instance for referencer if field declaration is not mutable.
			// But field declared as mutable, do not set.
			// It basically for the `!f.Decl.Mutable && f.Type.Mutable()` condition.
			if !f.Decl.Mutable {
				tc.referencer.tains = true
			} else {
				tc.referencer.tains = false
			}
			mut kind := tc.checkDecl(f.Decl.TypeSym.Decl)
			ok = kind != nil && ok
			if kind == nil {
				if self != s.env.sema && len(s.env.sema.errors) > 0 {
					self.errors = append(self.errors, s.env.sema.errors...)
					s.env.sema.errors = nil
				}
				continue
			}
			f.Type = kind

			// We have to check mutable and comparable conditions again.
			// Because type analysis is a simple precondition checker.
			// For the actual type, we have to check.
			// See developer reference (10.2.1).
			s.Mutable = s.Mutable || (!f.Decl.Mutable && f.Type.Mutable())
			s.Comparable = s.Comparable && f.Type.Comparable()
		}
		ret
	}

	fn precheckStructIns(mut &self, mut s: &StructIns, mut prev: &referencer, mut errorToken: &token::Token): (ok: bool) {
		// Return is source type is still pseudoSource of a strict type alias instance.
		// Following analysis must be done with real source type.
		if s.Source == pseudoSource {
			s.checked = false
			ret true
		}
		ok = self.checkStructEnv(s, prev, errorToken)
		if ok {
			// See implicit imports reference (1).
			// If structure instance is comparable and have not custom compare method,
			// compiler will use default compare method. If There is array field,
			// push instance for runtime function.
			if s.Comparable && self.meta.runtime != nil {
				// We will not have to check whether field's array type is comparable.
				// Structure is comparable, so all array types should be comparable.
				mut decl := runtimeFindFunc(self.meta.runtime, "arrayCmp")
				pushArr := fn(mut t: Kind, mut token: &token::Token) {
					mut arr, (ok) := t.(&Array)
					if !ok || arr == nil {
						ret
					}
					mut f := decl.instanceForce()
					f.Generics = append(f.Generics, &InsGeneric{Type: arr.Value})
					ok, _ = self.checkGenericFunc(&f, token)
					if !ok {
						panic("sema: arrayCmp evaluation failed, this is an implementation mistake")
					}
					s.Refers.Push(f)
				}
				if s.Source == nil {
					for (_, mut field) in s.Fields {
						pushArr(field.Type.ActualKind(), field.Decl.Token)
					}
				} else {
					pushArr(s.Source.ActualKind(), s.Decl.Token)
				}
			}
		}

		// Check instances even environment-based checking failed,
		// because prechecked structures are assumes they are
		// have checked instances for non-generic methods.
		for (_, mut f) in s.Methods {
			if len(f.Generics) == 0 {
				if self.readyToCheckFunc(s, f) == nil {
					// Avoid checking body of the function instance and etc.
					f.Instances[0].checked = true
					ok = false
				}
			}
		}
		ret
	}

	fn checkStructIns(mut &self, mut s: &StructIns) {
		for (_, mut f) in s.Methods {
			self.checkTypeMethod(f)
		}
	}

	fn checkTypeStruct(mut &self, mut s: &Struct) {
		if s.Bind {
			ret
		}
		s.checked = true

		if len(s.Generics) == 0 && len(s.Instances) == 0 {
			mut ins := s.instance()
			s.appendInstance(ins) // Append instance before precheck.
		}

		// Precheck is instance is not checked already.
		if len(s.Generics) == 0 {
			mut ins := s.Instances[0]
			if !ins.checked {
				ins.checked = true
				ok := self.precheckStructIns(ins, nil, nil)
				if !ok {
					ret
				}
			}
		}

		for (_, mut ins) in s.Instances {
			self.checkStructIns(ins)
		}
	}

	fn checkStructTypes(mut &self) {
		for (_, mut s) in self.file.Structs {
			self.checkTypeStruct(s)
		}
	}

	fn precheckStructType(mut &self, mut s: &Struct) {
		if s.Bind {
			ret
		}

		if len(s.Generics) == 0 && len(s.Instances) == 0 {
			mut ins := s.instance()
			s.appendInstance(ins) // Append instance before precheck.
		}

		// Precheck is instance is not checked already.
		if len(s.Generics) == 0 {
			mut ins := s.Instances[0]
			if !ins.checked {
				ins.checked = true
				ok := self.precheckStructIns(ins, nil, nil)
				if !ok {
					ret
				}
			}
		}
	}

	fn precheckStructTypes(mut &self) {
		for (_, mut s) in self.file.Structs {
			self.precheckStructType(s)
		}
	}

	fn checkRets(mut *self, mut f: &FuncIns, mut sc: &scopeChecker) {
		if f.Decl.IsVoid() {
			ret
		}
		self.meta.mrc.reset()
		mut ok := self.meta.mrc.memoizeLabelsAndGotos(sc)
		if !ok {
			self.pushErr(f.Decl.Token, "missing return at end of function")
		}
		ok = self.meta.mrc.check(f.Scope)
		if !ok {
			self.pushErr(f.Decl.Token, "missing return at end of function")
		}
	}

	// Checks scope of the function f.
	// The function environment must be filled.
	fn checkFuncInsSc(mut *self, mut f: &FuncIns, mut sc: &scopeChecker) {
		if len(f.env.vars) > 0 {
			sc.table.Vars = f.env.vars[:len(f.env.vars):len(f.env.vars)]
		}
		if len(f.env.generics) > 0 {
			sc.table.TypeAliases = f.env.generics[:len(f.env.generics):len(f.env.generics)]
		}

		n := len(sc.s.errors)
		sc.check(f.Decl.Scope, f.Scope)
		f.Scope.Owner = uintptr(f)

		// Check return statements if scopeChecker not forced to stop and no error.
		if !sc.stopped() && len(sc.s.errors) == n {
			self.checkRets(f, sc)
		}
	}

	fn checkFuncInsCaller(mut &self, mut f: &FuncIns, mut caller: &token::Token) {
		if f.Decl.Bind || f.checked {
			ret
		}
		f.checked = true

		f.fillEnviron(true)

		if f.env.file != nil {
			mut old := f.Decl.sema.file
			defer { f.Decl.sema.setCurrentFile(old) }
			f.env.sema.setCurrentFile(f.env.file)
		}

		mut sc := newScopeChecker(f.env.sema, f)
		sc.calledFrom = caller
		self.checkFuncInsSc(f, sc)

		if f.env.sema != self {
			self.errors = append(self.errors, f.env.sema.errors...)
			f.env.sema.errors = nil
		}
	}

	fn checkFuncIns(mut &self, mut f: &FuncIns) {
		self.checkFuncInsCaller(f, nil)
	}

	fn checkFunc(mut &self, mut f: &Func) {
		if f.Bind {
			ret
		}
		for (_, mut ins) in f.Instances {
			self.checkFuncIns(ins)
		}
	}

	fn checkTestFunc(mut *self, mut f: &FuncIns) {
		if f.Decl.Public {
			self.pushErr(f.Decl.Token, "test functions cannot be public")
			ret
		}

		if f.Decl.Unsafe ||
			!f.Decl.IsVoid() ||
			len(f.Decl.Generics) != 0 ||
			len(f.Params) != 1 ||
			f.Decl.Params[0].Mutable ||
			f.Decl.Params[0].Reference {
			self.pushErr(f.Decl.Token, "wrong test function declaration")
			self.pushSuggestion("proper declaration; fn myTest(t: &testing::T)")
			ret
		}

		mut sptr := f.Params[0].Type.Sptr()
		if sptr == nil {
			self.pushErr(f.Decl.Token, "wrong test function declaration")
			self.pushSuggestion("proper declaration; fn myTest(t: &testing::T)")
			ret
		}

		s, ok := sptr.Value.Kind.(&StructIns)
		if ok && s.Source == nil && isStdPackage(s.Decl.Token.File.Path, "testing") {
			ret
		}
		self.pushErr(f.Decl.Token, "wrong test function declaration")
		self.pushSuggestion("proper declaration; fn myTest(t: &testing::T)")
	}

	fn precheckFunc(mut &self, mut f: &Func) {
		if len(f.Generics) == 0 && len(f.Instances) == 0 {
			mut ins := f.instanceForce()
			f.Instances = append(f.Instances, ins)
			ok := self.reloadFuncInsTypes(ins)
			ins.reloaded = true

			if ok && hasDirective(f.Directives, directive::Test) {
				self.checkTestFunc(ins)
			}
		}
	}

	// Prechecks types of current package file's functions.
	fn precheckFuncs(mut &self) {
		for (_, mut decl) in self.file.Traits {
			for (_, mut m) in decl.Methods {
				self.precheckFunc(m)
			}
		}
		for (_, mut decl) in self.file.Funcs {
			self.precheckFunc(decl)
		}
	}

	// Checks types of current package file's functions.
	fn checkFuncs(mut &self) {
		for (_, mut decl) in self.file.Funcs {
			self.checkFunc(decl)
		}
	}

	// Check initialization cycles for global variables.
	fn checkInitializationCycles(mut &self) {
		mut message := new(strings::Builder)
		pushIllegalCycleError := fn(v1: str, v2: str) {
			const Padding = 7
			refersTo := log::Logf("@ refers to @", v1, v2)
			message.WriteStr(strings::Repeat(" ", Padding))!
			message.WriteStr(refersTo)!
			message.WriteByte('\n')!
		}
		mut cached := make([]&ReferenceStack, 0, 10)
		for (_, mut file) in self.files {
			for (_, mut v) in file.Vars {
				cached = cached[:0]
				let mut refCheck: fn(mut &cached: *[]&ReferenceStack, mut r: &ReferenceStack, owner: str): (cycle: bool)
				&_refCheck := &refCheck // For closure.
				refCheck = fn|mut cached, mut r, owner| {
					// We already checked/checking this reference stack.
					if slices::Contains(*cached, r) {
						ret false
					}
					*cached = append(*cached, r)
					n := message.Len()
					mut i := 0
					for i < r.Len(); i++ {
						mut ref := r.At(i)
						match type ref {
						| &StructIns:
							mut s := ref.(&StructIns)
							if r == s.Refers {
								break
							}
							pushIllegalCycleError(owner, s.Decl.Name) // Push trace.
							if unsafe { (*_refCheck)(cached, s.Refers, s.Decl.Name) } {
								ret true
							}
						| &FuncIns:
							mut f := ref.(&FuncIns)
							if r == f.Refers {
								break
							}
							pushIllegalCycleError(owner, f.Decl.Name) // Push trace.
							if unsafe { (*_refCheck)(cached, f.Refers, f.Decl.Name) } {
								ret true
							}
						| &Var:
							mut v2 := ref.(&Var)
							pushIllegalCycleError(owner, v2.Name) // Push trace.
							if v2 == v {
								ret true
							}
							if unsafe { (*_refCheck)(cached, v2.Refers, v2.Name) } {
								ret true
							}
							// Global variable v needs to global variable v2 for initialization.
							// So add v2 to v.Depends for correct collection of dependencies.
							if v2.Scope == nil && !v.depended(v2) {
								v.Depends = append(v.Depends, v2)
							}
						}
						unsafe { message.SetBuf(message.Buf()[:n]) } // Pop last trace.
					}
					ret false
				}
				if refCheck(&cached, v.Refers, v.Name) {
					self.pushErr(v.Token, "illegal cross cycle in declaration:\n"+message.Str())
					ret
				}
			}
		}
	}

	// Checks all types of all package files.
	// Breaks checking if checked file failed.
	fn checkPackageTypes(mut &self) {
		// Functions should be checked first.
		// Because they might be used by a global variable.
		// It may cause issues because functions will not be prechecked by eval.
		// So check functions first to make sure they are prechecked.
		// Generics; eval checks generics and not-instantiated generics are
		// not allowed for global variables, so no need special routine for generics.
		for (_, mut f) in self.files {
			self.setCurrentFile(f)
			self.precheckFuncs()
		}
		if len(self.errors) > 0 {
			ret
		}
		// We can check global variables here. Structures may refer to a global
		// variable, or a global variable may refer to a struct. But it is safe.
		// Eval uses type-checker for structure types and type-checker prechecks
		// structure if needed. For global variables, they will be evaluated if
		// needed when referred from a struct. So cycles are safe from now.
		for (_, mut f) in self.files {
			self.setCurrentFile(f)
			self.checkGlobals()
		}
		if len(self.errors) > 0 {
			ret
		}
		// Precheck structures before analysis of the implementations such as
		// function bodies, structure method bodies and etc.
		for (_, mut f) in self.files {
			self.setCurrentFile(f)
			self.precheckStructTypes()
		}
		if len(self.errors) > 0 {
			ret
		}
		// Check structures of strict type aliases.
		for (_, mut f) in self.files {
			self.setCurrentFile(f)
			for (_, mut ta) in self.file.TypeAliases {
				if ta.Strict {
					mut s := ta.TypeSym.Type.Kind.(&StructIns).Decl
					for (_, mut ins) in s.Instances {
						if !ins.checked {
							ins.checked = true
							ok := self.precheckStructIns(ins, nil, nil)
							if !ok {
								ret
							}
						}
					}
					// We can check strict structures here. It should be safe
					// as described above; structures will be prechecked if needed.
					// So other unchecked strict type aliases should not be a concern.
					self.checkTypeStruct(s)
				}
			}
		}

		for (_, mut f) in self.files {
			self.setCurrentFile(f)
			self.checkFuncs()
			self.checkStructTypes()
		}

		// If there is no error, check initialization cycles.
		if len(self.errors) == 0 {
			self.checkInitializationCycles()
		}
	}

	fn setFileSemaFields(mut &self) {
		for (_, mut f) in self.file.Funcs {
			f.sema = self
		}
		for (_, mut st) in self.file.Structs {
			st.sema = self
		}
	}

	fn setSemaFields(mut &self) {
		for (_, mut file) in self.files {
			self.setCurrentFile(file)
			self.setFileSemaFields()
		}
	}

	fn check(mut &self) {
		self.checkImports()
		if len(self.errors) > 0 {
			ret
		}

		self.checkInherits()
		if len(self.errors) > 0 {
			ret
		}

		self.implImpls()
		if len(self.errors) > 0 {
			ret
		}
		self.step |= stepImplsImplemented

		// Check enums here.
		// See developer reference (5).
		self.checkEnums()
		if len(self.errors) > 0 {
			ret
		}

		self.checkPackageDecls()
		if len(self.errors) > 0 {
			ret
		}

		self.step |= stepDeclsChecked
		self.checkPackageTypes()
		self.step |= stepDone
	}
}

// Memoization state flags for missingRetChecker.
const (
	_LMEMO_FALSE = 1 << iota
	_LMEMO_TRUE
	_LMEMO_CHECKING
)

struct missingRetChecker {
	mut breaked: map[uintptr]bool // break statement seen for iteration or match-case statement
	mut labels:  map[uintptr]int  // memoization for labels, reports state of label's following statements
	mut fell:    bool             // fall statement seen
	mut hard:    bool             // hard register, this should be true for the final report
	mut lead:    &Label           // goto label which is closest one to the root scope
}

impl missingRetChecker {
	// Resets all data for the new analysis.
	fn reset(*self) {
		self.hard = true
		if self.breaked == nil {
			self.breaked = map[uintptr]bool{}
		} else {
			delete(self.breaked)
		}
		if self.labels == nil {
			self.labels = map[uintptr]int{}
		} else {
			delete(self.labels)
		}
	}

	fn memoizeLabel(*self, mut l: &Label): (ok: bool) {
		laddr := uintptr(l)
		// If label is already checked, return the memoized data.
		mut r, ok := self.labels[laddr]
		if ok {
			ret r&_LMEMO_TRUE == _LMEMO_TRUE
		}
		// Temporarily memoize the label to avoid infinite recursion.
		// Also this data used to catch in-check state:
		self.labels[laddr] = _LMEMO_CHECKING
		// Check rest of the statements following label.
		// With `l.Index+1` skip the current label statement.
		i := l.Index + 1
		if l.Scope.Traits&ST_INFINITE == ST_INFINITE {
			ok = self.checkInfinite(l.Scope.Owner, l.Scope, i)
		} else {
			ok = self.checkScope(l.Scope, i)
		}
		if ok {
			r = _LMEMO_TRUE
		} else {
			r = _LMEMO_FALSE
		}
		// Memoize the actual result.
		self.labels[laddr] = r
		// Time to return.
		ret ok
	}

	fn memoizeGoto(*self, mut g: &Goto): (ok: bool) {
		// Goto statement appeared. We have to check statements by label.
		// Following statements will not be executed, ignore them, if any.

		// Update lead label data. If it is nil, set to g's label.
		// Otherwise make sure g's label is more close to the root.
		if self.lead == nil || self.lead.Scope.ChildIndex > g.Label.Scope.ChildIndex {
			self.lead = g.Label
		}
		let mut r: int
		// If goto jumps down, assume the label is not memoized yet.
		// Because label is declared below in the code.
		if g.Direction == DOWN {
			ok = false
		} else {
			r, ok = self.labels[uintptr(g.Label)]
		}
		if !ok {
			// Label is not memoized yet, so this is the first time.
			// Check scope by label index. Start from label index,
			// because label statement will trigger the memoization.
			// Save report to the hard register.
			// Because label is not checked, even not in in-check state.
			// So we jumping to below, we have to memoize "false" reports.
			// Otherwise we may miss "false" reports.
			//
			// Example wrong "true" report on pseudo AST:
			//	
			//	 fn foo(): int  { 
			//	     if true {    
			//	         goto Bar  > this branch jumps below, reports no return
			//	     }            
			//	     ret 0         > analysis sees this and assumes function returns
			//	 Bar:                we have to remember branch's report at this point
			//	 }                
			//	
			if g.Label.Scope.Traits&ST_INFINITE == ST_INFINITE {
				ok = self.checkInfinite(g.Label.Scope.Owner, g.Label.Scope, g.Label.Index)
			} else {
				ok = self.checkScope(g.Label.Scope, g.Label.Index)
			}
			// If analysis repor is true, then assign the result directly.
			// Otherwise we have to check following statements.
			if ok {
				// No operation needed for the hard register.
				// If self.hard is true, we have already true.
				// Otherwise, we must store the false state.
				// Just report the current result of analysis.
				ret ok
			} else {
				// Analysis report is false, we have to check following statements.
				// Otherwise we cannot know label's following situation.
				//
				// Example on pseudo AST:
				//	
				//	 fn foo(): str {      
				//	     {                
				//	         goto Keep     < jumps to below
				//	         ret "return" 
				//	     Keep:             < this label reports false for its own scope here
				//	     }                   but it is actually wrong
				//	     ret "return"      < because the following statement returns
				//	 }                       so label should report true.
				//	
				mut ls := g.Label.Scope
				for ls != nil {
					// No parent scope and we did not see "true" report.
					// So this label should report "false".
					if ls.Parent == nil {
						self.hard = false
						ret false
					}
					mut ps := ls.Parent
					// Start checking parent scope from the following
					// statements of the current child scope.
					i := ls.StmtIndex + 1
					if ps.Traits&ST_INFINITE == ST_INFINITE {
						ok = self.checkInfinite(ps.Owner, ps, i)
					} else {
						ok = self.checkScope(ps, i)
					}
					// Scope analysis returns true for the parent.
					// So this label should report "true".
					if ok {
						// No operation needed for the hard register.
						// If self.hard is true, we have already true.
						// Otherwise, we must store the false state.
						// Just report the current result of analysis.
						ret true
					}
					// Continue to the next parent scope.
					ls = ps
				}
				panic("unreachable")
			}
		} else if r&_LMEMO_CHECKING != _LMEMO_CHECKING {
			// Label is already memoized, report the result.
			ret r&_LMEMO_TRUE == _LMEMO_TRUE
		}
		// Jumping into scope is not allowed.
		// So goto jumps in the same scope or one of to parent scopes.
		// Make label and goto scopes equal for analysis if they not.
		if g.Scope.ChildIndex > g.Label.Scope.ChildIndex {
			// Scopes are different, make them equal.
			// See documentation of the [scopeChecker.checkGoto].
			mut gtsc := g.Scope
			for gtsc.ChildIndex-1 > g.Label.Scope.ChildIndex {
				gtsc = gtsc.Parent
			}
			// Scopes are same now, make sure the goto jumps above.
			ret gtsc.StmtIndex > g.Label.Index
		} else {
			// They are in the same scope. Report true anyway.
			// If goto jumps above, this is an infinite loop.
			// Otherwise goto jumps below, but this label is in-check state.
			// So already checking, report true for now.
			// If checking fails, root checker will report it with hard register.
			ret true
		}
	}

	// Memoizes labels and goto statements.
	// Reports whether all goto statements reports true.
	fn memoizeLabelsAndGotos(*self, mut sc: &scopeChecker): bool {
		if sc.labels != nil {
			for (_, mut lbl) in *sc.labels {
				self.memoizeLabel(lbl.node)
			}
		}
		if sc.gotos != nil {
			for (_, mut g) in *sc.gotos {
				// If any goto statement reports false, return with false immediately.
				// Because analysis will not be executed completely in this case.
				// This is such a fast path: if any goto statement reports false,
				// so there is no exact return in all branches.
				if !self.memoizeGoto(g) {
					ret false
				}
			}
		}
		ret true
	}

	fn checkConditional(*self, mut c: &Conditional): (ok: bool) {
		// To collect all break statements, check the all scopes.
		ok = true
		for (_, mut elif) in c.Elifs {
			if elif == nil {
				ok = false
				continue
			}
			if !self.checkScope(elif.Scope, 0) {
				ok = false
			}
		}
		// If there is no default case, there is no all-time return possibility, then report false.
		// Otherwise evaluate the default scope.
		if c.Default == nil {
			ok = false
		} else if !self.checkScope(c.Default.Scope, 0) {
			ok = false
		}
		ret
	}

	fn checkMatch(*self, mut m: &Match): (ok: bool) {
		// To collect all break and fall statements, check the all scopes.
		ok = true
		addr := uintptr(m)
		for (_, mut c) in m.Cases {
			if c == nil {
				ok = false
				continue
			}
			if self.checkScope(c.Scope, 0) {
				if self.fell {
					// Scope reports true, but this is the `fall` statement.
					// Catch break statements for the match.
					if self.breaked[addr] {
						ok = false
					}
				}
			} else {
				ok = false
			}

			self.fell = false
		}
		// If there is no default case, there is no all-time return possibility, then report false.
		// Otherwise evaluate the default scope.
		// No extra attention needed for the default case like other cases.
		if m.Default == nil {
			ok = false
		} else if !self.checkScope(m.Default.Scope, 0) {
			ok = false
		}
		ret
	}

	fn checkSelect(*self, mut slct: &Select): (ok: bool) {
		// To collect all break statements, check the all scopes.
		ok = true
		addr := uintptr(slct)
		for (_, mut c) in slct.Cases {
			if c == nil || !self.checkScope(c.Scope, 0) {
				ok = false
			} else {
				// Scope reports true. To make sure
				// catch break statements for the select.
				if self.breaked[addr] {
					ok = false
				}
			}
		}
		// If there is no default case, there is no all-time return possibility, then report false.
		// Otherwise evaluate the default scope.
		// No extra attention needed for the default case like other cases.
		if slct.Default == nil {
			ok = false
		} else if !self.checkScope(slct.Default.Scope, 0) {
			ok = false
		}
		ret
	}

	// Reports we have infinite iteration, starts from i.
	fn checkInfinite(*self, it: uintptr, mut s: &Scope, i: int): bool {
		mut lead := self.lead
		hard := self.hard

		// Clear lead label data for now.
		self.lead = nil

		// Check scope, but report is not a valid information.
		// Because checkScope reports false for no-return.
		// But we look for iteration breaker, not for return.
		// Just check the scope and collect break statements.
		self.checkScope(s, i)

		// We have lead label data, check it.
		if self.lead != nil {
			// If scopes are same, lead label is in iteration.
			// Otherwise scopes are different, make them equal.
			if s.ChildIndex > self.lead.Scope.ChildIndex {
				// See documentation of the [scopeChecker.checkGoto].
				mut itsc := s
				for itsc.ChildIndex-1 > self.lead.Scope.ChildIndex {
					itsc = itsc.Parent
				}
				// Scopes are same now, make sure the goto jumps down before report false.
				//
				// Scheme on pseudo AST
				//	
				//	 fn example() {       
				//	 Foo:                 
				//	     for {            
				//	         if true {    
				//	             goto Foo  > jumping to Foo is ok, repeats infinite iteration
				//	         }            
				//	         goto Bar      > jumping to Bar is crucial, it breaks iteration
				//	     }                
				//	 Bar:                 
				//	 }                    
				//	
				if itsc.StmtIndex < self.lead.Index {
					ret false
				}
			}
			// There is no old lead or the new lead more close to the root scope,
			// do not fallback to the old lead, because we have report it to parent
			// infinite loop analysis, if any. This lead might be breaker for it.
			//
			// Scheme on pseudo AST
			//	
			//	 fn example() {       
			//	     for {            
			//	         for {        
			//               goto Foo  < jumps to below, out of even the root infinite iteration
			//	         }               if we clear the current lead, analysis of the root iteration
			//	     }                   will not be aware of it is breaked
			//	 Foo:                 
			//	 }                    
			//	
			if lead == nil || lead.Scope.ChildIndex > self.lead.Scope.ChildIndex {
				lead = self.lead
			}
		}

		self.lead = lead
		self.hard = hard

		// Time to catch break statements for the iteration.
		if self.breaked[it] {
			ret false
		}

		// If infinite iteration never breaked, it makes the return value unavailable.
		// So do not complain about missing return statement.
		ret true
	}

	// Checks the scope, starts from i.
	// Reports whether return statement or infinite loop found.
	fn checkScope(*self, mut s: &Scope, i: int): bool {
		if s == nil {
			ret false
		}
		for (_, mut st) in s.Stmts[i:] {
			match type st {
			| &Label:
				ret self.memoizeLabel(st.(&Label))
			| &Goto:
				ret self.memoizeGoto(st.(&Goto))
			| &Ret:
				// Return statement appeared, report true for this scope.
				// But check the return expression before reporting true.
				mut r := st.(&Ret)
				mut f, isFunc := r.Expr.(&FuncCallExpr)
				// Function call appeared.
				// We have to check exceptional handler scope, if exist.
				// To collect break statements, it is needed.
				// Also if it is reports false, do not report true, continue.
				if isFunc && f.Except != nil && !self.checkScope(f.Except, 0) {
					break
				}
				ret true
			| &Use:
				// Use expression appeared, we are in exceptional handler scope.
				// This is fine, check this like return expression.
				mut u := st.(&Use)
				mut f, isFunc := u.Value.Model.(&FuncCallExpr)
				// Function call appeared.
				// We have to check exceptional handler scope, if exist.
				// To collect break statements, it is needed.
				// Also if it is reports false, do not report true, continue.
				if isFunc && f.Except != nil && !self.checkScope(f.Except, 0) {
					break
				}
				ret true
			| &Break:
				// Store if this break statement breaks an iteration or match-case.
				// Following statements will not be executed, ignore them, if any.
				brk := st.(&Break)
				match {
				| brk.It != 0:
					self.breaked[brk.It] = true
				| brk.Match != 0:
					self.breaked[brk.Match] = true
				| brk.Select != 0:
					self.breaked[brk.Select] = true
				}
				// Following statements will not be executed, ignore them, if any.
				ret false
			| &Continue:
				// Following statements will not be executed, ignore them, if any.
				ret false
			| &Fall:
				// Falling to the next case of match statement.
				// It may breaks iteration, if exist, or return.
				// If this statement appeared, there is always a next case.
				// Report true for this case, if following case is not reports false,
				// then this case's report does not matter.
				self.fell = true
				ret true
			| &InfIter:
				// If this iteration will not be breaked, then report true.
				// Because following statements will not be executed,
				// so function will not be ended.
				mut ii := st.(&InfIter)
				if self.checkInfinite(ii.Scope.Owner, ii.Scope, 0) {
					ret true
				}
			| &WhileIter:
				mut wn := st.(&WhileIter)
				// Condition is nil, possible infinite iteration.
				// If this iteration will not be breaked, then report true.
				// Because following statements will not be executed,
				// so function will not be ended.
				if wn.Scope.Traits&ST_INFINITE == ST_INFINITE {
					if self.checkInfinite(wn.Scope.Owner, wn.Scope, 0) {
						ret true
					}
				}
			| &Scope:
				// If scope reports true, then report true.
				if self.checkScope(st.(&Scope), 0) {
					ret true
				}
			| &Value:
				mut v := st.(&Value)
				match type v.Model {
				| &BuiltinPanicCallExpr
				| &BuiltinErrorCallExpr:
					// Following statements will not be executed, ignore them, if any.
					// And panic or error call makes the return value unavailable.
					ret true
				| &FuncCallExpr:
					// Function call appeared.
					// We have to check exceptional handler scope, if exist.
					// To collect break statements, it is needed.
					mut f := v.Model.(&FuncCallExpr)
					if f.Except != nil {
						self.checkScope(f.Except, 0)
					}
				|:
					// no-op
					continue
				}
			| &Conditional:
				// If all cases returns, then report true.
				if self.checkConditional(st.(&Conditional)) {
					ret true
				}
			| &Match:
				// If all cases returns, then report true.
				if self.checkMatch(st.(&Match)) {
					ret true
				}
			| &Select:
				// Select statement appeared.
				// It might be empty (so select{}), report true if so.
				// Because empty select statement yields CPU or panics.
				// Following statements will not be executed, ignore them, if any.
				mut slct := st.(&Select)
				if len(slct.Cases) == 0 && slct.Default == nil {
					ret true
				}
				// Select statement is not empty, check all cases like match.
				// If all cases returns, then report true.
				if self.checkSelect(slct) {
					ret true
				}
			|:
				// no-op
				continue
			}
		}
		// No return statement seen.
		ret false
	}

	// Like checkScope, but it pays attention to the hard register.
	// checkScope is intended for internal use.
	fn check(*self, mut s: &Scope): bool {
		ret self.checkScope(s, 0) && self.hard
	}
}

fn pushImplemented(mut t: &Trait, mut d: &Struct) {
push:
	match {
	| len(t.Implemented) > 0:
		for _, s in t.Implemented {
			if s == d {
				break push
			}
		}
		fall
	|:
		t.Implemented = append(t.Implemented, d)
	}
	for (_, mut i) in t.Inherits {
		pushImplemented(i.Type.Trait(), d)
	}
}

fn pushImplements(mut s: &Struct, mut t: &Trait) {
push:
	match {
	| len(s.Implements) > 0:
		for _, b in s.Implements {
			if b == t {
				break push
			}
		}
		fall
	|:
		s.Implements = append(s.Implements, t)
	}
	for (_, mut i) in t.Inherits {
		pushImplements(s, i.Type.Trait())
	}
}

fn pushRuntimeToStr(mut s: &sema, mut t: &Type, mut token: &token::Token,
	mut refers: &ReferenceStack) {
	if s.meta.runtime == nil || t.IsNil() || refers == nil {
		ret
	}
	mut f := runtimeFindFunc(s.meta.runtime, "toStr").instanceForce()
	f.Generics = append(f.Generics, &InsGeneric{Type: t})
	ok, _ := s.checkGenericFunc(&f, token)
	if !ok {
		panic("sema: toStr evaluation failed, this is an implementation mistake")
	}
	refers.Push(f)
}

fn pushRuntimeMaphash(mut s: &sema, mut t: &Type, mut token: &token::Token,
	mut refers: &ReferenceStack) {
	if s.meta.runtime == nil || t.IsNil() || refers == nil {
		ret
	}
	mut f := runtimeFindFunc(s.meta.runtime, "maphash").instanceForce()
	f.Generics = append(f.Generics, &InsGeneric{Type: t})
	ok, _ := s.checkGenericFunc(&f, token)
	if !ok {
		panic("sema: maphash evaluation failed, this is an implementation mistake")
	}
	refers.Push(f)
}

// Reports whether the alias valid for the import alias.
// Designed to check auto aliases.
fn isValidImpAlias(mut alias: str): (valid: bool) {
	if jule::IsBlank(alias) {
		ret false
	}
	if token::IsKeyword(alias) {
		ret false
	}
	mut r, mut size := utf8::DecodeRuneStr(alias)
	if !isLetter(r) {
		ret false
	}
	for {
		alias = alias[size:]
		if len(alias) == 0 {
			break
		}
		r, size = utf8::DecodeRuneStr(alias)
		if !isLetter(r) && !isDigit(r) {
			ret false
		}
	}
	ret true
}

fn checkTypeEnumRefCycle(mut s: &sema, mut e: &TypeEnum, mut item: &TypeEnumItem) {
	// If item type is a strict type alias (or structure type, does not matter in this case)
	// return immediately, no risk for cross references.
	// Strict type aliases will not be inherited.
	if item.TypeSym.Type.SoftStruct() != nil {
		ret
	}
	mut e2 := item.TypeSym.Type.TypeEnum()
	// If item type is not type-enum, no risk for cross references.
	if e2 == nil {
		ret
	}
	if e == e2 {
		s.pushErr(item.Token, "illegal cycle in declaration: @ refers to itself", e.Name)
		ret
	}
	mut message := new(strings::Builder)
	pushIllegalCycleError := fn(v1: str, v2: str) {
		const Padding = 7
		refersTo := log::Logf("@ refers to @", v1, v2)
		message.WriteStr(strings::Repeat(" ", Padding))!
		message.WriteStr(refersTo)!
		message.WriteByte('\n')!
	}
	mut checkCycles := (fn(mut e2: &TypeEnum): bool)(nil)
	&_checkCycles := &checkCycles // For closure.
	checkCycles = fn|mut e2| {
		n := message.Len()
		for (_, mut item2) in e2.Items {
			if item2.TypeSym.Type == nil {
				continue
			}
			mut ie := item2.TypeSym.Type.TypeEnum()
			if ie == nil {
				continue
			}
			pushIllegalCycleError(e2.Name, ie.Name)
			if ie == e || unsafe { !(*_checkCycles)(ie) } {
				ret false
			}
		}
		unsafe { message.SetBuf(message.Buf()[:n]) } // Pop last trace.
		ret true
	}
	pushIllegalCycleError(e.Name, e2.Name)
	ok := checkCycles(e2)
	if !ok {
		s.pushErr(e.Token, "illegal cross cycle in declaration:\n"+message.Str())
	}
}
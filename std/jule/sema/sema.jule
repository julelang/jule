// Copyright 2023-2025 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/jule"
use "std/jule/ast"
use "std/jule/build"
use "std/jule/constant"
use "std/jule/internal/mod"
use "std/jule/token"
use "std/jule/types"
use "std/slices"
use "std/strings"
use "std/unicode/utf8"

fn isValidModelForRef(mut &m: Expr): bool {
	match type m {
	| &Var:
		ret true
	| &StructSubIdentExpr:
		mut model := (&StructSubIdentExpr)(m)
		ret model.Field != nil && isValidModelForRef(model.Expr.Model)
	| &UnaryExpr:
		mut unary := (&UnaryExpr)(m)
		if unary.Op.Id != token::Id.Star {
			ret false
		}
		// Return true because of raw pointer dereferencing is an Unsafe Jule feature.
		if unary.Expr.Type.Ptr() != nil {
			ret true
		}
		// Dereferencing should be smart pointer, otherwise return false.
		if unary.Expr.Type.Sptr() == nil {
			ret false
		}
		ret isValidModelForRef(unary.Expr.Model)
	| &IndexingExpr:
		mut indexing := (&IndexingExpr)(m)
		if indexing.Expr.Type.Array() == nil {
			// allow only arrays, slice allocations will may be deallocated at runtime
			// arrays always guaranteed to be have fixed size at runtime
			ret false
		}
		ret isValidModelForRef(indexing.Expr.Model)
	|:
		ret false
	}
}

fn compilerErr(&token: &token::Token, line: bool, fmt: build::LogMsg, args: ...any): build::Log {
	mut log := build::Log{
		Kind: build::LogKind.Error,
		Row: token.Row,
		Column: token.Column,
		Path: token.File.Path,
		Text: build::Logf(fmt, args...),
	}
	if line {
		log.Line = token.File.GetRow(token.Row)
	}
	ret log
}

fn appendRetVars(mut &dest: []&Var, mut &f: &FuncIns) {
	if f.Decl.IsVoid() || f.Result == nil {
		ret
	}

	mut types := f.Types()
	for (i, mut ident) in f.Decl.Result.Idents {
		if token::IsIgnoreIdent(ident.Kind) || token::IsAnonIdent(ident.Kind) {
			continue
		}
		dest = append(dest, &Var{
			Used: true,
			Mutable: true,
			Ident: ident.Kind,
			Token: ident,
			Scope: f.Scope,
			TypeSym: &TypeSym{
				Type: types[i],
			},
			ValueSym: &ValueSym{
				Value: new(Value),
			},
			RetOrder: i,
		})
	}
	if len(f.Decl.Result.Idents) == 1 && len(dest) == 1 {
		dest[len(dest)-1].RetOrder = -1
	}
}

fn appendParamVars(mut &dest: []&Var, mut &f: &FuncIns) {
	if len(f.Params) == 0 {
		ret
	}

	for (_, mut p) in f.Params {
		if token::IsIgnoreIdent(p.Decl.Ident) || token::IsAnonIdent(p.Decl.Ident) {
			continue
		}

		mut v := &Var{
			Checked: true,
			Used: true,
			Reference: p.Decl.Reference,
			Mutable: p.Decl.Mutable,
			Ident: p.Decl.Ident,
			Token: p.Decl.Token,
			TypeSym: new(TypeSym),
			Scope: f.Scope,
			ValueSym: new(ValueSym),
		}

		match {
		| p.Decl.IsSelf():
			v.TypeSym.Type = &Type{
				Variadic: false,
				Kind: f.Owner,
			}
			v.Reference = !p.Decl.IsRef()

			if p.Decl.IsRef() {
				v.Ident = v.Ident[1:] // Remove reference sign.
				v.TypeSym.Type.Kind = &Sptr{
					Elem: &Type{
						Kind: v.TypeSym.Type.Kind,
					},
				}
			}
		| p.Decl.Variadic:
			v.TypeSym.Type = &Type{
				Variadic: false,
				Kind: &Slice{
					Elem: &Type{
						Kind: p.Type.Kind,
					},
				},
			}
		|:
			v.TypeSym.Type = p.Type
		}

		dest = append(dest, v)
	}
}

// Builds type aliases for generic types of scope.
// See developer reference (1), and (2).
fn appendGenericTypeAliases(mut &dest: []&TypeAlias, mut &f: &FuncIns) {
	mut size := len(f.Generics)
	if f.Decl.Owner != nil {
		size += len(f.Decl.Owner.Generics)
	}

	if size == 0 {
		ret
	}

	for (i, mut g) in f.Generics {
		if g == nil {
			continue
		}
		mut decl := f.Decl.Generics[i]
		dest = append(dest, &TypeAlias{
			Used: true,
			Generic: true,
			Scope: f.Decl.Scope,
			Ident: decl.Ident,
			Token: decl.Token,
			TypeSym: &TypeSym{Type: g.Type},
		})
	}

	if f.Decl.Owner != nil {
		mut owner := f.Owner
		for (i, mut g) in owner.Generics {
			mut decl := owner.Decl.Generics[i]
			dest = append(dest, &TypeAlias{
				Used: true,
				Generic: true,
				Scope: f.Decl.Scope,
				Ident: decl.Ident,
				Token: decl.Token,
				TypeSym: &TypeSym{Type: g.Type},
			})
		}
	}
}

fn findFile(mut &files: []&SymTab, &handler: &token::Fileset): &SymTab {
	for (_, mut fl) in files {
		if fl.File == handler {
			ret fl
		}
	}
	ret nil
}

unsafe fn pushSuggestion(mut log: *build::Log, fmt: build::LogMsg, args: ...any) {
	log.Suggestion = build::Logf(fmt, args...)
}

struct commonSemaMeta {
	comptimeTypeInfos: []&comptimeTypeInfo
	runtime:           &ImportInfo // Implicitly imported "std/runtime" package.
}

impl commonSemaMeta {
	fn pushComptimeTypeInfo(mut self, mut &t: &Type): &comptimeTypeInfo {
		for (_, mut t2) in self.comptimeTypeInfos {
			if t2.base.Equal(t) {
				ret t2
			}
		}
		mut t1 := &comptimeTypeInfo{base: t}
		self.comptimeTypeInfos = append(self.comptimeTypeInfos, t1)
		ret t1
	}
}

enum stepFlag {
	NA: 0,
	ImplsImplemented: 1 << 0,
	DeclsChecked: 1 << 1,
	Done: 1 << 2,
}

// Semantic analyzer for tables.
// Accepts tables as files of package.
struct sema {
	errors: []build::Log
	files:  []&SymTab // Package files.
	file:   &SymTab   // Current package file.
	flags:  Flag
	meta:   &commonSemaMeta
	step:   stepFlag
}

impl Lookup for sema {
	// Returns imported package by selector.
	// Returns nil if selector returns false for all packages.
	// Returns nil if selector is nil.
	//
	// Lookups:
	//	- Current file's imported packages.
	fn SelectPackage(mut self, selector: fn(&ImportInfo): bool): &ImportInfo {
		ret self.file.SelectPackage(selector)
	}

	// Returns variable by identifier and binded state.
	// Returns nil if not exist any variable in this identifier.
	//
	// Lookups:
	//	- Package file's symbol table.
	//	- Current file's public denifes of imported packages.
	fn FindVar(mut self, ident: str, binded: bool): &Var {
		// Lookup package files.
		mut v := findVarInPackage(self.files, ident, binded)
		if v != nil {
			ret v
		}
		ret nil
	}

	// Returns type alias by identifier and binded state.
	// Returns nil if not exist any type alias in this identifier.
	//
	// Lookups:
	//	- Package file's symbol table.
	//	- Current file's public denifes of imported packages.
	fn FindTypeAlias(mut self, ident: str, binded: bool): &TypeAlias {
		// Lookup package files.
		mut ta := findTypeAliasInPackage(self.files, ident, binded)
		if ta != nil {
			ret ta
		}
		ret nil
	}

	// Returns struct by identifier and binded state.
	// Returns nil if not exist any struct in this identifier.
	//
	// Lookups:
	//	- Package file's symbol table.
	//	- Current file's public denifes of imported packages.
	fn FindStruct(mut self, ident: str, binded: bool): &Struct {
		// Lookup package files.
		mut s := findStructInPackage(self.files, ident, binded)
		if s != nil {
			ret s
		}
		ret nil
	}

	// Returns function by identifier and binded state.
	// Returns nil if not exist any function in this identifier.
	//
	// Lookups:
	//	- Package file's symbol table.
	//	- Current file's public denifes of imported packages.
	fn FindFunc(mut self, ident: str, binded: bool): &Func {
		// Lookup package files.
		mut f := findFuncInPackage(self.files, ident, binded)
		if f != nil {
			ret f
		}
		ret nil
	}

	// Returns trait by identifier.
	// Returns nil if not exist any trait in this identifier.
	//
	// Lookups:
	//	- Package file's symbol table.
	//	- Current file's public denifes of imported packages.
	fn FindTrait(mut self, ident: str): &Trait {
		// Lookup package files.
		mut t := findTraitInPackage(self.files, ident)
		if t != nil {
			ret t
		}
		ret nil
	}

	// Returns enum by identifier.
	// Returns nil if not exist any enum in this identifier.
	//
	// Lookups:
	//	- Package file's symbol table.
	//	- Current file's public denifes of imported packages.
	fn FindEnum(mut self, ident: str): &Enum {
		// Lookup package files.
		mut e := findEnumInPackage(self.files, ident)
		if e != nil {
			ret e
		}
		ret nil
	}

	// Returns type enum by identifier.
	// Returns nil if not exist any type enum in this identifier.
	//
	// Lookups:
	//	- Package file's symbol table.
	//	- Current file's public denifes of imported packages.
	fn FindTypeEnum(mut self, ident: str): &TypeEnum {
		// Lookup package files.
		mut e := findTypeEnumInPackage(self.files, ident)
		if e != nil {
			ret e
		}
		ret nil
	}
}

impl sema {
	// Reports whether flags has given flag.
	fn isFlag(self, flags: Flag): bool { ret self.flags&flags == flags }

	fn getCurrentFile(mut self): &SymTab { ret self.file }
	fn setCurrentFile(mut self, mut f: &SymTab) { self.file = f }

	fn pushErr(mut self, token: &token::Token, fmt: build::LogMsg, args: ...any) {
		self.errors = append(self.errors, compilerErr(token, true, fmt, args...))
	}

	// Push suggestion to last log.
	fn pushSuggestion(mut self, fmt: build::LogMsg, args: ...any) {
		unsafe { pushSuggestion(&self.errors[len(self.errors)-1], fmt, args...) }
	}

	// Reports whether define is accessible in the current package.
	// The public and token parameters belongs to define which is accessed.
	fn isAccessibleDefine(self, public: bool, token: &token::Token): bool {
		if public || token.File == nil {
			// public or built-in
			ret true
		}
		selfDir := self.file.File.Dir()
		tokenDir := token.File.Dir()
		if selfDir == tokenDir {
			// define is in the same package
			ret true
		}
		// define is not public or in-package define
		// but it may come from the runtime package
		// so allow access if standard library package tries
		if isStdPackage(tokenDir, "runtime") && isStdPackage(selfDir, "") {
			ret true
		}
		ret false
	}

	// Reports this identifier duplicated in package's global scope.
	// The "self" parameter represents address of exception identifier.
	// If founded identifier address equals to self, will be skipped.
	fn isDuplicatedIdent(self, itself: uintptr, &ident: str, binded: bool): bool {
		for _, f in self.files {
			if f.isDuplicatedIdent(itself, ident, binded) {
				ret true
			}
		}
		ret false
	}

	fn checkDirectives(mut &self, mut &d: []&ast::Directive, mut o: any) {
		mut dc := directiveChecker{
			s: self,
			d: unsafe { (&[]&ast::Directive)(&d) },
			o: o,
		}
		dc.check()
	}

	fn checkGenericQuantity(mut self, required: int, given: int, token: &token::Token): (ok: bool) {
		match {
		| required == 0 && given > 0:
			self.pushErr(token, build::LogMsg.NotHasGenerics)
			ret false
		| required > 0 && given == 0:
			self.pushErr(token, build::LogMsg.HasGenerics)
			ret false
		| required < given:
			self.pushErr(token, build::LogMsg.GenericsOverflow)
			ret false
		| required > given:
			self.pushErr(token, build::LogMsg.MissingGenerics)
			ret false
		|:
			ret true
		}
	}

	fn getImportDef(self, &ident: str, mut &imp: &ImportInfo): any {
		if findPackageBuiltinDef(imp.LinkPath, ident) != nil {
			ret true
		}
		for (_, mut f) in imp.Package.Files {
			// Binded defines can't export.
			const Binded = false
			mut def := f.defByIdent(ident, Binded)
			if def != nil {
				ret def
			}
		}
		ret nil
	}

	fn checkImportSelection[T](mut self, &ident: &token::Token, &s: T): bool {
		if !self.isAccessibleDefine(s.Public, s.Token) {
			self.pushErr(ident, build::LogMsg.IdentIsNotAccessible, ident.Kind)
			self.pushSuggestion(build::LogMsg.MakePubToAccess)
			ret false
		}
		const Binded = false // Exported defines cannot be binded.
		if defByIdentPackage(self.files, s.Ident, Binded) != nil {
			self.pushErr(ident, build::LogMsg.SelectedImportExistInPackage, s.Ident)
			ret false
		}
		ret true
	}

	fn checkImportsAllSelectionsFromCollection[T](mut self, &s: []T, &et: &token::Token): bool {
		mut ok := true
		for _, d in s {
			if d.Public {
				ok = self.checkImportSelection(et, d) && ok
			}
		}
		ret ok
	}

	fn isUseAliasDuplication(mut self, &imp: &ImportInfo): bool {
		for (_, mut imp2) in self.file.Imports {
			if imp2 == imp {
				break
			}
			if imp2.Alias == imp.Alias {
				ret true
			}
		}
		ret false
	}

	fn checkAutoAlias(mut self, mut &imp: &ImportInfo): bool {
		if imp.LinkPath == "std/unsafe" {
			// the "std/unsafe" package is able to use unsafe keyword as alias
			ret true
		}
		valid := isValidImpAlias(imp.Alias)
		if valid {
			if self.isUseAliasDuplication(imp) {
				self.pushErr(imp.Decl.Path, build::LogMsg.DuplicatedUseAlias, imp.Alias)
				self.pushSuggestion(build::LogMsg.GiveAnAliasManually, imp.Decl.Path.Kind)
			}
		} else {
			self.pushErr(imp.Decl.Path, build::LogMsg.AutoAliasFail, imp.Decl.Path.Kind)
			self.pushSuggestion(build::LogMsg.GiveAnAliasManually, imp.Decl.Path.Kind)
		}
		ret valid
	}

	fn checkImport(mut self, mut &imp: &ImportInfo): bool {
		if imp.Binded {
			ret true
		}

		if imp.Decl.Alias != nil { // custom alias found
			if token::IsIgnoreIdent(imp.Alias) {
				self.pushErr(imp.Decl.Token, build::LogMsg.IgnoreIdent)
			} else if self.isUseAliasDuplication(imp) {
				self.pushErr(imp.Decl.Token, build::LogMsg.DuplicatedUseAlias, imp.Alias)
				self.pushSuggestion(build::LogMsg.RenameUseAliasAvoidDuplication)
			}

			// Check special cases for the "std/unsafe" package.
			if imp.LinkPath == "std/unsafe" {
				self.pushErr(imp.Decl.Alias, build::LogMsg.ExpectedPlainUseDecl, `use "std/unsafe"`)
				ret false
			}
		} else if !isImplicitImport(imp) && !self.checkAutoAlias(imp) {
			ret false
		}

		if len(imp.Package.Files) == 0 {
			ret true
		}

		if !imp.Duplicate {
			mut sema := &sema{
				flags: self.flags,
				meta: self.meta,
			}
			sema.check(imp.Package.Files)
			if len(sema.errors) != 0 {
				self.errors = append(self.errors, sema.errors...)
				sema.errors = nil
				ret false
			}
		}
		ret true
	}

	fn checkImports(mut self) {
		for (_, mut file) in self.files {
			self.setCurrentFile(file)
			for (_, mut imp) in file.Imports {
				ok := self.checkImport(imp)
				// Break checking if package has error.
				if !ok {
					ret
				}
			}
		}
	}

	fn implFileImpls(mut &self) {
		for (_, mut imp) in self.file.Impls {
			self.implImpl(imp)
		}
	}

	fn implImpls(mut &self) {
		for (_, mut file) in self.files {
			self.setCurrentFile(file)
			self.implFileImpls()
		}
	}

	fn checkEnums(mut &self) {
		for (_, mut file) in self.files {
			self.setCurrentFile(file)
			match {
			| !self.checkEnumDecls():
			| !self.checkTypeEnumDecls():
			}
		}
	}

	fn checkFileInherits(mut &self) {
		for (_, mut t) in self.file.Traits {
			ok := self._checkTraitDeclInherits(t)
			if !ok {
				ret
			}
		}
	}

	fn checkInherits(mut &self) {
		for (_, mut file) in self.files {
			self.setCurrentFile(file)
			self.checkFileInherits()
		}
	}

	fn typeChecker(mut &self, mut l: Lookup, mut generics: []&TypeAlias,
		mut referencer: &referencer): typeChecker {
		mut tc := typeChecker{
			s: self,
			rootLookup: l,
			lookup: l,
			referencer: referencer,
			useGenerics: generics,
		}
		match type l {
		| &scopeChecker:
			mut hard := (&scopeChecker)(l).getHardRoot()
			tc.refers = hard.owner.Refers
		}
		ret tc
	}

	// Builds type, builds result as kind and collects referred type aliases.
	fn buildTypeWithRefers(mut &self, mut &t: &ast::Type, mut l: Lookup,
		mut generics: []&TypeAlias, mut referencer: &referencer): &Type {
		ret self.typeChecker(l, generics, referencer).checkDecl(t)
	}

	// Checks TypeSYm, builds result as Type and collects referred type aliases.
	// Skips already checked types.
	// See also developer reference (11).
	fn checkTypeSymWithRefers(mut &self, mut &t: &TypeSym, mut l: Lookup, mut referencer: &referencer): (ok: bool) {
		mut ta := false // Referencer owner is type alias.
		if t.checked() {
			match type referencer.owner {
			| &TypeAlias:
				ta = true
			}
			if !ta {
				ret true
			}
		}
		mut tt := self.buildTypeWithRefers(t.Decl, l, nil, referencer)
		if tt == nil || !ta {
			t.Type = tt
		} else {
			(&StructIns)(t.Type.Kind).setSource(tt)
		}
		ret t.checked()
	}

	fn constraintChecker(mut &self): &constraintChecker {
		ret &constraintChecker{s: self}
	}

	// Checks type and builds result as Type.
	// Skips already checked types.
	fn checkTypeSym(mut &self, mut &t: &TypeSym, mut l: Lookup): bool {
		ret self.checkTypeSymWithRefers(t, l, nil)
	}

	// Same as the checkTypeSym but takes referencer.
	fn checkTypeSymRefers(mut &self, mut &t: &ast::Type, mut l: Lookup, mut refers: &ReferenceStack): &Type {
		mut tc := &typeChecker{
			s: self,
			rootLookup: l,
			lookup: l,
			refers: refers,
		}
		ret tc.checkDecl(t)
	}

	// Builds type with type aliases for generics.
	// Returns nil if error occur or failed.
	fn buildTypeWithGenerics(mut &self, mut &t: &ast::Type,
		mut generics: []&TypeAlias, mut refers: &ReferenceStack): &Type {
		mut tc := &typeChecker{
			s: self,
			rootLookup: self,
			lookup: self,
			useGenerics: generics,
			refers: refers,
		}
		ret tc.checkDecl(t)
	}

	// Same as self.buildTypeWithGenerics but not uses any generics.
	fn buildType(mut &self, mut &t: &ast::Type): &Type {
		ret self.buildTypeWithGenerics(t, nil, nil)
	}

	// Select type with name selection.
	fn selectType(mut &self, mut &t: &ast::Type): &Type {
		mut tc := &typeChecker{
			s: self,
			rootLookup: self,
			lookup: self,
			selection: true,
		}
		ret tc.checkDecl(t)
	}

	// Returns eval instance for configuration with
	// type prefix and checks var dependencies.
	fn evalpd(mut &self, mut l: Lookup, mut p: &Type, mut owner: &Var): &eval {
		mut e := &eval{
			s: self,
			lookup: l,
			owner: owner,
		}
		match type l {
		| &scopeChecker:
			e.unsafety = (&scopeChecker)(l).isUnsafe()
		}
		e.prefix = p
		ret e
	}

	// Returns eval instance for configuration with type prefix.
	fn evalp(mut &self, mut l: Lookup, mut p: &Type): &eval {
		ret self.evalpd(l, p, nil)
	}

	// Returns eval instance for configuration.
	fn eval(mut &self, mut l: Lookup): &eval {
		ret self.evalp(l, nil)
	}

	// Do not checks mutability.
	fn checkAssignType(mut &self, destIsRef: bool, mut &dest: &Type,
		mut &v: &Value, mut errorToken: &token::Token, mut refers: &ReferenceStack): bool {
		if v.Decl {
			self.pushErr(errorToken, build::LogMsg.InvalidExpr)
			ret false
		}
		if destIsRef {
			if !dest.Equal(v.Type) {
				self.pushErr(errorToken, build::LogMsg.IncompatibleTypes, dest.Str(), v.Type.Str())
				ret false
			}
		} else {
			mut atc := &assignTypeChecker{
				s: self,
				errorToken: errorToken,
				dest: dest,
				v: v,
				refers: refers,
			}
			ok := atc.check()
			if !ok {
				ret false
			}
		}

		if !v.IsConst() || dest.Prim() == nil {
			ret true
		}

		mut kind := dest.Prim().Kind

		match {
		| types::IsSigInt(kind):
			v.Constant.SetI64(v.Constant.AsI64())
		| types::IsUnsigInt(kind):
			v.Constant.SetU64(v.Constant.AsU64())
		| types::IsFloat(kind):
			v.Constant.SetF64(v.Constant.AsF64())
		}

		ret true
	}

	fn _checkTypeCompatibility(mut &self, mut &dest: &Type, mut &src: &Type,
		mut errorToken: &token::Token): bool {
		if src == nil {
			ret false
		}
		// Tuple to single type, always fails.
		if src.Tuple() != nil {
			ret false
		}
		mut tcc := typeCompatibilityChecker{
			s: self,
			errorToken: errorToken,
			dest: dest,
			src: src,
		}
		ret tcc.check()
	}

	fn checkTypeCompatibility(mut &self, mut &dest: &Type,
		mut &src: &Type, mut &errorToken: &token::Token): bool {
		if self._checkTypeCompatibility(dest, src, errorToken) {
			ret true
		}
		self.pushErr(errorToken, build::LogMsg.IncompatibleTypes, dest.Str(), src.Str())
		ret false
	}

	fn pushCompatibilityError(mut self, mut &dest: &Type, mut &src: &Value,
		mut &errorToken: &token::Token) {
		if src.untyped && src.IsConst() {
			match {
			| src.Constant.IsI64():
				self.pushErr(errorToken, build::LogMsg.IncompatibleTypes, dest.Str(), "untyped integer")
				ret
			| src.Constant.IsU64():
				self.pushErr(errorToken, build::LogMsg.IncompatibleTypes, dest.Str(), "untyped unsigned integer")
				ret
			| src.Constant.IsF64():
				self.pushErr(errorToken, build::LogMsg.IncompatibleTypes, dest.Str(), "untyped float")
				ret
			}
		}
		self.pushErr(errorToken, build::LogMsg.IncompatibleTypes, dest.Str(), src.Type.Str())
	}

	fn checkTypeCompatibility1(mut &self, mut &dest: &Type, mut &src: &Value,
		mut &errorToken: &token::Token): bool {
		if self._checkTypeCompatibility(dest, src.Type, errorToken) {
			ret true
		}
		self.pushCompatibilityError(dest, src, errorToken)
		ret false
	}

	// Builds non-generic types but skips generic types.
	// Builds generic identifiers as primitive type.
	//
	// Useful:
	//	- For non-generic type parsed string type kinds.
	//	- For checking non-generic types.
	fn buildNonGenericType(mut &self, mut &ast: &ast::Type,
		mut &generics: []&ast::Generic, mut &ignored: []&Type): &Type {
		mut tc := &typeChecker{
			s: self,
			rootLookup: self,
			lookup: self,
			ignoreGenerics: generics,
			ignoredGenerics: &ignored,
		}
		ret tc.checkDecl(ast)
	}

	fn buildFuncNonGenericTypes(mut &self, mut f: &FuncIns, mut &ignored: []&Type): (ok: bool) {
		let mut generics: []&ast::Generic = nil
		if f.Decl.IsMethod() {
			generics = append(f.Decl.Generics, f.Decl.Owner.Generics...)
		} else {
			generics = f.Decl.Generics
		}
		ret self.basicFuncEnvironment(f, fn(mut &sema: &sema): (ok: bool) {
			ok = true
			for (_, mut p) in f.Params {
				if !p.Decl.IsSelf() {
					p.Type = sema.buildNonGenericType(p.Decl.TypeSym.Decl, generics, unsafe { ignored })
					ok = ok && p.Type != nil
				}
			}
			if !f.Decl.IsVoid() {
				f.Result = sema.buildNonGenericType(f.Decl.Result.TypeSym.Decl, generics, unsafe { ignored })
				ok = ok && f.Result != nil
			}
			ret
		})
	}

	fn getTraitCheckFuncKind(mut &self, mut &f: &Func): &FuncIns {
		if len(f.Instances) == 1 {
			ret f.Instances[0]
		}
		mut ins := f.instanceForce()

		mut tc := &typeChecker{
			s: self,
			rootLookup: self,
			lookup: self,
		}
		for (_, mut p) in ins.Params {
			if !p.Decl.IsSelf() {
				p.Type = tc.checkDecl(p.Decl.TypeSym.Decl)
				if p.Type == nil {
					ret nil
				}
			}
		}
		if !f.IsVoid() {
			ins.Result = tc.checkDecl(f.Result.TypeSym.Decl)
			if ins.Result == nil {
				ret nil
			}
		}

		ret ins
	}

	fn checkConstraintsFunc(mut &self, mut &f: &FuncIns, mut &et: &token::Token, mut exist: &FuncIns): bool {
		mut cc := self.constraintChecker()
		cc.et = et
		cc.fi = f
		if exist != nil {
			for (i, mut g) in exist.Generics {
				f.Generics[i].Constraint = g.Constraint
			}
		} else {
			cc.uniq = true
		}
		ret cc.check()
	}

	fn checkConstraintsStruct(mut &self, mut &s: &StructIns, mut &et: &token::Token, mut exist: &StructIns): bool {
		mut cc := self.constraintChecker()
		cc.et = et
		cc.si = s
		if exist != nil {
			for (i, mut g) in exist.Generics {
				s.Generics[i].Constraint = g.Constraint
			}
		} else {
			cc.uniq = true
		}
		ret cc.check()
	}

	// Calls algo in the function's native environment.
	// Errors will be handled.
	// Returns result of algo.
	fn basicFuncEnvironment(mut &self, mut &f: &FuncIns, algo: fn(mut &sema: &sema): bool): bool {
		mut sema := f.Decl.sema
		mut old := sema.getCurrentFile()
		mut file := findFile(sema.files, f.Decl.Token.File)
		if file != nil {
			sema.setCurrentFile(file)
		}

		ok := algo(sema)

		if sema != self {
			self.errors = append(self.errors, sema.errors...)
			sema.errors = nil
		}
		sema.setCurrentFile(old)

		ret ok
	}

	// Calls basicFuncEnvironment internally but handles generics.
	fn funcEnvironment(mut &self, mut &f: &FuncIns, algo: fn(mut &sema: &sema, mut &generics: []&TypeAlias): bool): bool {
		mut size := len(f.Generics)
		if f.Decl != nil && f.Decl.Owner != nil {
			size += len(f.Decl.Owner.Generics)
		}
		mut generics := make([]&TypeAlias, 0, size)
		appendGenericTypeAliases(generics, f)
		ret self.basicFuncEnvironment(f, fn(mut &sema: &sema): bool {
			ret algo(sema, generics)
		})
	}

	fn checkFuncParamKind(mut &self, mut &p: &ParamIns) {
		p.Type.Variadic = p.Decl.Variadic
	}

	fn reloadFuncInsTypes(mut &self, mut f: &FuncIns): bool {
		if f.IsBuiltin() || f.IsAnon() {
			ret true
		}
		ret self.funcEnvironment(f, fn(mut &sema: &sema, mut &generics: []&TypeAlias): bool {
			mut ok := true
			for (_, mut p) in f.Params {
				if p.Decl.IsSelf() {
					if f.Owner == nil {
						// Trait methods have not owner yet. Skip them.
						continue
					}
					if p.Decl.IsRef() {
						p.Type = &Type{
							Kind: &Sptr{
								Elem: &Type{
									Kind: f.Owner,
								},
							},
						}
					} else {
						p.Type = &Type{Kind: f.Owner}
					}
				} else {
					p.Type = sema.buildTypeWithGenerics(p.Decl.TypeSym.Decl, generics, f.Refers)
					if p.Type != nil {
						self.checkFuncParamKind(p)
					} else {
						ok = false
					}
				}
			}
			if !f.Decl.IsVoid() {
				f.Result = sema.buildTypeWithGenerics(f.Decl.Result.TypeSym.Decl, generics, f.Refers)
				ok = f.Result != nil && ok
			}
			ret ok
		})
	}

	fn checkRefValidityForInitExpr(mut &self, leftMut: bool, mut &v: &Value, mut &errorToken: &token::Token): bool {
		if !isValidModelForRef(v.Model) {
			self.pushErr(errorToken, build::LogMsg.RefAssignNonVar)
			ret false
		}
		if leftMut && !v.Mutable {
			self.pushErr(errorToken, build::LogMsg.MutRefPointsImmut)
			ret false
		}
		ret true
	}

	// Reports whether struct is risky for mutability.
	// Designed for copy assignments.
	// It will not check mutability risk of the internal mutable data or etc.
	// It will check interior mutability risk of the new copy.
	// Assumes the assigned memory is mutable.
	fn isMutRiskyStruct(self, &s: &StructIns): bool {
		for _, f in s.Fields {
			// Inerior mutability enables to copy internal mutable data with safety.
			// If field is interior mutable and their kind is mutable,
			// check whether the field accessible. If field is not accessible,
			// there is no problem, because no risk for mutability.
			//
			// For example:
			//	We have a Foo struct. The Foo struct have the x field which is
			//	interior mutable with mutable kind. So the following code is risky:
			//
			//	a := Foo{}
			//	mut b := a
			//
			//	The example code above will create new copy of variable a, which is
			//	instance of struct Foo. If the field x is accessible, the variable
			//	b can mutate it, since it is mutable and can access to field x.
			//	Therefore, copying interior mutable fields with mutable kind
			//	must be disallowed if field is accessible for safety reasons.
			if f.Decl.Mutable && f.Type.Mutable() &&
				self.isAccessibleDefine(f.Decl.Public, f.Decl.Token) {
				ret true
			}
		}
		ret false
	}

	fn checkValidityForInitExpr(mut &self, leftMut: bool, leftRef: bool,
		&leftKind: &Type, mut &v: &Value, mut &errorToken: &token::Token): bool {
		if leftMut && !v.Mutable {
			// Check classical assignment mutability.
			if v.Type.Mutable() || v.Type.Variadic {
				self.pushErr(errorToken, build::LogMsg.AssignNonMutToMut, v.Type.Str())
				ret false
			}
			// Check interior mutability risk for the struct copy.
			s := v.Type.Struct()
			if s != nil && self.isMutRiskyStruct(s) {
				self.pushErr(errorToken, build::LogMsg.CopyWithMutableData, v.Type.Str())
				ret false
			}
		}
		if leftRef {
			if !self.checkRefValidityForInitExpr(leftMut, v, errorToken) {
				ret false
			}
		}
		mut atc := &assignTypeChecker{
			s: self,
			v: v,
			errorToken: errorToken,
		}
		ret atc.checkValidity()
	}

	fn checkTypeAliasDeclKind(mut &self, mut &ta: &TypeAlias, mut prev: &referencer, mut l: Lookup): (ok: bool) {
		mut old := self.file
		defer {
			self.setCurrentFile(old)
		}
		if ta.Token != nil {
			mut file := findFile(self.files, ta.Token.File)
			if file != nil {
				self.setCurrentFile(file)
			}
		}
		mut referencer := &referencer{
			name: ta.Ident,
			owner: ta,
			prev: prev,
		}
		if prev != nil {
			prev.next = referencer
			defer { prev.next = nil }
		}
		ok = self.checkTypeSymWithRefers(ta.TypeSym, l, referencer)
		if ok && ta.TypeSym.Type.Array() != nil && ta.TypeSym.Type.Array().Auto {
			self.pushErr(ta.TypeSym.Decl.Token, build::LogMsg.ArrayAutoSized)
			ok = false
		}
		ret
	}

	fn checkTypeAliasDecl(mut &self, mut &ta: &TypeAlias, mut prev: &referencer, mut l: Lookup): (ok: bool) {
		if token::IsIgnoreIdent(ta.Ident) {
			self.pushErr(ta.Token, build::LogMsg.IgnoreIdent)
		}
		if ta.TypeSym.Type != nil {
			// already checked
			ret true
		}
		// Type alias is strict, make strict type alias analysis.
		// See developer reference (11).
		if ta.Strict {
			mut s := initNewStructType(ta.Ident, pseudoSource)
			s.Decl.sema = self
			s.Decl.Binded = ta.Binded
			s.Decl.Token = ta.Token
			s.Decl.Public = ta.Public
			ta.TypeSym.Type = &Type{Kind: s}
		}
		ok = self.checkTypeAliasDeclKind(ta, prev, l)
		if !ok {
			ret false
		}
		if !ta.Strict && ta.Binded {
			self.pushErr(ta.Token, build::LogMsg.BindedAsSoftType)
			self.pushSuggestion(build::LogMsg.DefineAsStrictAlias, ta.Ident)
		}
		ret true
	}

	// Checks type alias declaration with duplicated identifiers.
	fn checkTypeAliasDeclDup(mut &self, mut &ta: &TypeAlias) {
		if self.isDuplicatedIdent(uintptr(ta), ta.Ident, ta.Binded) {
			self.pushErr(ta.Token, build::LogMsg.DuplicatedIdent, ta.Ident)
			self.pushSuggestion(build::LogMsg.RenameForAvoidDuplication)
		}
		self.checkTypeAliasDecl(ta, nil, self)
	}

	// Checks current package file's type alias declarations.
	fn checkTypeAliasDecls(mut &self): (ok: bool) {
		for (_, mut ta) in self.file.TypeAliases {
			self.checkTypeAliasDeclDup(ta)

			// Break checking if type alias has error.
			if len(self.errors) > 0 {
				ret false
			}
		}
		ret true
	}

	fn checkEnumItemsDup[T](mut self, items: []T) {
		for _, item in items {
			if item.Ident == "" {
				continue
			} else if token::IsIgnoreIdent(item.Ident) {
				self.pushErr(item.Token, build::LogMsg.IgnoreIdent)
			} else {
				for _, citem in items {
					if item == citem {
						break
					} else if item.Ident == citem.Ident {
						self.pushErr(item.Token, build::LogMsg.DuplicatedIdent, item.Ident)
						self.pushSuggestion(build::LogMsg.RenameForAvoidDuplication)
						break
					}
				}
			}
		}
	}

	fn checkEnumItemsStr(mut &self, mut &e: &Enum) {
		mut eval := self.eval(self)
		for (_, mut item) in e.Items {
			if item.AutoExpr() {
				item.ValueSym = &ValueSym{
					Value: &Value{
						Constant: constant::Const.NewStr(item.Ident),
					},
				}
				item.ValueSym.Value.Model = item.ValueSym.Value.Constant
			} else {
				mut v := eval.evalExpr(item.ValueSym.Expr)
				if v == nil {
					continue
				}

				if !v.IsConst() {
					self.pushErr(item.ValueSym.Expr.Token, build::LogMsg.ExprNotConst)
				}

				mut refers := (&ReferenceStack)(nil) // constant expressions not uses
				_ = self.checkAssignType(false, e.TypeSym.Type, v, item.Token, refers)
				item.ValueSym.Value = v
			}
		}
	}

	fn checkEnumItemInt[Int](mut &self, mut &eval: &eval, mut &e: &Enum, &prim: &Prim, mut &item: &EnumItem, mut &n: Int) {
		if item.AutoExpr() {
			item.ValueSym = &ValueSym{
				Value: new(Value),
			}
			const match type Int {
			| i64:
				item.ValueSym.Value.Constant = constant::Const.NewI64(n)
			| u64:
				item.ValueSym.Value.Constant = constant::Const.NewU64(n)
			|:
				panic("sema: unimplemented enum int type, this panic call should be unreachable")
			}
			item.ValueSym.Value.Model = item.ValueSym.Value.Constant
		} else {
			mut v := eval.evalExpr(item.ValueSym.Expr)
			if v == nil {
				ret
			}
			if !v.IsConst() {
				self.pushErr(item.ValueSym.Expr.Token, build::LogMsg.ExprNotConst)
			}
			mut refers := (&ReferenceStack)(nil) // constant expressions not uses
			_ = self.checkAssignType(false, e.TypeSym.Type, v, item.Token, refers)
			item.ValueSym.Value = v
			const match type Int {
			| i64:
				n = item.ValueSym.Value.Constant.ReadI64()
			| u64:
				n = item.ValueSym.Value.Constant.ReadU64()
			|:
				panic("sema: unimplemented enum int type, this panic call should be unreachable")
			}
		}
	}

	fn checkEnumItemsInt1[Int](mut &self, &prim: &Prim, mut &e: &Enum) {
		mut max := Int(0)
		const match type Int {
		| i64:
			max = types::MaxI(prim.Str())
		| u64:
			max = types::MaxU(prim.Str())
		|:
			panic("sema: unimplemented enum int type, this panic call should be unreachable")
		}

		mut eval := self.eval(self)
		mut n := Int(0)
		mut first := e.Items[0]
		self.checkEnumItemInt(eval, e, prim, first, n)
		if first.ValueSym.Value != nil {
			const match type Int {
			| i64:
				n = first.ValueSym.Value.Constant.AsI64()
			| u64:
				n = first.ValueSym.Value.Constant.AsU64()
			|:
				panic("sema: unimplemented enum int type, this panic call should be unreachable")
			}
		}
		for (_, mut item) in e.Items[1:] {
			if item.AutoExpr() && n > 0 && max-n <= 0 {
				self.pushErr(item.Token, build::LogMsg.OverflowLimits)
				break
			}
			n++
			self.checkEnumItemInt(eval, e, prim, item, n)
		}
	}

	fn checkEnumItemsInt(mut &self, mut &e: &Enum) {
		prim := e.TypeSym.Type.Prim()
		match {
		| types::IsSigInt(prim.Kind):
			self.checkEnumItemsInt1[i64](prim, e)
		|:
			self.checkEnumItemsInt1[u64](prim, e)
		}
	}

	fn checkEnumDecl(mut &self, mut &e: &Enum) {
		if token::IsIgnoreIdent(e.Ident) {
			self.pushErr(e.Token, build::LogMsg.IgnoreIdent)
		} else if self.isDuplicatedIdent(uintptr(e), e.Ident, false) {
			self.pushErr(e.Token, build::LogMsg.DuplicatedIdent, e.Ident)
			self.pushSuggestion(build::LogMsg.RenameForAvoidDuplication)
		}

		if len(e.Items) == 0 {
			self.pushErr(e.Token, build::LogMsg.NoMemberInEnum, e.Ident)
			ret
		}

		self.checkEnumItemsDup[&EnumItem](e.Items)

		if e.TypeSym != nil {
			if !self.checkTypeSym(e.TypeSym, self) {
				ret
			}
		} else {
			// Set to default type.
			e.TypeSym = findBuiltinTypeAlias(types::Kind.Int).TypeSym
		}

		mut t := e.TypeSym.Type.Prim()
		if t == nil {
			self.pushErr(e.Token, build::LogMsg.InvalidTypeSource)
			ret
		}

		// Check items.
		match {
		| t.IsStr():
			self.checkEnumItemsStr(e)
		| types::IsInt(t.Str()):
			self.checkEnumItemsInt(e)
		|:
			self.pushErr(e.Token, build::LogMsg.InvalidTypeSource)
		}
	}

	fn checkTypeEnumItemType(mut &self, mut &e: &TypeEnum, mut &item: &TypeEnumItem): (ok: bool) {
		mut old := self.file
		defer {
			self.setCurrentFile(old)
		}
		if e.Token != nil {
			mut file := findFile(self.files, e.Token.File)
			if file != nil {
				self.setCurrentFile(file)
			}
		}
		mut referencer := &referencer{
			name: e.Ident,
			owner: e,
		}
		ok = self.checkTypeSymWithRefers(item.TypeSym, self, referencer)
		if ok && item.TypeSym.Type.Array() != nil && item.TypeSym.Type.Array().Auto {
			self.pushErr(item.TypeSym.Decl.Token, build::LogMsg.ArrayAutoSized)
			ok = false
		}
		ret
	}

	fn checkTypeEnumDecl(mut &self, mut &e: &TypeEnum) {
		if token::IsIgnoreIdent(e.Ident) {
			self.pushErr(e.Token, build::LogMsg.IgnoreIdent)
		} else if self.isDuplicatedIdent(uintptr(e), e.Ident, false) {
			self.pushErr(e.Token, build::LogMsg.DuplicatedIdent, e.Ident)
			self.pushSuggestion(build::LogMsg.RenameForAvoidDuplication)
		}

		if len(e.Items) == 0 {
			self.pushErr(e.Token, build::LogMsg.NoMemberInEnum, e.Ident)
			ret
		}

		self.checkEnumItemsDup[&TypeEnumItem](e.Items)
		for (_, mut item) in e.Items {
			if item.TypeSym == nil {
				self.pushErr(item.Token, build::LogMsg.MissingType)
				continue
			}
			ok := self.checkTypeEnumItemType(e, item)
			if !ok {
				continue
			}
			p := item.TypeSym.Type.Prim()
			if p != nil && p.IsAny() {
				self.pushErr(item.Token, build::LogMsg.AnyWithTypeEnum)
			}
		}
	}

	// Checks current package file's enum declarations.
	fn checkEnumDecls(mut &self): (ok: bool) {
		for (_, mut e) in self.file.Enums {
			self.checkEnumDecl(e)
			// Break checking if type alias has error.
			if len(self.errors) > 0 {
				ret false
			}
		}
		ret true
	}

	// Checks current package file's type enum declarations.
	fn checkTypeEnumDecls(mut &self): (ok: bool) {
		for (_, mut e) in self.file.TypeEnums {
			self.checkTypeEnumDecl(e)
			// Break checking if type alias has error.
			if len(self.errors) > 0 {
				ret false
			}
		}
		ret true
	}

	fn checkDeclGenerics(mut self, &generics: []&ast::Generic): (ok: bool) {
		ok = true
		for i, g in generics {
			if token::IsIgnoreIdent(g.Ident) {
				self.pushErr(g.Token, build::LogMsg.IgnoreIdent)
				ok = false
				continue
			}

			// Check duplications.
		duplicationLookup:
			for j, ct in generics {
				match {
				| j >= i:
					// Skip current and following generics.
					break duplicationLookup
				| g.Ident == ct.Ident:
					self.pushErr(g.Token, build::LogMsg.DuplicatedIdent, g.Ident)
					self.pushSuggestion(build::LogMsg.RenameForAvoidDuplication)
					ok = false
					break duplicationLookup
				}
			}
		}
		ret
	}

	fn checkFuncDeclParamsDup(mut self, &f: &Func): (ok: bool) {
		ok = true
	check:
		for i, p in f.Params {
			// Lookup in generics.
			for _, g in f.Generics {
				if p.Ident == g.Ident {
					ok = false
					self.pushErr(p.Token, build::LogMsg.DuplicatedIdent, p.Ident)
					self.pushSuggestion(build::LogMsg.RenameForAvoidDuplication)
					continue check
				}
			}

		paramsLookup:
			for j, jp in f.Params {
				match {
				| j >= i:
					// Skip current and following parameters.
					break paramsLookup
				| token::IsIgnoreIdent(p.Ident)
				| token::IsIgnoreIdent(jp.Ident)
				| token::IsAnonIdent(p.Ident)
				| token::IsAnonIdent(jp.Ident):
					// Skip anonymous parameters.
					break paramsLookup
				| p.Ident == jp.Ident:
					ok = false
					self.pushErr(p.Token, build::LogMsg.DuplicatedIdent, p.Ident)
					self.pushSuggestion(build::LogMsg.RenameForAvoidDuplication)
					continue check
				}
			}
		}
		ret
	}

	fn checkFuncDeclResultDup(mut self, mut &f: &Func): (ok: bool) {
		ok = true
		if f.IsVoid() {
			ret
		}

		// Check duplications.
		for i, v in f.Result.Idents {
			if token::IsIgnoreIdent(v.Kind) || token::IsAnonIdent(v.Kind) {
				continue // Skip anonymous return variables.
			}
			// Lookup in generics.
			for _, g in f.Generics {
				if v.Kind == g.Ident {
					goto exist
				}
			}
			// Lookup in parameters.
			for _, p in f.Params {
				if v.Kind == p.Ident {
					goto exist
				}
			}

			// Lookup in return identifiers.
		itselfLookup:
			for j, jv in f.Result.Idents {
				match {
				| j >= i:
					// Skip current and following identifiers.
					break itselfLookup
				| jv.Kind == v.Kind:
					goto exist
				}
			}
			continue
		exist:
			self.pushErr(v, build::LogMsg.DuplicatedIdent, v.Kind)
			self.pushSuggestion(build::LogMsg.RenameForAvoidDuplication)
			ok = false
		}

		ret
	}

	fn checkFuncVariadicParam(mut &self, mut &f: &Func): bool {
		if len(f.Params) == 0 {
			ret false
		}
		mut param := f.Params[len(f.Params)-1]
		if param.Variadic && param.Reference {
			self.pushErr(param.Token, build::LogMsg.VariadicReference)
		}
		ret true
	}

	// Checks generics, parameters and return type.
	// Not checks scope, and other things.
	fn checkFuncDeclPrototype(mut &self, mut &f: &Func) {
		if f.Exceptional && f.Binded {
			self.pushErr(f.Token, build::LogMsg.BindedExceptional)
			ret
		}

		if f.Exceptional {
			if f.IsEntryPoint() {
				self.pushErr(f.Token, build::LogMsg.ExceptionalEntryPoint)
			} else if f.IsInit() {
				self.pushErr(f.Token, build::LogMsg.ExceptionalInit)
			}
		}

		match {
		| !self.checkDeclGenerics(f.Generics):
		| !self.checkFuncDeclParamsDup(f):
		| !self.checkFuncDeclResultDup(f):
		| !self.checkFuncVariadicParam(f):
		}
	}

	fn catchTraitInheritCycle(mut &self, t1: &Trait, mut t2: &Trait, mut &message: strings::Builder): (ok: bool) {
		ok = true
		for (_, mut i) in t2.Inherits {
			if i.Type == nil {
				continue
			}
			mut t3 := i.Type.Trait()
			if t1 == t3 {
				self.pushCycleError(t2.Ident, t3.Ident, message)
				ret false
			}
			if !self.catchTraitInheritCycle(t1, t3, message) {
				self.pushCycleError(t2.Ident, t3.Ident, message)
				ret false
			}
		}
		ret
	}

	fn _checkTraitDeclInherits(mut &self, mut &t: &Trait): (ok: bool) {
		ok = true
		for (i, mut it) in t.Inherits {
			if !self.checkTypeSym(it, self) {
				ok = false
				continue
			}
			mut t2 := it.Type.Trait()
			if t2 == nil {
				self.pushErr(it.Decl.Token, build::LogMsg.InheritedNonTrait, t.Ident, it.Type.Str())
				ok = false
				continue
			}
			for j, it2 in t.Inherits {
				if j >= i {
					break
				}
				if it2.Type != nil && it.Type.Equal(it2.Type) {
					self.pushErr(it.Decl.Token, build::LogMsg.DuplicatedIdent, t2.Ident)
					ok = false
					break
				}
			}
			if t == t2 {
				self.pushErr(it.Decl.Token, build::LogMsg.IllegalCycleRefersItself, t.Ident)
				ok = false
			} else {
				mut message := strings::Builder{}
				message.Grow(1 << 6)
				ok = ok && self.catchTraitInheritCycle(t, t2, message)
				if message.Len() > 0 {
					mut errMsg := message.Str()
					message.Clear()
					self.pushCycleError(t.Ident, t2.Ident, message)
					errMsg += message.Str()
					self.pushErr(it.Decl.Token, build::LogMsg.IllegalCrossCycle, errMsg)
				}
			}
		}
		ret ok
	}

	fn checkTraitDeclInherits(mut &self, mut &t: &Trait) {
		for (i, mut it) in t.Inherits {
			mut t1 := it.Type.Trait()
			for (j, mut it2) in t.Inherits {
				if j == i {
					continue
				}
				mut t2 := it2.Type.Trait()
				for (_, mut t1m) in t1.Methods {
					mut t2m := t2.FindMethod(t1m.Ident)
					if t2m == nil {
						continue
					}
					t1f := self.getTraitCheckFuncKind(t1m)
					t2f := self.getTraitCheckFuncKind(t2m)
					if !t1f.equalTrait(t2f) {
						self.pushErr(it.Decl.Token, build::LogMsg.IncompatibleInherit,
							t.Ident, t2.Ident, t1f.GetKindStr(true), t2f.GetKindStr(true))
						ret
					}
				}
			}
		}
	}

	fn checkTraitDeclMethod(mut &self, mut &f: &Func) {
		if token::IsIgnoreIdent(f.Ident) {
			self.pushErr(f.Token, build::LogMsg.IgnoreIdent)
		} else if token::IsAnonIdent(f.Ident) {
			self.pushErr(f.Token, build::LogMsg.AnonFunc)
		}
		f.sema = self
		self.checkFuncDeclPrototype(f)
		mut ins := f.instance()
		_ = self.reloadFuncInsTypes(ins)
		ins.reloaded = true
		f.appendInstance(ins)
	}

	fn checkTraitDeclMethods(mut &self, mut &t: &Trait) {
		for (i, mut f) in t.Methods {
			self.checkTraitDeclMethod(f)

			// Break checking if type alias has error.
			if len(self.errors) > 0 {
				ret
			}

			if t.findMethodInherit(f.Ident) != nil {
				self.pushErr(f.Token, build::LogMsg.DuplicatedIdent, f.Ident)
				self.pushSuggestion(build::LogMsg.RenameForAvoidDuplication)
				continue
			}

			// Check duplications.
		duplicateLookup:
			for j, jf in t.Methods {
				// NOTE:
				//	Ignore identifier checking is unnecessary here.
				//	Because ignore identifiers logs error.
				//	Errors breaks checking, so here is unreachable code for
				//	ignore identified methods.
				match {
				| j >= i:
					// Skip current and following methods.
					break duplicateLookup
				| f.Ident == jf.Ident:
					self.pushErr(f.Token, build::LogMsg.DuplicatedIdent, f.Ident)
					self.pushSuggestion(build::LogMsg.RenameForAvoidDuplication)
					break duplicateLookup
				}
			}
		}
	}

	fn checkTraitDecl(mut &self, mut &t: &Trait) {
		if token::IsIgnoreIdent(t.Ident) {
			self.pushErr(t.Token, build::LogMsg.IgnoreIdent)
		} else if self.isDuplicatedIdent(uintptr(t), t.Ident, false) {
			self.pushErr(t.Token, build::LogMsg.DuplicatedIdent, t.Ident)
			self.pushSuggestion(build::LogMsg.RenameForAvoidDuplication)
		}

		self.checkTraitDeclInherits(t)
		self.checkTraitDeclMethods(t)
	}

	// Checks current package file's trait declarations.
	fn checkTraitDecls(mut &self): (ok: bool) {
		for (_, mut t) in self.file.Traits {
			self.checkTraitDecl(t)
			// Break checking if type alias has error.
			if len(self.errors) > 0 {
				ret false
			}
		}
		ret true
	}

	fn checkTraitImplMethods(mut self, mut &base: &Trait, &ipl: &Impl): (ok: bool) {
		ok = true
		for _, f in ipl.Methods {
			if base.FindMethod(f.Ident) == nil {
				self.pushErr(f.Token, build::LogMsg.TraitHaveNotIdent, base.Ident, f.Ident)
				ok = false
			}
		}
		ret
	}

	fn implToStruct(mut &self, mut &dest: &Struct, mut &ipl: &Impl): (ok: bool) {
		ok = true

		// Methods.
		for (_, mut f) in ipl.Methods {
			if dest.FindMethod(f.Ident, f.Statically) != nil || dest.FindField(f.Ident) != nil {
				self.pushErr(f.Token, build::LogMsg.StructAlreadyHaveIdent, dest.Ident, f.Ident)
				ok = false
				continue
			}

			if len(dest.Generics) > 0 && len(f.Generics) > 0 {
				for _, fg in f.Generics {
					for _, dg in dest.Generics {
						if fg.Ident == dg.Ident {
							self.pushErr(fg.Token, build::LogMsg.MethodHasGenericWithSameIdent)
							ok = false
						}
					}
				}
			}

			self.checkDirectives(f.Directives, f)

			f.sema = self
			f.Owner = dest
			dest.Methods = append(dest.Methods, f)
		}

		if len(dest.Instances) == 1 {
			// We have an instance. It's should be impossible if structure is not
			// constructed by a strict type alias. If so, update data of the instance.
			mut s := dest.Instances[0]
			if s.Source != nil {
				s.Methods = dest.Methods
			}
		}

		ret
	}

	// Implement trait to destination.
	fn implTrait(mut &self, mut &decl: &Impl) {
		mut baseT := self.selectType(decl.Base)
		if baseT == nil {
			ret
		}
		mut base := baseT.Trait()
		if base == nil {
			self.pushErr(decl.Base.Token, build::LogMsg.ImplInvalidBase, baseT.Str())
			self.pushSuggestion(build::LogMsg.ExpectedTrait)
			ret
		}

		mut destT := self.selectType(decl.Dest)
		if destT == nil {
			ret
		}
		mut destS := destT.softStruct()
		if destS == nil {
			self.pushErr(decl.Dest.Token, build::LogMsg.ImplInvalidDest, destT.Str())
			self.pushSuggestion(build::LogMsg.ExpectedStruct)
			ret
		}

		mut dest := destS.Decl

		if dest.Token.File.Dir() != self.file.File.Dir() {
			self.pushErr(decl.Dest.Token, build::LogMsg.IllegalImplOutOfPackage)
			ret
		}

		pushImplemented(base, dest)
		pushImplements(dest, base)

		match {
		| !self.checkTraitImplMethods(base, decl):
		| !self.implToStruct(dest, decl):
		}
	}

	fn implStruct(mut &self, mut &decl: &Impl) {
		mut destT := self.selectType(decl.Dest)
		if destT == nil {
			ret
		}
		mut destS := destT.softStruct()
		if destS == nil {
			self.pushErr(decl.Dest.Token, build::LogMsg.ImplInvalidDest, destT.Str())
			self.pushSuggestion(build::LogMsg.ExpectedStruct)
			ret
		}

		mut dest := destS.Decl
		if dest.Token.File.Dir() != self.file.File.Dir() {
			self.pushErr(decl.Dest.Token, build::LogMsg.IllegalImplOutOfPackage)
			ret
		}

		match {
		| !self.implToStruct(dest, decl):
		}
	}

	// Implement implementation.
	fn implImpl(mut &self, mut &decl: &Impl) {
		match {
		| decl.IsTraitImpl():
			self.implTrait(decl)
		| decl.IsStructImpl():
			self.implStruct(decl)
		}
	}

	// Checks variable declaration.
	// Will not check duplicated identifiers.
	fn checkVarDecl(mut &self, mut &decl: &Var, mut l: Lookup) {
		if token::IsIgnoreIdent(decl.Ident) {
			self.pushErr(decl.Token, build::LogMsg.IgnoreIdent)
		}

		if decl.IsTypeInferred() {
			if !decl.IsInitialized() {
				self.pushErr(decl.Token, build::LogMsg.MissingValueForTypeInference)
			}
		} else {
			mut refers := (&ReferenceStack)(nil)
			match type l {
			| &sema:
				refers = decl.Refers
			| &scopeChecker:
				refers = (&scopeChecker)(l).getOwnerRefers()
			|:
				panic("sema: checkVarDecl: unimplemented referencer")
			}
			decl.TypeSym.Type = self.checkTypeSymRefers(decl.TypeSym.Decl, l, refers)
		}

		if decl.Reference {
			if decl.Constant {
				self.pushErr(decl.Token, build::LogMsg.ConstRef)
			}
			if decl.Statically {
				self.pushErr(decl.Token, build::LogMsg.StaticReference)
			}
		}

		if !decl.IsInitialized() {
			if decl.Constant {
				self.pushErr(decl.Token, build::LogMsg.ConstVarNotHaveExpr)
			}
			if decl.Statically {
				self.pushErr(decl.Token, build::LogMsg.StaticNotHaveExpr)
			}
			if decl.Reference {
				self.pushErr(decl.Token, build::LogMsg.RefNotInited)
			}
		}
	}

	// Checks variable declaration for global scope.
	// Checks duplicated identifiers by Sema.
	fn checkGlobalVarDecl(mut &self, mut &decl: &Var) {
		if self.isDuplicatedIdent(uintptr(decl), decl.Ident, decl.Binded) {
			self.pushErr(decl.Token, build::LogMsg.DuplicatedIdent, decl.Ident)
			self.pushSuggestion(build::LogMsg.RenameForAvoidDuplication)
		}
		if decl.Binded && decl.Constant {
			self.pushErr(decl.Token, build::LogMsg.BindedVarIsConst)
		}
		if !decl.Binded && !decl.Constant && !decl.Statically {
			self.pushErr(decl.Token, build::LogMsg.GlobalNotStatic)
			self.pushSuggestion(build::LogMsg.UseStaticKeywordToDef)
		}
		self.checkDirectives(decl.Directives, decl)
		self.checkVarDecl(decl, self)
	}

	// Checks current package file's global variable declarations.
	fn checkGlobalDecls(mut &self): (ok: bool) {
		for (_, mut decl) in self.file.Vars {
			self.checkGlobalVarDecl(decl)
			// Break checking if type alias has error.
			if len(self.errors) > 0 {
				ret false
			}
		}
		ret true
	}

	fn checkStructTraitImpl(mut &self, mut &strct: &Struct, mut &trt: &Trait): (ok: bool) {
		ok = true
		for (_, mut tf) in trt.Methods {
			mut exist := false
			mut sf := strct.FindMethod(tf.Ident, tf.Statically)
			tfK := self.getTraitCheckFuncKind(tf)
			if sf != nil {
				mut sfK := self.getTraitCheckFuncKind(sf)
				if sfK != nil {
					exist = tfK.equalTrait(sfK)
				}
			}
			if !exist {
				const Ident = true
				self.pushErr(strct.Token, build::LogMsg.NotImplTraitDef, trt.Ident, tfK.GetKindStr(Ident))
				ok = false
			}
		}
		ret
	}

	fn checkStructImpls(mut &self, mut &s: &Struct): (ok: bool) {
		ok = true
		for (_, mut trt) in s.Implements {
			ok = self.checkStructTraitImpl(s, trt) && ok
		}
		ret ok
	}

	fn checkStructFields(mut &self, mut &st: &Struct): (ok: bool) {
		ok = true
		for (_, mut f) in st.Fields {
			f.Owner = st
			if token::IsIgnoreIdent(f.Ident) {
				continue
			}
			// Check duplicated identifiers for fields.
			for _, cf in st.Fields {
				if f == cf {
					break
				} else if f.Ident == cf.Ident {
					self.pushErr(f.Token, build::LogMsg.DuplicatedIdent, f.Ident)
					self.pushSuggestion(build::LogMsg.RenameForAvoidDuplication)
					ok = false
				}
			}
		}
		ret ok
	}

	fn checkStructDecl(mut &self, mut &s: &Struct) {
		if token::IsIgnoreIdent(s.Ident) {
			self.pushErr(s.Token, build::LogMsg.IgnoreIdent)
		} else if self.isDuplicatedIdent(uintptr(s), s.Ident, s.Binded) {
			self.pushErr(s.Token, build::LogMsg.DuplicatedIdent, s.Ident)
			self.pushSuggestion(build::LogMsg.RenameForAvoidDuplication)
		}

		self.checkDirectives(s.Directives, s)

		match {
		| !self.checkDeclGenerics(s.Generics):
		| !self.checkStructFields(s):
		| !self.checkStructImpls(s):
		| !self.checkFuncDeclsBy(s.Methods):
		}

		// Here, we need to dispatch the methods again.
		// At this point, all `impl` statements should already be implemented.
		// During this process, some instances might have been created without
		// having the methods. To prevent this from causing errors,
		// the missing methods added with the `impl` statements must be dispatched
		// to the instances that have not have these methods.
		s.dispatchMethods()
	}

	// Checks current package file's structure declarations.
	fn checkStructDecls(mut &self): (ok: bool) {
		for (_, mut s) in self.file.Structs {
			self.checkStructDecl(s)
			// Break checking if type alias has error.
			if len(self.errors) > 0 {
				ret false
			}
		}
		for (_, mut ta) in self.file.TypeAliases {
			if !ta.Strict {
				continue
			}
			mut s := (&StructIns)(ta.TypeSym.Type.Kind).Decl
			match {
			| !self.checkStructImpls(s):
			| !self.checkFuncDeclsBy(s.Methods):
			}
			// Break checking if type alias has error.
			if len(self.errors) > 0 {
				ret false
			}
		}
		ret true
	}

	fn checkAnonFuncDecl(mut &self, mut &f: &Func) {
		f.sema = self
		self.checkFuncDeclPrototype(f)
	}

	fn checkFuncDecl(mut &self, mut &f: &Func) {
		if token::IsIgnoreIdent(f.Ident) {
			self.pushErr(f.Token, build::LogMsg.IgnoreIdent)
		} else if f.IsAnon() {
			self.pushErr(f.Token, build::LogMsg.AnonFunc)
		}

		self.checkDirectives(f.Directives, f)
		self.checkAnonFuncDecl(f)

		if f.Owner == nil && self.isDuplicatedIdent(uintptr(f), f.Ident, f.Binded) {
			if f.Ident == jule::InitFunc {
				init := self.FindFunc(jule::InitFunc, false)
				if init != nil {
					ret
				}
			}
			self.pushErr(f.Token, build::LogMsg.DuplicatedIdent, f.Ident)
			self.pushSuggestion(build::LogMsg.RenameForAvoidDuplication)
		}
	}

	fn checkFuncDeclsBy(mut &self, mut &funcs: []&Func): bool {
		for (_, mut f) in funcs {
			self.checkFuncDecl(f)
			// Break checking if error occurs.
			if len(self.errors) > 0 {
				ret false
			}
		}
		ret true
	}

	// Checks current package file's function declarations.
	fn checkFuncDecls(mut &self): (ok: bool) {
		ret self.checkFuncDeclsBy(self.file.Funcs)
	}

	fn pushCycleError(self, &st1: str, &st2: str, mut &message: strings::Builder) {
		const Padding = 7
		refersTo := build::Logf(build::LogMsg.RefersTo, st1, st2)
		m := message.Str()
		message.WriteStr(strings::Repeat(" ", Padding))!
		message.WriteStr(refersTo)!
		message.WriteByte('\n')!
		message.WriteStr(m)!
	}

	// Checks declarations of all package files.
	// Breaks checking if checked file failed.
	fn checkPackageDecls(mut &self) {
		for (_, mut f) in self.files {
			self.setCurrentFile(f)
			if !self.checkTypeAliasDecls() {
				ret
			}
		}

		for (_, mut f) in self.files {
			self.setCurrentFile(f)
			if !self.checkTraitDecls() {
				ret
			}
		}

		for (_, mut f) in self.files {
			self.setCurrentFile(f)
			if !self.checkGlobalDecls() {
				ret
			}
		}

		for (_, mut f) in self.files {
			self.setCurrentFile(f)
			match {
			| !self.checkFuncDecls():
			| !self.checkStructDecls():
			|:
				continue
			}
			ret
		}
	}

	fn checkDataForTypeInference(mut self, &v: &Value, &errToken: &token::Token): bool {
		match {
		| v.IsNil():
			self.pushErr(errToken, build::LogMsg.NilForTypeInference)
			ret false
		| v.IsVoid():
			self.pushErr(errToken, build::LogMsg.VoidForTypeInference)
			ret false
		| v.Type.Variadic:
			self.pushErr(errToken, build::LogMsg.InvalidExprForTypeInference)
			ret false
		|:
			ret true
		}
	}

	// Checks value of variable.
	fn checkVarValue(mut &self, mut &v: &Var) {
		if v.IsTypeInferred() {
			// Build new TypeSym because auto-type symbols are nil.
			v.TypeSym = &TypeSym{Type: v.ValueSym.Value.Type}

			self.checkDataForTypeInference(v.ValueSym.Value, v.ValueSym.Expr.Token)
			self.checkValidityForInitExpr(
				v.Mutable,
				v.Reference,
				v.TypeSym.Type,
				v.ValueSym.Value,
				v.ValueSym.Expr.Token)
		} else {
			mut arr := v.TypeSym.Type.Array()
			if arr != nil {
				if arr.Auto {
					dataArr := v.ValueSym.Value.Type.Array()
					if dataArr != nil {
						arr.N = dataArr.N
					}
				}
			}

			if self.checkAssignType(v.Reference, v.TypeSym.Type, v.ValueSym.Value, v.ValueSym.Expr.Token, v.Refers) {
				self.checkValidityForInitExpr(
					v.Mutable,
					v.Reference,
					v.TypeSym.Type,
					v.ValueSym.Value,
					v.ValueSym.Expr.Token)
			}
		}

		if v.Constant {
			if !v.ValueSym.Value.IsConst() && !v.ValueSym.Value.Type.comptime() {
				self.pushErr(v.ValueSym.Expr.Token, build::LogMsg.ExprNotConst)
			}
		} else {
			v.ValueSym.Value.Constant = nil
			v.ValueSym.Value.untyped = false
		}

		// Remove kind for avoid more tuple-type errors.
		if v.TypeSym.Type.Tuple() != nil {
			v.TypeSym.Type = nil
		}
	}

	// Evaluates value of variable if initialized.
	fn evalVarValue(mut &self, mut &decl: &Var, mut l: Lookup) {
		if !decl.IsInitialized() {
			ret
		}

		mut eval := (&eval)(nil)
		if decl.TypeSym != nil {
			eval = self.evalpd(l, decl.TypeSym.Type, decl)
		} else {
			eval = self.evalpd(l, nil, decl)
		}
		eval.target.mutable = decl.Mutable
		decl.ValueSym.Value = eval.evalExpr(decl.ValueSym.Expr)
	}

	// Evaluateds value of variable and checks.
	// Assumes the variable is global.
	fn checkVar(mut &self, mut &decl: &Var, mut l: Lookup) {
		decl.Checked = true
		self.evalVarValue(decl, l)
		if decl.ValueSym.Value == nil {
			ret // Skip checks if error occurs.
		}
		self.checkVarValue(decl)
	}

	// Checks current package file's global variables.
	fn checkGlobals(mut &self) {
		for (_, mut decl) in self.file.Vars {
			// Skip if variable is binded or already used.
			// If it is already used, should already analyzed.
			if decl.Binded || decl.Used {
				continue
			}
			self.checkVar(decl, self)
		}
	}

	// Returns new FuncIns as ready-to-analysis.
	// If function already has a instance, returns existing instance.
	// Returns nil if have a problem.
	fn readyToCheckFunc(mut &self, mut &s: &StructIns, mut &f: &Func): &FuncIns {
		mut ins := f.instance()
		if len(f.Instances) != 0 {
			ret ins
		}
		ins.Owner = s
		f.appendInstance(ins)
		ins.reloaded = true
		if self.reloadFuncInsTypes(ins) {
			ret ins
		}
		ret nil
	}

	// Checks new generics function instance.
	// If instance is already exist, f will point to exist instantantiation.
	fn checkGenericFunc(mut &self, mut &f: &FuncIns, mut &et: &token::Token): (ok: bool, exist: bool) {
		ok = self.reloadFuncInsTypes(f)
		f.reloaded = true
		if !ok {
			ret false, false
		}
		mut existInstance := f.Decl.appendInstance(f)
		// TODO: [check] is possible to optimize here using same environment with realoadFuncInsTypes?
		if !self.checkConstraintsFunc(f, et, existInstance) {
			ret false, false
		}
		if existInstance != nil {
			// Set f to exist one.
			f = existInstance
			exist = true
		} else {
			// Check generic function instance instantly.
			self.checkFuncInsCaller(f, et)
		}
		ok = true
		ret
	}

	fn checkTypeMethod(mut &self, mut &s: &StructIns, mut &f: &Func) {
		for (_, mut ins) in f.Instances {
			self.checkFuncIns(ins)
		}
	}

	// Checks environment-dependent parts of structure instance.
	// Which is contains fields and generic-type constraints.
	// If generic instance will be check, errorToken should be passed.
	fn checkStructEnv(mut &self, mut &s: &StructIns, mut prev: &referencer, mut errorToken: &token::Token): (ok: bool) {
		// If source is not nil, do not check.
		// This is unnecessary process for strict type alias structure instances.
		if s.Source != nil {
			ret true
		}
		mut tc := typeChecker{
			s: s.Decl.sema,
			rootLookup: s.Decl.sema,
			lookup: s.Decl.sema,
			referencer: &referencer{
				name: s.Decl.Ident,
				owner: s,
				prev: prev,
			},
			refers: s.Refers,
		}
		if prev != nil {
			prev.next = tc.referencer
			defer { prev.next = nil }
		}

		if len(s.Generics) > 0 {
			tc.useGenerics = make([]&TypeAlias, 0, len(s.Generics))
			for (i, mut g) in s.Generics {
				mut decl := s.Decl.Generics[i]
				tc.useGenerics = append(tc.useGenerics, &TypeAlias{
					Ident: decl.Ident,
					Token: decl.Token,
					TypeSym: &TypeSym{Type: g.Type},
				})
			}
		}

		mut oldFile := self.file
		defer { self.setCurrentFile(oldFile) }

		if self.file.File != s.Decl.Token.File {
			mut file := findFile(self.files, s.Decl.Token.File)
			if file != nil {
				self.setCurrentFile(file)
			}
		}

		if len(s.Generics) > 0 {
			mut cc := self.constraintChecker()
			cc.et = errorToken
			cc.si = s
			cc.genericsA = tc.useGenerics
			cc.uniq = true
			if !cc.check() {
				ret
			}
		}

		ok = true
		mut eval := self.eval(self)
		s.Comparable = !s.Decl.Binded
		for (_, mut f) in s.Fields {
			// Set instance for referencer if field declaration is not mutable.
			// But field declared as mutable, do not set.
			// It basically for the `!f.Decl.Mutable && f.Type.Mutable()` condition.
			if !f.Decl.Mutable {
				tc.referencer.tains = true
			} else {
				tc.referencer.tains = false
			}
			mut kind := tc.checkDecl(f.Decl.TypeSym.Decl)
			ok = kind != nil && ok
			if kind == nil {
				if self != s.Decl.sema && len(s.Decl.sema.errors) > 0 {
					self.errors = append(self.errors, s.Decl.sema.errors...)
					s.Decl.sema.errors = nil
				}
				continue
			}
			f.Type = kind

			// We have to check mutable and comparable conditions again.
			// Because type analysis is a simple precondition checker.
			// For the actual type, we have to check.
			// See developer reference (12.2.1).
			s.Mutable = s.Mutable || (!f.Decl.Mutable && f.Type.Mutable())
			s.Comparable = s.Comparable && f.Type.Comparable()

			// Skip this field if not has default value.
			if f.Decl.Default == nil {
				continue
			}
			eval.prefix = f.Type
			eval.field = f
			eval.target.mutable = true // struct may used as mutable, expressions should be mutable
			f.Default = eval.evalExpr(f.Decl.Default)

			// Skip if eval returned nil.
			// Relevant error(s) logged by eval.
			if f.Default == nil {
				continue
			}

			if !f.Default.IsConst() {
				self.pushErr(f.Decl.Default.Token, build::LogMsg.ExprNotConst)
				continue
			}

			const Reference = false // Fields cannot be reference.
			_ = self.checkAssignType(Reference, f.Type, f.Default, f.Decl.Default.Token, s.Refers)
		}
		ret
	}

	fn precheckStructIns(mut &self, mut s: &StructIns, mut prev: &referencer, mut errorToken: &token::Token): (ok: bool) {
		// Return is source type is still pseudoSource of a strict type alias instance.
		// Following analysis must be done with real source type.
		if s.Source == pseudoSource {
			s.Checked = false
			ret true
		}
		ok = self.checkStructEnv(s, prev, errorToken)
		if ok {
			// See implicit imports reference (1).
			// If structure instance is comparable and have not custom compare method,
			// compiler will use default compare method. If There is array field,
			// push instance for runtime function.
			if s.Comparable && self.meta.runtime != nil {
				mut decl := runtimeFindFunc(self.meta.runtime, "arrayCmp")
				pushArr := fn(mut t: Kind, mut token: &token::Token) {
					match type t {
					| &Array:
						break
					|:
						ret
					}
					mut arr := (&Array)(t)
					if arr == nil {
						ret
					}
					mut f := decl.instanceForce()
					f.Generics = append(f.Generics, &InsGeneric{Type: arr.Elem})
					ok, _ = self.checkGenericFunc(f, token)
					if !ok {
						panic("sema: arrayCmp evaluation failed, this is an implementation mistake")
					}
					s.Refers.Push(f)
				}
				if s.Source == nil {
					for (_, mut field) in s.Fields {
						pushArr(field.Type.ActualKind(), field.Decl.Token)
					}
				} else {
					pushArr(s.Source.ActualKind(), s.Decl.Token)
				}
			}
		}

		// Check instances even environment-based checking failed,
		// because prechecked structures are assumes they are
		// have checked instances for non-generic methods.
		for (_, mut f) in s.Methods {
			if len(f.Generics) == 0 {
				if self.readyToCheckFunc(s, f) == nil {
					ret false
				}
			}
		}
		ret
	}

	fn checkStructIns(mut &self, mut &s: &StructIns) {
		for (_, mut f) in s.Methods {
			self.checkTypeMethod(s, f)
		}
	}

	fn checkTypeStruct(mut &self, mut &s: &Struct) {
		if s.Binded {
			ret
		}

		if len(s.Generics) == 0 && len(s.Instances) == 0 {
			mut ins := s.instance()
			s.appendInstance(ins) // Append instance before precheck.
		}

		// Precheck is instance is not checked already.
		if len(s.Generics) == 0 {
			mut ins := s.Instances[0]
			if !ins.Checked {
				ins.Checked = true
				ok := self.precheckStructIns(ins, nil, nil)
				if !ok {
					ret
				}
			}
		}

		for (_, mut ins) in s.Instances {
			self.checkStructIns(ins)
		}
	}

	fn checkStructTypes(mut &self) {
		for (_, mut s) in self.file.Structs {
			self.checkTypeStruct(s)
		}
	}

	fn precheckStructType(mut &self, mut &s: &Struct) {
		if s.Binded {
			ret
		}

		if len(s.Generics) == 0 && len(s.Instances) == 0 {
			mut ins := s.instance()
			s.appendInstance(ins) // Append instance before precheck.
		}

		// Precheck is instance is not checked already.
		if len(s.Generics) == 0 {
			mut ins := s.Instances[0]
			if !ins.Checked {
				ins.Checked = true
				ok := self.precheckStructIns(ins, nil, nil)
				if !ok {
					ret
				}
			}
		}
	}

	fn precheckStructTypes(mut &self) {
		for (_, mut s) in self.file.Structs {
			self.precheckStructType(s)
		}
	}

	fn checkRets(mut self, mut &f: &FuncIns) {
		if f.Decl.IsVoid() {
			ret
		}
		mrc := missingRetChecker.new()
		ok := mrc.check(f.Scope)
		if !ok {
			self.pushErr(f.Decl.Token, build::LogMsg.MissingRet)
		}
	}

	fn checkFuncInsSc(mut self, mut &f: &FuncIns, mut &sc: &scopeChecker) {
		appendRetVars(sc.table.Vars, f)
		appendParamVars(sc.table.Vars, f)
		appendGenericTypeAliases(sc.table.TypeAliases, f)

		sc.check(f.Decl.Scope, f.Scope)

		// Check return statements if scopeChecker not forced to stop.
		if !sc.stopped() {
			self.checkRets(f)
		}
	}

	fn checkFuncInsCaller(mut &self, mut &f: &FuncIns, mut caller: &token::Token) {
		if f.Decl.Binded || f.checked {
			ret
		}
		f.checked = true

		mut old := f.Decl.sema.file
		defer { f.Decl.sema.setCurrentFile(old) }
		mut file := findFile(f.Decl.sema.files, f.Decl.Token.File)
		if file != nil {
			f.Decl.sema.setCurrentFile(file)
		}

		mut sc := newScopeChecker(f.Decl.sema, f)
		sc.calledFrom = caller
		self.checkFuncInsSc(f, sc)

		if f.Decl.sema != self {
			self.errors = append(self.errors, f.Decl.sema.errors...)
			f.Decl.sema.errors = nil
		}
	}

	fn checkFuncIns(mut &self, mut &f: &FuncIns) {
		self.checkFuncInsCaller(f, nil)
	}

	fn checkFunc(mut &self, mut &f: &Func) {
		if f.Binded {
			ret
		}
		for (_, mut ins) in f.Instances {
			self.checkFuncIns(ins)
		}
	}

	fn checkTestFunc(mut self, mut &f: &FuncIns) {
		if f.Decl.Public {
			self.pushErr(f.Decl.Token, build::LogMsg.PubTestFunc)
			self.pushSuggestion(build::LogMsg.RemovePubModifier)
			ret
		}

		if f.Decl.Unsafety ||
			!f.Decl.IsVoid() ||
			len(f.Decl.Generics) != 0 ||
			len(f.Params) != 1 ||
			f.Decl.Params[0].Mutable ||
			f.Decl.Params[0].Reference {
			self.pushErr(f.Decl.Token, build::LogMsg.WrongTestFuncDecl)
			self.pushSuggestion(build::LogMsg.UseExpectedTestFuncDecl)
			ret
		}

		mut sptr := f.Params[0].Type.Sptr()
		if sptr == nil {
			self.pushErr(f.Decl.Token, build::LogMsg.WrongTestFuncDecl)
			self.pushSuggestion(build::LogMsg.UseExpectedTestFuncDecl)
			ret
		}

		match type sptr.Elem.Kind {
		| &StructIns:
			s := (&StructIns)(sptr.Elem.Kind)
			if s.Source == nil && isStdPackage(s.Decl.Token.File.Path, "testing") {
				ret
			}
		}
		self.pushErr(f.Decl.Token, build::LogMsg.WrongTestFuncDecl)
		self.pushSuggestion(build::LogMsg.UseExpectedTestFuncDecl)
	}

	fn precheckFunc(mut &self, mut &f: &Func) {
		if !f.Binded && len(f.Generics) == 0 && len(f.Instances) == 0 {
			mut ins := f.instanceForce()
			f.Instances = append(f.Instances, ins)
			ok := self.reloadFuncInsTypes(ins)
			ins.reloaded = true

			if ok && hasDirective(f.Directives, build::Directive.Test) {
				self.checkTestFunc(ins)
			}
		}
	}

	// Prechecks types of current package file's functions.
	fn precheckFuncs(mut &self) {
		for (_, mut decl) in self.file.Traits {
			for (_, mut m) in decl.Methods {
				self.precheckFunc(m)
			}
		}
		for (_, mut decl) in self.file.Funcs {
			self.precheckFunc(decl)
		}
	}

	// Checks types of current package file's functions.
	fn checkFuncs(mut &self) {
		for (_, mut decl) in self.file.Funcs {
			self.checkFunc(decl)
		}
	}

	// Check initialization cycles for global variables.
	fn checkInitializationCycles(mut &self) {
		mut message := new(strings::Builder)
		message.Grow(1 << 5)
		pushIllegalCycleError := fn(v1: str, v2: str) {
			const Padding = 7
			refersTo := build::Logf(build::LogMsg.RefersTo, v1, v2)
			message.WriteStr(strings::Repeat(" ", Padding))!
			message.WriteStr(refersTo)!
			message.WriteByte('\n')!
		}
		mut cached := make([]&ReferenceStack, 0, 10)
		for (_, mut file) in self.files {
			for (_, mut v) in file.Vars {
				cached = cached[:0]
				let mut refCheck: fn(mut r: &ReferenceStack, owner: str): bool
				&_refCheck := refCheck
				refCheck = fn(mut r: &ReferenceStack, owner: str): bool {
					// We already checked/checking this reference stack.
					if slices::Contains(cached, r) {
						ret false
					}
					cached = append(cached, r)
					n := message.Len()
					mut i := 0
					for i < r.Len(); i++ {
						mut ref := r.At(i)
						match type ref {
						| &StructIns:
							mut s := (&StructIns)(ref)
							if r == s.Refers {
								break
							}
							pushIllegalCycleError(owner, s.Decl.Ident) // Push trace.
							if unsafe { _refCheck(s.Refers, s.Decl.Ident) } {
								ret true
							}
						| &FuncIns:
							mut f := (&FuncIns)(ref)
							if r == f.Refers {
								break
							}
							pushIllegalCycleError(owner, f.Decl.Ident) // Push trace.
							if unsafe { _refCheck(f.Refers, f.Decl.Ident) } {
								ret true
							}
						| &Var:
							mut v2 := (&Var)(ref)
							pushIllegalCycleError(owner, v2.Ident) // Push trace.
							if v2 == v {
								ret true
							}
							// Global variable v needs to global variable v2 for initialization.
							// So add v2 to v.Depends for correct collection of dependencies.
							if v2.Scope == nil {
								v.Depends = append(v.Depends, v2)
							}
						}
					}
					unsafe { message.SetBuf(message.Buf()[:n]) } // Pop last trace.
					ret false
				}
				if refCheck(v.Refers, v.Ident) {
					self.pushErr(v.Token, build::LogMsg.IllegalCrossCycle, message.Str())
					ret
				}
			}
		}
	}

	// Checks all types of all package files.
	// Breaks checking if checked file failed.
	fn checkPackageTypes(mut &self) {
		// Precheck necessary types first.
		for (_, mut f) in self.files {
			self.setCurrentFile(f)
			self.checkGlobals()
		}
		if len(self.errors) > 0 {
			ret
		}
		for (_, mut f) in self.files {
			self.setCurrentFile(f)
			self.precheckFuncs()
		}
		if len(self.errors) > 0 {
			ret
		}
		for (_, mut f) in self.files {
			self.setCurrentFile(f)
			self.precheckStructTypes()
		}
		if len(self.errors) > 0 {
			ret
		}

		// Check structures of strict type aliases.
		for (_, mut f) in self.files {
			self.setCurrentFile(f)
			for (_, mut ta) in self.file.TypeAliases {
				if ta.Strict {
					mut s := (&StructIns)(ta.TypeSym.Type.Kind)
					if !s.Checked {
						s.Checked = true
						ok := self.precheckStructIns(s, nil, nil)
						if !ok {
							ret
						}
					}
					self.checkTypeStruct(s.Decl)
				}
			}
		}

		for (_, mut f) in self.files {
			self.setCurrentFile(f)
			self.checkFuncs()
			self.checkStructTypes()
		}

		self.checkInitializationCycles()
	}

	fn setFileSemaFields(mut &self) {
		for (_, mut f) in self.file.Funcs {
			f.sema = self
		}
		for (_, mut st) in self.file.Structs {
			st.sema = self
		}
	}

	fn setSemaFields(mut &self) {
		for (_, mut file) in self.files {
			self.setCurrentFile(file)
			self.setFileSemaFields()
		}
	}

	fn check(mut &self, mut &files: []&SymTab) {
		self.files = files

		self.setSemaFields()

		self.checkImports()
		if len(self.errors) != 0 {
			ret
		}

		self.checkInherits()
		if len(self.errors) != 0 {
			ret
		}

		self.implImpls()
		if len(self.errors) != 0 {
			ret
		}
		self.step |= stepFlag.ImplsImplemented

		// Check enums here.
		// See developer reference (7).
		self.checkEnums()
		if len(self.errors) != 0 {
			ret
		}

		self.checkPackageDecls()
		if len(self.errors) != 0 {
			ret
		}

		self.step |= stepFlag.DeclsChecked
		self.checkPackageTypes()
		self.step |= stepFlag.Done
	}
}

struct missingRetChecker {
	mut breaked: []uintptr
	mut falled:  bool
}

impl missingRetChecker {
	static fn new(): missingRetChecker {
		ret missingRetChecker{
			breaked: make([]uintptr, 1<<4),
		}
	}

	fn checkConditional(self, mut c: &Conditional): bool {
		for (_, mut elif) in c.Elifs {
			if elif == nil {
				ret false
			}
			if !self.checkScope(elif.Scope) {
				ret false
			}
		}
		ret c.Default != nil && self.checkScope(c.Default.Scope)
	}

	fn checkMatch(self, mut m: &Match): bool {
		for (_, mut c) in m.Cases {
			if c == nil {
				ret false
			}
			n := len(self.breaked)
			ok := self.checkScope(c.Scope)
			match {
			| n != len(self.breaked):
				ret false
			| !ok:
				if !self.falled {
					ret false
				}
				fall
			| self.falled:
				self.falled = false
				if c.Next == nil {
					ret false
				}
				continue
			}
		}
		ret m.Default != nil && self.checkScope(m.Default.Scope)
	}

	fn checkInfIter(self, it: uintptr, mut &s: &Scope): bool {
		n := len(self.breaked)
		if self.checkScope(s) {
			self.breaked = self.breaked[:n]
			ret true
		}
		if n != len(self.breaked) {
			for _, addr in self.breaked[n:] {
				if it == addr {
					self.breaked = self.breaked[:n]
					ret false
				}
			}
			self.breaked = self.breaked[:n]
		}
		ret true
	}

	fn checkScope(self, mut s: &Scope): bool {
		if s == nil {
			ret false
		}
		for (_, mut st) in s.Stmts {
			match type st {
			| &Fall:
				self.falled = true
				ret false
			| &Break:
				addr := (&Break)(st).It
				if addr != 0 {
					self.breaked = append(self.breaked, addr)
				}
				ret false
			| &Continue:
				ret false
			| &InfIter:
				mut ii := (&InfIter)(st)
				if self.checkInfIter(uintptr(ii), ii.Scope) {
					ret true
				}
			| &WhileIter:
				mut wn := (&WhileIter)(st)
				if wn.IsWhileNext() && wn.Expr == nil {
					// Condition is nil, possible infinite iteration.
					if self.checkInfIter(uintptr(wn), wn.Scope) {
						ret true
					}
				}
			| &Ret:
				ret true
			| &Scope:
				if self.checkScope((&Scope)(st)) {
					ret true
				}
			| &Value:
				match type (&Value)(st).Model {
				| &BuiltinPanicCallExpr
				| &BuiltinErrorCallExpr:
					ret true
				}
			| &Conditional:
				if self.checkConditional((&Conditional)(st)) {
					ret true
				}
			| &Match:
				if self.checkMatch((&Match)(st)) {
					ret true
				}
			}
		}
		ret false
	}

	fn check(self, mut s: &Scope): bool {
		ret self.checkScope(s)
	}
}

fn pushImplemented(mut t: &Trait, mut &d: &Struct) {
push:
	match {
	| len(t.Implemented) > 0:
		for _, s in t.Implemented {
			if s == d {
				break push
			}
		}
		fall
	|:
		t.Implemented = append(t.Implemented, d)
	}
	for (_, mut i) in t.Inherits {
		pushImplemented(i.Type.Trait(), d)
	}
}

fn pushImplements(mut &s: &Struct, mut t: &Trait) {
push:
	match {
	| len(s.Implements) > 0:
		for _, b in s.Implements {
			if b == t {
				break push
			}
		}
		fall
	|:
		s.Implements = append(s.Implements, t)
	}
	for (_, mut i) in t.Inherits {
		pushImplements(s, i.Type.Trait())
	}
}

fn pushRuntimeToStr(mut &s: &sema, mut &t: &Type, mut &token: &token::Token,
	mut refers: &ReferenceStack) {
	if s.meta.runtime == nil || t.IsNil() || refers == nil {
		ret
	}
	mut f := runtimeFindFunc(s.meta.runtime, "toStr").instanceForce()
	f.Generics = append(f.Generics, &InsGeneric{Type: t})
	ok, _ := s.checkGenericFunc(f, token)
	if !ok {
		panic("sema: toStr evaluation failed, this is an implementation mistake")
	}
	refers.Push(f)
}

// Reports whether the alias valid for the import alias.
// Designed to check auto aliases.
fn isValidImpAlias(mut alias: str): (valid: bool) {
	if token::IsIgnoreIdent(alias) {
		ret false
	}
	if token::IsKeyword(alias) {
		ret false
	}
	mut r, mut size := utf8::DecodeRuneStr(alias)
	if r != '_' && !token::IsLetter(r) {
		ret false
	}
	for {
		alias = alias[size:]
		if len(alias) == 0 {
			break
		}
		r, size = utf8::DecodeRuneStr(alias)
		if r != '_' && !('0' <= r && r <= '9') && !token::IsLetter(r) {
			ret false
		}
	}
	ret true
}
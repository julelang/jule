// Copyright 2024-2025 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/comptime"
use "std/conv"
use "std/jule/ast"
use "std/jule/build"
use "std/jule/constant"
use "std/jule/log"
use "std/jule/token"
use "std/jule/types"

// All comptime-structure methods starts with underscore (_).

trait comptimeRangeKind {
	fn index(mut self, mut &v: &Value, i: int)
	fn ready(mut self, mut &keyA: &Var, mut &keyB: &Var)
	fn step(mut self, i: int, mut &keyA: &Var, mut &keyB: &Var)
	fn len(self): int
}

// Compile-time ranges.
struct comptimeRange {
	kind: comptimeRangeKind
}

impl Kind for comptimeRange {
	fn Str(self): str { ret "comptimeRange" }
	fn Equal(&self, other: &Type): bool { ret false }
}

// Compile-time field for structure.
struct comptimeStructField {
	field: &FieldIns
}

impl Kind for comptimeStructField {
	fn Str(self): str { ret "comptimeStructField" }
	fn Equal(&self, other: &Type): bool { ret false }
}

impl comptimeStructField {
	fn _Decl(mut &self, mut &e: &eval, mut &fc: &ast::FuncCallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Args[0].Token, log::ArgumentOverflow, "Decl")
			ret nil
		}
		ret &Value{
			Type: &Type{
				Kind: &comptimeDecl{decl: self.field.Decl},
			},
		}
	}

	fn _Type(mut &self, mut &e: &eval, mut &fc: &ast::FuncCallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Args[0].Token, log::ArgumentOverflow, "Type")
			ret nil
		}
		ret buildComptimeTypeInfoData(e.s, self.field.Type)
	}

	fn subIdent(mut &self, &ident: str): &Value {
		match ident {
		| "Decl":
			mut method := &FuncIns{
				caller: fn(mut &e: &eval, mut &fc: &ast::FuncCallExpr, mut &_: &Value): &Value {
					ret self._Decl(e, fc)
				},
			}
			ret buildAsComptimeMethodData(method)
		| "Type":
			mut method := &FuncIns{
				caller: fn(mut &e: &eval, mut &fc: &ast::FuncCallExpr, mut &_: &Value): &Value {
					ret self._Type(e, fc)
				},
			}
			ret buildAsComptimeMethodData(method)
		|:
			ret nil
		}
	}
}

// Compile-time fields range for structure.
struct comptimeStructFields {
	fields: []&FieldIns
}

impl Kind for comptimeStructFields {
	fn Str(self): str { ret "comptimeStructFields" }
	fn Equal(&self, other: &Type): bool { ret false }
}

impl comptimeRangeKind for comptimeStructFields {
	fn ready(mut self, mut &keyA: &Var, mut &keyB: &Var) {
		if keyA != nil {
			keyA.Constant = true
			keyA.ValueSym = &ValueSym{
				Value: new(Value),
			}
			keyA.TypeSym = findBuiltinTypeAlias(types::Int).TypeSym
		}
		if keyB != nil {
			keyB.Constant = true
			keyB.ValueSym = &ValueSym{
				Value: new(Value),
			}
			keyB.TypeSym = &TypeSym{
				Type: &Type{
					Kind: new(comptimeStructField),
				},
			}
		}
	}

	fn index(mut self, mut &v: &Value, i: int) {
		v.Decl = false
		v.untyped = false
		v.Constant = nil
		v.Type = &Type{
			Kind: &comptimeStructField{
				field: self.fields[i],
			},
		}
	}

	fn step(mut self, i: int, mut &keyA: &Var, mut &keyB: &Var) {
		if keyA != nil {
			// Kind should be assigned by caller.
			keyA.ValueSym.Value.Constant = constant::Const.NewI64(i64(i))
			keyA.ValueSym.Value.Model = keyA.ValueSym.Value.Constant
		}
		if keyB != nil {
			// Kind should be assigned by caller.
			keyB.TypeSym.Type.comptimeStructField().field = self.fields[i]
		}
	}

	fn len(self): int {
		ret len(self.fields)
	}
}

// Compile-time static field for structure.
struct comptimeStatic {
	field: &Var
}

impl Kind for comptimeStatic {
	fn Str(self): str { ret "comptimeStatic" }
	fn Equal(&self, other: &Type): bool { ret false }
}

impl comptimeStatic {
	fn _Decl(mut &self, mut &e: &eval, mut &fc: &ast::FuncCallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Args[0].Token, log::ArgumentOverflow, "Decl")
			ret nil
		}
		ret &Value{
			Type: &Type{
				Kind: &comptimeDecl{decl: self.field},
			},
		}
	}

	fn _Type(mut &self, mut &e: &eval, mut &fc: &ast::FuncCallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Args[0].Token, log::ArgumentOverflow, "Type")
			ret nil
		}
		ret buildComptimeTypeInfoData(e.s, self.field.TypeSym.Type)
	}

	fn subIdent(mut &self, &ident: str): &Value {
		match ident {
		| "Decl":
			mut method := &FuncIns{
				caller: fn(mut &e: &eval, mut &fc: &ast::FuncCallExpr, mut &_: &Value): &Value {
					ret self._Decl(e, fc)
				},
			}
			ret buildAsComptimeMethodData(method)
		| "Type":
			mut method := &FuncIns{
				caller: fn(mut &e: &eval, mut &fc: &ast::FuncCallExpr, mut &_: &Value): &Value {
					ret self._Type(e, fc)
				},
			}
			ret buildAsComptimeMethodData(method)
		|:
			ret nil
		}
	}
}

// Compile-time static fields range for structure.
struct comptimeStatics {
	fields: []&Var
}

impl Kind for comptimeStatics {
	fn Str(self): str { ret "comptimeStatics" }
	fn Equal(&self, other: &Type): bool { ret false }
}

impl comptimeRangeKind for comptimeStatics {
	fn ready(mut self, mut &keyA: &Var, mut &keyB: &Var) {
		if keyA != nil {
			keyA.Constant = true
			keyA.ValueSym = &ValueSym{
				Value: new(Value),
			}
			keyA.TypeSym = findBuiltinTypeAlias(types::Int).TypeSym
		}
		if keyB != nil {
			keyB.Constant = true
			keyB.ValueSym = &ValueSym{
				Value: new(Value),
			}
			keyB.TypeSym = &TypeSym{
				Type: &Type{
					Kind: new(comptimeStatic),
				},
			}
		}
	}

	fn index(mut self, mut &v: &Value, i: int) {
		v.Decl = false
		v.untyped = false
		v.Constant = nil
		v.Type = &Type{
			Kind: &comptimeStatic{
				field: self.fields[i],
			},
		}
	}

	fn step(mut self, i: int, mut &keyA: &Var, mut &keyB: &Var) {
		if keyA != nil {
			// Kind should be assigned by caller.
			keyA.ValueSym.Value.Constant = constant::Const.NewI64(i64(i))
			keyA.ValueSym.Value.Model = keyA.ValueSym.Value.Constant
		}
		if keyB != nil {
			// Kind should be assigned by caller.
			keyB.TypeSym.Type.comptimeStatic().field = self.fields[i]
		}
	}

	fn len(self): int {
		ret len(self.fields)
	}
}

// Compile-time field for enum.
struct comptimeEnumField {
	field: &Var
}

impl Kind for comptimeEnumField {
	fn Str(self): str { ret "comptimeEnumField" }
	fn Equal(&self, other: &Type): bool { ret false }
}

impl comptimeEnumField {
	fn _Decl(mut &self, mut &e: &eval, mut &fc: &ast::FuncCallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Args[0].Token, log::ArgumentOverflow, "Decl")
			ret nil
		}
		ret &Value{
			Type: &Type{
				Kind: &comptimeDecl{decl: self.field},
			},
		}
	}

	fn subIdent(mut &self, &ident: str): &Value {
		match ident {
		| "Decl":
			mut method := &FuncIns{
				caller: fn(mut &e: &eval, mut &fc: &ast::FuncCallExpr, mut &_: &Value): &Value {
					ret self._Decl(e, fc)
				},
			}
			ret buildAsComptimeMethodData(method)
		|:
			ret nil
		}
	}
}

// Compile-time fields range for enum.
struct comptimeEnumFields {
	fields: []&Var
}

impl Kind for comptimeEnumFields {
	fn Str(self): str { ret "comptimeEnumFields" }
	fn Equal(&self, other: &Type): bool { ret false }
}

impl comptimeRangeKind for comptimeEnumFields {
	fn ready(mut self, mut &keyA: &Var, mut &keyB: &Var) {
		if keyA != nil {
			keyA.Constant = true
			keyA.ValueSym = &ValueSym{
				Value: new(Value),
			}
			keyA.TypeSym = findBuiltinTypeAlias(types::Int).TypeSym
		}
		if keyB != nil {
			keyB.Constant = true
			keyB.ValueSym = &ValueSym{
				Value: new(Value),
			}
			keyB.TypeSym = &TypeSym{
				Type: &Type{
					Kind: new(comptimeEnumField),
				},
			}
		}
	}

	fn index(mut self, mut &v: &Value, i: int) {
		v.Decl = false
		v.untyped = false
		v.Constant = nil
		v.Type = &Type{
			Kind: &comptimeEnumField{
				field: self.fields[i],
			},
		}
	}

	fn step(mut self, i: int, mut &keyA: &Var, mut &keyB: &Var) {
		if keyA != nil {
			// Kind should be assigned by caller.
			keyA.ValueSym.Value.Constant = constant::Const.NewI64(i64(i))
			keyA.ValueSym.Value.Model = keyA.ValueSym.Value.Constant
		}
		if keyB != nil {
			// Kind should be assigned by caller.
			keyB.TypeSym.Type.comptimeEnumField().field = self.fields[i]
		}
	}

	fn len(self): int {
		ret len(self.fields)
	}
}

// Compile-time parameter for functions.
struct comptimeParam {
	param: &ParamIns
}

impl Kind for comptimeParam {
	fn Str(self): str { ret "comptimeParam" }
	fn Equal(&self, other: &Type): bool { ret false }
}

impl comptimeParam {
	fn _Decl(mut &self, mut &e: &eval, mut &fc: &ast::FuncCallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Args[0].Token, log::ArgumentOverflow, "Decl")
			ret nil
		}
		ret &Value{
			Type: &Type{
				Kind: &comptimeDecl{decl: self.param.Decl},
			},
		}
	}

	fn _Type(mut &self, mut &e: &eval, mut &fc: &ast::FuncCallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Args[0].Token, log::ArgumentOverflow, "Type")
			ret nil
		}
		ret buildComptimeTypeInfoData(e.s, self.param.Type)
	}

	fn _Recv(mut &self, mut &e: &eval, mut &fc: &ast::FuncCallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Args[0].Token, log::ArgumentOverflow, "Recv")
			ret nil
		}
		mut constant := constant::Const.NewBool(self.param.Decl.IsSelf())
		ret &Value{
			untyped: true,
			Type: primBool,
			Constant: constant,
			Model: constant,
		}
	}

	fn subIdent(mut &self, &ident: str): &Value {
		match ident {
		| "Decl":
			mut method := &FuncIns{
				caller: fn(mut &e: &eval, mut &fc: &ast::FuncCallExpr, mut &_: &Value): &Value {
					ret self._Decl(e, fc)
				},
			}
			ret buildAsComptimeMethodData(method)
		| "Recv":
			mut method := &FuncIns{
				caller: fn(mut &e: &eval, mut &fc: &ast::FuncCallExpr, mut &_: &Value): &Value {
					ret self._Recv(e, fc)
				},
			}
			ret buildAsComptimeMethodData(method)
		| "Type":
			mut method := &FuncIns{
				caller: fn(mut &e: &eval, mut &fc: &ast::FuncCallExpr, mut &_: &Value): &Value {
					ret self._Type(e, fc)
				},
			}
			ret buildAsComptimeMethodData(method)
		|:
			ret nil
		}
	}
}

// Compile-time parameters range for function.
struct comptimeParams {
	params: []&ParamIns
}

impl Kind for comptimeParams {
	fn Str(self): str { ret "comptimeParams" }
	fn Equal(&self, other: &Type): bool { ret false }
}

impl comptimeRangeKind for comptimeParams {
	fn ready(mut self, mut &keyA: &Var, mut &keyB: &Var) {
		if keyA != nil {
			keyA.Constant = true
			keyA.ValueSym = &ValueSym{
				Value: new(Value),
			}
			keyA.TypeSym = findBuiltinTypeAlias(types::Int).TypeSym
		}
		if keyB != nil {
			keyB.Constant = true
			keyB.ValueSym = &ValueSym{
				Value: new(Value),
			}
			keyB.TypeSym = &TypeSym{
				Type: &Type{
					Kind: new(comptimeParam),
				},
			}
		}
	}

	fn index(mut self, mut &v: &Value, i: int) {
		v.Decl = false
		v.untyped = false
		v.Constant = nil
		v.Type = &Type{
			Kind: &comptimeParam{
				param: self.params[i],
			},
		}
	}

	fn step(mut self, i: int, mut &keyA: &Var, mut &keyB: &Var) {
		if keyA != nil {
			// Kind should be assigned by caller.
			keyA.ValueSym.Value.Constant = constant::Const.NewI64(i64(i))
			keyA.ValueSym.Value.Model = keyA.ValueSym.Value.Constant
		}
		if keyB != nil {
			// Kind should be assigned by caller.
			keyB.TypeSym.Type.comptimeParam().param = self.params[i]
		}
	}

	fn len(self): int {
		ret len(self.params)
	}
}

// Compile-time type info range.
struct comptimeTypeInfos {
	types: []&comptimeTypeInfo
}

impl Kind for comptimeTypeInfos {
	fn Str(self): str { ret "comptimeTypeInfos" }
	fn Equal(&self, other: &Type): bool { ret false }
}

impl comptimeRangeKind for comptimeTypeInfos {
	fn ready(mut self, mut &keyA: &Var, mut &keyB: &Var) {
		if keyA != nil {
			keyA.Constant = true
			keyA.ValueSym = &ValueSym{
				Value: new(Value),
			}
			keyA.TypeSym = findBuiltinTypeAlias(types::Int).TypeSym
		}
		if keyB != nil {
			keyB.Constant = true
			keyB.ValueSym = &ValueSym{
				Value: new(Value),
			}
			keyB.TypeSym = &TypeSym{
				Type: &Type{
					Kind: new(comptimeTypeInfo),
				},
			}
		}
	}

	fn index(mut self, mut &v: &Value, i: int) {
		v.Decl = false
		v.untyped = false
		v.Constant = nil
		v.Type = &Type{
			Kind: self.types[i],
		}
	}

	fn step(mut self, i: int, mut &keyA: &Var, mut &keyB: &Var) {
		if keyA != nil {
			// Kind should be assigned by caller.
			keyA.ValueSym.Value.Constant = constant::Const.NewI64(i64(i))
			keyA.ValueSym.Value.Model = keyA.ValueSym.Value.Constant
		}
		if keyB != nil {
			// Kind should be assigned by caller.
			keyB.TypeSym.Type.Kind = self.types[i]
		}
	}

	fn len(self): int {
		ret len(self.types)
	}
}

// Compile-time type information data.
struct comptimeTypeInfo {
	base: &Type
}

impl Kind for comptimeTypeInfo {
	fn Str(self): str { ret "comptimeTypeInfo[" + self.base.Str() + "]" }
	fn Equal(&self, other: &Type): bool { ret false }
}

impl comptimeTypeInfo {
	fn _Hash(&self, mut &e: &eval, mut &fc: &ast::FuncCallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Args[0].Token, log::ArgumentOverflow, "Hash")
			ret nil
		}
		mut constant := constant::Const.NewU64(u64(uintptr(self)))
		constant.Kind = types::Uintptr
		ret &Value{
			untyped: false,
			Type: primUintptr,
			Constant: constant,
			Model: constant,
		}
	}

	fn _Decl(mut &self, mut &e: &eval, mut &fc: &ast::FuncCallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Args[0].Token, log::ArgumentOverflow, "Decl")
			ret nil
		}
		mut decl := comptimeDeclType(nil)
		match {
		| self.base.SoftStruct() != nil:
			decl = self.base.SoftStruct().Decl
		| self.base.Trait() != nil:
			decl = self.base.Trait()
		| self.base.Enum() != nil:
			decl = self.base.Enum()
		| self.base.TypeEnum() != nil:
			decl = self.base.TypeEnum()
		| self.base.Func() != nil:
			mut f := self.base.Func()
			match {
			| f.IsBuiltin():
				e.pushErr(fc.Token, log::InvalidTypeForFunc, self.base.Str(), "<built-in function>")
				ret nil
			| f.IsAnon():
				e.pushErr(fc.Token, log::InvalidTypeForFunc, self.base.Str(), "<anonymous function>")
				ret nil
			}
			decl = f.Decl
		|:
			e.pushErr(fc.Token, log::InvalidTypeForFunc, self.base.Str(), "Decl")
			ret nil
		}
		ret &Value{
			Type: &Type{
				Kind: &comptimeDecl{decl: decl},
			},
		}
	}

	fn _Str(&self, mut &e: &eval, mut &fc: &ast::FuncCallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Args[0].Token, log::ArgumentOverflow, "Str")
			ret nil
		}
		mut constant := constant::Const.NewStr(self.base.Str())
		ret &Value{
			untyped: true,
			Type: primStr,
			Constant: constant,
			Model: constant,
		}
	}

	fn _Kind(mut &self, mut &e: &eval, mut &fc: &ast::FuncCallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Args[0].Token, log::ArgumentOverflow, "Kind")
			ret nil
		}
		let mut c: &constant::Const = nil
		match {
		| self.base.Void():
			c = constant::Const.NewI64(comptime::Void)
		| self.base.Struct() != nil:
			c = constant::Const.NewI64(comptime::Struct)
		| self.base.Trait() != nil:
			c = constant::Const.NewI64(comptime::Trait)
		| self.base.Ptr() != nil:
			if self.base.Ptr().IsUnsafe() {
				c = constant::Const.NewI64(comptime::UnsafePtr)
			} else {
				c = constant::Const.NewI64(comptime::Ptr)
			}
		| self.base.Sptr() != nil:
			c = constant::Const.NewI64(comptime::SmartPtr)
		| self.base.Enum() != nil:
			c = constant::Const.NewI64(comptime::Enum)
		| self.base.TypeEnum() != nil:
			c = constant::Const.NewI64(comptime::TypeEnum)
		| self.base.Map() != nil:
			c = constant::Const.NewI64(comptime::Map)
		| self.base.Slice() != nil:
			c = constant::Const.NewI64(comptime::Slice)
		| self.base.Array() != nil:
			c = constant::Const.NewI64(comptime::Array)
		| self.base.Func() != nil:
			c = constant::Const.NewI64(comptime::Func)
		| self.base.Tuple() != nil:
			c = constant::Const.NewI64(comptime::Tuple)
		| self.base.Chan() != nil:
			c = constant::Const.NewI64(comptime::Chan)
		| self.base.Prim() != nil:
			prim := self.base.Prim()
			match {
			| prim.IsAny():
				c = constant::Const.NewI64(comptime::Any)
			| prim.IsBool():
				c = constant::Const.NewI64(comptime::Bool)
			| prim.IsStr():
				c = constant::Const.NewI64(comptime::Str)
			| prim.IsF32():
				c = constant::Const.NewI64(comptime::F32)
			| prim.IsF64():
				c = constant::Const.NewI64(comptime::F64)
			| prim.IsI8():
				c = constant::Const.NewI64(comptime::I8)
			| prim.IsI16():
				c = constant::Const.NewI64(comptime::I16)
			| prim.IsI32():
				c = constant::Const.NewI64(comptime::I32)
			| prim.IsI64():
				c = constant::Const.NewI64(comptime::I64)
			| prim.IsU8():
				c = constant::Const.NewI64(comptime::U8)
			| prim.IsU16():
				c = constant::Const.NewI64(comptime::U16)
			| prim.IsU32():
				c = constant::Const.NewI64(comptime::U32)
			| prim.IsU64():
				c = constant::Const.NewI64(comptime::U64)
			| prim.IsInt():
				c = constant::Const.NewI64(comptime::Int)
			| prim.IsUint():
				c = constant::Const.NewI64(comptime::Uint)
			| prim.IsUintptr():
				c = constant::Const.NewI64(comptime::Uintptr)
			}
		}
		if c == nil {
			panic("sema: Kind(): unimplemented type for comptime: " + self.base.Str())
		}
		ret &Value{
			untyped: true,
			Type: primInt,
			Constant: c,
			Model: c,
		}
	}

	fn _Bits(mut &self, mut &e: &eval, mut &fc: &ast::FuncCallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Args[0].Token, log::ArgumentOverflow, "Bits")
			ret nil
		}
		prim := self.base.Prim()
		if prim == nil {
			e.pushErr(fc.Token, log::InvalidTypeForFunc, self.base.Str(), "Bits")
			ret nil
		}
		n := types::BitSizeOf(prim.Kind)
		if n == -1 {
			e.pushErr(fc.Token, log::InvalidTypeForFunc, self.base.Str(), "Bits")
			ret nil
		}
		mut constant := constant::Const.NewI64(i64(n))
		ret &Value{
			untyped: true,
			Type: primInt,
			Constant: constant,
			Model: constant,
		}
	}

	fn _Elem(mut &self, mut &e: &eval, mut &fc: &ast::FuncCallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Args[0].Token, log::ArgumentOverflow, "Elem")
			ret nil
		}
		mut ptr := self.base.Ptr()
		if ptr != nil {
			if ptr.IsUnsafe() {
				e.pushErr(fc.Token, log::InvalidTypeForFunc, self.base.Str(), "Elem")
				ret nil
			}
			ret buildComptimeTypeInfoData(e.s, ptr.Elem)
		}
		mut sptr := self.base.Sptr()
		if sptr != nil {
			ret buildComptimeTypeInfoData(e.s, sptr.Elem)
		}
		mut slice := self.base.Slice()
		if slice != nil {
			ret buildComptimeTypeInfoData(e.s, slice.Elem)
		}
		mut array := self.base.Array()
		if array != nil {
			ret buildComptimeTypeInfoData(e.s, array.Elem)
		}
		mut c := self.base.Chan()
		if c != nil {
			ret buildComptimeTypeInfoData(e.s, c.Elem)
		}
		mut enm := self.base.Enum()
		if enm != nil {
			ret buildComptimeTypeInfoData(e.s, enm.TypeSym.Type)
		}
		e.pushErr(fc.Token, log::InvalidTypeForFunc, self.base.Str(), "Elem")
		ret nil
	}

	fn _Size(mut &self, mut &e: &eval, mut &fc: &ast::FuncCallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Args[0].Token, log::ArgumentOverflow, "Size")
			ret nil
		}
		mut arr := self.base.Array()
		if arr == nil {
			e.pushErr(fc.Token, log::InvalidTypeForFunc, self.base.Str(), "Size")
			ret nil
		}
		mut constant := constant::Const.NewI64(i64(arr.N))
		ret &Value{
			untyped: true,
			Type: primInt,
			Constant: constant,
			Model: constant,
		}
	}

	fn _Key(mut &self, mut &e: &eval, mut &fc: &ast::FuncCallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Args[0].Token, log::ArgumentOverflow, "Key")
			ret nil
		}
		mut m := self.base.Map()
		if m == nil {
			e.pushErr(fc.Token, log::InvalidTypeForFunc, self.base.Str(), "Key")
			ret nil
		}
		ret buildComptimeTypeInfoData(e.s, m.Key)
	}

	fn _Value(mut &self, mut &e: &eval, mut &fc: &ast::FuncCallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Args[0].Token, log::ArgumentOverflow, "Value")
			ret nil
		}
		mut m := self.base.Map()
		if m == nil {
			e.pushErr(fc.Token, log::InvalidTypeForFunc, self.base.Str(), "Value")
			ret nil
		}
		ret buildComptimeTypeInfoData(e.s, m.Val)
	}

	fn _Fields(mut &self, mut &e: &eval, mut &fc: &ast::FuncCallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Args[0].Token, log::ArgumentOverflow, "Fields")
			ret nil
		}
		mut s := self.base.Struct()
		if s != nil {
			ret &Value{
				Type: &Type{
					Kind: &comptimeStructFields{
						fields: s.Fields,
					},
				},
			}
		}
		mut enm := self.base.Enum()
		if enm != nil {
			ret &Value{
				Type: &Type{
					Kind: &comptimeEnumFields{
						fields: enm.Items,
					},
				},
			}
		}
		e.pushErr(fc.Token, log::InvalidTypeForFunc, self.base.Str(), "Fields")
		ret nil
	}

	fn _Binded(mut &self, mut &e: &eval, mut &fc: &ast::FuncCallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Args[0].Token, log::ArgumentOverflow, "Binded")
			ret nil
		}
		mut constant := constant::Const.NewBool(self.base.Binded())
		ret &Value{
			untyped: true,
			Type: primBool,
			Constant: constant,
			Model: constant,
		}
	}

	fn _Ordered(&self, mut &e: &eval, mut &fc: &ast::FuncCallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Args[0].Token, log::ArgumentOverflow, "Ordered")
			ret nil
		}
		mut constant := constant::Const.NewBool(self.base.Ordered())
		ret &Value{
			untyped: true,
			Type: primBool,
			Constant: constant,
			Model: constant,
		}
	}

	fn _Comparable(&self, mut &e: &eval, mut &fc: &ast::FuncCallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Args[0].Token, log::ArgumentOverflow, "Comparable")
			ret nil
		}
		mut constant := constant::Const.NewBool(self.base.Comparable())
		ret &Value{
			untyped: true,
			Type: primBool,
			Constant: constant,
			Model: constant,
		}
	}

	fn _Mutable(&self, mut &e: &eval, mut &fc: &ast::FuncCallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Args[0].Token, log::ArgumentOverflow, "Mutable")
			ret nil
		}
		mut constant := constant::Const.NewBool(self.base.Mutable())
		ret &Value{
			untyped: true,
			Type: primBool,
			Constant: constant,
			Model: constant,
		}
	}

	fn _Types(mut &self, mut &e: &eval, mut &fc: &ast::FuncCallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Args[0].Token, log::ArgumentOverflow, "Types")
			ret nil
		}
		mut tup := self.base.Tuple()
		if tup == nil {
			e.pushErr(fc.Token, log::InvalidTypeForFunc, self.base.Str(), "Types")
			ret nil
		}
		mut infos := &comptimeTypeInfos{
			types: make([]&comptimeTypeInfo, 0, len(tup.Types)),
		}
		for (_, mut t) in tup.Types {
			infos.types = append(infos.types, e.s.meta.pushComptimeTypeInfo(t))
		}
		ret &Value{
			Type: &Type{
				Kind: infos,
			},
		}
	}

	fn _CanNil(mut &self, mut &e: &eval, mut &fc: &ast::FuncCallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Args[0].Token, log::ArgumentOverflow, "CanNil")
			ret nil
		}
		mut constant := constant::Const.NewBool(self.base.NilCompatible())
		ret &Value{
			untyped: true,
			Type: primBool,
			Constant: constant,
			Model: constant,
		}
	}

	fn _GC(mut &self, mut &e: &eval, mut &fc: &ast::FuncCallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Args[0].Token, log::ArgumentOverflow, "GC")
			ret nil
		}
		mut constant := constant::Const.NewBool(self.base.GC())
		ret &Value{
			untyped: true,
			Type: primBool,
			Constant: constant,
			Model: constant,
		}
	}

	fn _Result(mut &self, mut &e: &eval, mut &fc: &ast::FuncCallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Args[0].Token, log::ArgumentOverflow, "Result")
			ret nil
		}
		mut f := self.base.Func()
		if f == nil {
			e.pushErr(fc.Token, log::InvalidTypeForFunc, self.base.Str(), "Result")
			ret nil
		}
		if f.Result == nil {
			ret buildComptimeTypeInfoData(e.s, primVoid)
		}
		ret buildComptimeTypeInfoData(e.s, f.Result)
	}

	fn _Params(mut &self, mut &e: &eval, mut &fc: &ast::FuncCallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Args[0].Token, log::ArgumentOverflow, "Params")
			ret nil
		}
		mut f := self.base.Func()
		if f == nil {
			e.pushErr(fc.Token, log::InvalidTypeForFunc, self.base.Str(), "Params")
			ret nil
		}
		ret &Value{
			Type: &Type{
				Kind: &comptimeParams{params: f.Params},
			},
		}
	}

	fn _Strict(mut &self, mut &e: &eval, mut &fc: &ast::FuncCallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Args[0].Token, log::ArgumentOverflow, "Strict")
			ret nil
		}
		s := self.base.SoftStruct()
		mut constant := constant::Const.NewBool(s != nil && s.Source != nil)
		ret &Value{
			untyped: true,
			Type: primBool,
			Constant: constant,
			Model: constant,
		}
	}

	fn subIdent(mut &self, &ident: str): &Value {
		match ident {
		| "Hash":
			mut method := &FuncIns{
				caller: fn(mut &e: &eval, mut &fc: &ast::FuncCallExpr, mut &_: &Value): &Value {
					ret self._Hash(e, fc)
				},
			}
			ret buildAsComptimeMethodData(method)
		| "Strict":
			mut method := &FuncIns{
				caller: fn(mut &e: &eval, mut &fc: &ast::FuncCallExpr, mut &_: &Value): &Value {
					ret self._Strict(e, fc)
				},
			}
			ret buildAsComptimeMethodData(method)
		| "Decl":
			mut method := &FuncIns{
				caller: fn(mut &e: &eval, mut &fc: &ast::FuncCallExpr, mut &_: &Value): &Value {
					ret self._Decl(e, fc)
				},
			}
			ret buildAsComptimeMethodData(method)
		| "Str":
			mut method := &FuncIns{
				caller: fn(mut &e: &eval, mut &fc: &ast::FuncCallExpr, mut &_: &Value): &Value {
					ret self._Str(e, fc)
				},
			}
			ret buildAsComptimeMethodData(method)
		| "Bits":
			mut method := &FuncIns{
				caller: fn(mut &e: &eval, mut &fc: &ast::FuncCallExpr, mut &_: &Value): &Value {
					ret self._Bits(e, fc)
				},
			}
			ret buildAsComptimeMethodData(method)
		| "Elem":
			mut method := &FuncIns{
				caller: fn(mut &e: &eval, mut &fc: &ast::FuncCallExpr, mut &_: &Value): &Value {
					ret self._Elem(e, fc)
				},
			}
			ret buildAsComptimeMethodData(method)
		| "Size":
			mut method := &FuncIns{
				caller: fn(mut &e: &eval, mut &fc: &ast::FuncCallExpr, mut &_: &Value): &Value {
					ret self._Size(e, fc)
				},
			}
			ret buildAsComptimeMethodData(method)
		| "Key":
			mut method := &FuncIns{
				caller: fn(mut &e: &eval, mut &fc: &ast::FuncCallExpr, mut &_: &Value): &Value {
					ret self._Key(e, fc)
				},
			}
			ret buildAsComptimeMethodData(method)
		| "Value":
			mut method := &FuncIns{
				caller: fn(mut &e: &eval, mut &fc: &ast::FuncCallExpr, mut &_: &Value): &Value {
					ret self._Value(e, fc)
				},
			}
			ret buildAsComptimeMethodData(method)
		| "Fields":
			mut method := &FuncIns{
				caller: fn(mut &e: &eval, mut &fc: &ast::FuncCallExpr, mut &_: &Value): &Value {
					ret self._Fields(e, fc)
				},
			}
			ret buildAsComptimeMethodData(method)
		| "Params":
			mut method := &FuncIns{
				caller: fn(mut &e: &eval, mut &fc: &ast::FuncCallExpr, mut &_: &Value): &Value {
					ret self._Params(e, fc)
				},
			}
			ret buildAsComptimeMethodData(method)
		| "Types":
			mut method := &FuncIns{
				caller: fn(mut &e: &eval, mut &fc: &ast::FuncCallExpr, mut &_: &Value): &Value {
					ret self._Types(e, fc)
				},
			}
			ret buildAsComptimeMethodData(method)
		| "Binded":
			mut method := &FuncIns{
				caller: fn(mut &e: &eval, mut &fc: &ast::FuncCallExpr, mut &_: &Value): &Value {
					ret self._Binded(e, fc)
				},
			}
			ret buildAsComptimeMethodData(method)
		| "Ordered":
			mut method := &FuncIns{
				caller: fn(mut &e: &eval, mut &fc: &ast::FuncCallExpr, mut &_: &Value): &Value {
					ret self._Ordered(e, fc)
				},
			}
			ret buildAsComptimeMethodData(method)
		| "Comparable":
			mut method := &FuncIns{
				caller: fn(mut &e: &eval, mut &fc: &ast::FuncCallExpr, mut &_: &Value): &Value {
					ret self._Comparable(e, fc)
				},
			}
			ret buildAsComptimeMethodData(method)
		| "Mutable":
			mut method := &FuncIns{
				caller: fn(mut &e: &eval, mut &fc: &ast::FuncCallExpr, mut &_: &Value): &Value {
					ret self._Mutable(e, fc)
				},
			}
			ret buildAsComptimeMethodData(method)
		| "CanNil":
			mut method := &FuncIns{
				caller: fn(mut &e: &eval, mut &fc: &ast::FuncCallExpr, mut &_: &Value): &Value {
					ret self._CanNil(e, fc)
				},
			}
			ret buildAsComptimeMethodData(method)
		| "GC":
			mut method := &FuncIns{
				caller: fn(mut &e: &eval, mut &fc: &ast::FuncCallExpr, mut &_: &Value): &Value {
					ret self._GC(e, fc)
				},
			}
			ret buildAsComptimeMethodData(method)
		| "Result":
			mut method := &FuncIns{
				caller: fn(mut &e: &eval, mut &fc: &ast::FuncCallExpr, mut &_: &Value): &Value {
					ret self._Result(e, fc)
				},
			}
			ret buildAsComptimeMethodData(method)
		| "Kind":
			mut method := &FuncIns{
				caller: fn(mut &e: &eval, mut &fc: &ast::FuncCallExpr, mut &_: &Value): &Value {
					ret self._Kind(e, fc)
				},
			}
			ret buildAsComptimeMethodData(method)
		|:
			ret nil
		}
	}
}

// Compile-time value information data.
struct comptimeValue {
	v: &Value
}

impl Kind for comptimeValue {
	fn Str(self): str { ret "comptimeValue" }
	fn Equal(&self, other: &Type): bool { ret false }
}

impl comptimeValue {
	fn _Unwrap(mut &self, mut &e: &eval, mut &fc: &ast::FuncCallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Args[0].Token, log::ArgumentOverflow, "Unwrap")
			ret nil
		}
		ret self.v
	}

	fn _Type(mut &self, mut &e: &eval, mut &fc: &ast::FuncCallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Args[0].Token, log::ArgumentOverflow, "Type")
			ret nil
		}
		ret buildComptimeTypeInfoData(e.s, self.v.Type)
	}

	fn _Lvalue(mut &self, mut &e: &eval, mut &fc: &ast::FuncCallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Args[0].Token, log::ArgumentOverflow, "Lvalue")
			ret nil
		}
		mut constant := constant::Const.NewBool(self.v.Lvalue)
		ret &Value{
			untyped: true,
			Type: primBool,
			Constant: constant,
			Model: constant,
		}
	}

	fn _Mutable(mut &self, mut &e: &eval, mut &fc: &ast::FuncCallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Args[0].Token, log::ArgumentOverflow, "Mutable")
			ret nil
		}
		mut constant := constant::Const.NewBool(self.v.Mutable)
		ret &Value{
			untyped: true,
			Type: primBool,
			Constant: constant,
			Model: constant,
		}
	}

	fn _Const(mut &self, mut &e: &eval, mut &fc: &ast::FuncCallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Args[0].Token, log::ArgumentOverflow, "Const")
			ret nil
		}
		mut constant := constant::Const.NewBool(self.v.IsConst())
		ret &Value{
			untyped: true,
			Type: primBool,
			Constant: constant,
			Model: constant,
		}
	}

	fn _Field(mut &self, mut &e: &eval, mut &fc: &ast::FuncCallExpr): &Value {
		if len(fc.Args) > 1 {
			e.pushErr(fc.Args[1].Token, log::ArgumentOverflow, "Field")
			ret nil
		}
		mut s := self.v.Type.Struct()
		if s == nil {
			e.pushErr(fc.Token, log::InvalidTypeForFunc, self.v.Type.Str(), "Field")
			ret nil
		}
		mut arg := fc.Args[0]
		mut v := e.evalExpr(arg, evalDefault)
		if v == nil {
			ret nil
		}
		if !v.IsConst() {
			e.pushErr(arg.Token, log::ExprNotConst)
			ret nil
		}
		prim := v.Type.Prim()
		if prim == nil || !prim.IsStr() {
			e.pushErr(arg.Token, log::IncompatibleTypes, str(types::Str), v.Type.Str())
			ret nil
		}
		ident := v.Constant.ReadStr()
		mut f := s.FindField(ident)
		if f == nil {
			e.pushErr(arg.Token, log::ObjHaveNotIdent, s.Decl.Ident, ident)
			ret nil
		}
		v = new(Value, *self.v)
		v = e.evalStructSubIdentField(v, s, arg.Token, f)
		ret buildComptimeValue(v)
	}

	fn _FieldByIndex(mut &self, mut &e: &eval, mut &fc: &ast::FuncCallExpr): &Value {
		if len(fc.Args) > 1 {
			e.pushErr(fc.Args[1].Token, log::ArgumentOverflow, "FieldByIndex")
			ret nil
		}
		mut s := self.v.Type.Struct()
		if s == nil {
			e.pushErr(fc.Token, log::InvalidTypeForFunc, self.v.Type.Str(), "Field")
			ret nil
		}
		mut arg := fc.Args[0]
		mut v := e.evalExpr(arg, evalDefault)
		if v == nil {
			ret nil
		}
		if !v.IsConst() {
			e.pushErr(arg.Token, log::ExprNotConst)
			ret nil
		}
		log := checkDataForIntegerIndexing(e.s, v, arg.Token, e.getOwnerRefers())
		if log != "" {
			e.pushErr(arg.Token, log)
			ret nil
		}
		i := v.Constant.AsU64()
		if i >= u64(len(s.Fields)) {
			e.pushErr(arg.Token, log::IndexOutOfRange, conv::FormatUint(i, 10), conv::Itoa(len(s.Fields)))
			ret nil
		}
		mut f := s.Fields[i]
		v = new(Value, *self.v)
		v = e.evalStructSubIdentField(v, s, arg.Token, f)
		ret buildComptimeValue(v)
	}

	fn _Method(mut &self, mut &e: &eval, mut &fc: &ast::FuncCallExpr): &Value {
		if len(fc.Args) > 1 {
			e.pushErr(fc.Args[1].Token, log::ArgumentOverflow, "Method")
			ret nil
		}
		mut ref := false
		mut s := (&StructIns)(nil)
		match type self.v.Type.Kind {
		| &Sptr:
			s = self.v.Type.Kind.(&Sptr).Elem.SoftStruct()
			ref = true
		| &StructIns:
			s = self.v.Type.Kind.(&StructIns)
		}
		if s == nil {
			e.pushErr(fc.Token, log::InvalidTypeForFunc, self.v.Type.Str(), "Method")
			ret nil
		}
		mut arg := fc.Args[0]
		mut v := e.evalExpr(arg, evalDefault)
		if v == nil {
			ret nil
		}
		if !v.IsConst() {
			e.pushErr(arg.Token, log::ExprNotConst)
			ret nil
		}
		prim := v.Type.Prim()
		if prim == nil || !prim.IsStr() {
			e.pushErr(arg.Token, log::IncompatibleTypes, str(types::Str), v.Type.Str())
			ret nil
		}
		ident := v.Constant.ReadStr()
		const Static = false
		mut m := s.FindMethod(ident, Static)
		if m == nil {
			e.pushErr(arg.Token, log::ObjHaveNotIdent, s.Decl.Ident, ident)
			ret nil
		}
		v = new(Value, *self.v)
		if ref {
			makeImplicitDeref(v, fc.Token)
		}
		v = e.evalStructSubIdentMethod(v, s, arg.Token, m, ref)
		ret buildComptimeValue(v)
	}

	fn subIdent(mut &self, &ident: str): &Value {
		match ident {
		| "Unwrap":
			mut method := &FuncIns{
				caller: fn(mut &e: &eval, mut &fc: &ast::FuncCallExpr, mut &_: &Value): &Value {
					ret self._Unwrap(e, fc)
				},
			}
			ret buildAsComptimeMethodData(method)
		| "Type":
			mut method := &FuncIns{
				caller: fn(mut &e: &eval, mut &fc: &ast::FuncCallExpr, mut &_: &Value): &Value {
					ret self._Type(e, fc)
				},
			}
			ret buildAsComptimeMethodData(method)
		| "Lvalue":
			mut method := &FuncIns{
				caller: fn(mut &e: &eval, mut &fc: &ast::FuncCallExpr, mut &_: &Value): &Value {
					ret self._Lvalue(e, fc)
				},
			}
			ret buildAsComptimeMethodData(method)
		| "Mutable":
			mut method := &FuncIns{
				caller: fn(mut &e: &eval, mut &fc: &ast::FuncCallExpr, mut &_: &Value): &Value {
					ret self._Mutable(e, fc)
				},
			}
			ret buildAsComptimeMethodData(method)
		| "Const":
			mut method := &FuncIns{
				caller: fn(mut &e: &eval, mut &fc: &ast::FuncCallExpr, mut &_: &Value): &Value {
					ret self._Const(e, fc)
				},
			}
			ret buildAsComptimeMethodData(method)
		| "Field":
			mut method := &FuncIns{
				caller: fn(mut &e: &eval, mut &fc: &ast::FuncCallExpr, mut &_: &Value): &Value {
					ret self._Field(e, fc)
				},
			}
			ret buildAsComptimeMethodData(method)
		| "FieldByIndex":
			mut method := &FuncIns{
				caller: fn(mut &e: &eval, mut &fc: &ast::FuncCallExpr, mut &_: &Value): &Value {
					ret self._FieldByIndex(e, fc)
				},
			}
			ret buildAsComptimeMethodData(method)
		| "Method":
			mut method := &FuncIns{
				caller: fn(mut &e: &eval, mut &fc: &ast::FuncCallExpr, mut &_: &Value): &Value {
					ret self._Method(e, fc)
				},
			}
			ret buildAsComptimeMethodData(method)
		|:
			ret nil
		}
	}
}

// Compile-time file info range.
struct comptimeFiles {
	files: []&SymTab
}

impl Kind for comptimeFiles {
	fn Str(self): str { ret "comptimeFiles" }
	fn Equal(&self, other: &Type): bool { ret false }
}

impl comptimeRangeKind for comptimeFiles {
	fn ready(mut self, mut &keyA: &Var, mut &keyB: &Var) {
		if keyA != nil {
			keyA.Constant = true
			keyA.ValueSym = &ValueSym{
				Value: new(Value),
			}
			keyA.TypeSym = findBuiltinTypeAlias(types::Int).TypeSym
		}
		if keyB != nil {
			keyB.Constant = true
			keyB.ValueSym = &ValueSym{
				Value: new(Value),
			}
			keyB.TypeSym = &TypeSym{
				Type: &Type{
					Kind: new(comptimeFile),
				},
			}
		}
	}

	fn index(mut self, mut &v: &Value, i: int) {
		v.Decl = false
		v.untyped = false
		v.Constant = nil
		v.Type = &Type{
			Kind: &comptimeFile{
				file: self.files[i],
			},
		}
	}

	fn step(mut self, i: int, mut &keyA: &Var, mut &keyB: &Var) {
		if keyA != nil {
			// Kind should be assigned by caller.
			keyA.ValueSym.Value.Constant = constant::Const.NewI64(i64(i))
			keyA.ValueSym.Value.Model = keyA.ValueSym.Value.Constant
		}
		if keyB != nil {
			// Kind should be assigned by caller.
			keyB.TypeSym.Type.Kind.(&comptimeFile).file = self.files[i]
		}
	}

	fn len(self): int {
		ret len(self.files)
	}
}

// Compile-time file information data.
struct comptimeFile {
	file: &SymTab
}

impl Kind for comptimeFile {
	fn Str(self): str { ret "comptimeFile" }
	fn Equal(&self, other: &Type): bool { ret false }
}

impl comptimeFile {
	fn _Path(mut &self, mut &e: &eval, mut &fc: &ast::FuncCallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Args[0].Token, log::ArgumentOverflow, "Path")
			ret nil
		}
		mut constant := constant::Const.NewStr(self.file.File.Path)
		ret &Value{
			untyped: true,
			Type: primStr,
			Constant: constant,
			Model: constant,
		}
	}

	fn _Name(mut &self, mut &e: &eval, mut &fc: &ast::FuncCallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Args[0].Token, log::ArgumentOverflow, "Name")
			ret nil
		}
		mut constant := constant::Const.NewStr(self.file.File.Name())
		ret &Value{
			untyped: true,
			Type: primStr,
			Constant: constant,
			Model: constant,
		}
	}

	fn _Dir(mut &self, mut &e: &eval, mut &fc: &ast::FuncCallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Args[0].Token, log::ArgumentOverflow, "Dir")
			ret nil
		}
		mut constant := constant::Const.NewStr(self.file.File.Dir())
		ret &Value{
			untyped: true,
			Type: primStr,
			Constant: constant,
			Model: constant,
		}
	}

	fn subIdent(mut &self, &ident: str): &Value {
		match ident {
		| "Path":
			mut method := &FuncIns{
				caller: fn(mut &e: &eval, mut &fc: &ast::FuncCallExpr, mut &_: &Value): &Value {
					ret self._Path(e, fc)
				},
			}
			ret buildAsComptimeMethodData(method)
		| "Name":
			mut method := &FuncIns{
				caller: fn(mut &e: &eval, mut &fc: &ast::FuncCallExpr, mut &_: &Value): &Value {
					ret self._Name(e, fc)
				},
			}
			ret buildAsComptimeMethodData(method)
		| "Dir":
			mut method := &FuncIns{
				caller: fn(mut &e: &eval, mut &fc: &ast::FuncCallExpr, mut &_: &Value): &Value {
					ret self._Dir(e, fc)
				},
			}
			ret buildAsComptimeMethodData(method)
		|:
			ret nil
		}
	}
}

// Compile-time declaration info range.
struct comptimeDecls {
	decls: []&comptimeDecl
}

impl Kind for comptimeDecls {
	fn Str(self): str { ret "comptimeDecls" }
	fn Equal(&self, other: &Type): bool { ret false }
}

impl comptimeRangeKind for comptimeDecls {
	fn ready(mut self, mut &keyA: &Var, mut &keyB: &Var) {
		if keyA != nil {
			keyA.Constant = true
			keyA.ValueSym = &ValueSym{
				Value: new(Value),
			}
			keyA.TypeSym = findBuiltinTypeAlias(types::Int).TypeSym
		}
		if keyB != nil {
			keyB.Constant = true
			keyB.ValueSym = &ValueSym{
				Value: new(Value),
			}
			keyB.TypeSym = &TypeSym{
				Type: &Type{
					Kind: new(comptimeDecl),
				},
			}
		}
	}

	fn index(mut self, mut &v: &Value, i: int) {
		v.Decl = false
		v.untyped = false
		v.Constant = nil
		v.Type = &Type{
			Kind: self.decls[i],
		}
	}

	fn step(mut self, i: int, mut &keyA: &Var, mut &keyB: &Var) {
		if keyA != nil {
			// Kind should be assigned by caller.
			keyA.ValueSym.Value.Constant = constant::Const.NewI64(i64(i))
			keyA.ValueSym.Value.Model = keyA.ValueSym.Value.Constant
		}
		if keyB != nil {
			// Kind should be assigned by caller.
			keyB.TypeSym.Type.Kind.(&comptimeDecl).decl = self.decls[i].decl
		}
	}

	fn len(self): int {
		ret len(self.decls)
	}
}

// Supported types for the comptimeDecl data.
// For any update, make sure all kinds are handled correctly.
enum comptimeDeclType: type {
	&Struct,
	&Func,
	&Enum,
	&TypeEnum,
	&Trait,
	&Field,
	&TypeAlias,
	&Var,
	&Param,
}

// Compile-time declaration information wrapper.
struct comptimeDecl {
	decl: comptimeDeclType
}

impl Kind for comptimeDecl {
	fn Str(self): str { ret "comptimeDecl" }
	fn Equal(&self, other: &Type): bool { ret false }
}

impl comptimeDecl {
	fn declAsStr(self): str {
		match type self.decl {
		| &Struct:
			ret "<struct>"
		| &Func:
			ret "<func>"
		| &Enum:
			ret "<enum>"
		| &TypeEnum:
			ret "<type enum>"
		| &Trait:
			ret "<trait>"
		| &Field:
			ret "<field>"
		| &TypeAlias:
			ret "<type alias>"
		| &Var:
			v := self.decl.(&Var)
			if v.IsEnumField() {
				ret "<enum field>"
			}
			ret "<var>"
		| &Param:
			ret "<param>"
		|:
			panic("sema: comptimeDecl.Name: unimplemented declaration kind")
		}
	}

	fn _Name(mut &self, mut &e: &eval, mut &fc: &ast::FuncCallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Args[0].Token, log::ArgumentOverflow, "Name")
			ret nil
		}
		mut name := ""
		match type self.decl {
		| &Struct:
			name = self.decl.(&Struct).Ident
		| &Func:
			name = self.decl.(&Func).Ident
		| &Enum:
			name = self.decl.(&Enum).Ident
		| &TypeEnum:
			name = self.decl.(&TypeEnum).Ident
		| &Trait:
			name = self.decl.(&Trait).Ident
		| &Field:
			name = self.decl.(&Field).Ident
		| &TypeAlias:
			name = self.decl.(&TypeAlias).Ident
		| &Var:
			name = self.decl.(&Var).Ident
		| &Param:
			name = self.decl.(&Param).Ident
		|:
			panic("sema: comptimeDecl.Name: unimplemented declaration kind")
		}
		mut constant := constant::Const.NewStr(name)
		ret &Value{
			untyped: true,
			Type: primStr,
			Constant: constant,
			Model: constant,
		}
	}

	fn _Public(mut &self, mut &e: &eval, mut &fc: &ast::FuncCallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Args[0].Token, log::ArgumentOverflow, "Public")
			ret nil
		}
		mut public := false
		match type self.decl {
		| &Param:
			e.pushErr(fc.Token, log::InvalidTypeForFunc, self.declAsStr(), "Public")
			ret nil
		| &Struct:
			public = self.decl.(&Struct).Public
		| &Func:
			public = self.decl.(&Func).Public
		| &Enum:
			public = self.decl.(&Enum).Public
		| &TypeEnum:
			public = self.decl.(&TypeEnum).Public
		| &Trait:
			public = self.decl.(&Trait).Public
		| &Field:
			public = self.decl.(&Field).Public
		| &TypeAlias:
			public = self.decl.(&TypeAlias).Public
		| &Var:
			v := self.decl.(&Var)
			if v.IsEnumField() {
				e.pushErr(fc.Token, log::InvalidTypeForFunc, self.declAsStr(), "Public")
				ret nil
			}
			public = v.Public
		|:
			panic("sema: comptimeDecl.Public: unimplemented declaration kind")
		}
		mut constant := constant::Const.NewBool(public)
		ret &Value{
			untyped: true,
			Type: primBool,
			Constant: constant,
			Model: constant,
		}
	}

	fn _Binded(mut &self, mut &e: &eval, mut &fc: &ast::FuncCallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Args[0].Token, log::ArgumentOverflow, "Binded")
			ret nil
		}
		mut binded := false
		match type self.decl {
		| &Enum
		| &TypeEnum
		| &Trait
		| &Field
		| &Param:
			e.pushErr(fc.Token, log::InvalidTypeForFunc, self.declAsStr(), "Binded")
			ret nil
		| &Struct:
			binded = self.decl.(&Struct).Binded
		| &Func:
			binded = self.decl.(&Func).Binded
		| &TypeAlias:
			binded = self.decl.(&TypeAlias).Binded
		| &Var:
			v := self.decl.(&Var)
			if v.IsEnumField() {
				e.pushErr(fc.Token, log::InvalidTypeForFunc, self.declAsStr(), "Binded")
				ret nil
			}
			binded = v.Binded
		|:
			panic("sema: comptimeDecl.Binded: unimplemented declaration kind")
		}
		mut constant := constant::Const.NewBool(binded)
		ret &Value{
			untyped: true,
			Type: primBool,
			Constant: constant,
			Model: constant,
		}
	}

	fn _Exceptional(mut &self, mut &e: &eval, mut &fc: &ast::FuncCallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Args[0].Token, log::ArgumentOverflow, "Exceptional")
			ret nil
		}
		match type self.decl {
		| &Func:
			break
		|:
			e.pushErr(fc.Token, log::InvalidTypeForFunc, self.declAsStr(), "Exceptional")
			ret nil
		}
		mut f := self.decl.(&Func)
		mut constant := constant::Const.NewBool(f.Exceptional)
		ret &Value{
			untyped: true,
			Type: primBool,
			Constant: constant,
			Model: constant,
		}
	}

	fn _Mutable(mut &self, mut &e: &eval, mut &fc: &ast::FuncCallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Args[0].Token, log::ArgumentOverflow, "Mutable")
			ret nil
		}
		mut mutable := false
		match type self.decl {
		| &Struct
		| &Func
		| &Enum
		| &TypeEnum
		| &Trait
		| &TypeAlias:
			e.pushErr(fc.Token, log::InvalidTypeForFunc, self.declAsStr(), "Mutable")
			ret nil
		| &Param:
			mutable = self.decl.(&Param).Mutable
		| &Field:
			mutable = self.decl.(&Field).Mutable
		| &Var:
			v := self.decl.(&Var)
			if v.IsEnumField() {
				e.pushErr(fc.Token, log::InvalidTypeForFunc, self.declAsStr(), "Mutable")
				ret nil
			}
			mutable = v.Mutable
		|:
			panic("sema: comptimeDecl.Mutable: unimplemented declaration kind")
		}
		mut constant := constant::Const.NewBool(mutable)
		ret &Value{
			untyped: true,
			Type: primBool,
			Constant: constant,
			Model: constant,
		}
	}

	fn _Variadic(mut &self, mut &e: &eval, mut &fc: &ast::FuncCallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Args[0].Token, log::ArgumentOverflow, "Variadic")
			ret nil
		}
		mut variadic := false
		match type self.decl {
		| &Struct
		| &Func
		| &Enum
		| &TypeEnum
		| &Trait
		| &TypeAlias
		| &Field
		| &Var:
			e.pushErr(fc.Token, log::InvalidTypeForFunc, self.declAsStr(), "Variadic")
			ret nil
		| &Param:
			variadic = self.decl.(&Param).Variadic
		|:
			panic("sema: comptimeDecl.Variadic: unimplemented declaration kind")
		}
		mut constant := constant::Const.NewBool(variadic)
		ret &Value{
			untyped: true,
			Type: primBool,
			Constant: constant,
			Model: constant,
		}
	}

	fn _Reference(mut &self, mut &e: &eval, mut &fc: &ast::FuncCallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Args[0].Token, log::ArgumentOverflow, "Reference")
			ret nil
		}
		mut ref := false
		match type self.decl {
		| &Struct
		| &Func
		| &Enum
		| &TypeEnum
		| &Trait
		| &TypeAlias
		| &Field:
			e.pushErr(fc.Token, log::InvalidTypeForFunc, self.declAsStr(), "Reference")
			ret nil
		| &Var:
			v := self.decl.(&Var)
			if v.IsEnumField() {
				e.pushErr(fc.Token, log::InvalidTypeForFunc, self.declAsStr(), "Reference")
				ret nil
			}
			ref = v.Reference
		| &Param:
			ref = self.decl.(&Param).Reference
		|:
			panic("sema: comptimeDecl.Reference: unimplemented declaration kind")
		}
		mut constant := constant::Const.NewBool(ref)
		ret &Value{
			untyped: true,
			Type: primBool,
			Constant: constant,
			Model: constant,
		}
	}

	fn _Params(mut &self, mut &e: &eval, mut &fc: &ast::FuncCallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Args[0].Token, log::ArgumentOverflow, "Params")
			ret nil
		}
		match type self.decl {
		| &Struct
		| &Enum
		| &TypeEnum
		| &Trait
		| &TypeAlias
		| &Field
		| &Var
		| &Param:
			e.pushErr(fc.Token, log::InvalidTypeForFunc, self.declAsStr(), "Params")
			ret nil
		| &Func:
			mut f := self.decl.(&Func)
			mut params := make([]&comptimeDecl, len(f.Params))
			for (i, mut param) in f.Params {
				params[i] = &comptimeDecl{decl: param}
			}
			ret &Value{
				Type: &Type{
					Kind: &comptimeDecls{
						decls: params,
					},
				},
			}
		|:
			panic("sema: comptimeDecl.Params: unimplemented declaration kind")
		}
	}

	fn _Fields(mut &self, mut &e: &eval, mut &fc: &ast::FuncCallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Args[0].Token, log::ArgumentOverflow, "Fields")
			ret nil
		}
		mut fields := ([]&comptimeDecl)(nil)
		match type self.decl {
		| &TypeEnum
		| &Trait
		| &TypeAlias
		| &Field
		| &Var
		| &Param
		| &Func:
			e.pushErr(fc.Token, log::InvalidTypeForFunc, self.declAsStr(), "Fields")
			ret nil
		| &Enum:
			mut enm := self.decl.(&Enum)
			fields = make([]&comptimeDecl, len(enm.Items))
			for (i, mut item) in enm.Items {
				fields[i] = &comptimeDecl{decl: item}
			}
		| &Struct:
			mut s := self.decl.(&Struct)
			fields = make([]&comptimeDecl, len(s.Fields))
			for (i, mut field) in s.Fields {
				fields[i] = &comptimeDecl{decl: field}
			}
		|:
			panic("sema: comptimeDecl.Fields: unimplemented declaration kind")
		}
		ret &Value{
			Type: &Type{
				Kind: &comptimeDecls{
					decls: fields,
				},
			},
		}
	}

	fn _Methods(mut &self, mut &e: &eval, mut &fc: &ast::FuncCallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Args[0].Token, log::ArgumentOverflow, "Methods")
			ret nil
		}
		mut methods := ([]&comptimeDecl)(nil)
		match type self.decl {
		| &TypeEnum
		| &TypeAlias
		| &Field
		| &Var
		| &Param
		| &Func
		| &Enum:
			e.pushErr(fc.Token, log::InvalidTypeForFunc, self.declAsStr(), "Methods")
			ret nil
		| &Trait:
			mut t := self.decl.(&Trait)
			methods = make([]&comptimeDecl, len(t.Methods))
			for (i, mut method) in t.Methods {
				methods[i] = &comptimeDecl{decl: method}
			}
		| &Struct:
			mut s := self.decl.(&Struct)
			methods = make([]&comptimeDecl, len(s.Methods))
			for (i, mut method) in s.Methods {
				methods[i] = &comptimeDecl{decl: method}
			}
		|:
			panic("sema: comptimeDecl.Methods: unimplemented declaration kind")
		}
		ret &Value{
			Type: &Type{
				Kind: &comptimeDecls{
					decls: methods,
				},
			},
		}
	}

	fn _Tags(mut &self, mut &e: &eval, mut &fc: &ast::FuncCallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Args[0].Token, log::ArgumentOverflow, "Tags")
			ret nil
		}
		match type self.decl {
		| &Field:
			f := self.decl.(&Field)
			mut constant := constant::Const.NewI64(i64(len(f.Tags)))
			ret &Value{
				untyped: true,
				Type: primInt,
				Constant: constant,
				Model: constant,
			}
		|:
			e.pushErr(fc.Token, log::InvalidTypeForFunc, self.declAsStr(), "Tag")
			ret nil
		}
	}

	fn _Tag(mut &self, mut &e: &eval, mut &fc: &ast::FuncCallExpr): &Value {
		if len(fc.Args) > 1 {
			e.pushErr(fc.Args[1].Token, log::ArgumentOverflow, "Tag")
			ret nil
		}
		f, field := self.decl.(&Field)
		if !field {
			e.pushErr(fc.Token, log::InvalidTypeForFunc, self.declAsStr(), "Tag")
			ret nil
		}
		mut arg := fc.Args[0]
		mut v := e.evalExpr(arg, evalDefault)
		if v == nil {
			ret nil
		}
		if !v.IsConst() {
			e.pushErr(arg.Token, log::ExprNotConst)
			ret nil
		}
		prim := v.Type.Prim()
		if prim == nil || !prim.IsStr() {
			e.pushErr(arg.Token, log::IncompatibleTypes, str(types::Str), v.Type.Str())
			ret nil
		}
		key := v.Constant.ReadStr()
		value, _ := f.Tags[key]
		mut constant := constant::Const.NewStr(value)
		ret &Value{
			untyped: true,
			Type: primStr,
			Constant: constant,
			Model: constant,
		}
	}

	fn _IsTag(mut &self, mut &e: &eval, mut &fc: &ast::FuncCallExpr): &Value {
		if len(fc.Args) > 1 {
			e.pushErr(fc.Args[1].Token, log::ArgumentOverflow, "IsTag")
			ret nil
		}
		f, field := self.decl.(&Field)
		if !field {
			e.pushErr(fc.Token, log::InvalidTypeForFunc, self.declAsStr(), "IsTag")
			ret nil
		}
		mut arg := fc.Args[0]
		mut v := e.evalExpr(arg, evalDefault)
		if v == nil {
			ret nil
		}
		if !v.IsConst() {
			e.pushErr(arg.Token, log::ExprNotConst)
			ret nil
		}
		prim := v.Type.Prim()
		if prim == nil || !prim.IsStr() {
			e.pushErr(arg.Token, log::IncompatibleTypes, str(types::Str), v.Type.Str())
			ret nil
		}
		key := v.Constant.ReadStr()
		_, exist := f.Tags[key]
		mut constant := constant::Const.NewBool(exist)
		ret &Value{
			untyped: true,
			Type: primBool,
			Constant: constant,
			Model: constant,
		}
	}

	fn subIdent(mut &self, &ident: str): &Value {
		match ident {
		| "Name":
			mut method := &FuncIns{
				caller: fn(mut &e: &eval, mut &fc: &ast::FuncCallExpr, mut &_: &Value): &Value {
					ret self._Name(e, fc)
				},
			}
			ret buildAsComptimeMethodData(method)
		| "Public":
			mut method := &FuncIns{
				caller: fn(mut &e: &eval, mut &fc: &ast::FuncCallExpr, mut &_: &Value): &Value {
					ret self._Public(e, fc)
				},
			}
			ret buildAsComptimeMethodData(method)
		| "Binded":
			mut method := &FuncIns{
				caller: fn(mut &e: &eval, mut &fc: &ast::FuncCallExpr, mut &_: &Value): &Value {
					ret self._Binded(e, fc)
				},
			}
			ret buildAsComptimeMethodData(method)
		| "Exceptional":
			mut method := &FuncIns{
				caller: fn(mut &e: &eval, mut &fc: &ast::FuncCallExpr, mut &_: &Value): &Value {
					ret self._Exceptional(e, fc)
				},
			}
			ret buildAsComptimeMethodData(method)
		| "Mutable":
			mut method := &FuncIns{
				caller: fn(mut &e: &eval, mut &fc: &ast::FuncCallExpr, mut &_: &Value): &Value {
					ret self._Mutable(e, fc)
				},
			}
			ret buildAsComptimeMethodData(method)
		| "Variadic":
			mut method := &FuncIns{
				caller: fn(mut &e: &eval, mut &fc: &ast::FuncCallExpr, mut &_: &Value): &Value {
					ret self._Variadic(e, fc)
				},
			}
			ret buildAsComptimeMethodData(method)
		| "Reference":
			mut method := &FuncIns{
				caller: fn(mut &e: &eval, mut &fc: &ast::FuncCallExpr, mut &_: &Value): &Value {
					ret self._Reference(e, fc)
				},
			}
			ret buildAsComptimeMethodData(method)
		| "Params":
			mut method := &FuncIns{
				caller: fn(mut &e: &eval, mut &fc: &ast::FuncCallExpr, mut &_: &Value): &Value {
					ret self._Params(e, fc)
				},
			}
			ret buildAsComptimeMethodData(method)
		| "Fields":
			mut method := &FuncIns{
				caller: fn(mut &e: &eval, mut &fc: &ast::FuncCallExpr, mut &_: &Value): &Value {
					ret self._Fields(e, fc)
				},
			}
			ret buildAsComptimeMethodData(method)
		| "Methods":
			mut method := &FuncIns{
				caller: fn(mut &e: &eval, mut &fc: &ast::FuncCallExpr, mut &_: &Value): &Value {
					ret self._Methods(e, fc)
				},
			}
			ret buildAsComptimeMethodData(method)
		| "Tags":
			mut method := &FuncIns{
				caller: fn(mut &e: &eval, mut &fc: &ast::FuncCallExpr, mut &_: &Value): &Value {
					ret self._Tags(e, fc)
				},
			}
			ret buildAsComptimeMethodData(method)
		| "Tag":
			mut method := &FuncIns{
				caller: fn(mut &e: &eval, mut &fc: &ast::FuncCallExpr, mut &_: &Value): &Value {
					ret self._Tag(e, fc)
				},
			}
			ret buildAsComptimeMethodData(method)
		| "IsTag":
			mut method := &FuncIns{
				caller: fn(mut &e: &eval, mut &fc: &ast::FuncCallExpr, mut &_: &Value): &Value {
					ret self._IsTag(e, fc)
				},
			}
			ret buildAsComptimeMethodData(method)
		|:
			ret nil
		}
	}
}

struct comptimeSliceRange {
	s: &SliceExpr
}

impl comptimeRangeKind for comptimeSliceRange {
	fn ready(mut self, mut &keyA: &Var, mut &keyB: &Var) {
		if keyA != nil {
			keyA.Constant = true
			keyA.ValueSym = &ValueSym{
				Value: new(Value),
			}
			keyA.TypeSym = findBuiltinTypeAlias(types::Int).TypeSym
		}
		if keyB != nil {
			keyB.Constant = true
			keyB.ValueSym = &ValueSym{
				Value: new(Value),
			}
			keyB.TypeSym = &TypeSym{
				Type: self.s.ElemType,
			}
		}
	}

	fn index(mut self, mut &v: &Value, i: int) {
		panic("sema: index method of comptimeSliceRange should not be used")
	}

	fn step(mut self, i: int, mut &keyA: &Var, mut &keyB: &Var) {
		if keyA != nil {
			// Kind should be assigned by caller.
			keyA.ValueSym.Value.Constant = constant::Const.NewI64(i64(i))
			keyA.ValueSym.Value.Model = keyA.ValueSym.Value.Constant
		}
		if keyB != nil {
			// Kind should be assigned by caller.
			keyB.ValueSym.Value = self.s.Elems[i]
		}
	}

	fn len(self): int {
		ret len(self.s.Elems)
	}
}

fn buildAsComptimeMethodData(mut &f: &FuncIns): &Value {
	ret &Value{
		Type: &Type{
			Kind: f,
		},
	}
}

fn findComptimePackage(mut &s: &sema): &ImportInfo {
	ret s.SelectPackage(fn(pkg: &ImportInfo): bool {
		ret pkg.LinkPath == "std/comptime"
	})
}

fn buildComptimeTypeInfoData(mut &s: &sema, mut &t: &Type): &Value {
	ret &Value{
		Type: &Type{
			Kind: s.meta.pushComptimeTypeInfo(t),
		},
	}
}

fn buildComptimeValue(mut &v: &Value): &Value {
	ret &Value{
		Type: &Type{
			Kind: &comptimeValue{
				v: v,
			},
		},
	}
}
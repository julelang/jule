// Copyright 2024 The Jule Authors. All rights reserved.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/comptime"
use "std/conv"
use "std/jule/ast"
use "std/jule/build"
use "std/jule/constant"
use "std/jule/log"
use "std/jule/token"
use "std/jule/types"

// All comptime-structure methods starts with underscore (_).

trait comptimeRangeKind {
	fn index(mut *self, mut v: &Value, i: int)
	fn ready(mut *self, mut keyA: &Var, mut keyB: &Var)
	fn step(mut *self, i: int, mut keyA: &Var, mut keyB: &Var)
	fn len(*self): int
}

// Compile-time ranges.
struct comptimeRange {
	kind: comptimeRangeKind
}

impl Kind for comptimeRange {
	fn Str(*self): str { ret "comptimeRange" }
	fn Equal(&self, other: &Type): bool { ret false }
}

// Compile-time field for structure.
struct comptimeStructField {
	field: &FieldIns
}

impl Kind for comptimeStructField {
	fn Str(*self): str { ret "comptimeStructField" }
	fn Equal(&self, other: &Type): bool { ret false }
}

impl comptimeStructField {
	fn _Decl(mut &self, mut e: &eval, mut fc: &ast::CallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Token, "passed more argument than expected to Decl")
			e.pushSuggestion("call like; Decl()")
			ret nil
		}
		ret &Value{
			Type: &Type{
				Kind: &comptimeDecl{decl: self.field.Decl},
			},
		}
	}

	fn _Type(mut &self, mut e: &eval, mut fc: &ast::CallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Token, "passed more argument than expected to Type")
			e.pushSuggestion("call like; Type()")
			ret nil
		}
		ret buildComptimeTypeInfoData(e.s, self.field.Type)
	}

	fn subIdent(mut &self, name: str): &Value {
		match name {
		| "Decl":
			mut method := &FuncIns{
				caller: fn|mut e, mut fc, _| self._Decl(e, fc),
			}
			ret buildAsComptimeMethodData(method)
		| "Type":
			mut method := &FuncIns{
				caller: fn|mut e, mut fc, _| self._Type(e, fc),
			}
			ret buildAsComptimeMethodData(method)
		|:
			ret nil
		}
	}
}

// Compile-time fields range for structure.
struct comptimeStructFields {
	fields: []&FieldIns
}

impl Kind for comptimeStructFields {
	fn Str(*self): str { ret "comptimeStructFields" }
	fn Equal(&self, other: &Type): bool { ret false }
}

impl comptimeRangeKind for comptimeStructFields {
	fn ready(mut *self, mut keyA: &Var, mut keyB: &Var) {
		if keyA != nil {
			keyA.Constant = true
			keyA.ValueSym = &ValueSym{
				Value: new(Value),
			}
			keyA.TypeSym = findBuiltinTypeAlias(types::Int).TypeSym
		}
		if keyB != nil {
			keyB.Constant = true
			keyB.ValueSym = &ValueSym{
				Value: new(Value),
			}
			keyB.TypeSym = &TypeSym{
				Type: &Type{
					Kind: new(comptimeStructField),
				},
			}
		}
	}

	fn index(mut *self, mut v: &Value, i: int) {
		v.Decl = false
		v.untyped = false
		v.Constant = nil
		v.Type = &Type{
			Kind: &comptimeStructField{
				field: self.fields[i],
			},
		}
	}

	fn step(mut *self, i: int, mut keyA: &Var, mut keyB: &Var) {
		if keyA != nil {
			// Kind should be assigned by caller.
			keyA.ValueSym.Value.Constant = constant::NewI64(i64(i))
			keyA.ValueSym.Value.Model = keyA.ValueSym.Value.Constant
		}
		if keyB != nil {
			// Kind should be assigned by caller.
			keyB.TypeSym.Type.comptimeStructField().field = self.fields[i]
		}
	}

	fn len(*self): int {
		ret len(self.fields)
	}
}

// Compile-time static field for structure.
struct comptimeStatic {
	field: &Var
}

impl Kind for comptimeStatic {
	fn Str(*self): str { ret "comptimeStatic" }
	fn Equal(&self, other: &Type): bool { ret false }
}

impl comptimeStatic {
	fn _Decl(mut &self, mut e: &eval, mut fc: &ast::CallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Token, "passed more argument than expected to Decl")
			e.pushSuggestion("call like; Decl()")
			ret nil
		}
		ret &Value{
			Type: &Type{
				Kind: &comptimeDecl{decl: self.field},
			},
		}
	}

	fn _Type(mut &self, mut e: &eval, mut fc: &ast::CallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Token, "passed more argument than expected to Type")
			e.pushSuggestion("call like; Type()")
			ret nil
		}
		ret buildComptimeTypeInfoData(e.s, self.field.TypeSym.Type)
	}

	fn subIdent(mut &self, name: str): &Value {
		match name {
		| "Decl":
			mut method := &FuncIns{
				caller: fn|mut e, mut fc, _| self._Decl(e, fc),
			}
			ret buildAsComptimeMethodData(method)
		| "Type":
			mut method := &FuncIns{
				caller: fn|mut e, mut fc, _| self._Type(e, fc),
			}
			ret buildAsComptimeMethodData(method)
		|:
			ret nil
		}
	}
}

// Compile-time static fields range for structure.
struct comptimeStatics {
	fields: []&Var
}

impl Kind for comptimeStatics {
	fn Str(*self): str { ret "comptimeStatics" }
	fn Equal(&self, other: &Type): bool { ret false }
}

impl comptimeRangeKind for comptimeStatics {
	fn ready(mut *self, mut keyA: &Var, mut keyB: &Var) {
		if keyA != nil {
			keyA.Constant = true
			keyA.ValueSym = &ValueSym{
				Value: new(Value),
			}
			keyA.TypeSym = findBuiltinTypeAlias(types::Int).TypeSym
		}
		if keyB != nil {
			keyB.Constant = true
			keyB.ValueSym = &ValueSym{
				Value: new(Value),
			}
			keyB.TypeSym = &TypeSym{
				Type: &Type{
					Kind: new(comptimeStatic),
				},
			}
		}
	}

	fn index(mut *self, mut v: &Value, i: int) {
		v.Decl = false
		v.untyped = false
		v.Constant = nil
		v.Type = &Type{
			Kind: &comptimeStatic{
				field: self.fields[i],
			},
		}
	}

	fn step(mut *self, i: int, mut keyA: &Var, mut keyB: &Var) {
		if keyA != nil {
			// Kind should be assigned by caller.
			keyA.ValueSym.Value.Constant = constant::NewI64(i64(i))
			keyA.ValueSym.Value.Model = keyA.ValueSym.Value.Constant
		}
		if keyB != nil {
			// Kind should be assigned by caller.
			keyB.TypeSym.Type.comptimeStatic().field = self.fields[i]
		}
	}

	fn len(*self): int {
		ret len(self.fields)
	}
}

// Compile-time field for enum.
struct comptimeEnumField {
	field: &Var
}

impl Kind for comptimeEnumField {
	fn Str(*self): str { ret "comptimeEnumField" }
	fn Equal(&self, other: &Type): bool { ret false }
}

impl comptimeEnumField {
	fn _Decl(mut &self, mut e: &eval, mut fc: &ast::CallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Token, "passed more argument than expected to Decl")
			e.pushSuggestion("call like; Decl()")
			ret nil
		}
		ret &Value{
			Type: &Type{
				Kind: &comptimeDecl{decl: self.field},
			},
		}
	}

	fn subIdent(mut &self, name: str): &Value {
		match name {
		| "Decl":
			mut method := &FuncIns{
				caller: fn|mut e, mut fc, _| self._Decl(e, fc),
			}
			ret buildAsComptimeMethodData(method)
		|:
			ret nil
		}
	}
}

// Compile-time fields range for enum.
struct comptimeEnumFields {
	fields: []&Var
}

impl Kind for comptimeEnumFields {
	fn Str(*self): str { ret "comptimeEnumFields" }
	fn Equal(&self, other: &Type): bool { ret false }
}

impl comptimeRangeKind for comptimeEnumFields {
	fn ready(mut *self, mut keyA: &Var, mut keyB: &Var) {
		if keyA != nil {
			keyA.Constant = true
			keyA.ValueSym = &ValueSym{
				Value: new(Value),
			}
			keyA.TypeSym = findBuiltinTypeAlias(types::Int).TypeSym
		}
		if keyB != nil {
			keyB.Constant = true
			keyB.ValueSym = &ValueSym{
				Value: new(Value),
			}
			keyB.TypeSym = &TypeSym{
				Type: &Type{
					Kind: new(comptimeEnumField),
				},
			}
		}
	}

	fn index(mut *self, mut v: &Value, i: int) {
		v.Decl = false
		v.untyped = false
		v.Constant = nil
		v.Type = &Type{
			Kind: &comptimeEnumField{
				field: self.fields[i],
			},
		}
	}

	fn step(mut *self, i: int, mut keyA: &Var, mut keyB: &Var) {
		if keyA != nil {
			// Kind should be assigned by caller.
			keyA.ValueSym.Value.Constant = constant::NewI64(i64(i))
			keyA.ValueSym.Value.Model = keyA.ValueSym.Value.Constant
		}
		if keyB != nil {
			// Kind should be assigned by caller.
			keyB.TypeSym.Type.comptimeEnumField().field = self.fields[i]
		}
	}

	fn len(*self): int {
		ret len(self.fields)
	}
}

// Compile-time parameter for functions.
struct comptimeParam {
	param: &ParamIns
}

impl Kind for comptimeParam {
	fn Str(*self): str { ret "comptimeParam" }
	fn Equal(&self, other: &Type): bool { ret false }
}

impl comptimeParam {
	fn _Decl(mut &self, mut e: &eval, mut fc: &ast::CallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Token, "passed more argument than expected to Decl")
			e.pushSuggestion("call like; Decl()")
			ret nil
		}
		ret &Value{
			Type: &Type{
				Kind: &comptimeDecl{decl: self.param.Decl},
			},
		}
	}

	fn _Type(mut &self, mut e: &eval, mut fc: &ast::CallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Token, "passed more argument than expected to Type")
			e.pushSuggestion("call like; Type()")
			ret nil
		}
		ret buildComptimeTypeInfoData(e.s, self.param.Type)
	}

	fn _Recv(mut &self, mut e: &eval, mut fc: &ast::CallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Token, "passed more argument than expected to Recv")
			e.pushSuggestion("call like; Recv()")
			ret nil
		}
		mut constant := constant::NewBool(self.param.Decl.IsSelf())
		ret &Value{
			untyped: true,
			Type: primBool,
			Constant: constant,
			Model: constant,
		}
	}

	fn subIdent(mut &self, name: str): &Value {
		match name {
		| "Decl":
			mut method := &FuncIns{
				caller: fn|mut e, mut fc, _| self._Decl(e, fc),
			}
			ret buildAsComptimeMethodData(method)
		| "Recv":
			mut method := &FuncIns{
				caller: fn|mut e, mut fc, _| self._Recv(e, fc),
			}
			ret buildAsComptimeMethodData(method)
		| "Type":
			mut method := &FuncIns{
				caller: fn|mut e, mut fc, _| self._Type(e, fc),
			}
			ret buildAsComptimeMethodData(method)
		|:
			ret nil
		}
	}
}

// Compile-time parameters range for function.
struct comptimeParams {
	params: []&ParamIns
}

impl Kind for comptimeParams {
	fn Str(*self): str { ret "comptimeParams" }
	fn Equal(&self, other: &Type): bool { ret false }
}

impl comptimeRangeKind for comptimeParams {
	fn ready(mut *self, mut keyA: &Var, mut keyB: &Var) {
		if keyA != nil {
			keyA.Constant = true
			keyA.ValueSym = &ValueSym{
				Value: new(Value),
			}
			keyA.TypeSym = findBuiltinTypeAlias(types::Int).TypeSym
		}
		if keyB != nil {
			keyB.Constant = true
			keyB.ValueSym = &ValueSym{
				Value: new(Value),
			}
			keyB.TypeSym = &TypeSym{
				Type: &Type{
					Kind: new(comptimeParam),
				},
			}
		}
	}

	fn index(mut *self, mut v: &Value, i: int) {
		v.Decl = false
		v.untyped = false
		v.Constant = nil
		v.Type = &Type{
			Kind: &comptimeParam{
				param: self.params[i],
			},
		}
	}

	fn step(mut *self, i: int, mut keyA: &Var, mut keyB: &Var) {
		if keyA != nil {
			// Kind should be assigned by caller.
			keyA.ValueSym.Value.Constant = constant::NewI64(i64(i))
			keyA.ValueSym.Value.Model = keyA.ValueSym.Value.Constant
		}
		if keyB != nil {
			// Kind should be assigned by caller.
			keyB.TypeSym.Type.comptimeParam().param = self.params[i]
		}
	}

	fn len(*self): int {
		ret len(self.params)
	}
}

// Compile-time type info range.
struct comptimeTypeInfos {
	types: []&comptimeTypeInfo
}

impl Kind for comptimeTypeInfos {
	fn Str(*self): str { ret "comptimeTypeInfos" }
	fn Equal(&self, other: &Type): bool { ret false }
}

impl comptimeRangeKind for comptimeTypeInfos {
	fn ready(mut *self, mut keyA: &Var, mut keyB: &Var) {
		if keyA != nil {
			keyA.Constant = true
			keyA.ValueSym = &ValueSym{
				Value: new(Value),
			}
			keyA.TypeSym = findBuiltinTypeAlias(types::Int).TypeSym
		}
		if keyB != nil {
			keyB.Constant = true
			keyB.ValueSym = &ValueSym{
				Value: new(Value),
			}
			keyB.TypeSym = &TypeSym{
				Type: &Type{
					Kind: new(comptimeTypeInfo),
				},
			}
		}
	}

	fn index(mut *self, mut v: &Value, i: int) {
		v.Decl = false
		v.untyped = false
		v.Constant = nil
		v.Type = &Type{
			Kind: self.types[i],
		}
	}

	fn step(mut *self, i: int, mut keyA: &Var, mut keyB: &Var) {
		if keyA != nil {
			// Kind should be assigned by caller.
			keyA.ValueSym.Value.Constant = constant::NewI64(i64(i))
			keyA.ValueSym.Value.Model = keyA.ValueSym.Value.Constant
		}
		if keyB != nil {
			// Kind should be assigned by caller.
			keyB.TypeSym.Type.Kind = self.types[i]
		}
	}

	fn len(*self): int {
		ret len(self.types)
	}
}

// Compile-time type information data.
struct comptimeTypeInfo {
	base: &Type
}

impl Kind for comptimeTypeInfo {
	fn Str(*self): str { ret "comptimeTypeInfo[" + self.base.Str() + "]" }
	fn Equal(&self, other: &Type): bool { ret false }
}

impl comptimeTypeInfo {
	fn _Hash(&self, mut e: &eval, mut fc: &ast::CallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Token, "passed more argument than expected to Hash")
			e.pushSuggestion("call like; Hash()")
			ret nil
		}
		mut constant := constant::NewU64(u64(uintptr(self)))
		constant.Kind = types::Uintptr
		ret &Value{
			untyped: false,
			Type: primUintptr,
			Constant: constant,
			Model: constant,
		}
	}

	fn _Decl(mut &self, mut e: &eval, mut fc: &ast::CallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Token, "passed more argument than expected to Decl")
			e.pushSuggestion("call like; Decl()")
			ret nil
		}
		mut decl := comptimeDeclType(nil)
		match {
		| self.base.SoftStruct() != nil:
			decl = self.base.SoftStruct().Decl
		| self.base.Trait() != nil:
			decl = self.base.Trait()
		| self.base.Enum() != nil:
			decl = self.base.Enum()
		| self.base.TypeEnum() != nil:
			decl = self.base.TypeEnum()
		| self.base.Func() != nil:
			mut f := self.base.Func()
			match {
			| f.IsBuiltin():
				e.pushErr(fc.Args[0].Token, "type @ is invalid for built-in function", self.base.Str())
				ret nil
			| f.IsAnon():
				e.pushErr(fc.Args[0].Token, "type @ is invalid for anonymous function", self.base.Str())
				ret nil
			}
			decl = f.Decl
		|:
			e.pushErr(fc.Args[0].Token, "type @ is invalid for function Decl", self.base.Str())
			ret nil
		}
		ret &Value{
			Type: &Type{
				Kind: &comptimeDecl{decl: decl},
			},
		}
	}

	fn _Str(&self, mut e: &eval, mut fc: &ast::CallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Token, "passed more argument than expected to Str")
			e.pushSuggestion("call like; Str()")
			ret nil
		}
		mut constant := constant::NewStr(self.base.Str())
		ret &Value{
			untyped: true,
			Type: primStr,
			Constant: constant,
			Model: constant,
		}
	}

	fn _Kind(mut &self, mut e: &eval, mut fc: &ast::CallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Token, "passed more argument than expected to Kind")
			e.pushSuggestion("call like; Kind()")
			ret nil
		}
		let mut c: &constant::Const
		match {
		| self.base.Void():
			c = constant::NewI64(comptime::Void)
		| self.base.Struct() != nil:
			c = constant::NewI64(comptime::Struct)
		| self.base.Trait() != nil:
			c = constant::NewI64(comptime::Trait)
		| self.base.Ptr() != nil:
			if self.base.Ptr().IsUnsafe() {
				c = constant::NewI64(comptime::Unsafeptr)
			} else {
				c = constant::NewI64(comptime::Ptr)
			}
		| self.base.Sptr() != nil:
			c = constant::NewI64(comptime::Smartptr)
		| self.base.Enum() != nil:
			c = constant::NewI64(comptime::Enum)
		| self.base.TypeEnum() != nil:
			c = constant::NewI64(comptime::TypeEnum)
		| self.base.Map() != nil:
			c = constant::NewI64(comptime::Map)
		| self.base.Slice() != nil:
			c = constant::NewI64(comptime::Slice)
		| self.base.Array() != nil:
			c = constant::NewI64(comptime::Array)
		| self.base.Func() != nil:
			c = constant::NewI64(comptime::Func)
		| self.base.Tuple() != nil:
			c = constant::NewI64(comptime::Tuple)
		| self.base.Chan() != nil:
			c = constant::NewI64(comptime::Chan)
		| self.base.Prim() != nil:
			prim := self.base.Prim()
			match {
			| prim.IsAny():
				c = constant::NewI64(comptime::Any)
			| prim.IsBool():
				c = constant::NewI64(comptime::Bool)
			| prim.IsStr():
				c = constant::NewI64(comptime::Str)
			| prim.IsF32():
				c = constant::NewI64(comptime::F32)
			| prim.IsF64():
				c = constant::NewI64(comptime::F64)
			| prim.IsCmplx64():
				c = constant::NewI64(comptime::Cmplx64)
			| prim.IsCmplx128():
				c = constant::NewI64(comptime::Cmplx128)
			| prim.IsI8():
				c = constant::NewI64(comptime::I8)
			| prim.IsI16():
				c = constant::NewI64(comptime::I16)
			| prim.IsI32():
				c = constant::NewI64(comptime::I32)
			| prim.IsI64():
				c = constant::NewI64(comptime::I64)
			| prim.IsU8():
				c = constant::NewI64(comptime::U8)
			| prim.IsU16():
				c = constant::NewI64(comptime::U16)
			| prim.IsU32():
				c = constant::NewI64(comptime::U32)
			| prim.IsU64():
				c = constant::NewI64(comptime::U64)
			| prim.IsInt():
				c = constant::NewI64(comptime::Int)
			| prim.IsUint():
				c = constant::NewI64(comptime::Uint)
			| prim.IsUintptr():
				c = constant::NewI64(comptime::Uintptr)
			}
		}
		if c == nil {
			panic("sema: Kind(): unimplemented type for comptime: " + self.base.Str())
		}
		ret &Value{
			untyped: true,
			Type: primInt,
			Constant: c,
			Model: c,
		}
	}

	fn _Bits(mut &self, mut e: &eval, mut fc: &ast::CallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Token, "passed more argument than expected to Bits")
			e.pushSuggestion("call like; Bits()")
			ret nil
		}
		prim := self.base.Prim()
		if prim == nil {
			e.pushErr(fc.Args[0].Token, "type @ is invalid for function Bits", self.base.Str())
			ret nil
		}
		n := types::BitSizeOf(prim.Kind)
		if n == -1 {
			e.pushErr(fc.Args[0].Token, "type @ is invalid for function Bits", self.base.Str())
			ret nil
		}
		mut constant := constant::NewI64(i64(n))
		ret &Value{
			untyped: true,
			Type: primInt,
			Constant: constant,
			Model: constant,
		}
	}

	fn _Value(mut &self, mut e: &eval, mut fc: &ast::CallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Token, "passed more argument than expected to Value")
			e.pushSuggestion("call like; Value()")
			ret nil
		}
		mut ptr := self.base.Ptr()
		if ptr != nil {
			if ptr.IsUnsafe() {
				e.pushErr(fc.Args[0].Token, "type @ is invalid for function Value", self.base.Str())
				ret nil
			}
			ret buildComptimeTypeInfoData(e.s, ptr.Value)
		}
		mut sptr := self.base.Sptr()
		if sptr != nil {
			ret buildComptimeTypeInfoData(e.s, sptr.Value)
		}
		mut slice := self.base.Slice()
		if slice != nil {
			ret buildComptimeTypeInfoData(e.s, slice.Value)
		}
		mut array := self.base.Array()
		if array != nil {
			ret buildComptimeTypeInfoData(e.s, array.Value)
		}
		mut c := self.base.Chan()
		if c != nil {
			ret buildComptimeTypeInfoData(e.s, c.Value)
		}
		mut enm := self.base.Enum()
		if enm != nil {
			ret buildComptimeTypeInfoData(e.s, enm.TypeSym.Type)
		}
		mut m := self.base.Map()
		if m != nil {
			ret buildComptimeTypeInfoData(e.s, m.Value)
		}
		e.pushErr(fc.Args[0].Token, "type @ is invalid for function Value", self.base.Str())
		ret nil
	}

	fn _Size(mut &self, mut e: &eval, mut fc: &ast::CallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Token, "passed more argument than expected to Size")
			e.pushSuggestion("call like; Size()")
			ret nil
		}
		mut arr := self.base.Array()
		if arr == nil {
			e.pushErr(fc.Args[0].Token, "type @ is invalid for function Size", self.base.Str())
			ret nil
		}
		mut constant := constant::NewI64(i64(arr.N))
		ret &Value{
			untyped: true,
			Type: primInt,
			Constant: constant,
			Model: constant,
		}
	}

	fn _Key(mut &self, mut e: &eval, mut fc: &ast::CallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Token, "passed more argument than expected to Key")
			e.pushSuggestion("call like; Key()")
			ret nil
		}
		mut m := self.base.Map()
		if m == nil {
			e.pushErr(fc.Args[0].Token, "type @ is invalid for function Key", self.base.Str())
			ret nil
		}
		ret buildComptimeTypeInfoData(e.s, m.Key)
	}

	fn _Fields(mut &self, mut e: &eval, mut fc: &ast::CallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Token, "passed more argument than expected to Fields")
			e.pushSuggestion("call like; Fields()")
			ret nil
		}
		mut s := self.base.Struct()
		if s != nil {
			ret &Value{
				Type: &Type{
					Kind: &comptimeStructFields{
						fields: s.Fields,
					},
				},
			}
		}
		mut enm := self.base.Enum()
		if enm != nil {
			ret &Value{
				Type: &Type{
					Kind: &comptimeEnumFields{
						fields: enm.Items,
					},
				},
			}
		}
		e.pushErr(fc.Args[0].Token, "type @ is invalid for function Fields", self.base.Str())
		ret nil
	}

	fn _Extern(mut &self, mut e: &eval, mut fc: &ast::CallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Token, "passed more argument than expected to Extern")
			e.pushSuggestion("call like; Extern()")
			ret nil
		}
		mut constant := constant::NewBool(self.base.Extern())
		ret &Value{
			untyped: true,
			Type: primBool,
			Constant: constant,
			Model: constant,
		}
	}

	fn _Ordered(&self, mut e: &eval, mut fc: &ast::CallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Token, "passed more argument than expected to Ordered")
			e.pushSuggestion("call like; Ordered()")
			ret nil
		}
		mut constant := constant::NewBool(self.base.Ordered())
		ret &Value{
			untyped: true,
			Type: primBool,
			Constant: constant,
			Model: constant,
		}
	}

	fn _Comparable(&self, mut e: &eval, mut fc: &ast::CallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Token, "passed more argument than expected to Comparable")
			e.pushSuggestion("call like; Comparable()")
			ret nil
		}
		mut constant := constant::NewBool(self.base.Comparable())
		ret &Value{
			untyped: true,
			Type: primBool,
			Constant: constant,
			Model: constant,
		}
	}

	fn _Mutable(&self, mut e: &eval, mut fc: &ast::CallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Token, "passed more argument than expected to Mutable")
			e.pushSuggestion("call like; Mutable()")
			ret nil
		}
		mut constant := constant::NewBool(self.base.Mutable())
		ret &Value{
			untyped: true,
			Type: primBool,
			Constant: constant,
			Model: constant,
		}
	}

	fn _Types(mut &self, mut e: &eval, mut fc: &ast::CallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Token, "passed more argument than expected to Types")
			e.pushSuggestion("call like; Types()")
			ret nil
		}
		mut tup := self.base.Tuple()
		if tup == nil {
			e.pushErr(fc.Args[0].Token, "type @ is invalid for function Types", self.base.Str())
			ret nil
		}
		mut infos := &comptimeTypeInfos{
			types: make([]&comptimeTypeInfo, 0, len(tup.Types)),
		}
		for (_, mut t) in tup.Types {
			infos.types = append(infos.types, e.s.meta.pushComptimeTypeInfo(t))
		}
		ret &Value{
			Type: &Type{
				Kind: infos,
			},
		}
	}

	fn _CanNil(mut &self, mut e: &eval, mut fc: &ast::CallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Token, "passed more argument than expected to CanNil")
			e.pushSuggestion("call like; CanNil()")
			ret nil
		}
		mut constant := constant::NewBool(self.base.NilCompatible())
		ret &Value{
			untyped: true,
			Type: primBool,
			Constant: constant,
			Model: constant,
		}
	}

	fn _GC(mut &self, mut e: &eval, mut fc: &ast::CallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Token, "passed more argument than expected to GC")
			e.pushSuggestion("call like; GC()")
			ret nil
		}
		mut constant := constant::NewBool(self.base.GC())
		ret &Value{
			untyped: true,
			Type: primBool,
			Constant: constant,
			Model: constant,
		}
	}

	fn _Result(mut &self, mut e: &eval, mut fc: &ast::CallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Token, "passed more argument than expected to Result")
			e.pushSuggestion("call like; Result()")
			ret nil
		}
		mut f := self.base.Func()
		if f == nil {
			e.pushErr(fc.Args[0].Token, "type @ is invalid for function Result", self.base.Str())
			ret nil
		}
		if f.Result == nil {
			ret buildComptimeTypeInfoData(e.s, primVoid)
		}
		ret buildComptimeTypeInfoData(e.s, f.Result)
	}

	fn _Params(mut &self, mut e: &eval, mut fc: &ast::CallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Token, "passed more argument than expected to Params")
			e.pushSuggestion("call like; Params()")
			ret nil
		}
		mut f := self.base.Func()
		if f == nil {
			e.pushErr(fc.Args[0].Token, "type @ is invalid for function Params", self.base.Str())
			ret nil
		}
		ret &Value{
			Type: &Type{
				Kind: &comptimeParams{params: f.Params},
			},
		}
	}

	fn _Strict(mut &self, mut e: &eval, mut fc: &ast::CallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Token, "passed more argument than expected to Strict")
			e.pushSuggestion("call like; Strict()")
			ret nil
		}
		s := self.base.SoftStruct()
		mut constant := constant::NewBool(s != nil && s.Source != nil)
		ret &Value{
			untyped: true,
			Type: primBool,
			Constant: constant,
			Model: constant,
		}
	}

	fn _Source(mut &self, mut e: &eval, mut fc: &ast::CallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Token, "passed more argument than expected to Source")
			e.pushSuggestion("call like; Source()")
			ret nil
		}
		mut s := self.base.SoftStruct()
		isStrict := s != nil && s.Source != nil
		if !isStrict {
			e.pushErr(fc.Args[0].Token, "type @ is invalid for function Source", self.base.Str())
			ret nil
		}
		ret buildComptimeTypeInfoData(e.s, s.Source)
	}

	fn _ActualSource(mut &self, mut e: &eval, mut fc: &ast::CallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Token, "passed more argument than expected to ActualSource")
			e.pushSuggestion("call like; ActualSource()")
			ret nil
		}
		s := self.base.SoftStruct()
		isStrict := s != nil && s.Source != nil
		if !isStrict {
			e.pushErr(fc.Args[0].Token, "type @ is invalid for function ActualSource", self.base.Str())
			ret nil
		}
		mut t := &Type{Kind: self.base.ActualKind()}
		ret buildComptimeTypeInfoData(e.s, t)
	}

	fn subIdent(mut &self, name: str): &Value {
		match name {
		| "Hash":
			mut method := &FuncIns{
				caller: fn|mut e, mut fc, _| self._Hash(e, fc),
			}
			ret buildAsComptimeMethodData(method)
		| "Source":
			mut method := &FuncIns{
				caller: fn|mut e, mut fc, _| self._Source(e, fc),
			}
			ret buildAsComptimeMethodData(method)
		| "ActualSource":
			mut method := &FuncIns{
				caller: fn|mut e, mut fc, _| self._ActualSource(e, fc),
			}
			ret buildAsComptimeMethodData(method)
		| "Strict":
			mut method := &FuncIns{
				caller: fn|mut e, mut fc, _| self._Strict(e, fc),
			}
			ret buildAsComptimeMethodData(method)
		| "Decl":
			mut method := &FuncIns{
				caller: fn|mut e, mut fc, _| self._Decl(e, fc),
			}
			ret buildAsComptimeMethodData(method)
		| "Str":
			mut method := &FuncIns{
				caller: fn|mut e, mut fc, _| self._Str(e, fc),
			}
			ret buildAsComptimeMethodData(method)
		| "Bits":
			mut method := &FuncIns{
				caller: fn|mut e, mut fc, _| self._Bits(e, fc),
			}
			ret buildAsComptimeMethodData(method)
		| "Size":
			mut method := &FuncIns{
				caller: fn|mut e, mut fc, _| self._Size(e, fc),
			}
			ret buildAsComptimeMethodData(method)
		| "Key":
			mut method := &FuncIns{
				caller: fn|mut e, mut fc, _| self._Key(e, fc),
			}
			ret buildAsComptimeMethodData(method)
		| "Value":
			mut method := &FuncIns{
				caller: fn|mut e, mut fc, _| self._Value(e, fc),
			}
			ret buildAsComptimeMethodData(method)
		| "Fields":
			mut method := &FuncIns{
				caller: fn|mut e, mut fc, _| self._Fields(e, fc),
			}
			ret buildAsComptimeMethodData(method)
		| "Params":
			mut method := &FuncIns{
				caller: fn|mut e, mut fc, _| self._Params(e, fc),
			}
			ret buildAsComptimeMethodData(method)
		| "Types":
			mut method := &FuncIns{
				caller: fn|mut e, mut fc, _| self._Types(e, fc),
			}
			ret buildAsComptimeMethodData(method)
		| "Extern":
			mut method := &FuncIns{
				caller: fn|mut e, mut fc, _| self._Extern(e, fc),
			}
			ret buildAsComptimeMethodData(method)
		| "Ordered":
			mut method := &FuncIns{
				caller: fn|mut e, mut fc, _| self._Ordered(e, fc),
			}
			ret buildAsComptimeMethodData(method)
		| "Comparable":
			mut method := &FuncIns{
				caller: fn|mut e, mut fc, _| self._Comparable(e, fc),
			}
			ret buildAsComptimeMethodData(method)
		| "Mutable":
			mut method := &FuncIns{
				caller: fn|mut e, mut fc, _| self._Mutable(e, fc),
			}
			ret buildAsComptimeMethodData(method)
		| "CanNil":
			mut method := &FuncIns{
				caller: fn|mut e, mut fc, _| self._CanNil(e, fc),
			}
			ret buildAsComptimeMethodData(method)
		| "GC":
			mut method := &FuncIns{
				caller: fn|mut e, mut fc, _| self._GC(e, fc),
			}
			ret buildAsComptimeMethodData(method)
		| "Result":
			mut method := &FuncIns{
				caller: fn|mut e, mut fc, _| self._Result(e, fc),
			}
			ret buildAsComptimeMethodData(method)
		| "Kind":
			mut method := &FuncIns{
				caller: fn|mut e, mut fc, _| self._Kind(e, fc),
			}
			ret buildAsComptimeMethodData(method)
		|:
			ret nil
		}
	}
}

// Compile-time value information data.
struct comptimeValue {
	v: &Value
}

impl Kind for comptimeValue {
	fn Str(*self): str { ret "comptimeValue" }
	fn Equal(&self, other: &Type): bool { ret false }
}

impl comptimeValue {
	fn _Unwrap(mut &self, mut e: &eval, mut fc: &ast::CallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Token, "passed more argument than expected to Unwrap")
			e.pushSuggestion("call like; Unwrap()")
			ret nil
		}
		ret self.v
	}

	fn _Type(mut &self, mut e: &eval, mut fc: &ast::CallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Token, "passed more argument than expected to Type")
			e.pushSuggestion("call like; Type()")
			ret nil
		}
		ret buildComptimeTypeInfoData(e.s, self.v.Type)
	}

	fn _Lvalue(mut &self, mut e: &eval, mut fc: &ast::CallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Token, "passed more argument than expected to Lvalue")
			e.pushSuggestion("call like; Lvalue()")
			ret nil
		}
		mut constant := constant::NewBool(self.v.Lvalue)
		ret &Value{
			untyped: true,
			Type: primBool,
			Constant: constant,
			Model: constant,
		}
	}

	fn _Mutable(mut &self, mut e: &eval, mut fc: &ast::CallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Token, "passed more argument than expected to Mutable")
			e.pushSuggestion("call like; Mutable()")
			ret nil
		}
		mut constant := constant::NewBool(self.v.Mutable)
		ret &Value{
			untyped: true,
			Type: primBool,
			Constant: constant,
			Model: constant,
		}
	}

	fn _Const(mut &self, mut e: &eval, mut fc: &ast::CallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Token, "passed more argument than expected to Const")
			e.pushSuggestion("call like; Const()")
			ret nil
		}
		mut constant := constant::NewBool(self.v.IsConst())
		ret &Value{
			untyped: true,
			Type: primBool,
			Constant: constant,
			Model: constant,
		}
	}

	fn _Field(mut &self, mut e: &eval, mut fc: &ast::CallExpr): &Value {
		if len(fc.Args) > 1 {
			e.pushErr(fc.Token, "passed more argument than expected to Field")
			e.pushSuggestion("call like; Field(name)")
			ret nil
		}
		mut s := self.v.Type.Struct()
		if s == nil {
			e.pushErr(fc.Args[0].Token, "type @ is invalid for function Field", self.v.Type.Str())
			ret nil
		}
		mut arg := fc.Args[0]
		mut v := e.evalExpr(arg, evalDefault)
		if v == nil {
			ret nil
		}
		if !v.IsConst() {
			e.pushErr(arg.Token, "expression must be constant")
			ret nil
		}
		prim := v.Type.Prim()
		if prim == nil || !prim.IsStr() {
			e.pushErr(arg.Token, "mismatched types: @ and @", str(types::Str), v.Type.Str())
			ret nil
		}
		name := v.Constant.ReadStr()
		mut f := s.FindField(name)
		if f == nil {
			e.pushErr(arg.Token, "type @ has no field or method: @", s.Decl.Name, name)
			ret nil
		}
		v = new(Value, *self.v)
		v = e.evalStructSelectorField(v, s, arg.Token, f)
		ret buildComptimeValue(v)
	}

	fn _FieldByIndex(mut &self, mut e: &eval, mut fc: &ast::CallExpr): &Value {
		if len(fc.Args) > 1 {
			e.pushErr(fc.Token, "passed more argument than expected to FieldByIndex")
			e.pushSuggestion("call like; FieldByIndex(index)")
			ret nil
		}
		mut s := self.v.Type.Struct()
		if s == nil {
			e.pushErr(fc.Args[0].Token, "type @ is invalid for function FieldByIndex", self.v.Type.Str())
			ret nil
		}
		mut arg := fc.Args[0]
		mut v := e.evalExpr(arg, evalDefault)
		if v == nil {
			ret nil
		}
		if !v.IsConst() {
			e.pushErr(arg.Token, "expression must be constant")
			ret nil
		}
		log := checkDataForIntegerIndex(e.s, v, arg.Token, e.getOwnerRefers())
		if log != "" {
			e.pushErr(arg.Token, log)
			ret nil
		}
		i := v.Constant.AsU64()
		if i >= u64(len(s.Fields)) {
			e.pushErr(arg.Token, "index @ out of range, collection length is @", conv::FormatUint(i, 10), conv::Itoa(len(s.Fields)))
			ret nil
		}
		mut f := s.Fields[i]
		v = new(Value, *self.v)
		v = e.evalStructSelectorField(v, s, arg.Token, f)
		ret buildComptimeValue(v)
	}

	fn _Method(mut &self, mut e: &eval, mut fc: &ast::CallExpr): &Value {
		if len(fc.Args) > 1 {
			e.pushErr(fc.Token, "passed more argument than expected to Method")
			e.pushSuggestion("call like; Method(name)")
			ret nil
		}
		mut ref := false
		mut s := (&StructIns)(nil)
		match type self.v.Type.Kind {
		| &Sptr:
			s = self.v.Type.Kind.(&Sptr).Value.SoftStruct()
			ref = true
		| &StructIns:
			s = self.v.Type.Kind.(&StructIns)
		}
		if s == nil {
			e.pushErr(fc.Args[0].Token, "type @ is invalid for function Method", self.v.Type.Str())
			ret nil
		}
		mut arg := fc.Args[0]
		mut v := e.evalExpr(arg, evalDefault)
		if v == nil {
			ret nil
		}
		if !v.IsConst() {
			e.pushErr(arg.Token, "expression must be constant")
			ret nil
		}
		prim := v.Type.Prim()
		if prim == nil || !prim.IsStr() {
			e.pushErr(arg.Token, "mismatched types: @ and @", str(types::Str), v.Type.Str())
			ret nil
		}
		name := v.Constant.ReadStr()
		const Static = false
		mut m := s.FindMethod(name, Static)
		if m == nil {
			e.pushErr(arg.Token, "type @ has no field or method: @", s.Decl.Name, name)
			ret nil
		}
		v = new(Value, *self.v)
		if ref {
			makeImplicitDeref(v, fc.Token)
		}
		v = e.evalStructSelectorMethod(v, s, arg.Token, m, ref)
		ret buildComptimeValue(v)
	}

	fn subIdent(mut &self, name: str): &Value {
		match name {
		| "Unwrap":
			mut method := &FuncIns{
				caller: fn|mut e, mut fc, _| self._Unwrap(e, fc),
			}
			ret buildAsComptimeMethodData(method)
		| "Type":
			mut method := &FuncIns{
				caller: fn|mut e, mut fc, _| self._Type(e, fc),
			}
			ret buildAsComptimeMethodData(method)
		| "Lvalue":
			mut method := &FuncIns{
				caller: fn|mut e, mut fc, _| self._Lvalue(e, fc),
			}
			ret buildAsComptimeMethodData(method)
		| "Mutable":
			mut method := &FuncIns{
				caller: fn|mut e, mut fc, _| self._Mutable(e, fc),
			}
			ret buildAsComptimeMethodData(method)
		| "Const":
			mut method := &FuncIns{
				caller: fn|mut e, mut fc, _| self._Const(e, fc),
			}
			ret buildAsComptimeMethodData(method)
		| "Field":
			mut method := &FuncIns{
				caller: fn|mut e, mut fc, _| self._Field(e, fc),
			}
			ret buildAsComptimeMethodData(method)
		| "FieldByIndex":
			mut method := &FuncIns{
				caller: fn|mut e, mut fc, _| self._FieldByIndex(e, fc),
			}
			ret buildAsComptimeMethodData(method)
		| "Method":
			mut method := &FuncIns{
				caller: fn|mut e, mut fc, _| self._Method(e, fc),
			}
			ret buildAsComptimeMethodData(method)
		|:
			ret nil
		}
	}
}

// Compile-time file info range.
struct comptimeFiles {
	files: []&SymTab
}

impl Kind for comptimeFiles {
	fn Str(*self): str { ret "comptimeFiles" }
	fn Equal(&self, other: &Type): bool { ret false }
}

impl comptimeRangeKind for comptimeFiles {
	fn ready(mut *self, mut keyA: &Var, mut keyB: &Var) {
		if keyA != nil {
			keyA.Constant = true
			keyA.ValueSym = &ValueSym{
				Value: new(Value),
			}
			keyA.TypeSym = findBuiltinTypeAlias(types::Int).TypeSym
		}
		if keyB != nil {
			keyB.Constant = true
			keyB.ValueSym = &ValueSym{
				Value: new(Value),
			}
			keyB.TypeSym = &TypeSym{
				Type: &Type{
					Kind: new(comptimeFile),
				},
			}
		}
	}

	fn index(mut *self, mut v: &Value, i: int) {
		v.Decl = false
		v.untyped = false
		v.Constant = nil
		v.Type = &Type{
			Kind: &comptimeFile{
				file: self.files[i],
			},
		}
	}

	fn step(mut *self, i: int, mut keyA: &Var, mut keyB: &Var) {
		if keyA != nil {
			// Kind should be assigned by caller.
			keyA.ValueSym.Value.Constant = constant::NewI64(i64(i))
			keyA.ValueSym.Value.Model = keyA.ValueSym.Value.Constant
		}
		if keyB != nil {
			// Kind should be assigned by caller.
			keyB.TypeSym.Type.Kind.(&comptimeFile).file = self.files[i]
		}
	}

	fn len(*self): int {
		ret len(self.files)
	}
}

// Compile-time file information data.
struct comptimeFile {
	file: &SymTab
}

impl Kind for comptimeFile {
	fn Str(*self): str { ret "comptimeFile" }
	fn Equal(&self, other: &Type): bool { ret false }
}

impl comptimeFile {
	fn _Path(mut &self, mut e: &eval, mut fc: &ast::CallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Token, "passed more argument than expected to Path")
			e.pushSuggestion("call like; Path()")
			ret nil
		}
		mut constant := constant::NewStr(self.file.File.Path)
		ret &Value{
			untyped: true,
			Type: primStr,
			Constant: constant,
			Model: constant,
		}
	}

	fn _Name(mut &self, mut e: &eval, mut fc: &ast::CallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Token, "passed more argument than expected to Name")
			e.pushSuggestion("call like; Name()")
			ret nil
		}
		mut constant := constant::NewStr(self.file.File.Name())
		ret &Value{
			untyped: true,
			Type: primStr,
			Constant: constant,
			Model: constant,
		}
	}

	fn _Dir(mut &self, mut e: &eval, mut fc: &ast::CallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Token, "passed more argument than expected to Dir")
			e.pushSuggestion("call like; Dir()")
			ret nil
		}
		mut constant := constant::NewStr(self.file.File.Dir())
		ret &Value{
			untyped: true,
			Type: primStr,
			Constant: constant,
			Model: constant,
		}
	}

	fn subIdent(mut &self, name: str): &Value {
		match name {
		| "Path":
			mut method := &FuncIns{
				caller: fn|mut e, mut fc, _| self._Path(e, fc),
			}
			ret buildAsComptimeMethodData(method)
		| "Name":
			mut method := &FuncIns{
				caller: fn|mut e, mut fc, _| self._Name(e, fc),
			}
			ret buildAsComptimeMethodData(method)
		| "Dir":
			mut method := &FuncIns{
				caller: fn|mut e, mut fc, _| self._Dir(e, fc),
			}
			ret buildAsComptimeMethodData(method)
		|:
			ret nil
		}
	}
}

// Compile-time declaration info range.
struct comptimeDecls {
	decls: []&comptimeDecl
}

impl Kind for comptimeDecls {
	fn Str(*self): str { ret "comptimeDecls" }
	fn Equal(&self, other: &Type): bool { ret false }
}

impl comptimeRangeKind for comptimeDecls {
	fn ready(mut *self, mut keyA: &Var, mut keyB: &Var) {
		if keyA != nil {
			keyA.Constant = true
			keyA.ValueSym = &ValueSym{
				Value: new(Value),
			}
			keyA.TypeSym = findBuiltinTypeAlias(types::Int).TypeSym
		}
		if keyB != nil {
			keyB.Constant = true
			keyB.ValueSym = &ValueSym{
				Value: new(Value),
			}
			keyB.TypeSym = &TypeSym{
				Type: &Type{
					Kind: new(comptimeDecl),
				},
			}
		}
	}

	fn index(mut *self, mut v: &Value, i: int) {
		v.Decl = false
		v.untyped = false
		v.Constant = nil
		v.Type = &Type{
			Kind: self.decls[i],
		}
	}

	fn step(mut *self, i: int, mut keyA: &Var, mut keyB: &Var) {
		if keyA != nil {
			// Kind should be assigned by caller.
			keyA.ValueSym.Value.Constant = constant::NewI64(i64(i))
			keyA.ValueSym.Value.Model = keyA.ValueSym.Value.Constant
		}
		if keyB != nil {
			// Kind should be assigned by caller.
			keyB.TypeSym.Type.Kind.(&comptimeDecl).decl = self.decls[i].decl
		}
	}

	fn len(*self): int {
		ret len(self.decls)
	}
}

// Supported types for the comptimeDecl data.
// For any update, make sure all kinds are handled correctly.
enum comptimeDeclType: type {
	&Struct,
	&Func,
	&Enum,
	&TypeEnum,
	&Trait,
	&Field,
	&TypeAlias,
	&Var,
	&Param,
}

// Compile-time declaration information wrapper.
struct comptimeDecl {
	decl: comptimeDeclType
}

impl Kind for comptimeDecl {
	fn Str(*self): str { ret "comptimeDecl" }
	fn Equal(&self, other: &Type): bool { ret false }
}

impl comptimeDecl {
	fn declAsStr(*self): str {
		match type self.decl {
		| &Struct:
			ret "<struct>"
		| &Func:
			ret "<func>"
		| &Enum:
			ret "<enum>"
		| &TypeEnum:
			ret "<type enum>"
		| &Trait:
			ret "<trait>"
		| &Field:
			ret "<field>"
		| &TypeAlias:
			ret "<type alias>"
		| &Var:
			v := self.decl.(&Var)
			if v.IsEnumField() {
				ret "<enum field>"
			}
			ret "<var>"
		| &Param:
			ret "<param>"
		|:
			panic("sema: comptimeDecl.Name: unimplemented declaration kind")
		}
	}

	fn _Name(mut &self, mut e: &eval, mut fc: &ast::CallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Token, "passed more argument than expected to Name")
			e.pushSuggestion("call like; Name()")
			ret nil
		}
		mut name := ""
		match type self.decl {
		| &Struct:
			name = self.decl.(&Struct).Name
		| &Func:
			name = self.decl.(&Func).Name
		| &Enum:
			name = self.decl.(&Enum).Name
		| &TypeEnum:
			name = self.decl.(&TypeEnum).Name
		| &Trait:
			name = self.decl.(&Trait).Name
		| &Field:
			name = self.decl.(&Field).Name
		| &TypeAlias:
			name = self.decl.(&TypeAlias).Name
		| &Var:
			name = self.decl.(&Var).Name
		| &Param:
			name = self.decl.(&Param).Name
		|:
			panic("sema: comptimeDecl.Name: unimplemented declaration kind")
		}
		mut constant := constant::NewStr(name)
		ret &Value{
			untyped: true,
			Type: primStr,
			Constant: constant,
			Model: constant,
		}
	}

	fn _Public(mut &self, mut e: &eval, mut fc: &ast::CallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Token, "passed more argument than expected to Public")
			e.pushSuggestion("call like; Public()")
			ret nil
		}
		mut public := false
		match type self.decl {
		| &Param:
			e.pushErr(fc.Args[0].Token, "type @ is invalid for function Public", self.declAsStr())
			ret nil
		| &Struct:
			public = self.decl.(&Struct).Public
		| &Func:
			public = self.decl.(&Func).Public
		| &Enum:
			public = self.decl.(&Enum).Public
		| &TypeEnum:
			public = self.decl.(&TypeEnum).Public
		| &Trait:
			public = self.decl.(&Trait).Public
		| &Field:
			public = self.decl.(&Field).Public
		| &TypeAlias:
			public = self.decl.(&TypeAlias).Public
		| &Var:
			v := self.decl.(&Var)
			if v.IsEnumField() {
				e.pushErr(fc.Args[0].Token, "type @ is invalid for function Public", self.declAsStr())
				ret nil
			}
			public = v.Public
		|:
			panic("sema: comptimeDecl.Public: unimplemented declaration kind")
		}
		mut constant := constant::NewBool(public)
		ret &Value{
			untyped: true,
			Type: primBool,
			Constant: constant,
			Model: constant,
		}
	}

	fn _Extern(mut &self, mut e: &eval, mut fc: &ast::CallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Token, "passed more argument than expected to Extern")
			e.pushSuggestion("call like; Extern()")
			ret nil
		}
		mut _extern := false
		match type self.decl {
		| &Enum
		| &TypeEnum
		| &Trait
		| &Field
		| &Param:
			e.pushErr(fc.Args[0].Token, "type @ is invalid for function Extern", self.declAsStr())
			ret nil
		| &Struct:
			_extern = self.decl.(&Struct).Extern
		| &Func:
			_extern = self.decl.(&Func).Extern
		| &TypeAlias:
			_extern = self.decl.(&TypeAlias).Extern
		| &Var:
			v := self.decl.(&Var)
			if v.IsEnumField() {
				e.pushErr(fc.Args[0].Token, "type @ is invalid for function Extern", self.declAsStr())
				ret nil
			}
			_extern = v.Extern
		|:
			panic("sema: comptimeDecl.Extern: unimplemented declaration kind")
		}
		mut constant := constant::NewBool(_extern)
		ret &Value{
			untyped: true,
			Type: primBool,
			Constant: constant,
			Model: constant,
		}
	}

	fn _Exceptional(mut &self, mut e: &eval, mut fc: &ast::CallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Token, "passed more argument than expected to Exceptional")
			e.pushSuggestion("call like; Exceptional()")
			ret nil
		}
		match type self.decl {
		| &Func:
			break
		|:
			e.pushErr(fc.Args[0].Token, "type @ is invalid for function Exceptional", self.declAsStr())
			ret nil
		}
		mut f := self.decl.(&Func)
		mut constant := constant::NewBool(f.Exceptional)
		ret &Value{
			untyped: true,
			Type: primBool,
			Constant: constant,
			Model: constant,
		}
	}

	fn _Mutable(mut &self, mut e: &eval, mut fc: &ast::CallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Token, "passed more argument than expected to Mutable")
			e.pushSuggestion("call like; Mutable()")
			ret nil
		}
		mut mutable := false
		match type self.decl {
		| &Struct
		| &Func
		| &Enum
		| &TypeEnum
		| &Trait
		| &TypeAlias:
			e.pushErr(fc.Args[0].Token, "type @ is invalid for function Mutable", self.declAsStr())
			ret nil
		| &Param:
			mutable = self.decl.(&Param).Mutable
		| &Field:
			mutable = self.decl.(&Field).Mutable
		| &Var:
			v := self.decl.(&Var)
			if v.IsEnumField() {
				e.pushErr(fc.Args[0].Token, "type @ is invalid for function Mutable", self.declAsStr())
				ret nil
			}
			mutable = v.Mutable
		|:
			panic("sema: comptimeDecl.Mutable: unimplemented declaration kind")
		}
		mut constant := constant::NewBool(mutable)
		ret &Value{
			untyped: true,
			Type: primBool,
			Constant: constant,
			Model: constant,
		}
	}

	fn _Variadic(mut &self, mut e: &eval, mut fc: &ast::CallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Token, "passed more argument than expected to Variadic")
			e.pushSuggestion("call like; Variadic()")
			ret nil
		}
		mut variadic := false
		match type self.decl {
		| &Struct
		| &Func
		| &Enum
		| &TypeEnum
		| &Trait
		| &TypeAlias
		| &Field
		| &Var:
			e.pushErr(fc.Args[0].Token, "type @ is invalid for function Variadic", self.declAsStr())
			ret nil
		| &Param:
			variadic = self.decl.(&Param).Variadic
		|:
			panic("sema: comptimeDecl.Variadic: unimplemented declaration kind")
		}
		mut constant := constant::NewBool(variadic)
		ret &Value{
			untyped: true,
			Type: primBool,
			Constant: constant,
			Model: constant,
		}
	}

	fn _Reference(mut &self, mut e: &eval, mut fc: &ast::CallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Token, "passed more argument than expected to Reference")
			e.pushSuggestion("call like; Reference()")
			ret nil
		}
		mut ref := false
		match type self.decl {
		| &Struct
		| &Func
		| &Enum
		| &TypeEnum
		| &Trait
		| &TypeAlias
		| &Field:
			e.pushErr(fc.Args[0].Token, "type @ is invalid for function Reference", self.declAsStr())
			ret nil
		| &Var:
			v := self.decl.(&Var)
			if v.IsEnumField() {
				e.pushErr(fc.Args[0].Token, "type @ is invalid for function Reference", self.declAsStr())
				ret nil
			}
			ref = v.Reference
		| &Param:
			ref = self.decl.(&Param).Reference
		|:
			panic("sema: comptimeDecl.Reference: unimplemented declaration kind")
		}
		mut constant := constant::NewBool(ref)
		ret &Value{
			untyped: true,
			Type: primBool,
			Constant: constant,
			Model: constant,
		}
	}

	fn _Params(mut &self, mut e: &eval, mut fc: &ast::CallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Token, "passed more argument than expected to Params")
			e.pushSuggestion("call like; Params()")
			ret nil
		}
		match type self.decl {
		| &Struct
		| &Enum
		| &TypeEnum
		| &Trait
		| &TypeAlias
		| &Field
		| &Var
		| &Param:
			e.pushErr(fc.Args[0].Token, "type @ is invalid for function Params", self.declAsStr())
			ret nil
		| &Func:
			mut f := self.decl.(&Func)
			mut params := make([]&comptimeDecl, len(f.Params))
			for (i, mut param) in f.Params {
				params[i] = &comptimeDecl{decl: param}
			}
			ret &Value{
				Type: &Type{
					Kind: &comptimeDecls{
						decls: params,
					},
				},
			}
		|:
			panic("sema: comptimeDecl.Params: unimplemented declaration kind")
		}
	}

	fn _Fields(mut &self, mut e: &eval, mut fc: &ast::CallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Token, "passed more argument than expected to Fields")
			e.pushSuggestion("call like; Fields()")
			ret nil
		}
		mut fields := ([]&comptimeDecl)(nil)
		match type self.decl {
		| &TypeEnum
		| &Trait
		| &TypeAlias
		| &Field
		| &Var
		| &Param
		| &Func:
			e.pushErr(fc.Args[0].Token, "type @ is invalid for function Fields", self.declAsStr())
			ret nil
		| &Enum:
			mut enm := self.decl.(&Enum)
			fields = make([]&comptimeDecl, len(enm.Items))
			for (i, mut item) in enm.Items {
				fields[i] = &comptimeDecl{decl: item}
			}
		| &Struct:
			mut s := self.decl.(&Struct)
			fields = make([]&comptimeDecl, len(s.Fields))
			for (i, mut field) in s.Fields {
				fields[i] = &comptimeDecl{decl: field}
			}
		|:
			panic("sema: comptimeDecl.Fields: unimplemented declaration kind")
		}
		ret &Value{
			Type: &Type{
				Kind: &comptimeDecls{
					decls: fields,
				},
			},
		}
	}

	fn _Methods(mut &self, mut e: &eval, mut fc: &ast::CallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Token, "passed more argument than expected to Methods")
			e.pushSuggestion("call like; Methods()")
			ret nil
		}
		mut methods := ([]&comptimeDecl)(nil)
		match type self.decl {
		| &TypeEnum
		| &TypeAlias
		| &Field
		| &Var
		| &Param
		| &Func
		| &Enum:
			e.pushErr(fc.Args[0].Token, "type @ is invalid for function Methods", self.declAsStr())
			ret nil
		| &Trait:
			mut t := self.decl.(&Trait)
			methods = make([]&comptimeDecl, len(t.Methods))
			for (i, mut method) in t.Methods {
				methods[i] = &comptimeDecl{decl: method}
			}
		| &Struct:
			mut s := self.decl.(&Struct)
			methods = make([]&comptimeDecl, len(s.Methods))
			for (i, mut method) in s.Methods {
				methods[i] = &comptimeDecl{decl: method}
			}
		|:
			panic("sema: comptimeDecl.Methods: unimplemented declaration kind")
		}
		ret &Value{
			Type: &Type{
				Kind: &comptimeDecls{
					decls: methods,
				},
			},
		}
	}

	fn _Tags(mut &self, mut e: &eval, mut fc: &ast::CallExpr): &Value {
		if len(fc.Args) > 0 {
			e.pushErr(fc.Token, "passed more argument than expected to Tags")
			e.pushSuggestion("call like; Tags()")
			ret nil
		}
		match type self.decl {
		| &Field:
			f := self.decl.(&Field)
			mut constant := constant::NewI64(i64(len(f.Tags)))
			ret &Value{
				untyped: true,
				Type: primInt,
				Constant: constant,
				Model: constant,
			}
		|:
			e.pushErr(fc.Args[0].Token, "type @ is invalid for function Tag", self.declAsStr())
			ret nil
		}
	}

	fn _Tag(mut &self, mut e: &eval, mut fc: &ast::CallExpr): &Value {
		if len(fc.Args) > 1 {
			e.pushErr(fc.Token, "passed more argument than expected to Tag")
			e.pushSuggestion("call like; Tag(name)")
			ret nil
		}
		f, field := self.decl.(&Field)
		if !field {
			e.pushErr(fc.Args[0].Token, "type @ is invalid for function Tag", self.declAsStr())
			ret nil
		}
		mut arg := fc.Args[0]
		mut v := e.evalExpr(arg, evalDefault)
		if v == nil {
			ret nil
		}
		if !v.IsConst() {
			e.pushErr(arg.Token, "expression must be constant")
			ret nil
		}
		prim := v.Type.Prim()
		if prim == nil || !prim.IsStr() {
			e.pushErr(arg.Token, "mismatched types: @ and @", str(types::Str), v.Type.Str())
			ret nil
		}
		key := v.Constant.ReadStr()
		value, _ := f.Tags[key]
		mut constant := constant::NewStr(value)
		ret &Value{
			untyped: true,
			Type: primStr,
			Constant: constant,
			Model: constant,
		}
	}

	fn _IsTag(mut &self, mut e: &eval, mut fc: &ast::CallExpr): &Value {
		if len(fc.Args) > 1 {
			e.pushErr(fc.Token, "passed more argument than expected to IsTag")
			e.pushSuggestion("call like; IsTag(name)")
			ret nil
		}
		f, field := self.decl.(&Field)
		if !field {
			e.pushErr(fc.Args[0].Token, "type @ is invalid for function IsTag", self.declAsStr())
			ret nil
		}
		mut arg := fc.Args[0]
		mut v := e.evalExpr(arg, evalDefault)
		if v == nil {
			ret nil
		}
		if !v.IsConst() {
			e.pushErr(arg.Token, "expression must be constant")
			ret nil
		}
		prim := v.Type.Prim()
		if prim == nil || !prim.IsStr() {
			e.pushErr(arg.Token, "mismatched types: @ and @", str(types::Str), v.Type.Str())
			ret nil
		}
		key := v.Constant.ReadStr()
		_, exist := f.Tags[key]
		mut constant := constant::NewBool(exist)
		ret &Value{
			untyped: true,
			Type: primBool,
			Constant: constant,
			Model: constant,
		}
	}

	fn subIdent(mut &self, name: str): &Value {
		match name {
		| "Name":
			mut method := &FuncIns{
				caller: fn|mut e, mut fc, _| self._Name(e, fc),
			}
			ret buildAsComptimeMethodData(method)
		| "Public":
			mut method := &FuncIns{
				caller: fn|mut e, mut fc, _| self._Public(e, fc),
			}
			ret buildAsComptimeMethodData(method)
		| "Extern":
			mut method := &FuncIns{
				caller: fn|mut e, mut fc, _| self._Extern(e, fc),
			}
			ret buildAsComptimeMethodData(method)
		| "Exceptional":
			mut method := &FuncIns{
				caller: fn|mut e, mut fc, _| self._Exceptional(e, fc),
			}
			ret buildAsComptimeMethodData(method)
		| "Mutable":
			mut method := &FuncIns{
				caller: fn|mut e, mut fc, _| self._Mutable(e, fc),
			}
			ret buildAsComptimeMethodData(method)
		| "Variadic":
			mut method := &FuncIns{
				caller: fn|mut e, mut fc, _| self._Variadic(e, fc),
			}
			ret buildAsComptimeMethodData(method)
		| "Reference":
			mut method := &FuncIns{
				caller: fn|mut e, mut fc, _| self._Reference(e, fc),
			}
			ret buildAsComptimeMethodData(method)
		| "Params":
			mut method := &FuncIns{
				caller: fn|mut e, mut fc, _| self._Params(e, fc),
			}
			ret buildAsComptimeMethodData(method)
		| "Fields":
			mut method := &FuncIns{
				caller: fn|mut e, mut fc, _| self._Fields(e, fc),
			}
			ret buildAsComptimeMethodData(method)
		| "Methods":
			mut method := &FuncIns{
				caller: fn|mut e, mut fc, _| self._Methods(e, fc),
			}
			ret buildAsComptimeMethodData(method)
		| "Tags":
			mut method := &FuncIns{
				caller: fn|mut e, mut fc, _| self._Tags(e, fc),
			}
			ret buildAsComptimeMethodData(method)
		| "Tag":
			mut method := &FuncIns{
				caller: fn|mut e, mut fc, _| self._Tag(e, fc),
			}
			ret buildAsComptimeMethodData(method)
		| "IsTag":
			mut method := &FuncIns{
				caller: fn|mut e, mut fc, _| self._IsTag(e, fc),
			}
			ret buildAsComptimeMethodData(method)
		|:
			ret nil
		}
	}
}

struct comptimeSliceRange {
	s: &SliceExpr
}

impl comptimeRangeKind for comptimeSliceRange {
	fn ready(mut *self, mut keyA: &Var, mut keyB: &Var) {
		if keyA != nil {
			keyA.Constant = true
			keyA.ValueSym = &ValueSym{
				Value: new(Value),
			}
			keyA.TypeSym = findBuiltinTypeAlias(types::Int).TypeSym
		}
		if keyB != nil {
			keyB.Constant = true
			keyB.ValueSym = &ValueSym{
				Value: new(Value),
			}
			keyB.TypeSym = &TypeSym{
				Type: self.s.ElemType,
			}
		}
	}

	fn index(mut *self, mut v: &Value, i: int) {
		panic("sema: index method of comptimeSliceRange should not be used")
	}

	fn step(mut *self, i: int, mut keyA: &Var, mut keyB: &Var) {
		if keyA != nil {
			// Kind should be assigned by caller.
			keyA.ValueSym.Value.Constant = constant::NewI64(i64(i))
			keyA.ValueSym.Value.Model = keyA.ValueSym.Value.Constant
		}
		if keyB != nil {
			// Kind should be assigned by caller.
			keyB.ValueSym.Value = self.s.Elems[i]
		}
	}

	fn len(*self): int {
		ret len(self.s.Elems)
	}
}

fn buildAsComptimeMethodData(mut f: &FuncIns): &Value {
	ret &Value{
		Type: &Type{
			Kind: f,
		},
	}
}

fn findComptimePackage(mut s: &sema): &ImportInfo {
	ret s.SelectPackage(fn|pkg| pkg.LinkPath == "std/comptime")
}

fn buildComptimeTypeInfoData(mut s: &sema, mut t: &Type): &Value {
	ret &Value{
		Type: &Type{
			Kind: s.meta.pushComptimeTypeInfo(t),
		},
	}
}

fn buildComptimeValue(mut v: &Value): &Value {
	ret &Value{
		Type: &Type{
			Kind: &comptimeValue{
				v: v,
			},
		},
	}
}
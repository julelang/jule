// Copyright 2023 The Jule Project Contributors. All rights reserved.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/conv"
use "std/jule"
use "std/jule/ast"
use "std/jule/build"
use "std/jule/constant"
use "std/jule/log"
use "std/jule/token"
use "std/jule/types"
use "std/strings"

// Statement type.
enum Stmt: type {
	&Scope,
	&Var,
	&Value,
	&Conditional,
	&InfIter,
	&WhileIter,
	&RangeIter,
	&Continue,
	&Label,
	&Goto,
	&Postfix,
	&Assign,
	&MultiAssign,
	&Match,
	&Fall,
	&Break,
	&Ret,
	&Select,
	&Use,
}

fn newScopeCheckerBase(mut s: &sema, mut owner: &FuncIns): &scopeChecker {
	ret &scopeChecker{
		s: s,
		owner: owner,
		table: new(SymTab),
	}
}

fn newScopeChecker(mut s: &sema, mut owner: &FuncIns): &scopeChecker {
	mut base := newScopeCheckerBase(s, owner)
	base.labels = new([]&scopeLabel, nil)
	base.gotos = new([]&Goto, nil)
	ret base
}

struct exprPart {
	data: &Value
	expr: &ast::Expr
}

// Represents traits of a scope.
type ScopeTrait: int

// Scope traits.
const (
	// Scope is an infinite scope.
	// This passed when scope owner is exactly and infinite iteration,
	// or while-next iteration with no condition.
	ST_INFINITE: ScopeTrait = 1 << iota

	// Scope is an error handling scope.
	ST_ERROR_HANDLER
)

// Scope.
struct Scope {
	Traits:   ScopeTrait
	Owner:    uintptr // Memory address of the owner.
	Parent:   &Scope
	Unsafe:   bool
	Deferred: bool
	Stmts:    []Stmt

	// Data of the child scope starting from the root scope.
	// For the root scope, counting starts from 0. So the root scope will be 0.
	// It increases by one for each child scope.
	ChildIndex: int

	// If the scope is a child scope,
	// it contains the data of the statement in which it was appear.
	StmtIndex: int
}

// Use statement.
struct Use {
	Value: &Value
}

// Chain conditional node.
struct If {
	Expr:  Expr
	Scope: &Scope
}

// Default scope of conditional chain.
struct Else {
	Scope: &Scope
}

// Conditional chain.
struct Conditional {
	Elifs:   []&If // First not is root condition.
	Default: &Else
}

// Infinity iteration.
struct InfIter {
	Scope: &Scope // See developer reference (8).
}

// While iteration.
struct WhileIter {
	Scope: &Scope // See developer reference (8).
	Expr:  Expr   // Can be nil if iteration is while-next kind.
	Next:  Stmt   // Nil if iteration is not while-next kind.
}

impl WhileIter {
	// Reports whether iteration is while-next kind.
	fn IsWhileNext(*self): bool {
		ret self.Next != nil
	}
}

// Range iteration.
struct RangeIter {
	Scope:     &Scope // See developer reference (8).
	Expr:      &Value
	ExprToken: &token::Token
	KeyA:      &Var
	KeyB:      &Var
}

// Continue statement.
struct Continue {
	It: uintptr
}

// Break statement.
struct Break {
	It:     uintptr
	Match:  uintptr
	Select: uintptr
}

// Label.
struct Label {
	Name:  str
	Scope: &Scope // Owner scope.
	Index: int    // Index of statement.
}

// Basic direction flags.
type Direction: int

// Directions.
const (
	UP: Direction = iota
	DOWN
)

// Goto statement.
struct Goto {
	Name:      str
	Token:     &token::Token
	Label:     &Label
	Scope:     &Scope // Owner scope.
	Index:     int    // Index of statement.
	Direction: Direction
}

// Postfix assignment.
struct Postfix {
	Expr: Expr
	Op:   str
}

// Assignment.
struct Assign {
	Left:  &OperandExpr
	Right: &OperandExpr
	Op:    &token::Token
}

// Multi-declarative assignment.
struct MultiAssign {
	Decls: []&Var
	Left:  []&Value // Nil Model:s represents ignored expressions.
	Right: Expr
	Op:    &token::Token
}

// Match-Case.
struct Match {
	Scope:     &Scope // Owner scope. See developer reference (8).
	Expr:      &Value
	TypeMatch: bool
	Comptime:  bool
	Cases:     []&Case
	Default:   &Case
}

impl Match {
	// Reports whether match is type-match for generic type.
	fn IsGenericTypeMatch(*self): bool {
		ret self.TypeMatch && self.Expr != nil && self.Expr.Type.Generic
	}
}

// Select-Case.
struct Select {
	Scope:   &Scope // Owner scope. See developer reference (8).
	Cases:   []&Case
	Default: &Case
}

// Valid owner types for Case.
enum CaseOwner: type {
	&Match,
	&Select,
}

// Internal wrapper for CaseOwner.
type caseOwner: CaseOwner

impl caseOwner {
	// Returns data in uintptr.
	// Assumes self is not nil.
	fn asUintptr(*self): uintptr {
		match type *self {
		| &Match:
			ret uintptr((*self).(&Match))
		| &Select:
			ret uintptr((*self).(&Select))
		|:
			panic("unreachable")
		}
	}
}

// Match-Case case.
struct Case {
	Owner: CaseOwner
	Scope: &Scope
	Exprs: []&Value // Nil for select statements. Refer to Stmt field.
	Next:  &Case

	// Possible in select statements;
	//  - "<-chan", represented as &Value
	//  - "chan<-foo", represented as &Value
	//	- "x = <-chan", represented as &Assign
	//	- "x := <-chan", represented as &Var
	Stmt: Stmt
}

impl Case {
	// Reports whether case is default.
	fn isDefault(*self): bool { ret self.Exprs == nil }
}

// Fall statement.
struct Fall {
	DestCase: uintptr
}

// Return statement.
struct Ret {
	Func: &FuncIns
	Expr: Expr
}

struct scopeLabel {
	token: &token::Token
	node:  &Label
	used:  bool
}

// Result information for the use statements.
struct result {
	func:    &FuncIns // Handling function.
	mutable: bool     // Whether will be assigned to mutable storage.
}

// Stmt node analysis flags.
const (
	checkNodeDefault       = iota
	checkNodeNoExceptional = 1 << iota
)

// Scope checker.
struct scopeChecker {
	calledFrom: &token::Token
	s:          &sema
	owner:      &FuncIns // See developer reference (1).
	parent:     &scopeChecker
	childIndex: int // Index of child scope.
	table:      &SymTab
	scope:      &Scope
	tree:       &ast::ScopeTree
	result:     &result // Result type for the use statement.
	it:         uintptr
	cse:        uintptr
	captured:   &[]&Var        // Anonymous function's captured variables will be stored here.
	labels:     &[]&scopeLabel // All labels of all scopes.
	gotos:      &[]&Goto       // All gotos of all scopes.
	i:          int            // Index of current statement.
}

impl Lookup for scopeChecker {
	// Returns imported package by selector.
	// Returns nil if selector returns false for all packages.
	// Returns nil if selector is nil.
	//
	// Lookups:
	//	- Sema.
	fn SelectPackage(mut *self, selector: fn(&ImportInfo): bool): &ImportInfo {
		ret self.s.SelectPackage(selector)
	}

	// Returns variable by identifier and external state.
	// Returns nil if not exist any variable in this identifier.
	//
	// Lookups:
	//	- Current scope.
	//	- Parent scopes.
	//	- Sema.
	fn FindVar(mut *self, name: str, _extern: bool): &Var {
		const Closure = true // allow capturing variables from parent scope
		if !_extern { // Local variables cannot be external.
			mut v := self.findVar(name, Closure)
			if v != nil {
				ret v
			}
		}
		ret self.s.FindVar(name, _extern)
	}

	// Returns type alias by identifier and external state.
	// Returns nil if not exist any type alias in this identifier.
	//
	// Lookups:
	//	- Current scope.
	//	- Parent scopes.
	//	- Sema.
	fn FindTypeAlias(mut *self, name: str, _extern: bool): &TypeAlias {
		// Search reverse for correct shadowing.
		const Reverse = true
		mut ta := self.table.findTypeAlias(name, _extern, Reverse)
		if ta != nil {
			ret ta
		}

		mut parent := self.parent
		for parent != nil {
			ta = parent.table.findTypeAlias(name, _extern, Reverse)
			if ta != nil {
				ret ta
			}
			parent = parent.parent
		}

		ret self.s.FindTypeAlias(name, _extern)
	}

	// Returns struct by identifier and external state.
	// Returns nil if not exist any struct in this identifier.
	//
	// Lookups:
	//	- Sema.
	fn FindStruct(mut *self, name: str, _extern: bool): &Struct {
		ret self.s.FindStruct(name, _extern)
	}

	// Returns function by identifier and external state.
	// Returns nil if not exist any function in this identifier.
	//
	// Lookups:
	//	- Sema.
	fn FindFunc(mut *self, name: str, _extern: bool): &Func {
		ret self.s.FindFunc(name, _extern)
	}

	// Returns trait by identifier.
	// Returns nil if not exist any trait in this identifier.
	//
	// Lookups:
	//	- Sema.
	fn FindTrait(mut *self, name: str): &Trait {
		ret self.s.FindTrait(name)
	}

	// Returns enum by identifier.
	// Returns nil if not exist any enum in this identifier.
	//
	// Lookups:
	//	- Sema.
	fn FindEnum(mut *self, name: str): &Enum {
		ret self.s.FindEnum(name)
	}

	// Returns type enum by identifier.
	// Returns nil if not exist any type enum in this identifier.
	//
	// Lookups:
	//	- Sema.
	fn FindTypeEnum(mut *self, name: str): &TypeEnum {
		ret self.s.FindTypeEnum(name)
	}
}

impl scopeChecker {
	// Reports whether scope is unsafe.
	fn isUnsafe(mut &self): bool {
		mut scope := self

	iter:
		if scope.scope.Unsafe {
			ret true
		}

		if scope.parent != nil {
			scope = scope.parent
			goto iter
		}

		ret false
	}

	// Reports whether scope is unsafe.
	fn isAsync(mut &self): bool {
		r := self.getRoot()
		ret r.owner != nil && r.owner.Decl != nil && r.owner.Decl.Async
	}

	// Reports scope is root.
	// Accepts anonymous functions as root.
	fn isRoot(*self): bool {
		ret self.parent == nil || self.owner != nil
	}

	// Stop checking.
	fn stop(mut *self) {
		self.i = -1
	}

	// Reports whether checking is stopped.
	fn stopped(*self): bool {
		ret self.i == -1
	}

	// Reports scope is deferred.
	fn isDeferred(mut &self): bool {
		mut scope := self

	iter:
		if scope.scope.Deferred {
			ret true
		}

		if scope.parent != nil {
			scope = scope.parent
			goto iter
		}

		ret false
	}

	// Push captured variable.
	// It will append to all [captured] fields,
	// because if child-scopes captures this variable,
	// parent-scopes must be capture this variable too.
	// Starts pushing from self to all parents.
	// If any parent scope is not captures variable v, iteration will be break.
	fn pushCaptured(mut &self, mut v: &Var) {
		mut sc := self
		for {
			if sc.captured != nil {
				for _, cv in *sc.captured {
					if cv == v {
						goto exist
					}
				}
				*sc.captured = append(*sc.captured, v)
			exist:
			}
			if sc.parent == nil {
				break
			}
			sc = sc.parent
			if !isVarCaptured(sc, sc, v) {
				break
			}
		}
	}

	// Returns root scope.
	// Accepts anonymous functions as root.
	fn getRoot(mut &self): &scopeChecker {
		mut root := self
		for root.parent != nil && root.owner == nil {
			root = root.parent
		}
		ret root
	}

	// Returns hard root scope, owner always represents root function of this scope.
	// Not accepts anonymous functions as root.
	fn getHardRoot(mut &self): &scopeChecker {
		mut root := self
		for root.parent != nil {
			root = root.parent
		}
		ret root
	}

	fn getOwnerRefers(mut &self): &ReferenceStack {
		ret self.getHardRoot().owner.Refers
	}

	// Like [Lookup.FindVar] but designed for local variables only.
	fn findVar(mut *self, name: str, closure: bool): &Var {
		const Reverse = true // Search reverse for correct shadowing.
		const Extern = false // Local variables cannot be external.
		mut parent := unsafe { (&scopeChecker)(self) }
		for parent != nil {
			// Closure limitation mode is disabled and we are in the closure.
			// Do not lookup variables from the parent scopes.
			if !closure && parent.parent != nil && parent.owner != nil {
				ret nil
			}
			mut v := parent.table.findVar(name, Extern, Reverse)
			if v != nil {
				ret v
			}
			parent = parent.parent
		}
		ret nil
	}

	// Returns label by identifier.
	// Returns nil if not exist any label in this identifier.
	// Just lookups current scope.
	fn findLabel(mut *self, name: str): &Label {
		for (_, mut st) in self.scope.Stmts {
			mut label, ok := st.(&Label)
			if ok && label.Name == name {
				ret label
			}
		}
		ret nil
	}

	// Returns label by identifier.
	// Returns nil if not exist any label in this identifier.
	// Just lookups current scope.
	fn findLabelScope(mut &self, name: str): &scopeLabel {
		mut label := self.findLabelAll(name)
		if label != nil && label.node.Scope == self.scope {
			ret label
		}
		ret nil
	}

	// Returns label by identifier.
	// Returns nil if not exist any label in this identifier.
	// Lookups all labels.
	fn findLabelAll(mut *self, name: str): &scopeLabel {
		for (_, mut lbl) in *self.labels {
			if lbl.node.Name == name {
				ret lbl
			}
		}
		ret nil
	}

	// Reports this identifier duplicated in scope.
	// The "self" parameter represents address of exception identifier.
	// If founded identifier address equals to self, will be skipped.
	fn isDuplicatedName(mut *self, itself: uintptr, name: str): bool {
		const Closure = false
		shadowing := self.s.isFlag(Shadowing)
		v := self.findVar(name, Closure)
		if v != nil && uintptr(v) != itself {
			if v.Scope == nil { // Ignore globals.
				ret false
			}
			ret v.Scope == self.scope || !shadowing
		}

		ta := self.FindTypeAlias(name, false)
		if ta != nil && uintptr(ta) != itself {
			if ta.Scope == nil { // Ignore globals.
				ret false
			}
			ret ta.Scope == self.tree || !shadowing
		}

		ret false
	}

	fn checkVarDecl1(mut &self, mut v: &Var) {
		defer {
			self.table.Vars = append(self.table.Vars, v)
			self.scope.Stmts = append(self.scope.Stmts, v)
		}

		if !jule::IsBlank(v.Name) && self.isDuplicatedName(uintptr(v), v.Name) {
			self.s.pushErr(v.Token, "identifier @ is duplicated in this scope", v.Name)
			self.stop()
			ret
		}

		self.s.checkVarDecl(v, self)
		if !v.IsTypeInferred() && (v.TypeSym == nil || v.TypeSym.Type == nil) {
			ret
		}
		// We should imitate the [sema.checkVar].
		// Instruction order must remain the same.
		v.Checked = true
		self.s.evalVarValue(v, self)
		if !v.IsInitialized() || v.ValueSym.Value == nil {
			// Skip checks if error occurs when evaluated expression,
			// or unitiliazed variable.
			ret
		}
		self.removeInteriorMutRisk(v.ValueSym.Value)
		self.s.checkVarValue(v)
		// Variable v is a scope variable and scope variables will not collect
		// referencer for themselves. So, if any reference exist for v,
		// push the references to scope owner's referencer and clear from v.
		if v.Refers.Len() > 0 {
			mut refers := self.getOwnerRefers()
			if refers != nil {
				refers.buffer = append(refers.buffer, v.Refers.buffer...)
				v.Refers.clear()
			}
		}
	}

	fn checkVarDecl(mut &self, mut decl: &ast::Var, mut &out: *&Var) {
		if jule::IsBlank(decl.Name) {
			self.s.pushErr(decl.Token, "blank identifier cannot be used as an identifier for this declaration")
			ret
		}
		n := len(self.s.errors)
		mut v := buildVar(decl)
		if out != nil {
			*out = v
		}
		v.Scope = self.scope
		self.checkVarDecl1(v)
		// Do not continue to analysis of this scope, variable declaration have error(s).
		if len(self.s.errors) != n {
			self.stop()
		}
	}

	fn checkTypeAlias(mut &self, mut ta: &TypeAlias) {
		if self.isDuplicatedName(uintptr(ta), ta.Name) {
			self.s.pushErr(ta.Token, "identifier @ is duplicated in this scope", ta.Name)
			self.stop()
			ret
		}
		self.s.checkTypeAliasDecl(ta, nil, self)
		self.table.TypeAliases = append(self.table.TypeAliases, ta)

		// Stop immediately if destination type is could not evaluated.
		if ta.TypeSym.Type == nil {
			self.stop()
		}
	}

	fn checkTypeAliasDecl(mut &self, mut decl: &ast::TypeAlias) {
		mut ta := buildTypeAlias(decl)
		self.checkTypeAlias(ta)
	}

	fn getChild(mut *self): &Scope {
		ret &Scope{
			Owner: uintptr(self.scope),
			Parent: self.scope,
			ChildIndex: self.childIndex + 1,
		}
	}

	fn checkChildSsc(mut &self, mut tree: &ast::ScopeTree, mut s: &Scope, mut ssc: &scopeChecker) {
		s.StmtIndex = self.i
		s.ChildIndex = ssc.childIndex
		ssc.parent = self
		ssc.check(tree, s)
	}

	fn checkChildSc(mut &self, mut tree: &ast::ScopeTree, mut ssc: &scopeChecker): &Scope {
		mut s := self.getChild()
		self.checkChildSsc(tree, s, ssc)
		ret s
	}

	fn checkChild(mut &self, mut tree: &ast::ScopeTree): &Scope {
		mut ssc := self.newChildChecker()
		ret self.checkChildSc(tree, ssc)
	}

	fn checkAnonScope(mut &self, mut tree: &ast::ScopeTree) {
		if tree.Deferred {
			self.getRoot().owner.Decl.HasDefer = true
		}
		mut s := self.checkChild(tree)
		self.scope.Stmts = append(self.scope.Stmts, s)
	}

	fn processErrorCall(mut &self, mut m: &BuiltinErrorCallExpr, err: &token::Token) {
		if self.isDeferred() {
			self.s.pushErr(err, "error calls are not allowed in deferred scope")
		}

		mut root := self.getRoot()
		if !root.owner.Decl.Exceptional {
			self.s.pushErr(err, "error calls are not allowed in non-exceptional scopes")
		}
		m.Func = root.owner
	}

	fn checkExpr(mut &self, mut expr: &ast::Expr, flags: int) {
		mut eval := self.s.eval(self)
		eval.target.ignored = true
		mut evalFlags := evalDefault | evalPhysicalMem | evalUnwrapUntyped
		if flags&checkNodeNoExceptional != checkNodeNoExceptional {
			evalFlags |= evalExceptional
		}
		mut v := eval.evalExpr(expr, evalFlags)
		if v == nil || v.Model == nil {
			// Skip nil data, because evaluation failed and error documented (it should be) already.
			// Skip nil modeled data, this return only caused by built-in functions and it should be safe.
			ret
		}

		match type v.Model {
		| &BuiltinErrorCallExpr:
			mut m := v.Model.(&BuiltinErrorCallExpr)
			self.processErrorCall(m, expr.Token)
			self.scope.Stmts = append(self.scope.Stmts, v)
		| &BackendEmitExpr
		| &AddrcallExpr
		| &BuiltinAppendCallExpr
		| &BuiltinPrintCallExpr
		| &BuiltinPrintlnCallExpr
		| &BuiltinPanicCallExpr
		| &BuiltinCopyCallExpr
		| &BuiltinDeleteCallExpr
		| &BuiltinCloseCallExpr
		| &FuncCallExpr
		| &ChanRecv
		| &ChanSend:
			self.scope.Stmts = append(self.scope.Stmts, v)
		|:
			self.s.pushErr(expr.Token, "invalid syntax")
		}
	}

	fn checkIf(mut &self, mut i: &ast::If): &If {
		mut s := self.checkChild(i.Scope)

		mut v := self.s.eval(self).evalExpr(i.X, evalDefault|evalPhysicalMem|evalUnwrapUntyped)
		if v == nil {
			ret nil
		}

		mut prim := v.Type.Prim()
		if prim == nil || !prim.IsBool() {
			self.s.pushErr(i.X.Token, "if statement expressions must be boolean")
			ret nil
		}

		ret &If{
			Expr: v.Model,
			Scope: s,
		}
	}

	fn checkElse(mut &self, mut e: &ast::Else): &Else {
		ret &Else{
			Scope: self.checkChild(e.Scope),
		}
	}

	fn checkConditional(mut &self, mut conditional: &ast::Conditional) {
		mut c := new(Conditional)
		self.scope.Stmts = append(self.scope.Stmts, c)

		c.Elifs = make([]&If, 0, len(conditional.Tail)+1)

		for (_, mut elif) in conditional.Tail {
			c.Elifs = append(c.Elifs, self.checkIf(elif))
		}

		if conditional.Default != nil {
			c.Default = self.checkElse(conditional.Default)
		}
	}

	fn checkIterScopeSsc(mut &self, it: uintptr, mut tree: &ast::ScopeTree, mut s: &Scope, mut ssc: &scopeChecker) {
		ssc.it = it
		self.checkChildSsc(tree, s, ssc)
	}

	fn checkIterScopeSc(mut &self, it: uintptr, mut tree: &ast::ScopeTree, mut ssc: &scopeChecker): &Scope {
		mut scope := self.getChild()
		self.checkIterScopeSsc(it, tree, scope, ssc)
		scope.Owner = it
		ret scope
	}

	fn checkIterScope(mut &self, it: uintptr, mut tree: &ast::ScopeTree): &Scope {
		mut ssc := self.newChildChecker()
		ret self.checkIterScopeSc(it, tree, ssc)
	}

	fn checkInfIter(mut &self, mut it: &ast::Iter) {
		mut kind := new(InfIter)
		self.scope.Stmts = append(self.scope.Stmts, kind)
		kind.Scope = self.checkIterScope(uintptr(kind), it.Scope)
		kind.Scope.Traits |= ST_INFINITE
	}

	fn checkWhileIter(mut &self, mut it: &ast::Iter) {
		mut wh := it.Kind.(&ast::WhileKind)
		if wh.X == nil && wh.Next == nil {
			self.checkInfIter(it)
			ret
		}

		mut kind := new(WhileIter)
		self.scope.Stmts = append(self.scope.Stmts, kind)
		kind.Scope = self.checkIterScope(uintptr(kind), it.Scope)
		if wh.IsWhileNext() && wh.X == nil {
			kind.Scope.Traits |= ST_INFINITE
		}

		if wh.X != nil {
			mut v := self.s.eval(self).evalExpr(wh.X, evalDefault|evalPhysicalMem|evalUnwrapUntyped)
			if v == nil {
				ret
			}

			prim := v.Type.Prim()
			if prim == nil {
				self.s.pushErr(it.Token, "while iteration expression must be boolean")
				ret
			}

			if !prim.IsBool() {
				self.s.pushErr(it.Token, "while iteration expression must be boolean")
				ret
			}

			kind.Expr = v.Model
		}

		if wh.IsWhileNext() {
			if !isValidStmtForNext(wh.Next) {
				self.s.pushErr(wh.NextToken, "invalid statement for while-next")
				ret
			}

			n := len(self.scope.Stmts)
			self.checkNode(wh.Next, checkNodeNoExceptional)
			if n < len(self.scope.Stmts) {
				mut st := self.scope.Stmts[n]
				self.scope.Stmts = self.scope.Stmts[:n] // Remove trailing statements.
				if !isValidStmtForNext2(st) {
					self.s.pushErr(wh.NextToken, "invalid statement for while-next")
				}
				kind.Next = st
			}
		}
	}

	fn checkComptimeRangeIter(mut &self, mut it: &ast::Iter, mut kind: &RangeIter, mut v: &Value) {
		if kind.KeyA != nil {
			if !self.s.isFlag(Shadowing) && self.isDuplicatedName(0, kind.KeyA.Name) {
				self.s.pushErr(kind.KeyA.Token, "identifier @ is duplicated in this scope", kind.KeyA.Name)
			}
		}
		if kind.KeyB != nil {
			if !self.s.isFlag(Shadowing) && self.isDuplicatedName(0, kind.KeyB.Name) {
				self.s.pushErr(kind.KeyB.Token, "identifier @ is duplicated in this scope", kind.KeyB.Name)
			}
		}

		mut rang := it.Kind.(&ast::RangeKind)
		makeComptimeRange(v, false)
		if v.Decl {
			self.s.pushErr(rang.X.Token, "invalid type for comptime iteration: "+v.Type.Str())
			ret
		}

		mut rc := rangeChecker{
			sc: self,
			Kind: kind,
			rang: rang,
			v: v,
		}
		ok := rc.check()
		if !ok {
			ret
		}

		mut comptime := v.Type.comptimeRange()
		comptime.kind.ready(kind.KeyA, kind.KeyB)
		mut i := 0
		errors := len(self.s.errors)
		for i < comptime.kind.len(); i++ {
			mut ssc := self.newChildChecker()
			mut scope := self.getChild()
			if kind.KeyA != nil {
				kind.KeyA.Scope = scope
				ssc.table.Vars = append(ssc.table.Vars, kind.KeyA)
			}
			if kind.KeyB != nil {
				kind.KeyB.Scope = scope
				ssc.table.Vars = append(ssc.table.Vars, kind.KeyB)
			}
			comptime.kind.step(i, kind.KeyA, kind.KeyB)
			self.checkChildSsc(it.Scope, scope, ssc)
			if errors != len(self.s.errors) {
				// Stop execution if new error occurred.
				break
			}
			self.scope.Stmts = append(self.scope.Stmts, scope)
		}
	}

	fn checkRangeIter(mut &self, mut it: &ast::Iter) {
		mut rang := it.Kind.(&ast::RangeKind)

		// Evaluate expression as mutable. Because we can't know type of the expression,
		// so we can't able to determine whether expression should be mutable by type.
		// We should evaluate expression as mutable target, because if type have mutability,
		// the iteration variables may mutate the range expression.
		mut eval := self.s.eval(self)
		eval.target.mutable = true

		mut v := eval.evalExpr1(rang.X, evalDefault|evalPhysicalMem|evalUnwrapUntyped)
		if v == nil {
			ret
		}

		mut kind := &RangeIter{
			Expr: v,
			ExprToken: rang.X.Token,
		}

		if it.Comptime {
			self.checkComptimeRangeIter(it, kind, v)
			ret
		}
		if v.Type.comptime() {
			self.s.pushErr(rang.X.Token, "comptime expressions are not allowed for runtime range iterations")
			self.s.pushSuggestion("declare comptime range iteration, like; const for ...")
			ret
		}

		mut rc := rangeChecker{
			sc: self,
			Kind: kind,
			rang: rang,
			v: v,
		}
		ok := rc.check()
		if !ok {
			ret
		}

		self.scope.Stmts = append(self.scope.Stmts, kind)

		mut ssc := self.newChildChecker()
		mut scope := self.getChild()

		if kind.KeyA != nil {
			if !self.s.isFlag(Shadowing) && self.isDuplicatedName(0, kind.KeyA.Name) {
				self.s.pushErr(kind.KeyA.Token, "identifier @ is duplicated in this scope", kind.KeyA.Name)
			}
			kind.KeyA.Scope = scope
			ssc.table.Vars = append(ssc.table.Vars, kind.KeyA)
		}

		if kind.KeyB != nil {
			if !self.s.isFlag(Shadowing) && self.isDuplicatedName(0, kind.KeyB.Name) {
				self.s.pushErr(kind.KeyB.Token, "identifier @ is duplicated in this scope", kind.KeyB.Name)
			}
			kind.KeyB.Scope = scope
			ssc.table.Vars = append(ssc.table.Vars, kind.KeyB)
		}

		self.checkIterScopeSsc(uintptr(kind), it.Scope, scope, ssc)
		kind.Scope = scope
	}

	fn checkIter(mut &self, mut it: &ast::Iter) {
		if it.IsInfinite() {
			if it.Comptime {
				self.s.pushErr(it.Token, "comptime iterations can only be range iterations")
				ret
			}
			self.checkInfIter(it)
			ret
		}

		match type it.Kind {
		| &ast::WhileKind:
			if it.Comptime {
				self.s.pushErr(it.Token, "comptime iterations can only be range iterations")
				ret
			}
			self.checkWhileIter(it)
		| &ast::RangeKind:
			self.checkRangeIter(it)
		|:
			println("error <unimplemented iteration kind>")
		}
	}

	fn checkValidContLabel(mut &self, it: uintptr): bool {
		mut scope := self

	iter:
		if scope.it == it {
			ret true
		}

		if scope.parent != nil {
			scope = scope.parent
			goto iter
		}

		ret false
	}

	fn checkValidBreakLabel(mut &self, ptr: uintptr): bool {
		mut scope := self

	iter:
		// Check for iterations.
		if scope.it == ptr {
			ret true
		}

		// Check for match and select.
		if scope.cse != 0 {
			owner := unsafe { caseOwner((*Case)(scope.cse).Owner).asUintptr() }
			if owner == ptr {
				ret true
			}
		}

		if scope.parent != nil {
			scope = scope.parent
			goto iter
		}

		ret false
	}

	fn checkContValidScope(mut &self, c: &ast::Continue): &Continue {
		if self.isDeferred() {
			self.s.pushErr(c.Token, "continue keyword cannot be used out of iteration scopes")
			ret nil
		}

		if c.Label != nil {
			ret new(Continue)
		}

		mut scope := self
	iter:
		match {
		| scope.it == 0 && scope.parent != nil && scope.owner == nil:
			scope = scope.parent
			goto iter
		| scope.it != 0:
			ret &Continue{It: scope.it}
		}

		self.s.pushErr(c.Token, "continue keyword cannot be used out of iteration scopes")
		ret nil
	}

	fn checkCont(mut &self, c: &ast::Continue) {
		mut cont := self.checkContValidScope(c)
		if cont == nil {
			ret
		}

		if c.Label != nil { // Label given.
			mut label := findLabelParent(c.Label.Kind, self.parent)
			if label == nil {
				self.s.pushErr(c.Label, "undefined label: "+conv::Quote(c.Label.Kind))
				ret
			}

			label.used = true

			if label.node.Index+1 >= len(label.node.Scope.Stmts) {
				self.s.pushErr(c.Label, "invalid label to continue", c.Label.Kind)
				ret
			}

			i := label.node.Index + 1
			if i >= len(label.node.Scope.Stmts) {
				self.s.pushErr(c.Label, "invalid label to continue")
			} else {
				mut st := label.node.Scope.Stmts[i]
				match type st {
				| &InfIter:
					cont.It = uintptr(st.(&InfIter))
				| &RangeIter:
					cont.It = uintptr(st.(&RangeIter))
				| &WhileIter:
					cont.It = uintptr(st.(&WhileIter))
				|:
					self.s.pushErr(c.Label, "invalid label to continue", c.Label.Kind)
				}
			}
		}

		if cont.It != 0 {
			if !self.checkValidContLabel(cont.It) {
				self.s.pushErr(c.Label, "invalid label to continue", c.Label.Kind)
			}
		}

		self.scope.Stmts = append(self.scope.Stmts, cont)
	}

	fn checkLabel(mut &self, mut l: &ast::Label) {
		if self.findLabel(l.Name) != nil {
			self.s.pushErr(l.Token, "label is already exist: "+conv::Quote(l.Name))
			ret
		}

		mut label := &Label{
			Name: l.Name,
			Scope: self.scope,
			Index: self.i,
		}

		self.scope.Stmts = append(self.scope.Stmts, label)
		*self.labels = append(*self.labels, &scopeLabel{
			token: l.Token,
			node: label,
		})
	}

	fn pushGoto(mut &self, mut gt: &ast::Goto) {
		mut st := &Goto{
			Token: gt.Label,
			Name: gt.Label.Kind,
			Scope: self.scope,
			Index: self.i,
		}
		self.scope.Stmts = append(self.scope.Stmts, st)
		*self.gotos = append(*self.gotos, st)
	}

	fn checkPostfix(mut &self, mut a: &ast::Assign) {
		if len(a.X) > 1 {
			self.s.pushErr(a.Op, "invalid syntax")
			ret
		}

		mut eval := self.s.eval(self)
		eval.target.mutable = true

		mut x := a.X[0].X
		mut v := eval.evalExpr(x, evalDefault)
		if v == nil {
			ret
		}

		_ = checkAssign(self.s, v, nil, a.Op)

		if v.Type.Ptr() != nil {
			if isRef(v) {
				self.s.pushErr(a.Op, "postfix operator are not supported by the reference pointer type @", v.Type.Str())
				ret
			} else {
				mut ptr := v.Type.Ptr()
				if ptr.IsUnsafe() {
					self.s.pushErr(a.Op, "operator @ is not defined for type @", a.Op.Kind, v.Type.Str())
					ret
				}
			}
		} else {
			if v.Type.Prim() == nil || !types::IsNum(v.Type.Prim().Kind) {
				self.s.pushErr(a.Op, "operator @ is not defined for type @", a.Op.Kind, v.Type.Str())
				ret
			}
		}

		self.scope.Stmts = append(self.scope.Stmts, &Postfix{
			Expr: v.Model,
			Op: a.Op.Kind,
		})
	}

	fn isNewAssignIdent(mut *self, name: str): bool {
		if jule::IsBlank(name) || name == "" {
			ret false
		}
		ret self.table.defByIdent(name, false) == nil
	}

	// Remove the interior mutability risk if the v represents a structure and
	// this scope is owned by method which is owned by the relevant structure.
	// In this case we should remove the interior mutability risk of data to allow copying.
	// Otherwise assign analysis will complain and copy operation will not be allowed.
	//
	// See also documentation of the [sema.isMutRiskyStruct] method.
	fn removeInteriorMutRisk(mut &self, mut v: &Value) {
		s := v.Type.Struct()
		if s == nil {
			ret
		}
		root := self.getHardRoot()
		// Owner is not structure or structure is mutable.
		// If structure is mutable, it means there is risky mutable-typed
		// fields even for internal members.
		if root.owner.Owner != s || s.Mutable {
			ret
		}
		// Mark data as mutable.
		// Mutable data is not occurs mutability risk for analysis.
		v.Mutable = true
	}

	fn checkSingleAssign(mut &self, mut a: &ast::Assign, flags: int) {
		let mut l: &Value = nil

		if !jule::IsBlank(a.X[0].Name) {
			mut x := a.X[0].X
			mut eval := self.s.eval(self)
			eval.target.mutable = true
			l = eval.evalExpr(x, evalDefault)
			if l == nil {
				ret
			}
		}

		mut eval := (&eval)(nil)
		if l != nil {
			eval = self.s.evalp(self, l.Type)
		} else {
			eval = self.s.eval(self)
		}
		eval.target.mutable = true
		eval.unsafety = self.isUnsafe()
		// Eval with evalUnwrapUntyped if l == nil, otherwise type will be checked.
		// So, do not unwrap untyped values.
		mut evalFlags := evalDefault
		if flags&checkNodeNoExceptional != checkNodeNoExceptional {
			evalFlags |= evalExceptional
		}
		if l == nil {
			evalFlags |= evalUnwrapUntyped
		} else if isRef(l) {
			evalFlags |= evalRefptr
		}
		mut r := eval.evalExpr(a.Y, evalFlags)
		if r == nil {
			ret
		}

		self.removeInteriorMutRisk(r)

		if l == nil {
			if r.Type.Void() {
				self.s.pushErr(a.Y.Token, "invalid expression")
			}
			if a.Op.ID != token::ASSIGN {
				self.s.pushErr(a.Op, "invalid syntax")
			}
			self.scope.Stmts = append(self.scope.Stmts, r)
			ret
		}

		if !checkAssign(self.s, l, r, a.Op) {
			ret
		}

		tup := r.Type.Tuple()
		if tup != nil {
			self.s.pushErr(a.Op, "missing identifier for assignment, expected @, found 1", len(tup.Types))
			ret
		}

		mut lm := &OperandExpr{
			Type: l.Type,
			Model: l.Model,
		}
		mut rm := &OperandExpr{
			Type: r.Type,
			Model: r.Model,
		}
		self.scope.Stmts = append(self.scope.Stmts, &Assign{Left: lm, Right: rm, Op: a.Op})

		if a.Op.ID == token::ASSIGN {
			const firstAssignToDest = false // this is not the first assignment to the variable
			reference := isRef(l)
			if self.s.checkAssignType(reference, firstAssignToDest, l.Type, r, a.Op, self.getOwnerRefers()) {
				// The type model data might be stale because [checkAssignType] may update them.
				// But don't assign to lm and rm, implicit casting must not affect original representation.
			}
			ret
		}
		id := a.Op.ID
		a.Op.ID = removeEqFromOp(a.Op.ID)
		mut solver := binaryEval.new(eval, a.Op, a.Op, a.Y.Token)
		solver.l, solver.r = l, r
		_ = solver.evalOp()
		a.Op.ID = id
	}

	fn processEndPartOfMultiAssign(mut &self, mut st: &MultiAssign, mut a: &ast::Assign,
		mut lexpr: &ast::AssignLeft, mut l: &Value, mut r: exprPart, strict: bool) {
		if !lexpr.Reference && jule::IsBlank(lexpr.Name) {
			if r.data.Type.Void() {
				self.s.pushErr(a.Y.Token, "invalid expression")
				self.s.pushSuggestion("expected value, found void type")
			}
			st.Left = append(st.Left, nil)
			ret
		}
		if a.Decl {
			match type lexpr.X.Data {
			| &ast::NameExpr:
				if !self.isNewAssignIdent(lexpr.Name) {
					goto norm
				}
			|:
				if lexpr.Mutable || lexpr.Reference {
					self.s.pushErr(lexpr.Token, "invalid syntax")
					ret
				}
				goto norm
			}
			if self.isDuplicatedName(0, lexpr.Name) {
				self.s.pushErr(lexpr.Token, "identifier @ is duplicated in this scope", lexpr.Name)
				self.stop()
				ret
			}
			if jule::IsBlank(lexpr.Name) {
				self.s.pushErr(lexpr.Token, "blank identifier cannot be used as an identifier for this declaration")
			}

			// Add new variable declaration statement.
			mut v := &Var{
				Name: lexpr.Name,
				Token: lexpr.Token,
				Mutable: lexpr.Mutable,
				Reference: lexpr.Reference,
				Scope: self.scope,
				ValueSym: &ValueSym{
					Expr: r.expr,
					Value: r.data,
				},
			}
			self.s.checkVarValue(v)
			st.Left = append(st.Left, &Value{
				Lvalue: !v.Constant,
				Mutable: v.Mutable,
				Reference: v.Reference,
				Type: v.TypeSym.Type,
				Model: v,
			})
			st.Decls = append(st.Decls, v)
			self.table.Vars = append(self.table.Vars, v)
			ret
		}
	norm:
		if lexpr.Mutable || lexpr.Reference {
			self.s.pushErr(lexpr.Token, "identifier @ is duplicated in this scope", lexpr.Name)
		}

		if !checkAssign(self.s, l, r.data, lexpr.Token) {
			ret
		}

		// Set reference false because this is normal assignment.
		// So, we don't need to check reference assignment should using lvalue.
		mut reference := false
		if self.s.checkValidityForInitExpr(l.Mutable, reference, l.Type, r.data, r.expr.Token) {
			// Enable reference checking if strict mode enabled.
			reference = strict
			// This is not the first assignment to the variable.
			// So analysis must use false for this information.
			// But for strict mode, use the true to avoid assignment error.
			firstAssignToDest := reference
			self.s.checkAssignType(reference, firstAssignToDest, l.Type, r.data, r.expr.Token, self.getOwnerRefers())
		}
		st.Left = append(st.Left, l)
	}

	fn getRightExprsOfMultiAssign(mut &self, mut a: &ast::Assign,
		mut eval: &eval): (parts: []exprPart, right: &Value, ok: bool) {
		updateMut := fn(i: int) {
			l := a.X[i]
			// Mark target as mutable because if an expression can take assignment
			// it should be a mutable memory, but set as immutable if variable declaring
			// and it is not mutable.
			//
			// This is not actually a mutability safety checking.
			// This just makes responsive-mutability possible and correct.
			eval.target.mutable = !jule::IsBlank(l.Name) // if assigned to blank identifier, there is no mutability risk
			if a.Decl && eval.target.mutable {
				if l.Mutable && l.Reference {
					eval.target.mutable = l.Mutable
				} else {
					_, isName := l.X.Data.(&ast::NameExpr)
					if isName && self.isNewAssignIdent(l.Name) {
						eval.target.mutable = l.Mutable
					}
				}
			}
		}

		ok = true
		match type a.Y.Data {
		| &ast::TupleExpr:
			mut tup := a.Y.Data.(&ast::TupleExpr)
			parts = make([]exprPart, 0, len(tup.X))
			i := 0
			mut _i := unsafe { (&int)(&i) }                // reference pointer for closure
			mut _ok := unsafe { (&bool)(&ok) }             // reference pointer for closure
			mut _parts := unsafe { (&[]exprPart)(&parts) } // reference pointer for closure
			right = eval.evalTupleFunc(tup, fn|mut expr| {
				if *_i >= len(a.X) {
					ret nil
				}
				updateMut(*_i)
				// Do not unwrap untyped literals, type analysis will check overflows.
				// Check only if assigned to blank identifier.
				mut flags := evalDefault
				if jule::IsBlank(a.X[*_i].Name) {
					flags |= evalPhysicalMem | evalUnwrapUntyped
				}
				if a.X[*_i].Reference {
					flags |= evalRefptr
				}
				mut v := eval.evalExpr(expr, flags)
				if v != nil {
					*_parts = append(*_parts, exprPart{v, expr})
				} else {
					*_ok = false
				}
				ret v
			})
		|:
			// Some special cases such as map-lookup assignments may evaluated here.
			// It is mutability safe even if map stored in immutable memory and have mutable type value.
			// Because mutability will be checked by assignment analysis.
			updateMut(0)
			mut evalFlags := evalDefault | evalPhysicalMem | evalUnwrapUntyped | evalExceptional
			if a.X[0].Reference {
				evalFlags |= evalRefptr
			}
			right = eval.evalExpr(a.Y, evalFlags)
			if right == nil {
				ok = false
				ret
			}

			if right.Type.Tuple() != nil {
				mut t := right.Type.Tuple()
				parts = make([]exprPart, 0, len(t.Types))
				for (_, mut kind) in t.Types {
					parts = append(parts, exprPart{
						&Value{
							Mutable: true, // Function return.
							Type: kind,
						},
						a.Y,
					})
				}
			} else {
				parts = [{right, a.Y}]
			}
		}
		ret
	}

	fn checkMultiAssign(mut &self, mut a: &ast::Assign) {
		if a.Op.ID != token::ASSIGN && a.Op.ID != token::DEFINE {
			self.s.pushErr(a.Op, "invalid syntax")
			ret
		}

		errors := len(self.s.errors)
		mut eval := self.s.eval(self)
		mut right, mut rightData, mut ok := self.getRightExprsOfMultiAssign(a, eval)
		if !ok {
			ret
		}

		mut strict := false // any type compatibility analysis requires exact same type
		if len(right) == 1 {
			match type right[0].data.Model {
			| &IndexingExpr:
				mut iem := right[0].data.Model.(&IndexingExpr)
				if iem.Expr.Type.Map() != nil { // Is map lookup.
					strict = true
					right = [
						{&Value{Mutable: right[0].data.Mutable, Type: iem.Expr.Type.Map().Value}, right[0].expr},
						{&Value{Type: primBool}, right[0].expr},
					]
				}
			| &TypeAssertionExpr:
				mut ce := right[0].data.Model.(&TypeAssertionExpr)
				prim := ce.Expr.Type.Prim()
				if prim != nil && prim.IsAny() || ce.Expr.Type.TypeEnum() != nil || ce.Expr.Type.Trait() != nil {
					strict = true
					right = [
						{&Value{Mutable: right[0].data.Mutable, Type: ce.Type}, right[0].expr},
						{&Value{Type: primBool}, right[0].expr},
					]
					// Handle and add reference to dynAssertAssign function.
					// If an error was generated while evaluating the expression,
					// do not handle it to avoid more errors. Because runtime
					// implementation may generate additional errors.
					// On trait types, we should know type is compatible for casting.
					// Otherwise runtime assertion implementation will generate
					// errors about it too.
					if errors == len(self.s.errors) && self.s.meta.runtime != nil {
						mut decl := runtimeFindFunc(self.s.meta.runtime, "dynAssertAssign")
						mut f := decl.instanceForce()
						f.Generics = append(f.Generics, &InsGeneric{Type: ce.Expr.Type}, &InsGeneric{Type: ce.Type})
						mut token := right[0].expr.Token
						ok, _ = self.s.checkGenericFunc(&f, token)
						if !ok {
							panic("sema: dynAssertAssign evaluation failed, this is an implementation mistake")
						}
						mut refers := self.getOwnerRefers()
						if refers != nil && !refers.Exist[&FuncIns](f) {
							refers.Push(f)
						}
					}
				}
			| &ChanRecv:
				mut cr := right[0].data.Model.(&ChanRecv)
				strict = true
				right = [
					{&Value{Mutable: right[0].data.Mutable, Type: cr.Expr.Type.Chan().Value}, right[0].expr},
					{&Value{Type: primBool}, right[0].expr},
				]
			|:
				// no-op
			}
		}

		match {
		| len(a.X) > len(right):
			self.s.pushErr(a.Op, "passed identifiers more than expected, expected @, passed @", len(right), conv::Itoa(len(a.X)))
			ret
		| len(a.X) < len(right):
			self.s.pushErr(a.Op, "passed identifiers less than expected, expected @, passed @", len(right), conv::Itoa(len(a.X)))
			ret
		}

		// evaluate left operands as mutable because they will be mutated because of assignment
		eval.target.mutable = true

		mut st := &MultiAssign{
			Right: rightData.Model,
			Op: a.Op,
		}
		for i in a.X {
			mut lexpr := a.X[i]
			let mut l: &Value = nil
			if !jule::IsBlank(lexpr.Name) {
				if !a.Decl {
					goto eval
				}
				// If variable is reference or mutable, this is exactly a new identifier.
				if lexpr.Mutable || lexpr.Reference {
					goto end
				}
				_, ok = lexpr.X.Data.(&ast::NameExpr)
				if ok {
					if self.isNewAssignIdent(lexpr.Name) {
						goto end
					}
				}
			eval:
				l = eval.evalExpr(lexpr.X, evalDefault)
				if l == nil {
					continue
				}
			end:
			}
			mut r := right[i]
			self.removeInteriorMutRisk(r.data)
			self.processEndPartOfMultiAssign(st, a, lexpr, l, r, strict)
		}
		self.scope.Stmts = append(self.scope.Stmts, st)
	}

	fn checkAssign(mut &self, mut a: &ast::Assign, flags: int) {
		match {
		| token::IsPostfix(a.Op.ID):
			self.checkPostfix(a)
		| len(a.X) == 1:
			self.checkSingleAssign(a, flags)
		|:
			self.checkMultiAssign(a)
		}
	}

	fn checkCaseScope(mut &self, c: &Case, mut tree: &ast::ScopeTree): &Scope {
		mut ssc := self.newChildChecker()
		ssc.cse = uintptr(c)
		ret self.checkChildSc(tree, ssc)
	}

	fn checkCase(mut &self, mut m: &Match, mut astm: &ast::Match, i: int, mut c: &ast::Case, mut expr: &Value): &Case {
		mut enm := getMatchEnum(m.Expr.Type)
		mut case := m.Cases[i]
		case.Exprs = make([]&Value, 0, len(c.X))
		mut constMatched := false
		mut eval := self.s.eval(self)
		for (_, mut e) in c.X {
			let mut v: &Value
			if enm == nil {
				v = eval.evalExprPlain(e)
			} else {
				mut name, ok := e.Data.(&ast::NameExpr)
				if ok {
					v = eval.evalEnumStatic(enm, name.Token)
				} else {
					self.s.pushErr(e.Token, "invalid expression")
					self.s.pushSuggestion("use field names directly to match enum")
				}
			}
			if v == nil {
				continue
			}

			if m.TypeMatch {
				// Match types. There is not need to check whether v.Decl is true.
				// Parser always tries to build type declarations for type-match cases.
				// So, v is should be type declaration already.
				case.Exprs = append(case.Exprs, v)
				if countMatchType(m, v.Type, 2) > 1 {
					self.s.pushErr(e.Token, "type @ is already matched", v.Type.Str())
				}
				if m.Comptime {
					constMatched = constMatched || expr.Type.Equal(v.Type)
				} else if expr.Type.TypeEnum() != nil || expr.Type.Trait() != nil {
					// Check whether checked types are compatible for type-enum or trait.
					// For type-enums, do not consider inherited type-enums compatible directly.
					// But still their internal type list will be considered compatible.
					// This is needed to count all inherited type list elements as compatible,
					// except the type-enum's itself.
					_ = self.s.checkTypeCompatibility(expr.Type, v.Type, e.Token, typeCompDefault|typeCompNoInherited)
				}
				continue
			}

			if v.Decl {
				self.s.pushErr(e.Token, "expected value, found type declaration")
				self.s.pushSuggestion("use type-match statement to match type of dynamic types")
				continue
			}

			if m.Comptime {
				if !v.IsConst() && v.Type.comptimeTypeInfo() == nil {
					self.s.pushErr(e.Token, "expression must be constant")
					self.s.pushSuggestion("comptime-matching requires constant expression")
					continue
				}
				if !constMatched {
					if v.IsConst() {
						constMatched = expr.IsConst() && v.Constant.EQL(*expr.Constant)
					} else {
						exprCti := expr.Type.comptimeTypeInfo()
						constMatched = exprCti != nil && v.Type.comptimeTypeInfo().base.Equal(exprCti.base)
					}
				}
			}

			case.Exprs = append(case.Exprs, v)
			// If matching an enum, check for the duplicate cases.
			if enm != nil {
				name := e.Data.(&ast::NameExpr)
				if countMatchEnum(astm, name.Name, 2) > 1 {
					self.s.pushErr(e.Token, "field @ is already matched", conv::Quote(name.Name))
				}
			}
			if !m.Comptime ||
				expr.Type.comptimeTypeInfo() == nil ||
				v.Type.comptimeTypeInfo() == nil {
				mut checker := assignTypeChecker{
					s: self.s,
					dest: expr.Type,
					v: v,
					errorToken: e.Token,
					refers: self.getOwnerRefers(),
				}
				checker.check()
			}
		}
		if !m.Comptime || constMatched {
			case.Scope = self.checkCaseScope(case, c.Scope)
		}
		ret case
	}

	fn checkCases(mut &self, mut m: &ast::Match, mut rm: &Match, mut expr: &Value) {
		rm.Cases = make([]&Case, 0, len(m.Cases))
		for i in m.Cases {
			mut case := &Case{
				Owner: rm,
			}
			if i > 0 {
				rm.Cases[i-1].Next = case
			}
			rm.Cases = append(rm.Cases, case)
		}

		if rm.Default != nil && len(m.Cases) > 0 {
			rm.Cases[len(rm.Cases)-1].Next = rm.Default
		}

		for (i, mut c) in m.Cases {
			self.checkCase(rm, m, i, c, expr)
		}
	}

	fn checkDefault(mut &self, mut owner: CaseOwner, mut d: &ast::Else): &Case {
		mut def := &Case{
			Owner: owner,
		}
		def.Scope = self.checkCaseScope(def, d.Scope)
		ret def
	}

	fn checkComptimePanic(mut &self, mut callToken: &token::Token, mut s: &Scope) {
		if len(s.Stmts) != 1 {
			ret
		}
		mut stmt := s.Stmts[0]
		mut v, mut ok := stmt.(&Value)
		if !ok {
			ret
		}
		mut m, (ok) := v.Model.(&BuiltinPanicCallExpr)
		if !ok {
			ret
		}
		c, (ok) := m.Expr.(&constant::Const)
		if !ok || !c.IsStr() {
			ret
		}
		if callToken == nil {
			mut root := self.getHardRoot()
			if root.calledFrom == nil {
				callToken = m.Token
			} else {
				callToken = root.calledFrom
			}
		}
		self.s.pushErr(callToken, "comptime panic: "+c.ReadStr())
		self.stop()
	}

	fn processConstMatch(mut &self, mut tm: &Match, mut m: &ast::Match) {
		for (i, mut c) in tm.Cases {
			if c.Scope != nil {
				let mut token: &token::Token = nil
				if !tm.TypeMatch && len(c.Scope.Stmts) > 0 {
					token = m.Cases[i].Scope.Stmts[0].Token
				}
				self.checkComptimePanic(token, c.Scope)
				tm.Default = c
				tm.Cases = nil
				ret
			}
		}
		if m.Default != nil {
			tm.Cases = nil
			tm.Default = self.checkDefault(tm, m.Default)
			if tm.Default != nil {
				let mut token: &token::Token = nil
				if !tm.TypeMatch {
					token = m.Default.Scope.Stmts[0].Token
				}
				self.checkComptimePanic(token, tm.Default.Scope)
			}
		} else {
			// Remove all cases, no success matching.
			tm.Cases = nil
		}
	}

	// Checks and reports whether the all possible types of enum handled in the match statement.
	// Writes all missing types as a list to sb.
	fn checkAllTypeEnumCasesHandled(mut &self, mut m: &Match, mut te: &TypeEnum, mut &sb: *strings::Builder): (ok: bool) {
		let mut isPushedAlready: fn(mut t: &TypeEnum, mut item: &TypeEnumItem): bool
		&_isPushedAlready := &isPushedAlready
		isPushedAlready = fn|mut t, mut item| {
			for (_, mut titem) in t.Items {
				if titem == item {
					ret false
				}
				mut ke := titem.TypeSym.Type.TypeEnum()
				// Check if the titem's type is not type-enum.
				// Because inherited type-enums will not be considered compatible in type matching.
				// See documentation of the [self.checkCase] function for type-match statements.
				if ke == nil {
					if titem.TypeSym.Type.Equal(item.TypeSym.Type) {
						ret true
					}
				}
				// If item is not strict type alias, check inherited types if it is type-enum.
				if titem.TypeSym.Type.SoftStruct() == nil {
					if ke != nil {
						pushed := unsafe { (*_isPushedAlready)(ke, item) }
						if pushed {
							ret true
						}
					}
				}
			}
			ret false
		}

		ok = true
		for (_, mut item) in te.Items {
			if countMatchType(m, item.TypeSym.Type, 1) == 1 {
				continue
			}
			// If item is not strict type alias, check inherited types if it is type-enum.
			if item.TypeSym.Type.SoftStruct() == nil {
				mut ke := item.TypeSym.Type.TypeEnum()
				if ke != nil {
					ok = ok && self.checkAllTypeEnumCasesHandled(m, ke, sb)
					continue
				}
			}
			// error: type is not exist in the match statement.
			ok = false
			if isPushedAlready(te, item) {
				continue
			}
			if sb.Len() > 0 {
				sb.WriteStr(", ")!
			}
			sb.WriteStr(item.TypeSym.Type.Str())!
		}
		ret
	}

	fn checkTypeMatch(mut &self, mut m: &ast::Match) {
		mut v := self.s.eval(self).eval1(m.X, evalDefault|evalPhysicalMem|evalUnwrapUntyped)
		if v == nil {
			ret
		}

		mut te := v.Type.TypeEnum()
		if m.Comptime {
			mut cti := v.Type.comptimeTypeInfo()
			if cti == nil {
				if !v.Decl {
					self.s.pushErr(m.X.Token, "expected type declaration, found value")
					ret
				}
			} else {
				v.Type = cti.base
			}
		} else if v.Decl || !((v.Type.Prim() != nil && v.Type.Prim().IsAny()) || v.Type.Trait() != nil || te != nil) {
			self.s.pushErr(m.X.Token, "type-match statement must take dynamic type")
			self.s.pushSuggestion("such as any, trait, or type-enum")
			ret
		}

		mut tm := &Match{
			Scope: self.scope,
			TypeMatch: true,
			Expr: v,
			Comptime: m.Comptime,
		}

		// Do not check default if comptime matching enabled.
		// We do not know any case will be matched yet.
		// The [self.processConstMatch] will check cases and if not exist
		// any matching, will check default case if exist and handle it.
		if !tm.Comptime && m.Default != nil {
			tm.Default = self.checkDefault(tm, m.Default)
		}

		self.checkCases(m, tm, v)
		if tm.Comptime {
			self.processConstMatch(tm, m)
		}

		// If the expression type is a type-enum, make sure all the type cases handled.
		// If match statement have a default case, avoid evaluation cost, handled all cases.
		if tm.Default == nil && te != nil {
			mut sb := strings::Builder{}
			ok := self.checkAllTypeEnumCasesHandled(tm, te, &sb)
			if !ok {
				self.s.pushErr(m.Token, "match statement does not handle all possible types\n       missing: "+sb.Str())
				self.s.pushSuggestion("handle missing cases or add a default case")
			}
		}

		self.scope.Stmts = append(self.scope.Stmts, tm)
	}

	fn checkAllEnumCasesHandled(mut &self, mut m: &ast::Match, mut enm: &Enum) {
		mut sb := strings::Builder{}
		for _, item in enm.Items {
			if countMatchEnum(m, item.Name, 1) == 0 {
				if sb.Len() > 0 {
					sb.WriteStr(", ")!
				}
				sb.WriteStr(item.Name)!
			}
		}
		if sb.Len() > 0 {
			self.s.pushErr(m.Token, "match statement does not handle all possible enum fields\n       missing: "+sb.Str())
			self.s.pushSuggestion("handle missing cases or add a default case")
		}
	}

	fn checkCommonMatch(mut &self, mut m: &ast::Match) {
		let mut v: &Value = nil
		if m.X == nil {
			v = &Value{
				untyped: true,
				Constant: constant::NewBool(true),
				Type: primBool,
			}
			v.Model = v.Constant
		} else {
			v = self.s.eval(self).evalExpr1(m.X, evalDefault|evalPhysicalMem|evalUnwrapUntyped)
			if v == nil {
				ret
			}
		}

		if m.Comptime {
			if !canComptimeMatch(v) {
				self.s.pushErr(m.X.Token, "expression must be constant")
				self.s.pushSuggestion("comptime-matching requires constant expression")
				ret
			}
		} else if v.Type.comptime() {
			self.s.pushErr(m.X.Token, "expression must be constant")
			self.s.pushSuggestion("comptime-matching requires constant expression")
			ret
		}

		mut mc := &Match{
			Scope: self.scope,
			Expr: v,
			Comptime: m.Comptime,
		}

		// Push into stmts here. Otherwise, labeled break statements and others
		// will may log error(s) even semantic is good.
		self.scope.Stmts = append(self.scope.Stmts, mc)

		// Save the current error count of semantic analysis.
		// It will be used to detect new errors, if any.
		errors := len(self.s.errors)

		// Do not check default if comptime matching enabled.
		// We do not know any case will be matched yet.
		// The [self.processConstMatch] will check cases and if not exist
		// any matching, will check default case if exist and handle it.
		if !mc.Comptime && m.Default != nil {
			mc.Default = self.checkDefault(mc, m.Default)
		}
		self.checkCases(m, mc, v)
		if mc.Comptime {
			self.processConstMatch(mc, m)
		}
		// If there is no error for this match statement,
		// check the cases for enum if matching an enum.
		// If match statement have a default case, avoid evaluation cost, handled all cases.
		if mc.Default == nil && errors == len(self.s.errors) {
			mut enm := getMatchEnum(mc.Expr.Type)
			if enm != nil {
				self.checkAllEnumCasesHandled(m, enm)
			}
		}
	}

	fn checkMatch(mut &self, mut m: &ast::Match) {
		if m.Type {
			self.checkTypeMatch(m)
			ret
		}
		self.checkCommonMatch(m)
	}

	fn checkSelectCase(mut &self, mut slct: &Select, i: int, mut c: &ast::Case): &Case {
		mut case := slct.Cases[i]
		case.Exprs = make([]&Value, 0, len(c.X))
		mut eval := self.s.eval(self)

		mut ssc := self.newChildChecker()
		mut scope := self.getChild()
		ssc.scope = scope

		if c.Stmt != nil {
			match type c.Stmt {
			| &ast::Var:
				mut sv := c.Stmt.(&ast::Var)
				let mut var: &Var
				ssc.checkVarDecl((&ast::Var)(sv), &var)
				if ssc.stopped() || var == nil {
					ret nil
				}
				match type var.ValueSym.Value.Model {
				| &ChanRecv | &ChanSend:
					ssc.scope.Stmts = ssc.scope.Stmts[:len(ssc.scope.Stmts)-1]
					case.Stmt = var
				|:
					self.s.pushErr(var.ValueSym.Expr.Token, "invalid select expression, expected channel receive or send")
				}
			| &ast::Assign:
				mut assign := c.Stmt.(&ast::Assign)
				ssc.checkAssign(assign, checkNodeDefault|checkNodeNoExceptional)
				if self.stopped() {
					ret nil
				}
				mut stmt := ssc.scope.Stmts[len(ssc.scope.Stmts)-1]
				match type stmt {
				| &Value:
					mut v := stmt.(&Value)
					match type v.Model {
					| &ChanRecv | &ChanSend:
						ssc.scope.Stmts = ssc.scope.Stmts[:len(ssc.scope.Stmts)-1]
						case.Stmt = v
					|:
						self.s.pushErr(assign.Y.Token, "invalid select expression, expected channel receive or send")
					}
				| &Assign:
					mut assignStmt := stmt.(&Assign)
					match type assignStmt.Right.Model {
					| &ChanRecv | &ChanSend:
						ssc.scope.Stmts = ssc.scope.Stmts[:len(ssc.scope.Stmts)-1]
						case.Stmt = stmt
					|:
						self.s.pushErr(assign.Y.Token, "invalid select expression, expected channel receive or send")
					}
				|:
					panic("unreachable")
				}
			|:
				panic("unreachable")
			}
		} else {
			mut e := c.X[0]
			mut v := eval.evalExpr(e, evalDefault|evalPhysicalMem|evalUnwrapUntyped)
			if v != nil {
				match type v.Model {
				| &ChanRecv | &ChanSend:
					case.Stmt = v
				|:
					self.s.pushErr(e.Token, "invalid select expression, expected channel receive or send")
				}
			}
		}

		// Do what [scopeChecker.checkCaseScope] does.
		// Inline implementation of this function.
		// If it scales too much, consider implementing it as a function.
		ssc.cse = uintptr(case)

		self.checkChildSsc(c.Scope, scope, ssc)
		case.Scope = scope

		ret case
	}

	fn checkSelectCases(mut &self, mut sc: &ast::Select, mut slct: &Select) {
		slct.Cases = make([]&Case, 0, len(sc.Cases))
		for i in sc.Cases {
			mut case := &Case{
				Owner: slct,
			}
			if i > 0 {
				slct.Cases[i-1].Next = case
			}
			slct.Cases = append(slct.Cases, case)
		}

		if slct.Default != nil && len(sc.Cases) > 0 {
			slct.Cases[len(slct.Cases)-1].Next = slct.Default
		}

		for (i, mut c) in sc.Cases {
			self.checkSelectCase(slct, i, c)
		}
	}

	fn checkSelect(mut &self, mut sc: &ast::Select) {
		if !self.isAsync() {
			self.s.pushErr(sc.Token, "`select` statements can only be used within an `async` scope")
		}
		mut slct := &Select{
			Scope: self.scope,
		}
		// Push into stmts here. Otherwise, labeled break statements and others
		// will may log error(s) even semantic is good.
		self.scope.Stmts = append(self.scope.Stmts, slct)
		if sc.Default != nil {
			slct.Default = self.checkDefault(slct, sc.Default)
		}
		self.checkSelectCases(sc, slct)
	}

	fn checkFall(mut &self, f: &ast::Fall) {
		if self.cse == 0 ||
			len(self.scope.Stmts)+1 < len(self.scope.Stmts) ||
			self.isDeferred() {
			self.s.pushErr(f.Token, "fall keyword can only be used at end of case scopes")
			ret
		}

		mut case := unsafe { (*Case)(self.cse) }
		match type unsafe { case.Owner } {
		| &Match:
			if unsafe { case.Owner.(&Match).Comptime } {
				self.s.pushErr(f.Token, "fall statement is not allowed for comptime-matching")
				ret
			}
		| &Select:
			self.s.pushErr(f.Token, "fall statement is not allowed for select statements")
			ret
		}
		if unsafe { case.Next } == nil {
			self.s.pushErr(f.Token, "fall statement cannot be used in the final case")
			ret
		}

		self.scope.Stmts = append(self.scope.Stmts, &Fall{
			DestCase: unsafe { uintptr(case.Next) },
		})
	}

	fn checkBreakWithLabel(mut &self, b: &ast::Break): &Break {
		mut brk := self.checkPlainBreak(b)
		if brk == nil {
			ret nil
		}

		// Set pointer to zero.
		// Pointer will set by label.
		brk.It = 0
		brk.Match = 0

		mut label := findLabelParent(b.Label.Kind, self.parent)
		if label == nil {
			self.s.pushErr(b.Label, "invalid label to break: "+conv::Quote(b.Label.Kind))
			ret nil
		}

		label.used = true

		if label.node.Index+1 >= len(label.node.Scope.Stmts) {
			self.s.pushErr(b.Label, "invalid label to break: "+conv::Quote(b.Label.Kind))
			ret nil
		}

		i := label.node.Index + 1
		if i >= len(label.node.Scope.Stmts) {
			self.s.pushErr(b.Label, "invalid label to break: "+conv::Quote(b.Label.Kind))
		} else {
			mut st := label.node.Scope.Stmts[i]
			match type st {
			| &InfIter:
				brk.It = uintptr(st.(&InfIter))
			| &RangeIter:
				brk.It = uintptr(st.(&RangeIter))
			| &WhileIter:
				brk.It = uintptr(st.(&WhileIter))
			| &Match:
				brk.Match = uintptr(st.(&Match))
			| &Select:
				brk.Select = uintptr(st.(&Select))
			|:
				self.s.pushErr(b.Label, "invalid label to break: "+conv::Quote(b.Label.Kind))
			}
		}

		if brk.It != 0 {
			if !self.checkValidBreakLabel(brk.It) {
				self.s.pushErr(b.Label, "invalid label to break: "+conv::Quote(b.Label.Kind))
			}
		}

		if brk.Match != 0 {
			if !self.checkValidBreakLabel(brk.Match) {
				self.s.pushErr(b.Label, "invalid label to break: "+conv::Quote(b.Label.Kind))
			}
		}

		if brk.Select != 0 {
			if !self.checkValidBreakLabel(brk.Select) {
				self.s.pushErr(b.Label, "invalid label to break: "+conv::Quote(b.Label.Kind))
			}
		}

		ret brk
	}

	fn checkPlainBreak(mut &self, b: &ast::Break): &Break {
		if self.isDeferred() {
			self.s.pushErr(b.Token, "break keyword cannot be used out of iteration or match statement scopes")
			ret nil
		}

		mut scope := self
	iter:
		match {
		| scope.it == 0 && scope.cse == 0 && scope.parent != nil && scope.owner == nil:
			scope = scope.parent
			goto iter
		| scope.it != 0:
			ret &Break{It: scope.it}
		| scope.cse != 0:
			owner := caseOwner(unsafe { (*Case)(scope.cse).Owner }).asUintptr()
			ret &Break{Match: owner}
		}

		self.s.pushErr(b.Token, "break keyword cannot be used out of iteration or match statement scopes")
		ret nil
	}

	fn checkBreak(mut &self, b: &ast::Break) {
		if b.Label != nil { // Label given.
			mut brk := self.checkBreakWithLabel(b)
			self.scope.Stmts = append(self.scope.Stmts, brk)
			ret
		}

		mut brk := self.checkPlainBreak(b)
		self.scope.Stmts = append(self.scope.Stmts, brk)
	}

	fn checkRet2(mut &self, mut token: &token::Token, mut x: &ast::Expr) {
		mut rt := &Ret{
			Func: self.getRoot().owner,
		}
		self.scope.Stmts = append(self.scope.Stmts, rt)

		mut rtc := &retTypeChecker{
			sc: self,
			f: rt.Func,
			errorToken: token,
			mutable: true,
		}
		ok := rtc.check(x)
		if !ok {
			ret
		}

		if x != nil {
			rt.Expr = rtc.expr.Model
		}
	}

	fn checkRet(mut &self, mut r: &ast::Ret) {
		if self.isDeferred() {
			self.s.pushErr(r.Token, "return statement is not allowed in deferred scope")
		}
		self.checkRet2(r.Token, r.X)
	}

	fn checkUseExpr(mut &self, ue: &ast::UseExpr) {
		if self.result == nil {
			self.s.pushErr(ue.Token, "use expression is not allowed out of exceptional handler scope")
			ret
		}

		if self.isDeferred() {
			self.s.pushErr(ue.Token, "use expression is not allowed in deferred scope")
		}

		if self.i+1 < len(self.tree.Stmts) {
			self.s.pushErr(ue.Token, "use expression must be the last statement of the scope")
		}
		// Validated at end of scope's analysis.
	}

	fn checkNode(mut &self, mut node: ast::StmtData, flags: int) {
		match type node {
		| &ast::ScopeTree:
			self.checkAnonScope(node.(&ast::ScopeTree))
		| &ast::Var:
			self.checkVarDecl(node.(&ast::Var), nil)
		| &ast::TypeAlias:
			self.checkTypeAliasDecl(node.(&ast::TypeAlias))
		| &ast::Expr:
			self.checkExpr(node.(&ast::Expr), flags)
		| &ast::Conditional:
			self.checkConditional(node.(&ast::Conditional))
		| &ast::Iter:
			self.checkIter(node.(&ast::Iter))
		| &ast::Continue:
			self.checkCont(node.(&ast::Continue))
		| &ast::Label:
			self.checkLabel(node.(&ast::Label))
		| &ast::Goto:
			self.pushGoto(node.(&ast::Goto))
		| &ast::Assign:
			self.checkAssign(node.(&ast::Assign), flags)
		| &ast::Match:
			self.checkMatch(node.(&ast::Match))
		| &ast::Select:
			self.checkSelect(node.(&ast::Select))
		| &ast::Fall:
			self.checkFall(node.(&ast::Fall))
		| &ast::Break:
			self.checkBreak(node.(&ast::Break))
		| &ast::Ret:
			self.checkRet(node.(&ast::Ret))
		| &ast::UseExpr:
			self.checkUseExpr(node.(&ast::UseExpr))
		|:
			println("error <unimplemented scope node>")
		}
	}

	fn checkResult(mut &self) {
		mut stmt := self.tree.Stmts[len(self.tree.Stmts)-1]
		match type stmt.Data {
		| &ast::UseExpr:
			mut ue := stmt.Data.(&ast::UseExpr)
			mut rtc := &retTypeChecker{
				sc: self,
				f: self.result.func,
				errorToken: ue.X.Token,
				mutable: self.result.mutable,
			}
			_ = rtc.check(ue.X)
			self.scope.Stmts = append(self.scope.Stmts, &Use{Value: rtc.expr})
		| &ast::Expr:
			mut expr := stmt.Data.(&ast::Expr)
			mut v := self.s.eval(self).evalExpr(expr, evalDefault|evalPhysicalMem|evalUnwrapUntyped|evalExceptional)
			if v == nil {
				ret
			}
			match type v.Model {
			| &BuiltinPanicCallExpr:
				self.scope.Stmts = append(self.scope.Stmts, v)
			| &BuiltinErrorCallExpr:
				mut m := v.Model.(&BuiltinErrorCallExpr)
				self.processErrorCall(m, expr.Token)
				self.scope.Stmts = append(self.scope.Stmts, v)
			|:
				ret
			}
		| &ast::Goto
		| &ast::Break
		| &ast::Continue
		| &ast::Ret:
			self.checkNode(stmt.Data, checkNodeDefault)
		|:
			self.checkNode(stmt.Data, checkNodeDefault)
			ret
		}

		// Set result to nil, it is a mark for whether result is processed.
		self.result = nil
	}

	fn checkTree(mut &self) {
		self.i = 0
		mut n := len(self.tree.Stmts)
		if self.result != nil {
			// Skip last statement if result is exist.
			// Algorithm will check last statement for result.
			// So, if you check last statement also here, it will duplicate.
			n--
		}
		for self.i < n; self.i++ {
			mut stmt := self.tree.Stmts[self.i]
			// Handle group variables, if any.
			// Grouped variables represented by the root (first) variable of the group.
			// See developer reference (12).
			// In the HIR, all variables of the group should be in the HIR.
			// See developer reference (13).
			mut astv, _ := stmt.Data.(&ast::Var)
			if astv != nil {
				if len(astv.Group) > 0 {
					// Save the length of variables in the table.
					// Then add group variables one-by-one.
					// This is safe because in the scope semantics,
					// variables must be defined in order. So any group member
					// cannot refer to following members, only already defined leading ones.
					// Do not add all group members first, it may be result as
					// wrong shadowing for global variables and even may point
					// to itself.
					//
					// To select group members, make sure the table slice have
					// enough space to hold new variables defined by the group.
					// Then select the required slice memory block for group.
					// Following append calls will append the group members
					// to slice's selected memory block.
					tn := len(self.table.Vars)
					self.table.Vars = growSlice(self.table.Vars, len(astv.Group))
					mut group := self.table.Vars[tn : tn+len(astv.Group) : tn+len(astv.Group)]
					for (i, mut v) in astv.Group {
						mut cv := buildVar(v)
						cv.Scope = self.scope
						cv.Group = group
						cv.GroupIndex = i
						// Add itself as group member.
						// The [sema.evalVarValue] assumes group members are not nil.
						// Currently, only risk is the first member.
						// If the first member is nil, program may panic.
						// This assignment prevents this.
						cv.Group[i] = cv
						self.checkVarDecl1(cv)
						if self.stopped() {
							ret
						}
					}
					// Skip this node, it is already checked.
					continue
				}
			}
			self.checkNode(stmt.Data, checkNodeDefault)
			if self.stopped() {
				ret
			}
		}
		if self.result != nil && len(self.tree.Stmts) != 0 {
			self.checkResult()
		}
	}

	fn checkGoto(mut *self, mut gt: &Goto, mut label: &scopeLabel) {
		mut n := 0
		if gt.Scope == label.node.Scope {
			// Scopes are same and label at above, so it is safe.
			if gt.Index > label.node.Index {
				gt.Direction = UP
				ret
			}
			// Limit controlling to goto's position.
			// Label and goto is in same scope.
			n = gt.Index
		} else if gt.Scope.ChildIndex > label.node.Scope.ChildIndex {
			// Label owned by a parent scope.
			// Find the parent scope of goto scope based on label.
			// So we can evaluate by same scope conditions.
			// This selected parent scope must be nearest child scope to the label's scope.
			// This child scope is equals to `label.node.Scope.ChildIndex+1`.
			//
			// Scheme on pseudo AST
			//	
			//	 fn example() {          > scope of label
			//	 Label:                 
			//	     if foo {            > nearest child scope to scope of label, to be selected
			//	         if bar {        > scope of goto
			//	             goto Label 
			//	         }              
			//	     }                  
			//	 }                      
			//	
			mut gtsc := gt.Scope
			for gtsc.ChildIndex-1 > label.node.Scope.ChildIndex {
				gtsc = gtsc.Parent
			}
			// To make sure parent scopes are common of goto and label,
			// also check the label's parent scope. If they are not equal,
			// goto jumps into scope.
			//
			// NOTE:
			// Compare with the gtsc.Parent. For correct scope comparison,
			// we have to use parent scope of gtsc.
			// See documentation about getting parent scope of goto.
			if gtsc.Parent != label.node.Scope {
				self.s.pushErr(gt.Token, "goto jumps into scope")
				ret
			}
			// Scopes are same and label at above, so it is safe.
			if gtsc.StmtIndex > label.node.Index {
				gt.Direction = UP
				ret
			}
			// Cap analysis statement position limit to goto's position.
			// Label and goto is in same scope. If same scope condition is not met,
			// we will have zero offset because of root scope.
			// So algorithm will check all statements without limitation,
			// so any declaration will cause an error.
			n = gtsc.StmtIndex
		} else {
			// Condition is;
			//	gt.Scope != nil label.node.Scope &&
			//	gt.Scope.ChildIndex < label.node.Scope.ChildIndex
			//
			// Label owned by a more deepter child scope than goto's scope or equal.
			// But scopes are not equal, so equal case does not works.
			// In final case; goto jumps into scope, which is not allowed.
			self.s.pushErr(gt.Token, "goto jumps into scope")
			ret
		}
		gt.Direction = DOWN

		mut s := label.node.Scope     // Start checking at scope of label.
		mut i := label.node.Index - 1 // Start end limit by label statement.
		for {
			for i >= n; i-- {
				mut stmt := s.Stmts[i]
				if stmtIsDef(stmt) {
					self.s.pushErr(gt.Token, "goto @ jumps over declaration(s)", conv::Quote(gt.Name))
					ret
				}
			}
			if s.ChildIndex > gt.Scope.ChildIndex {
				// Current scope is more depth than goto scope.
				// So jump to parent scope to check any missing declaration.
				s = s.Parent
				i = s.StmtIndex - 1 // Set end limit to above of current scope statement.
				continue
			}
			break
		}
	}

	fn checkGotos(mut *self) {
		for (_, mut gt) in *self.gotos {
			mut label := self.findLabelAll(gt.Name)
			if label == nil {
				self.s.pushErr(gt.Token, "undefined label: "+conv::Quote(gt.Name))
				continue
			}
			gt.Label = label.node
			label.used = true
			self.checkGoto(gt, label)
		}
	}

	fn checkLabels(mut *self) {
		for _, l in *self.labels {
			if !l.used {
				self.s.pushErr(l.token, "declared but not used: "+conv::Quote(l.node.Name))
			}
		}
	}

	fn checkVars(mut *self) {
		for _, v in self.table.Vars {
			if !v.Used && !v.Constant && !jule::IsBlank(v.Name) && !jule::IsAnon(v.Name) {
				self.s.pushErr(v.Token, "declared but not used: "+conv::Quote(v.Name))
			}
		}
	}

	fn checkAliases(mut *self) {
		for _, a in self.table.TypeAliases {
			if !a.Used && !jule::IsBlank(a.Name) && !jule::IsAnon(a.Name) {
				self.s.pushErr(a.Token, "declared but not used: "+conv::Quote(a.Name))
			}
		}
	}

	// Checks scope tree.
	fn check(mut &self, mut tree: &ast::ScopeTree, mut s: &Scope) {
		s.Deferred = tree.Deferred
		s.Unsafe = tree.Unsafe

		errors := len(self.s.errors)

		self.tree = tree
		self.scope = s

		// Catch one-line return statement expressions without keyword.
		if self.owner != nil && self.owner.oneliner && !self.owner.Decl.IsVoid() {
			mut expr, isExpr := self.tree.Stmts[0].Data.(&ast::Expr)
			if isExpr {
				self.checkRet2(expr.Token, expr)
				goto FinalStage
			}
		}

		self.checkTree()

	FinalStage:
		// If we have new errors, don't check unused declarations.
		if errors == len(self.s.errors) {
			self.checkVars()
			self.checkAliases()

			if self.isRoot() {
				self.checkGotos()
				self.checkLabels()
			}
		}
	}

	fn newChildChecker(mut &self): &scopeChecker {
		mut base := newScopeCheckerBase(self.s, nil)
		base.parent = self
		base.labels = self.labels
		base.gotos = self.gotos
		base.childIndex = self.childIndex + 1
		ret base
	}
}

fn removeEqFromOp(op: int): int {
	match op {
	| token::ADD_ASSIGN:
		ret token::ADD
	| token::SUB_ASSIGN:
		ret token::SUB
	| token::MUL_ASSIGN:
		ret token::MUL
	| token::QUO_ASSIGN:
		ret token::QUO
	| token::REM_ASSIGN:
		ret token::REM
	| token::SHL_ASSIGN:
		ret token::SHL
	| token::SHR_ASSIGN:
		ret token::SHR
	| token::XOR_ASSIGN:
		ret token::XOR
	| token::AND_ASSIGN:
		ret token::AND
	| token::OR_ASSIGN:
		ret token::OR
	|:
		ret op
	}
}

// Makes data d as comptimeRange.
// If type is not supported, d.Decl will be true.
// If onlyComptime is true, only handles comptime types.
fn makeComptimeRange(mut v: &Value, onlyComptime: bool) {
	match {
	| v.Type.comptimeStructFields() != nil:
		v.Type = &Type{Kind: &comptimeRange{v.Type.comptimeStructFields()}}
		ret
	| v.Type.comptimeEnumFields() != nil:
		v.Type = &Type{Kind: &comptimeRange{v.Type.comptimeEnumFields()}}
		ret
	| v.Type.comptimeTypeInfos() != nil:
		v.Type = &Type{Kind: &comptimeRange{v.Type.comptimeTypeInfos()}}
		ret
	| v.Type.comptimeParams() != nil:
		v.Type = &Type{Kind: &comptimeRange{v.Type.comptimeParams()}}
		ret
	| v.Type.comptimeStatics() != nil:
		v.Type = &Type{Kind: &comptimeRange{v.Type.comptimeStatics()}}
		ret
	| v.Type.comptimeFiles() != nil:
		v.Type = &Type{Kind: &comptimeRange{v.Type.comptimeFiles()}}
		ret
	| v.Type.comptimeDecls() != nil:
		v.Type = &Type{Kind: &comptimeRange{v.Type.comptimeDecls()}}
		ret
	| !onlyComptime && v.Type.Slice() != nil:
		match type v.Model {
		| &SliceExpr:
			mut s := v.Model.(&SliceExpr)
			for _, e in s.Elems {
				if !e.IsConst() {
					goto Fail
				}
			}
			v.Type = &Type{Kind: &comptimeRange{&comptimeSliceRange{s}}}
			ret
		|:
			// no-op
		}
	}
Fail:
	// Flag for failure.
	v.Decl = true
}

// Reports whether v can match at comptime.
fn canComptimeMatch(mut v: &Value): bool {
	// Do not allow value if has unsupported type for type infer.
	if !isGoodValueToInfer(v) {
		ret false
	}
	ret v.IsConst() || v.Type.comptimeTypeInfo() != nil
}

fn stmtIsDef(stmt: Stmt): bool {
	match type stmt {
	| &Var:
		ret true
	| &MultiAssign:
		ma := stmt.(&MultiAssign)
		ret len(ma.Decls) > 0
	|:
		ret false
	}
}

// Counts matched fields with name and returns the result.
// If limit=0, counts all fields, otherwise the count is limited by the limit.
fn countMatchEnum(m: &ast::Match, name: str, limit: int): int {
	mut n := 0
loop:
	for _, c in m.Cases {
		for _, x in c.X {
			_name := x.Data.(&ast::NameExpr)
			if _name.Name == name {
				n++
				if limit != 0 && n >= limit {
					break loop
				}
			}
		}
	}
	ret n
}

// Counts matched types with t and returns the result.
// If limit=0, counts all types, otherwise the count is limited by the limit.
fn countMatchType(m: &Match, t: &Type, limit: int): int {
	mut n := 0
loop:
	for _, c in m.Cases {
		if c == nil {
			continue
		}
		for _, expr in c.Exprs {
			// Break loop because this expression is not parsed yet.
			// So, parsed cases finished.
			if expr == nil {
				break loop
			}
			if t.Equal(expr.Type) {
				n++
				if limit != 0 && n >= limit {
					break loop
				}
			}
		}
	}
	ret n
}

// Returns label by identifier.
// Returns nil if not exist any label in this identifier.
// Lookups given scope and parent scopes.
fn findLabelParent(name: str, mut scope: &scopeChecker): &scopeLabel {
	mut label := scope.findLabelScope(name)
	for label == nil {
		if scope.parent == nil || scope.owner != nil {
			ret nil
		}
		scope = scope.parent
		label = scope.findLabelScope(name)
	}
	ret label
}

fn getExprs(mut m: ast::ExprData): []ast::ExprData {
	match type m {
	| &ast::TupleExpr:
		mut tup := m.(&ast::TupleExpr)
		mut models := make([]ast::ExprData, 0, len(tup.X))
		for (_, mut x) in tup.X {
			models = append(models, x.Data)
		}
		ret models
	|:
		ret [m]
	}
}

fn checkAssignMut(mut s: &sema, left: &Value, mut right: &Value, op: &token::Token): (ok: bool) {
	match {
	| !left.Mutable:
		s.pushErr(op, "cannot assign to immutable memory")
		ret false
	| right != nil && !right.Mutable && right.Type.Mutable():
		s.pushErr(op, "immutable data cannot be assigned to a mutable memory because of type @, which is mutable", right.Type.Str())
		ret false
	|:
		ret true
	}
}

fn checkAssign(mut s: &sema, mut left: &Value, mut right: &Value, op: &token::Token): (ok: bool) {
	// If left operand or it's type is nil, report false.
	// No need to log any error, because it will be already appended.
	// If left operand is nil, error about the issue must be logged already.
	if left == nil || left.Type == nil {
		ret false
	}

	f := left.Type.Func()
	if f != nil && f.Decl != nil && f.Decl.Global {
		// Make sure function is indeed a global function.
		// Model is equals to the function when referred to directly.
		// Otherwise it may be a variable, if it used as anonymous function.
		if left.Model == f {
			s.pushErr(op, "cannot assign to function")
			ret false
		}
	}
	// Assignment to constant memory.
	if left.IsConst() {
		s.pushErr(op, "cannot assign to constant memory")
		ret false
	}
	// Fast path: check whether value is lvalue.
	// If value is lvalue, it is ok.
	if !left.Lvalue {
		// Slow path: value is not lvalue. We need to check
		// special cases.
		match type left.Model {
		| &IndexingExpr:
			// Type is map. We need to check special case for maps.
			// Because map indexing is not considered lvalue.
			mut i := left.Model.(&IndexingExpr)
			// Map type indexing. Map indexing is not considered lvalue.
			// But we can assign, so it is ok.
			if i.Expr.Type.Map() != nil {
				break
			}
			fall
		|:
			// Default case.
			s.pushErr(op, "assignment required lvalue")
			ret false
		}
	}
	ret checkAssignMut(s, left, right, op)
}

fn isValidStmtForNext(mut n: ast::StmtData): bool {
	match type n {
	| &ast::Assign:
		ret !n.(&ast::Assign).Decl
	| &ast::Expr:
		ret true
	|:
		ret false
	}
}

fn isValidStmtForNext2(st: Stmt): bool {
	match type st {
	| &Postfix
	| &Assign
	| &MultiAssign:
		ret true
	| &Value:
		_, ok := st.(&Value).Model.(&FuncCallExpr)
		ret ok
	|:
		ret false
	}
}

// Increases the slice's capacity, if necessary, to guarantee space for
// another n elements. After growSlice(n), at least n elements can be appended
// to the slice without another allocation. If n is negative or too large to
// allocate the memory, it panics.
fn growSlice[S: []E, E](mut s: S, mut n: int): S {
	if n < 0 {
		panic("cannot be negative")
	}
	n -= cap(s) - len(s)
	if n > 0 {
		s = append(s[:cap(s)], make([]E, n)...)[:len(s)]
	}
	ret s
}
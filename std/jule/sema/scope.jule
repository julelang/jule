// Copyright 2023-2025 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/jule/ast"
use "std/jule/build"
use "std/jule/constant"
use "std/jule/token"
use "std/jule/types"

// Statement type.
enum Stmt: type {
	&Scope,
	&Var,
	&Value,
	&Conditional,
	&InfIter,
	&WhileIter,
	&RangeIter,
	&Continue,
	&Label,
	&Goto,
	&Postfix,
	&Assign,
	&MultiAssign,
	&Match,
	&Fall,
	&Break,
	&Ret,
	&Select,
}

fn newScopeCheckerBase(mut &s: &sema, mut owner: &FuncIns): &scopeChecker {
	ret &scopeChecker{
		s: s,
		owner: owner,
		table: new(SymTab),
	}
}

fn newScopeChecker(mut &s: &sema, mut owner: &FuncIns): &scopeChecker {
	mut base := newScopeCheckerBase(s, owner)
	base.labels = new([]&scopeLabel, nil)
	base.gotos = new([]&Goto, nil)
	ret base
}

struct exprPart {
	data: &Value
	expr: &ast::Expr
}

// Scope.
struct Scope {
	Parent:   &Scope
	Unsafety: bool
	Deferred: bool
	Stmts:    []Stmt

	// Data of the child scope starting from the root scope.
	// For the root scope, counting starts from 0. So the root scope will be 0.
	// It increases by one for each child scope.
	ChildIndex: int

	// If the scope is a child scope,
	// it contains the data of the statement in which it was appear.
	StmtIndex: int
}

// Chain conditional node.
struct If {
	Expr:  Expr
	Scope: &Scope
}

// Default scope of conditional chain.
struct Else {
	Scope: &Scope
}

// Conditional chain.
struct Conditional {
	Elifs:   []&If // First not is root condition.
	Default: &Else
}

// Infinity iteration.
struct InfIter {
	Scope: &Scope // See developer reference (10).
}

// While iteration.
struct WhileIter {
	Scope: &Scope // See developer reference (10).
	Expr:  Expr   // Can be nil if iteration is while-next kind.
	Next:  Stmt   // Nil if iteration is not while-next kind.
}

impl WhileIter {
	// Reports whether iteration is while-next kind.
	fn IsWhileNext(self): bool {
		ret self.Next != nil
	}
}

// Range iteration.
struct RangeIter {
	Scope:     &Scope // See developer reference (10).
	Expr:      &Value
	ExprToken: &token::Token
	KeyA:      &Var
	KeyB:      &Var
}

// Continue statement.
struct Continue {
	It: uintptr
}

// Break statement.
struct Break {
	It:     uintptr
	Match:  uintptr
	Select: uintptr
}

// Label.
struct Label {
	Ident: str
	Scope: &Scope // Owner scope.
	Index: int    // Index of statement.
}

// Goto statement.
struct Goto {
	Ident: str
	Token: &token::Token
	Label: &Label
	Scope: &Scope // Owner scope.
	Index: int    // Index of statement.
}

// Postfix assignment.
struct Postfix {
	Expr: Expr
	Op:   str
}

// Assignment.
struct Assign {
	Left:  &OperandExpr
	Right: &OperandExpr
	Op:    &token::Token
}

// Multi-declarative assignment.
struct MultiAssign {
	Decls: []&Var
	Left:  []&Value // Nil Model:s represents ignored expressions.
	Right: Expr
	Op:    &token::Token
}

// Match-Case.
struct Match {
	Scope:     &Scope // Owner scope. See developer reference (10).
	Expr:      &Value
	TypeMatch: bool
	Comptime:  bool
	Cases:     []&Case
	Default:   &Case
}

impl Match {
	// Reports whether match is type-match for generic type.
	fn IsGenericTypeMatch(self): bool {
		ret self.TypeMatch && self.Expr != nil && self.Expr.Type.Generic
	}
}

// Select-Case.
struct Select {
	Scope:   &Scope // Owner scope. See developer reference (10).
	Cases:   []&Case
	Default: &Case
}

// Valid owner types for Case.
enum CaseOwner: type {
	&Match,
	&Select,
}

// Internal wrapper for CaseOwner.
type caseOwner: CaseOwner

impl caseOwner {
	// Returns data in uintptr.
	// Assumes self is not nil.
	fn asUintptr(self): uintptr {
		match type self {
		| &Match:
			ret uintptr((&Match)(self))
		| &Select:
			ret uintptr((&Select)(self))
		|:
			panic("unreachable")
		}
	}
}

// Match-Case case.
struct Case {
	Owner: CaseOwner
	Scope: &Scope
	Exprs: []&Value
	Next:  &Case
}

impl Case {
	// Reports whether case is default.
	fn isDefault(self): bool { ret self.Exprs == nil }
}

// Fall statement.
struct Fall {
	DestCase: uintptr
}

// Return statement.
struct Ret {
	Func: &FuncIns
	Expr: Expr
}

struct scopeLabel {
	token: &token::Token
	node:  &Label
	used:  bool
}

// Result information for the use statements.
struct result {
	func:    &FuncIns // Handling function.
	mutable: bool     // Whether will be assigned to mutable storage.
}

// Scope checker.
struct scopeChecker {
	calledFrom: &token::Token
	s:          &sema
	owner:      &FuncIns // See developer reference (1).
	parent:     &scopeChecker
	childIndex: int // Index of child scope.
	table:      &SymTab
	scope:      &Scope
	tree:       &ast::ScopeTree
	result:     &result // Result type for the use statement.
	it:         uintptr
	cse:        uintptr
	captured:   &[]&Var        // Anonymous function's captured variables will be stored here.
	labels:     &[]&scopeLabel // All labels of all scopes.
	gotos:      &[]&Goto       // All gotos of all scopes.
	i:          int            // Index of current statement.
}

impl Lookup for scopeChecker {
	// Returns imported package by selector.
	// Returns nil if selector returns false for all packages.
	// Returns nil if selector is nil.
	//
	// Lookups:
	//	- Sema.
	fn SelectPackage(mut self, selector: fn(&ImportInfo): bool): &ImportInfo {
		ret self.s.SelectPackage(selector)
	}

	// Returns variable by identifier and binded state.
	// Returns nil if not exist any variable in this identifier.
	//
	// Lookups:
	//	- Current scope.
	//	- Parent scopes.
	//	- Sema.
	fn FindVar(mut self, ident: str, binded: bool): &Var {
		if !binded { // Local variables cannot be binded.
			mut v := self.findVar(ident)
			if v != nil {
				ret v
			}
		}
		ret self.s.FindVar(ident, binded)
	}

	// Returns type alias by identifier and binded state.
	// Returns nil if not exist any type alias in this identifier.
	//
	// Lookups:
	//	- Current scope.
	//	- Parent scopes.
	//	- Sema.
	fn FindTypeAlias(mut self, ident: str, binded: bool): &TypeAlias {
		// Search reverse for correct shadowing.
		const Reverse = true
		mut ta := self.table.findTypeAlias(ident, binded, Reverse)
		if ta != nil {
			ret ta
		}

		mut parent := self.parent
		for parent != nil {
			ta = parent.table.findTypeAlias(ident, binded, Reverse)
			if ta != nil {
				ret ta
			}
			parent = parent.parent
		}

		ret self.s.FindTypeAlias(ident, binded)
	}

	// Returns struct by identifier and binded state.
	// Returns nil if not exist any struct in this identifier.
	//
	// Lookups:
	//	- Sema.
	fn FindStruct(mut self, ident: str, binded: bool): &Struct {
		ret self.s.FindStruct(ident, binded)
	}

	// Returns function by identifier and binded state.
	// Returns nil if not exist any function in this identifier.
	//
	// Lookups:
	//	- Sema.
	fn FindFunc(mut self, ident: str, binded: bool): &Func {
		ret self.s.FindFunc(ident, binded)
	}

	// Returns trait by identifier.
	// Returns nil if not exist any trait in this identifier.
	//
	// Lookups:
	//	- Sema.
	fn FindTrait(mut self, ident: str): &Trait {
		ret self.s.FindTrait(ident)
	}

	// Returns enum by identifier.
	// Returns nil if not exist any enum in this identifier.
	//
	// Lookups:
	//	- Sema.
	fn FindEnum(mut self, ident: str): &Enum {
		ret self.s.FindEnum(ident)
	}

	// Returns type enum by identifier.
	// Returns nil if not exist any type enum in this identifier.
	//
	// Lookups:
	//	- Sema.
	fn FindTypeEnum(mut self, ident: str): &TypeEnum {
		ret self.s.FindTypeEnum(ident)
	}
}

impl scopeChecker {
	// Reports whether scope is unsafe.
	fn isUnsafe(mut &self): bool {
		mut scope := self

	iter:
		if scope.scope.Unsafety {
			ret true
		}

		if scope.parent != nil {
			scope = scope.parent
			goto iter
		}

		ret false
	}

	// Reports scope is root.
	// Accepts anonymous functions as root.
	fn isRoot(self): bool {
		ret self.parent == nil || self.owner != nil
	}

	// Stop checking.
	fn stop(mut self) {
		self.i = -1
	}

	// Reports whether checking is stopped.
	fn stopped(self): bool {
		ret self.i == -1
	}

	// Reports scope is deferred.
	fn isDeferred(mut &self): bool {
		mut scope := self

	iter:
		if scope.scope.Deferred {
			ret true
		}

		if scope.parent != nil {
			scope = scope.parent
			goto iter
		}

		ret false
	}

	// Push captured variable.
	// It will append to all [captured] fields,
	// because if child-scopes captures this variable,
	// parent-scopes must be capture this variable too.
	// Starts pushing from self to all parents.
	// If any parent scope is not captures variable v, iteration will be break.
	fn pushCaptured(mut &self, mut &v: &Var) {
		mut sc := self
		for {
			if sc.captured != nil {
				for _, cv in *sc.captured {
					if cv == v {
						goto exist
					}
				}
				*sc.captured = append(*sc.captured, v)
			exist:
			}
			if sc.parent == nil {
				break
			}
			sc = sc.parent
			if !isVarCaptured(sc, sc, v) {
				break
			}
		}
	}

	// Returns root scope.
	// Accepts anonymous functions as root.
	fn getRoot(mut &self): &scopeChecker {
		mut root := self
		for root.parent != nil && root.owner == nil {
			root = root.parent
		}
		ret root
	}

	// Returns hard root scope, owner always represents root function of this scope.
	// Not accepts anonymous functions as root.
	fn getHardRoot(mut &self): &scopeChecker {
		mut root := self
		for root.parent != nil {
			root = root.parent
		}
		ret root
	}

	fn getOwnerRefers(mut &self): &ReferenceStack {
		ret self.getHardRoot().owner.Refers
	}

	// Like [Lookup.FindVar] but designed for local variables only.
	fn findVar(mut self, ident: str): &Var {
		const Reverse = true // Search reverse for correct shadowing.
		const Binded = false // Local variables cannot be binded.
		mut v := self.table.findVar(ident, Binded, Reverse)
		if v != nil {
			ret v
		}
		mut parent := self.parent
		for parent != nil {
			v = parent.table.findVar(ident, Binded, Reverse)
			if v != nil {
				ret v
			}
			parent = parent.parent
		}
		ret nil
	}

	// Returns label by identifier.
	// Returns nil if not exist any label in this identifier.
	// Just lookups current scope.
	fn findLabel(mut self, &ident: str): &Label {
		for (_, mut st) in self.scope.Stmts {
			match type st {
			| &Label:
				mut label := (&Label)(st)
				if label.Ident == ident {
					ret label
				}
			}
		}
		ret nil
	}

	// Returns label by identifier.
	// Returns nil if not exist any label in this identifier.
	// Just lookups current scope.
	fn findLabelScope(mut &self, &ident: str): &scopeLabel {
		mut label := self.findLabelAll(ident)
		if label != nil && label.node.Scope == self.scope {
			ret label
		}
		ret nil
	}

	// Returns label by identifier.
	// Returns nil if not exist any label in this identifier.
	// Lookups all labels.
	fn findLabelAll(mut self, &ident: str): &scopeLabel {
		for (_, mut lbl) in *self.labels {
			if lbl.node.Ident == ident {
				ret lbl
			}
		}
		ret nil
	}

	// Reports this identifier duplicated in scope.
	// The "self" parameter represents address of exception identifier.
	// If founded identifier address equals to self, will be skipped.
	fn isDuplicatedIdent(mut self, itself: uintptr, &ident: str): bool {
		v := self.FindVar(ident, false)
		if v != nil && uintptr(v) != itself {
			if v.Scope == nil { // Ignore globals.
				ret false
			}
			ret v.Scope == self.scope || !self.s.isFlag(Flag.Shadowing)
		}

		ta := self.FindTypeAlias(ident, false)
		if ta != nil && uintptr(ta) != itself {
			if ta.Scope == nil { // Ignore globals.
				ret false
			}
			ret ta.Scope == self.tree || !self.s.isFlag(Flag.Shadowing)
		}

		ret false
	}

	fn checkVarDecl(mut &self, mut decl: &ast::Var) {
		mut v := buildVar(decl)
		v.Scope = self.scope

		defer {
			self.table.Vars = append(self.table.Vars, v)
			self.scope.Stmts = append(self.scope.Stmts, v)
		}

		if self.isDuplicatedIdent(uintptr(v), v.Ident) {
			self.s.pushErr(v.Token, build::LogMsg.DuplicatedIdent, v.Ident)
			self.s.pushSuggestion(build::LogMsg.RenameForAvoidDuplication)
			self.stop()
			ret
		}

		self.s.checkVarDecl(v, self)
		if !v.IsTypeInferred() && (v.TypeSym == nil || v.TypeSym.Type == nil) {
			ret
		}

		self.s.evalVarValue(v, self)
		if !v.IsInitialized() || v.ValueSym.Value == nil {
			// Skip checks if error occurs when evaluated expression,
			// or unitiliazed variable.
			ret
		}
		self.removeInteriorMutRisk(v.ValueSym.Value)
		self.s.checkVarValue(v)
	}

	fn checkTypeAlias(mut &self, mut &ta: &TypeAlias) {
		if self.isDuplicatedIdent(uintptr(ta), ta.Ident) {
			self.s.pushErr(ta.Token, build::LogMsg.DuplicatedIdent, ta.Ident)
			self.s.pushSuggestion(build::LogMsg.RenameForAvoidDuplication)
			self.stop()
			ret
		}
		self.s.checkTypeAliasDecl(ta, self)
		self.table.TypeAliases = append(self.table.TypeAliases, ta)

		// Stop immediately if destination type is could not evaluated.
		if ta.TypeSym.Type == nil {
			self.stop()
		}
	}

	fn checkTypeAliasDecl(mut &self, mut decl: &ast::TypeAlias) {
		mut ta := buildTypeAlias(decl)
		self.checkTypeAlias(ta)
	}

	fn getChild(mut self): &Scope {
		ret &Scope{
			Parent: self.scope,
		}
	}

	fn checkChildSsc(mut &self, mut &tree: &ast::ScopeTree, mut &s: &Scope, mut &ssc: &scopeChecker) {
		s.StmtIndex = self.i
		s.ChildIndex = ssc.childIndex
		ssc.parent = self
		ssc.check(tree, s)
	}

	fn checkChildSc(mut &self, mut &tree: &ast::ScopeTree, mut &ssc: &scopeChecker): &Scope {
		mut s := self.getChild()
		self.checkChildSsc(tree, s, ssc)
		ret s
	}

	fn checkChild(mut &self, mut &tree: &ast::ScopeTree): &Scope {
		mut ssc := self.newChildChecker()
		ret self.checkChildSc(tree, ssc)
	}

	fn checkAnonScope(mut &self, mut tree: &ast::ScopeTree) {
		// Scope is deferred. Handle as anonymous function, it may be a closure.
		// See: https://manual.jule.dev/introduction/scopes#deferred-scopes
		if tree.Deferred {
			self.getRoot().owner.Decl.HasDefer = true
			mut f := &ast::Func{
				Scope: tree,
				Ident: token::Ident.Anon,
				Result: new(ast::RetType),
			}
			mut e := self.s.eval(self)
			mut v := e.evalAnonFunc(f)
			self.scope.Stmts = append(self.scope.Stmts, v)
			ret
		}
		mut s := self.checkChild(tree)
		self.scope.Stmts = append(self.scope.Stmts, s)
	}

	fn processErrorCall(mut &self, mut &m: &BuiltinErrorCallExpr, err: &token::Token) {
		if self.isDeferred() {
			self.s.pushErr(err, build::LogMsg.ErrorInDeferred)
		}

		mut root := self.getRoot()
		if !root.owner.Decl.Exceptional {
			self.s.pushErr(err, build::LogMsg.ErrorWithNonExceptional)
			self.s.pushSuggestion(build::LogMsg.DeclareExceptional)
		}
		m.Func = root.owner
	}

	fn checkExpr(mut &self, mut expr: &ast::Expr) {
		mut eval := self.s.eval(self)
		eval.target.ignored = true
		mut v := eval.evalExpr(expr)
		if v == nil || v.Model == nil {
			// Skip nil data, because evaluation failed and error documented (it should be) already.
			// Skip nil modeled data, this return only caused by built-in functions and it should be safe.
			ret
		}

		match type v.Model {
		| &BuiltinErrorCallExpr:
			mut m := (&BuiltinErrorCallExpr)(v.Model)
			self.processErrorCall(m, expr.Token)
			self.scope.Stmts = append(self.scope.Stmts, v)
		| &BackendEmitExpr
		| &BuiltinAppendCallExpr
		| &BuiltinPrintCallExpr
		| &BuiltinPrintlnCallExpr
		| &BuiltinPanicCallExpr
		| &BuiltinCopyCallExpr
		| &BuiltinDeleteCallExpr
		| &BuiltinCloseCallExpr
		| &FreeExpr
		| &FuncCallExpr
		| &ChanRecv
		| &ChanSend:
			self.scope.Stmts = append(self.scope.Stmts, v)
		|:
			self.s.pushErr(expr.Token, build::LogMsg.InvalidSyntax)
		}
	}

	fn checkIf(mut &self, mut i: &ast::If): &If {
		mut s := self.checkChild(i.Scope)

		mut v := self.s.eval(self).evalExpr(i.Expr)
		if v == nil {
			ret nil
		}

		mut prim := v.Type.Prim()
		if prim == nil || !prim.IsBool() {
			self.s.pushErr(i.Expr.Token, build::LogMsg.IfRequireBoolExpr)
			ret nil
		}

		ret &If{
			Expr: v.Model,
			Scope: s,
		}
	}

	fn checkElse(mut &self, mut e: &ast::Else): &Else {
		ret &Else{
			Scope: self.checkChild(e.Scope),
		}
	}

	fn checkConditional(mut &self, mut conditional: &ast::Conditional) {
		mut c := new(Conditional)
		self.scope.Stmts = append(self.scope.Stmts, c)

		c.Elifs = make([]&If, 0, len(conditional.Tail)+1)

		c.Elifs = append(c.Elifs, self.checkIf(conditional.Head))
		for (_, mut elif) in conditional.Tail {
			c.Elifs = append(c.Elifs, self.checkIf(elif))
		}

		if conditional.Default != nil {
			c.Default = self.checkElse(conditional.Default)
		}
	}

	fn checkIterScopeSsc(mut &self, it: uintptr, mut tree: &ast::ScopeTree, mut &s: &Scope, mut ssc: &scopeChecker) {
		ssc.it = it
		self.checkChildSsc(tree, s, ssc)
	}

	fn checkIterScopeSc(mut &self, it: uintptr, mut tree: &ast::ScopeTree, mut ssc: &scopeChecker): &Scope {
		mut scope := self.getChild()
		self.checkIterScopeSsc(it, tree, scope, ssc)
		ret scope
	}

	fn checkIterScope(mut &self, it: uintptr, mut &tree: &ast::ScopeTree): &Scope {
		mut ssc := self.newChildChecker()
		ret self.checkIterScopeSc(it, tree, ssc)
	}

	fn checkInfIter(mut &self, mut &it: &ast::Iter) {
		mut kind := new(InfIter)
		self.scope.Stmts = append(self.scope.Stmts, kind)
		kind.Scope = self.checkIterScope(uintptr(kind), it.Scope)
	}

	fn checkWhileIter(mut &self, mut &it: &ast::Iter) {
		mut wh := (&ast::WhileKind)(it.Kind)
		if wh.Expr == nil && wh.Next == nil {
			self.checkInfIter(it)
			ret
		}

		mut kind := new(WhileIter)
		self.scope.Stmts = append(self.scope.Stmts, kind)
		kind.Scope = self.checkIterScope(uintptr(kind), it.Scope)

		if wh.Expr != nil {
			mut v := self.s.eval(self).evalExpr(wh.Expr)
			if v == nil {
				ret
			}

			prim := v.Type.Prim()
			if prim == nil {
				self.s.pushErr(it.Token, build::LogMsg.IterWhileRequireBoolExpr)
				ret
			}

			if !prim.IsBool() {
				self.s.pushErr(it.Token, build::LogMsg.IterWhileRequireBoolExpr)
				ret
			}

			kind.Expr = v.Model
		}

		if wh.IsWhileNext() {
			if !isValidAstStForNextSt(wh.Next) {
				self.s.pushErr(wh.NextToken, build::LogMsg.InvalidStmtForNext)
				ret
			}

			n := len(self.scope.Stmts)
			self.checkNode(wh.Next)
			if n < len(self.scope.Stmts) {
				mut st := self.scope.Stmts[n]
				self.scope.Stmts = self.scope.Stmts[:n] // Remove trailing statements.
				if !isValidStForNextSt(st) {
					self.s.pushErr(wh.NextToken, build::LogMsg.InvalidStmtForNext)
				}
				kind.Next = st
			}
		}
	}

	fn checkComptimeRangeIter(mut &self, mut &it: &ast::Iter, mut &kind: &RangeIter, mut &v: &Value) {
		if kind.KeyA != nil {
			if !self.s.isFlag(Flag.Shadowing) && self.isDuplicatedIdent(0, kind.KeyA.Ident) {
				self.s.pushErr(kind.KeyA.Token, build::LogMsg.DuplicatedIdent, kind.KeyA.Ident)
				self.s.pushSuggestion(build::LogMsg.RenameForAvoidDuplication)
			}
		}
		if kind.KeyB != nil {
			if !self.s.isFlag(Flag.Shadowing) && self.isDuplicatedIdent(0, kind.KeyB.Ident) {
				self.s.pushErr(kind.KeyB.Token, build::LogMsg.DuplicatedIdent, kind.KeyB.Ident)
				self.s.pushSuggestion(build::LogMsg.RenameForAvoidDuplication)
			}
		}

		mut rang := (&ast::RangeKind)(it.Kind)
		makeComptimeRange(v, false)
		if v.Decl {
			self.s.pushErr(rang.Expr.Token, build::LogMsg.InvalidTypeForComptimeIter, v.Type.Str())
			ret
		}

		mut rc := rangeChecker{
			sc: self,
			Kind: kind,
			rang: rang,
			v: v,
		}
		ok := rc.check()
		if !ok {
			ret
		}

		mut comptime := v.Type.comptimeRange()
		comptime.kind.ready(kind.KeyA, kind.KeyB)
		mut i := 0
		errors := len(self.s.errors)
		for i < comptime.kind.len(); i++ {
			mut ssc := self.newChildChecker()
			mut scope := self.getChild()
			if kind.KeyA != nil {
				kind.KeyA.Scope = scope
				ssc.table.Vars = append(ssc.table.Vars, kind.KeyA)
			}
			if kind.KeyB != nil {
				kind.KeyB.Scope = scope
				ssc.table.Vars = append(ssc.table.Vars, kind.KeyB)
			}
			comptime.kind.step(i, kind.KeyA, kind.KeyB)
			self.checkChildSsc(it.Scope, scope, ssc)
			if errors != len(self.s.errors) {
				// Stop execution if new error occurred.
				break
			}
			self.scope.Stmts = append(self.scope.Stmts, scope)
		}
	}

	fn checkRangeIter(mut &self, mut &it: &ast::Iter) {
		mut rang := (&ast::RangeKind)(it.Kind)

		// Evaluate expression as mutable. Because we can't know type of the expression,
		// so we can't able to determine whether expression should be mutable by type.
		// We should evaluate expression as mutable target, because if type have mutability,
		// the iteration variables may mutate the range expression.
		mut eval := self.s.eval(self)
		eval.target.mutable = true

		mut v := eval.evalExpr1(rang.Expr)
		if v == nil {
			ret
		}

		mut kind := &RangeIter{
			Expr: v,
			ExprToken: rang.Expr.Token,
		}

		if it.Comptime {
			self.checkComptimeRangeIter(it, kind, v)
			ret
		}
		if v.Type.comptime() {
			self.s.pushErr(rang.Expr.Token, build::LogMsg.ComptimeExprForRuntimeIteration)
			self.s.pushSuggestion(build::LogMsg.DeclareComptimeForeach)
			ret
		}

		mut rc := rangeChecker{
			sc: self,
			Kind: kind,
			rang: rang,
			v: v,
		}
		ok := rc.check()
		if !ok {
			ret
		}

		self.scope.Stmts = append(self.scope.Stmts, kind)

		mut ssc := self.newChildChecker()
		mut scope := self.getChild()

		if kind.KeyA != nil {
			if !self.s.isFlag(Flag.Shadowing) && self.isDuplicatedIdent(0, kind.KeyA.Ident) {
				self.s.pushErr(kind.KeyA.Token, build::LogMsg.DuplicatedIdent, kind.KeyA.Ident)
				self.s.pushSuggestion(build::LogMsg.RenameForAvoidDuplication)
			}
			kind.KeyA.Scope = scope
			ssc.table.Vars = append(ssc.table.Vars, kind.KeyA)
		}

		if kind.KeyB != nil {
			if !self.s.isFlag(Flag.Shadowing) && self.isDuplicatedIdent(0, kind.KeyB.Ident) {
				self.s.pushErr(kind.KeyB.Token, build::LogMsg.DuplicatedIdent, kind.KeyB.Ident)
				self.s.pushSuggestion(build::LogMsg.RenameForAvoidDuplication)
			}
			kind.KeyB.Scope = scope
			ssc.table.Vars = append(ssc.table.Vars, kind.KeyB)
		}

		self.checkIterScopeSsc(uintptr(kind), it.Scope, scope, ssc)
		kind.Scope = scope
	}

	fn checkIter(mut &self, mut it: &ast::Iter) {
		if it.IsInf() {
			if it.Comptime {
				self.s.pushErr(it.Token, build::LogMsg.InvalidComptimeIter)
				ret
			}
			self.checkInfIter(it)
			ret
		}

		match type it.Kind {
		| &ast::WhileKind:
			if it.Comptime {
				self.s.pushErr(it.Token, build::LogMsg.InvalidComptimeIter)
				ret
			}
			self.checkWhileIter(it)
		| &ast::RangeKind:
			self.checkRangeIter(it)
		|:
			println("error <unimplemented iteration kind>")
		}
	}

	fn checkValidContLabel(mut &self, it: uintptr): bool {
		mut scope := self

	iter:
		if scope.it == it {
			ret true
		}

		if scope.parent != nil {
			scope = scope.parent
			goto iter
		}

		ret false
	}

	fn checkValidBreakLabel(mut &self, ptr: uintptr): bool {
		mut scope := self

	iter:
		// Check for iterations.
		if scope.it == ptr {
			ret true
		}

		// Check for match and select.
		if scope.cse != 0 {
			owner := unsafe { caseOwner((*Case)(scope.cse).Owner).asUintptr() }
			if owner == ptr {
				ret true
			}
		}

		if scope.parent != nil {
			scope = scope.parent
			goto iter
		}

		ret false
	}

	fn checkContValidScope(mut &self, c: &ast::Continue): &Continue {
		if self.isDeferred() {
			self.s.pushErr(c.Token, build::LogMsg.ContinueAtOutOfValidScope)
			ret nil
		}

		if c.Label != nil {
			ret new(Continue)
		}

		mut scope := self
	iter:
		match {
		| scope.it == 0 && scope.parent != nil && scope.owner == nil:
			scope = scope.parent
			goto iter
		| scope.it != 0:
			ret &Continue{It: scope.it}
		}

		self.s.pushErr(c.Token, build::LogMsg.ContinueAtOutOfValidScope)
		ret nil
	}

	fn checkCont(mut &self, c: &ast::Continue) {
		mut cont := self.checkContValidScope(c)
		if cont == nil {
			ret
		}

		if c.Label != nil { // Label given.
			mut label := findLabelParent(c.Label.Kind, self.parent)
			if label == nil {
				self.s.pushErr(c.Label, build::LogMsg.LabelNotExist, c.Label.Kind)
				ret
			}

			label.used = true

			if label.node.Index+1 >= len(label.node.Scope.Stmts) {
				self.s.pushErr(c.Label, build::LogMsg.InvalidLabel, c.Label.Kind)
				ret
			}

			i := label.node.Index + 1
			if i >= len(label.node.Scope.Stmts) {
				self.s.pushErr(c.Label, build::LogMsg.InvalidLabel)
			} else {
				mut st := label.node.Scope.Stmts[i]
				match type st {
				| &InfIter:
					cont.It = uintptr((&InfIter)(st))
				| &RangeIter:
					cont.It = uintptr((&RangeIter)(st))
				| &WhileIter:
					cont.It = uintptr((&WhileIter)(st))
				|:
					self.s.pushErr(c.Label, build::LogMsg.InvalidLabel, c.Label.Kind)
				}
			}
		}

		if cont.It != 0 {
			if !self.checkValidContLabel(cont.It) {
				self.s.pushErr(c.Label, build::LogMsg.InvalidLabel, c.Label.Kind)
			}
		}

		self.scope.Stmts = append(self.scope.Stmts, cont)
	}

	fn checkLabel(mut &self, mut l: &ast::Label) {
		if self.findLabel(l.Ident) != nil {
			self.s.pushErr(l.Token, build::LogMsg.LabelExist, l.Ident)
			ret
		}

		mut label := &Label{
			Ident: l.Ident,
			Scope: self.scope,
			Index: self.i,
		}

		self.scope.Stmts = append(self.scope.Stmts, label)
		*self.labels = append(*self.labels, &scopeLabel{
			token: l.Token,
			node: label,
		})
	}

	fn pushGoto(mut &self, mut gt: &ast::Goto) {
		mut st := &Goto{
			Token: gt.Label,
			Ident: gt.Label.Kind,
			Scope: self.scope,
			Index: self.i,
		}
		self.scope.Stmts = append(self.scope.Stmts, st)
		*self.gotos = append(*self.gotos, st)
	}

	fn checkPostfix(mut &self, mut a: &ast::Assign) {
		if len(a.Left) > 1 {
			self.s.pushErr(a.Setter, build::LogMsg.InvalidSyntax)
			ret
		}

		mut eval := self.s.eval(self)
		eval.target.mutable = true

		mut expr := a.Left[0].Expr
		mut v := eval.evalExpr(expr)
		if v == nil {
			ret
		}

		_ = checkAssign(self.s, v, nil, a.Setter)

		if v.Type.Ptr() != nil {
			mut ptr := v.Type.Ptr()
			if ptr.IsUnsafe() {
				self.s.pushErr(a.Setter, build::LogMsg.OperatorNotForJuleType, a.Setter.Kind, v.Type.Str())
				ret
			}
		} else {
			if v.Type.Prim() == nil || !types::IsNum(v.Type.Prim().Kind) {
				self.s.pushErr(a.Setter, build::LogMsg.OperatorNotForJuleType, a.Setter.Kind, v.Type.Str())
				ret
			}
		}

		self.scope.Stmts = append(self.scope.Stmts, &Postfix{
			Expr: v.Model,
			Op: a.Setter.Kind,
		})
	}

	fn isNewAssignIdent(mut self, ident: str): bool {
		if token::IsIgnoreIdent(ident) || ident == "" {
			ret false
		}
		ret self.table.defByIdent(ident, false) == nil
	}

	// Remove the interior mutability risk if the v represents a structure and
	// this scope is owned by method which is owned by the relevant structure.
	// In this case we should remove the interior mutability risk of data to allow copying.
	// Otherwise assign analysis will complain and copy operation will not be allowed.
	//
	// See also documentation of the [sema.isMutRiskyStruct] method.
	fn removeInteriorMutRisk(mut &self, mut &v: &Value) {
		s := v.Type.Struct()
		if s == nil {
			ret
		}
		root := self.getHardRoot()
		// Owner is not structure or structure is mutable.
		// If structure is mutable, it means there is risky mutable-typed
		// fields even for internal members.
		if root.owner.Owner != s || s.Mutable {
			ret
		}
		// Mark data as mutable.
		// Mutable data is not occurs mutability risk for analysis.
		v.Mutable = true
	}

	fn checkSingleAssign(mut &self, mut &a: &ast::Assign) {
		let mut l: &Value = nil

		if !token::IsIgnoreIdent(a.Left[0].Ident) {
			mut expr := a.Left[0].Expr
			mut eval := self.s.eval(self)
			eval.target.mutable = true
			l = eval.evalExpr(expr)
			if l == nil {
				ret
			}
		}

		mut eval := (&eval)(nil)
		if l != nil {
			eval = self.s.evalp(self, l.Type)
		} else {
			eval = self.s.eval(self)
		}
		eval.target.mutable = true
		eval.unsafety = self.isUnsafe()
		mut r := eval.evalExpr(a.Right)
		if r == nil {
			ret
		}

		self.removeInteriorMutRisk(r)

		if l == nil {
			if r.Type.Void() {
				self.s.pushErr(a.Right.Token, build::LogMsg.InvalidExpr)
			}
			if a.Setter.Id != token::Id.Eq {
				self.s.pushErr(a.Setter, build::LogMsg.InvalidSyntax)
			}
			self.scope.Stmts = append(self.scope.Stmts, r)
			ret
		}

		if !checkAssign(self.s, l, r, a.Setter) {
			ret
		}

		if r.Type.Tuple() != nil {
			self.s.pushErr(a.Setter, build::LogMsg.MissingMultiAssignIdents)
			ret
		}

		mut lm := &OperandExpr{
			Type: l.Type,
			Model: l.Model,
		}
		mut rm := &OperandExpr{
			Type: r.Type,
			Model: r.Model,
		}
		self.scope.Stmts = append(self.scope.Stmts, &Assign{Left: lm, Right: rm, Op: a.Setter})

		if a.Setter.Id == token::Id.Eq {
			mut checker := assignTypeChecker{
				s: self.s,
				dest: l.Type,
				v: r,
				errorToken: a.Setter,
				refers: self.getOwnerRefers(),
			}
			if checker.check() {
				rm.Model = r.Model
				lm.Model = l.Model
			}
			ret
		}
		id := a.Setter.Id
		a.Setter.Id = removeEqFromOp(a.Setter.Id)
		mut solver := binaryEval.new(eval, a.Setter)
		solver.l, solver.r = l, r
		_ = solver.evalOp()
		a.Setter.Id = id
	}

	fn processEndPartOfMultiAssign(mut &self, mut &st: &MultiAssign, mut &a: &ast::Assign,
		mut &lexpr: &ast::AssignLeft, mut &l: &Value, mut &r: exprPart, strict: bool) {
		if !lexpr.Reference && token::IsIgnoreIdent(lexpr.Ident) {
			if r.data.Type.Void() {
				self.s.pushErr(a.Right.Token, build::LogMsg.InvalidExpr)
			}
			st.Left = append(st.Left, nil)
			ret
		}
		if a.Declarative {
			match type lexpr.Expr.Kind {
			| &ast::IdentExpr:
				if !self.isNewAssignIdent(lexpr.Ident) {
					goto norm
				}
			|:
				if lexpr.Mutable || lexpr.Reference {
					self.s.pushErr(lexpr.Token, build::LogMsg.InvalidSyntax)
					ret
				}
				goto norm
			}
			if self.isDuplicatedIdent(0, lexpr.Ident) {
				self.s.pushErr(lexpr.Token, build::LogMsg.DuplicatedIdent, lexpr.Ident)
				self.s.pushSuggestion(build::LogMsg.RenameForAvoidDuplication)
				self.stop()
				ret
			}
			if token::IsIgnoreIdent(lexpr.Ident) {
				self.s.pushErr(lexpr.Token, build::LogMsg.IgnoreIdent)
			}

			// Add new variable declaration statement.
			mut v := &Var{
				Ident: lexpr.Ident,
				Token: lexpr.Token,
				Mutable: lexpr.Mutable,
				Reference: lexpr.Reference,
				Scope: self.scope,
				ValueSym: &ValueSym{
					Expr: r.expr,
					Value: r.data,
				},
			}
			self.s.checkVarValue(v)
			st.Left = append(st.Left, &Value{
				Lvalue: !v.Constant,
				Mutable: v.Mutable,
				Reference: v.Reference,
				Type: v.TypeSym.Type,
				Model: v,
			})
			st.Decls = append(st.Decls, v)
			self.table.Vars = append(self.table.Vars, v)
			ret
		}
	norm:
		if lexpr.Mutable || lexpr.Reference {
			self.s.pushErr(lexpr.Token, build::LogMsg.DuplicatedIdent, lexpr.Ident)
			self.s.pushSuggestion(build::LogMsg.RenameForAvoidDuplication)
		}

		if !checkAssign(self.s, l, r.data, lexpr.Token) {
			ret
		}

		// Set reference false because this is normal assignment.
		// So, we don't need to check reference assignment should using lvalue.
		mut reference := false
		if self.s.checkValidityForInitExpr(l.Mutable, reference, l.Type, r.data, r.expr.Token) {
			reference = strict // enable reference checking if strict mode enabled
			self.s.checkAssignType(reference, l.Type, r.data, r.expr.Token, self.getOwnerRefers())
		}
		st.Left = append(st.Left, l)
	}

	fn getRightExprsOfMultiAssign(mut &self, mut a: &ast::Assign,
		mut eval: &eval): (parts: []exprPart, right: &Value, ok: bool) {
		updateMut := fn(i: int) {
			l := a.Left[i]
			// Mark target as mutable because if an expression can take assignment
			// it should be a mutable memory, but set as immutable if variable declaring
			// and it is not mutable.
			//
			// This is not actually a mutability safety checking.
			// This just makes responsive-mutability possible and correct.
			eval.target.mutable = !token::IsIgnoreIdent(l.Ident) // if assigned to blank identifier, there is no mutability risk
			match {
			| a.Declarative && eval.target.mutable:
				if l.Mutable && l.Reference {
					eval.target.mutable = l.Mutable
					break
				}
				match type l.Expr.Kind {
				| &ast::IdentExpr:
					if self.isNewAssignIdent(l.Ident) {
						eval.target.mutable = l.Mutable
					}
				}
			}
		}

		match type a.Right.Kind {
		| &ast::TupleExpr:
			mut tup := (&ast::TupleExpr)(a.Right.Kind)
			parts = make([]exprPart, 0, len(tup.Expr))
			i := 0
			mut _i := unsafe { (&int)(&i) } // reference pointer for closure
			mut _parts := unsafe { (&[]exprPart)(&parts) }
			right = eval.evalTupleFunc(tup, fn(mut &expr: &ast::Expr): &Value {
				if *_i >= len(a.Left) {
					ret nil
				}
				updateMut(*_i)
				mut v := eval.evalExpr(expr)
				if v != nil {
					*_parts = append(*_parts, exprPart{v, expr})
				}
				ret v
			})
		|:
			// Map-lookup assignments may evaluated here.
			// It is mutability safe even if map stored in immutable memory and have mutable type value.
			// Because mutability will be checked by assignment analysis.
			updateMut(0)
			right = eval.evalExpr(a.Right)
			if right == nil {
				ret
			}

			if right.Type.Tuple() != nil {
				mut t := right.Type.Tuple()
				parts = make([]exprPart, 0, len(t.Types))
				for (_, mut kind) in t.Types {
					parts = append(parts, exprPart{
						&Value{
							Mutable: true, // Function return.
							Type: kind,
						},
						a.Right,
					})
				}
			} else {
				parts = [{right, a.Right}]
			}
		}
		ok = true
		ret
	}

	fn checkMultiAssign(mut &self, mut &a: &ast::Assign) {
		if a.Setter.Id != token::Id.Eq && a.Setter.Id != token::Id.ColonEq {
			self.s.pushErr(a.Setter, build::LogMsg.InvalidSyntax)
			ret
		}

		mut eval := self.s.eval(self)
		mut right, rightData, ok := self.getRightExprsOfMultiAssign(a, eval)
		if !ok {
			ret
		}

		mut strict := false // any type compatibility analysis requires exact same type
		if len(right) == 1 {
			match type right[0].data.Model {
			| &IndexingExpr:
				mut iem := (&IndexingExpr)(right[0].data.Model)
				if iem.Expr.Type.Map() != nil { // Is map lookup.
					strict = true
					right = [
						{&Value{Mutable: right[0].data.Mutable, Type: iem.Expr.Type.Map().Val}, right[0].expr},
						{&Value{Type: primBool}, right[0].expr},
					]
				}
			| &ChanRecv:
				mut cr := (&ChanRecv)(right[0].data.Model)
				strict = true
				right = [
					{&Value{Mutable: right[0].data.Mutable, Type: cr.Expr.Type.Chan().Elem}, right[0].expr},
					{&Value{Type: primBool}, right[0].expr},
				]
			}
		}

		match {
		| len(a.Left) > len(right):
			self.s.pushErr(a.Setter, build::LogMsg.OverflowMultiAssignIdents)
			ret
		| len(a.Left) < len(right):
			self.s.pushErr(a.Setter, build::LogMsg.MissingMultiAssignIdents)
			ret
		}

		// evaluate left operands as mutable because they will be mutated because of assignment
		eval.target.mutable = true

		mut st := &MultiAssign{
			Right: rightData.Model,
			Op: a.Setter,
		}
		for i in a.Left {
			mut lexpr := a.Left[i]
			let mut l: &Value = nil
			if !token::IsIgnoreIdent(lexpr.Ident) {
				if !a.Declarative {
					goto eval
				}
				if lexpr.Mutable && lexpr.Reference {
					goto end
				}
				match type lexpr.Expr.Kind {
				| &ast::IdentExpr:
					if self.isNewAssignIdent(lexpr.Ident) {
						goto end
					}
				}
			eval:
				l = eval.evalExpr(lexpr.Expr)
				if l == nil {
					continue
				}
			end:
			}
			mut r := right[i]
			self.removeInteriorMutRisk(r.data)
			self.processEndPartOfMultiAssign(st, a, lexpr, l, r, strict)
		}
		self.scope.Stmts = append(self.scope.Stmts, st)
	}

	fn checkAssign(mut &self, mut a: &ast::Assign) {
		match {
		| token::IsPostfixOp(a.Setter.Id):
			self.checkPostfix(a)
		| len(a.Left) == 1:
			self.checkSingleAssign(a)
		|:
			self.checkMultiAssign(a)
		}
	}

	fn checkCaseScope(mut &self, &c: &Case, mut &tree: &ast::ScopeTree): &Scope {
		mut ssc := self.newChildChecker()
		ssc.cse = uintptr(c)
		ret self.checkChildSc(tree, ssc)
	}

	fn checkCase(mut &self, mut m: &Match, i: int, mut c: &ast::Case, mut expr: &Value): &Case {
		mut case := m.Cases[i]
		case.Exprs = make([]&Value, 0, len(c.Exprs))
		mut constMatched := false
		mut eval := self.s.eval(self)
		for (_, mut e) in c.Exprs {
			mut v := eval.evalExprKind(e.Kind)
			if v == nil {
				continue
			}

			if m.TypeMatch {
				// Match types. There is not need to check whether v.Decl is true.
				// Parser always tries to build type declarations for type-match cases.
				// So, v is should be type declaration already.
				case.Exprs = append(case.Exprs, v)
				if countMatchType(m, v.Type) > 1 {
					self.s.pushErr(e.Token, build::LogMsg.DuplicateMatchType, v.Type.Str())
				}
				if m.Comptime {
					constMatched = constMatched || expr.Type.Equal(v.Type)
				} else {
					if expr.Type.TypeEnum() != nil {
						_ = self.s.checkTypeCompatibility(expr.Type, v.Type, e.Token)
					} else {
						trt := expr.Type.Trait()
						if trt != nil {
							_ = self.s.checkTypeCompatibility(expr.Type, v.Type, e.Token)
						}
					}
				}
				applyRuntimeToStr(self.s, v.Type, m.Expr.Type, e.Token, self.getOwnerRefers())
				continue
			}

			if v.Decl {
				self.s.pushErr(e.Token, build::LogMsg.DeclFoundInsteadExpr)
				self.s.pushSuggestion(build::LogMsg.UseTypeMatch)
				continue
			}

			if m.Comptime {
				if !v.IsConst() && v.Type.comptimeTypeInfo() == nil {
					self.s.pushErr(e.Token, build::LogMsg.ExprNotConst)
					self.s.pushSuggestion(build::LogMsg.InvalidExprForConstMatch)
					continue
				}
				if !constMatched {
					if v.IsConst() {
						constMatched = expr.IsConst() && v.Constant.Eq(*expr.Constant)
					} else {
						exprCti := expr.Type.comptimeTypeInfo()
						constMatched = exprCti != nil && v.Type.comptimeTypeInfo().base.Equal(exprCti.base)
					}
				}
			}

			case.Exprs = append(case.Exprs, v)
			if !m.Comptime ||
				expr.Type.comptimeTypeInfo() == nil ||
				v.Type.comptimeTypeInfo() == nil {
				mut checker := assignTypeChecker{
					s: self.s,
					dest: expr.Type,
					v: v,
					errorToken: e.Token,
					refers: self.getOwnerRefers(),
				}
				checker.check()
			}
		}
		if !m.Comptime || constMatched {
			case.Scope = self.checkCaseScope(case, c.Scope)
		}
		ret case
	}

	fn checkCases(mut &self, mut &m: &ast::Match, mut rm: &Match, mut expr: &Value) {
		rm.Cases = make([]&Case, 0, len(m.Cases))
		for i in m.Cases {
			mut case := &Case{
				Owner: rm,
			}
			if i > 0 {
				rm.Cases[i-1].Next = case
			}
			rm.Cases = append(rm.Cases, case)
		}

		if rm.Default != nil && len(m.Cases) > 0 {
			rm.Cases[len(rm.Cases)-1].Next = rm.Default
		}

		for (i, mut c) in m.Cases {
			self.checkCase(rm, i, c, expr)
		}
	}

	fn checkDefault(mut &self, mut owner: CaseOwner, mut d: &ast::Else): &Case {
		mut def := &Case{
			Owner: owner,
		}
		def.Scope = self.checkCaseScope(def, d.Scope)
		ret def
	}

	fn checkComptimePanic(mut &self, mut callToken: &token::Token, &s: &Scope) {
		if len(s.Stmts) != 1 {
			ret
		}
		stmt := s.Stmts[0]
		match type stmt {
		| &Value:
			v := (&Value)(stmt)
			match type v.Model {
			| &BuiltinPanicCallExpr:
				mut m := (&BuiltinPanicCallExpr)(v.Model)
				match type m.Expr {
				| &constant::Const:
					c := (&constant::Const)(m.Expr)
					if !c.IsStr() {
						break
					}
					if callToken == nil {
						mut root := self.getHardRoot()
						if root.calledFrom == nil {
							callToken = m.Token
						} else {
							callToken = root.calledFrom
						}
					}
					self.s.pushErr(callToken, build::LogMsg.ComptimePanic, c.ReadStr())
					self.stop()
				}
			}
		}
	}

	fn processConstMatch(mut &self, mut &tm: &Match, mut &m: &ast::Match) {
		for (i, mut c) in tm.Cases {
			if c.Scope != nil {
				let mut token: &token::Token = nil
				if !tm.TypeMatch && len(c.Scope.Stmts) > 0 {
					token = m.Cases[i].Scope.Stmts[0].Token
				}
				self.checkComptimePanic(token, c.Scope)
				tm.Default = c
				tm.Cases = nil
				ret
			}
		}
		if m.Default != nil {
			tm.Cases = nil
			tm.Default = self.checkDefault(tm, m.Default)
			if tm.Default != nil {
				let mut token: &token::Token = nil
				if !tm.TypeMatch {
					token = m.Default.Scope.Stmts[0].Token
				}
				self.checkComptimePanic(token, tm.Default.Scope)
			}
		} else {
			// Remove all cases, no success matching.
			tm.Cases = nil
		}
	}

	fn checkTypeMatch(mut &self, mut &m: &ast::Match) {
		mut v := self.s.eval(self).eval1(m.Expr)
		if v == nil {
			ret
		}

		if m.Comptime {
			mut cti := v.Type.comptimeTypeInfo()
			if cti == nil {
				if !v.Decl {
					self.s.pushErr(m.Expr.Token, build::LogMsg.InvalidComptimeTypeMatchExpr)
					ret
				}
			} else {
				v.Type = cti.base
			}
		} else if v.Decl || !((v.Type.Prim() != nil && v.Type.Prim().IsAny()) || v.Type.Trait() != nil || v.Type.TypeEnum() != nil) {
			self.s.pushErr(m.Expr.Token, build::LogMsg.TypeCaseHasNotValidExpr)
			ret
		}

		mut tm := &Match{
			Scope: self.scope,
			TypeMatch: true,
			Expr: v,
			Comptime: m.Comptime,
		}

		// Do not check default if comptime matching enabled.
		// We do not know any case will be matched yet.
		// The [self.processConstMatch] will check cases and if not exist
		// any matching, will check default case if exist and handle it.
		if !tm.Comptime && m.Default != nil {
			tm.Default = self.checkDefault(tm, m.Default)
		}

		self.checkCases(m, tm, v)
		if tm.Comptime {
			self.processConstMatch(tm, m)
		}
		self.scope.Stmts = append(self.scope.Stmts, tm)
	}

	fn checkCommonMatch(mut &self, mut &m: &ast::Match) {
		let mut v: &Value = nil
		if m.Expr == nil {
			v = &Value{
				Constant: constant::Const.NewBool(true),
				Type: primBool,
			}
			v.Model = v.Constant
		} else {
			v = self.s.eval(self).evalExpr1(m.Expr)
			if v == nil {
				ret
			}
		}

		if m.Comptime {
			if !canComptimeMatch(v) {
				self.s.pushErr(m.Expr.Token, build::LogMsg.ExprNotConst)
				self.s.pushSuggestion(build::LogMsg.InvalidExprForConstMatch)
				ret
			}
		} else if v.Type.comptime() {
			self.s.pushErr(m.Expr.Token, build::LogMsg.ExprNotConst)
			self.s.pushSuggestion(build::LogMsg.InvalidExprForConstMatch)
			ret
		}

		mut mc := &Match{
			Scope: self.scope,
			Expr: v,
			Comptime: m.Comptime,
		}

		// Push into stmts here. Otherwise, labeled break statements and others
		// will may log error(s) even semantic is good.
		self.scope.Stmts = append(self.scope.Stmts, mc)

		// Do not check default if comptime matching enabled.
		// We do not know any case will be matched yet.
		// The [self.processConstMatch] will check cases and if not exist
		// any matching, will check default case if exist and handle it.
		if !mc.Comptime && m.Default != nil {
			mc.Default = self.checkDefault(mc, m.Default)
		}

		self.checkCases(m, mc, v)
		if mc.Comptime {
			self.processConstMatch(mc, m)
		}
	}

	fn checkMatch(mut &self, mut m: &ast::Match) {
		if m.TypeMatch {
			self.checkTypeMatch(m)
			ret
		}
		self.checkCommonMatch(m)
	}

	fn checkSelectCase(mut &self, mut slct: &Select, i: int, mut c: &ast::Case): &Case {
		mut case := slct.Cases[i]
		case.Exprs = make([]&Value, 0, len(c.Exprs))
		mut eval := self.s.eval(self)
		for (_, mut e) in c.Exprs {
			mut v := eval.evalExpr(e)
			if v == nil {
				continue
			}
			match type v.Model {
			| &ChanRecv | &ChanSend:
				case.Exprs = append(case.Exprs, v)
			|:
				self.s.pushErr(e.Token, build::LogMsg.InvalidSelectExpr)
			}
		}
		case.Scope = self.checkCaseScope(case, c.Scope)
		ret case
	}

	fn checkSelectCases(mut &self, mut &sc: &ast::Select, mut slct: &Select) {
		slct.Cases = make([]&Case, 0, len(sc.Cases))
		for i in sc.Cases {
			mut case := &Case{
				Owner: slct,
			}
			if i > 0 {
				slct.Cases[i-1].Next = case
			}
			slct.Cases = append(slct.Cases, case)
		}

		if slct.Default != nil && len(sc.Cases) > 0 {
			slct.Cases[len(slct.Cases)-1].Next = slct.Default
		}

		for (i, mut c) in sc.Cases {
			self.checkSelectCase(slct, i, c)
		}
	}

	fn checkSelect(mut &self, mut sc: &ast::Select) {
		if self.s.meta.runtime != nil {
			// Add reference to runtime::chanSelect function.
			mut f := runtimeFindFunc(self.s.meta.runtime, "chanSelect").instance()
			mut refers := self.getOwnerRefers()
			if refers != nil && !refers.Exist[&FuncIns](f) {
				refers.Push(f)
			}
		}

		mut slct := &Select{
			Scope: self.scope,
		}
		// Push into stmts here. Otherwise, labeled break statements and others
		// will may log error(s) even semantic is good.
		self.scope.Stmts = append(self.scope.Stmts, slct)
		if sc.Default != nil {
			slct.Default = self.checkDefault(slct, sc.Default)
		}
		self.checkSelectCases(sc, slct)
	}

	fn checkFall(mut &self, f: &ast::Fall) {
		if self.cse == 0 ||
			len(self.scope.Stmts)+1 < len(self.scope.Stmts) ||
			self.isDeferred() {
			self.s.pushErr(f.Token, build::LogMsg.FallthroughWrongUse)
			ret
		}

		mut case := unsafe { (*Case)(self.cse) }
		match type unsafe { case.Owner } {
		| &Match:
			if unsafe { (&Match)(case.Owner).Comptime } {
				self.s.pushErr(f.Token, build::LogMsg.ComptimeFallthrough)
				ret
			}
		| &Select:
			self.s.pushErr(f.Token, build::LogMsg.SelectFallthrough)
			ret
		}
		if unsafe { case.Next } == nil {
			self.s.pushErr(f.Token, build::LogMsg.FallthroughIntoFinalCase)
			self.s.pushSuggestion(build::LogMsg.RemoveFallthroughFromFinalCase)
			ret
		}

		self.scope.Stmts = append(self.scope.Stmts, &Fall{
			DestCase: unsafe { uintptr(case.Next) },
		})
	}

	fn checkBreakWithLabel(mut &self, b: &ast::Break): &Break {
		mut brk := self.checkPlainBreak(b)
		if brk == nil {
			ret nil
		}

		// Set pointer to zero.
		// Pointer will set by label.
		brk.It = 0
		brk.Match = 0

		mut label := findLabelParent(b.Label.Kind, self.parent)
		if label == nil {
			self.s.pushErr(b.Label, build::LogMsg.LabelNotExist, b.Label.Kind)
			ret nil
		}

		label.used = true

		if label.node.Index+1 >= len(label.node.Scope.Stmts) {
			self.s.pushErr(b.Label, build::LogMsg.InvalidLabel, b.Label.Kind)
			ret nil
		}

		i := label.node.Index + 1
		if i >= len(label.node.Scope.Stmts) {
			self.s.pushErr(b.Label, build::LogMsg.InvalidLabel, b.Label.Kind)
		} else {
			mut st := label.node.Scope.Stmts[i]
			match type st {
			| &InfIter:
				brk.It = uintptr((&InfIter)(st))
			| &RangeIter:
				brk.It = uintptr((&RangeIter)(st))
			| &WhileIter:
				brk.It = uintptr((&WhileIter)(st))
			| &Match:
				brk.Match = uintptr((&Match)(st))
			| &Select:
				brk.Select = uintptr((&Select)(st))
			|:
				self.s.pushErr(b.Label, build::LogMsg.InvalidLabel, b.Label.Kind)
			}
		}

		if brk.It != 0 {
			if !self.checkValidBreakLabel(brk.It) {
				self.s.pushErr(b.Label, build::LogMsg.InvalidLabel, b.Label.Kind)
			}
		}

		if brk.Match != 0 {
			if !self.checkValidBreakLabel(brk.Match) {
				self.s.pushErr(b.Label, build::LogMsg.InvalidLabel, b.Label.Kind)
			}
		}

		if brk.Select != 0 {
			if !self.checkValidBreakLabel(brk.Select) {
				self.s.pushErr(b.Label, build::LogMsg.InvalidLabel, b.Label.Kind)
			}
		}

		ret brk
	}

	fn checkPlainBreak(mut &self, b: &ast::Break): &Break {
		if self.isDeferred() {
			self.s.pushErr(b.Token, build::LogMsg.BreakAtOutOfValidScope)
			ret nil
		}

		mut scope := self
	iter:
		match {
		| scope.it == 0 && scope.cse == 0 && scope.parent != nil && scope.owner == nil:
			scope = scope.parent
			goto iter
		| scope.it != 0:
			ret &Break{It: scope.it}
		| scope.cse != 0:
			owner := caseOwner(unsafe { (*Case)(scope.cse).Owner }).asUintptr()
			ret &Break{Match: owner}
		}

		self.s.pushErr(b.Token, build::LogMsg.BreakAtOutOfValidScope)
		ret nil
	}

	fn checkBreak(mut &self, b: &ast::Break) {
		if b.Label != nil { // Label given.
			mut brk := self.checkBreakWithLabel(b)
			self.scope.Stmts = append(self.scope.Stmts, brk)
			ret
		}

		mut brk := self.checkPlainBreak(b)
		self.scope.Stmts = append(self.scope.Stmts, brk)
	}

	fn checkRet(mut &self, mut r: &ast::Ret) {
		if self.isDeferred() {
			self.s.pushErr(r.Token, build::LogMsg.RetInDeferred)
		}

		mut rt := &Ret{
			Func: self.getRoot().owner,
		}
		self.scope.Stmts = append(self.scope.Stmts, rt)

		mut rtc := &retTypeChecker{
			sc: self,
			f: rt.Func,
			errorToken: r.Token,
			mutable: true,
		}
		ok := rtc.check(r.Expr)
		if !ok {
			ret
		}

		if r.Expr != nil {
			rt.Expr = rtc.model
		}
	}

	fn checkUseExpr(mut &self, ue: &ast::UseExpr) {
		if self.result == nil {
			self.s.pushErr(ue.Token, build::LogMsg.UseExprOutOfScope)
			ret
		}

		if self.isDeferred() {
			self.s.pushErr(ue.Token, build::LogMsg.UseExprInDeferred)
		}

		if self.i+1 < len(self.tree.Stmts) {
			self.s.pushErr(ue.Token, build::LogMsg.UseExprNotLast)
		}
		// Validated at end of scope's analysis.
	}

	fn checkNode(mut &self, mut &node: ast::StmtData) {
		match type node {
		| &ast::ScopeTree:
			self.checkAnonScope((&ast::ScopeTree)(node))
		| &ast::Var:
			self.checkVarDecl((&ast::Var)(node))
		| &ast::TypeAlias:
			self.checkTypeAliasDecl((&ast::TypeAlias)(node))
		| &ast::Expr:
			self.checkExpr((&ast::Expr)(node))
		| &ast::Conditional:
			self.checkConditional((&ast::Conditional)(node))
		| &ast::Iter:
			self.checkIter((&ast::Iter)(node))
		| &ast::Continue:
			self.checkCont((&ast::Continue)(node))
		| &ast::Label:
			self.checkLabel((&ast::Label)(node))
		| &ast::Goto:
			self.pushGoto((&ast::Goto)(node))
		| &ast::Assign:
			self.checkAssign((&ast::Assign)(node))
		| &ast::Match:
			self.checkMatch((&ast::Match)(node))
		| &ast::Select:
			self.checkSelect((&ast::Select)(node))
		| &ast::Fall:
			self.checkFall((&ast::Fall)(node))
		| &ast::Break:
			self.checkBreak((&ast::Break)(node))
		| &ast::Ret:
			self.checkRet((&ast::Ret)(node))
		| &ast::UseExpr:
			self.checkUseExpr((&ast::UseExpr)(node))
		|:
			println("error <unimplemented scope node>")
		}
	}

	fn checkResult(mut &self) {
		mut stmt := self.tree.Stmts[len(self.tree.Stmts)-1]
		match type stmt.Data {
		| &ast::UseExpr:
			mut ue := (&ast::UseExpr)(stmt.Data)
			mut v := self.s.eval(self).evalExpr(ue.Expr)
			if v == nil {
				ret
			}
			self.scope.Stmts = append(self.scope.Stmts, v)
			mut rtc := &retTypeChecker{
				sc: self,
				errorToken: ue.Expr.Token,
				types: self.result.func.Types(),
				mutable: self.result.mutable,
			}
			_ = rtc.check(ue.Expr)
		| &ast::Expr:
			mut expr := (&ast::Expr)(stmt.Data)
			mut v := self.s.eval(self).evalExpr(expr)
			if v == nil {
				ret
			}
			match type v.Model {
			| &BuiltinPanicCallExpr:
				self.scope.Stmts = append(self.scope.Stmts, v)
			| &BuiltinErrorCallExpr:
				mut m := (&BuiltinErrorCallExpr)(v.Model)
				self.processErrorCall(m, expr.Token)
				self.scope.Stmts = append(self.scope.Stmts, v)
			|:
				ret
			}
		| &ast::Goto
		| &ast::Break
		| &ast::Continue
		| &ast::Ret:
			self.checkNode(stmt.Data)
		|:
			self.checkNode(stmt.Data)
			ret
		}

		// Set result to nil, it is a mark for whether result is processed.
		self.result = nil
	}

	fn checkTree(mut &self) {
		self.i = 0
		mut n := len(self.tree.Stmts)
		if self.result != nil {
			// Skip last statement if result is exist.
			// Algorithm will check last statement for result.
			// So, if you check last statement also here, it will duplicate.
			n--
		}
		for self.i < n; self.i++ {
			mut stmt := self.tree.Stmts[self.i]
			self.checkNode(stmt.Data)
			if self.stopped() {
				ret
			}
		}
		if self.result != nil && len(self.tree.Stmts) != 0 {
			self.checkResult()
		}
	}

	fn checkGoto(mut self, mut &gt: &Goto, mut &label: &scopeLabel) {
		mut n := 0
		if gt.Scope == label.node.Scope {
			// Scopes are same and label at above, so it is safe.
			if gt.Index > label.node.Index {
				ret
			}
			// Limit controlling to goto's position.
			// Label and goto is in same scope.
			n = gt.Index
		} else if gt.Scope.ChildIndex > label.node.Scope.ChildIndex {
			// Label owned by a parent scope.
			// Find parent scope of goto scope based on label.
			// So we can evaluate by same scope conditions.
			mut gtsc := gt.Scope
			for gtsc.ChildIndex-1 > label.node.Scope.ChildIndex {
				gtsc = gtsc.Parent
			}
			if gtsc.StmtIndex > label.node.Index {
				// Scopes are same and label at above, so it is safe.
				ret
			}
			// Limit controlling to goto's position.
			// Label and goto is in same scope.
			// If same scope condition is not met,
			// we have zero offset because of root scope.
			// So algorithm will check all statements without limitation,
			// so any declaration will cause an error.
			n = gtsc.StmtIndex
		} else {
			// Label owned by a child scope. Set limit offset to zero.
			// Thus algorithm will check all statements without limitation,
			// so any declaration will cause an error.
			n = 0
		}

		mut s := label.node.Scope     // Start checking at scope of label.
		mut i := label.node.Index - 1 // Start end limit by label statement.
		for {
			for i >= n; i-- {
				mut stmt := s.Stmts[i]
				if stmtIsDef(stmt) {
					self.s.pushErr(gt.Token, build::LogMsg.GotoJumpsDeclarations, gt.Ident)
					ret
				}
			}
			if s.ChildIndex > gt.Scope.ChildIndex {
				// Current scope is more depth than goto scope.
				// So jump to parent scope to check any missing declaration.
				s = s.Parent
				i = s.StmtIndex - 1 // Set end limit to above of current scope statement.
				continue
			}
			break
		}
	}

	fn checkGotos(mut self) {
		for (_, mut gt) in *self.gotos {
			mut label := self.findLabelAll(gt.Ident)
			if label == nil {
				self.s.pushErr(gt.Token, build::LogMsg.LabelNotExist, gt.Ident)
				continue
			}
			gt.Label = label.node
			label.used = true
			self.checkGoto(gt, label)
		}
	}

	fn checkLabels(mut self) {
		for _, l in *self.labels {
			if !l.used {
				self.s.pushErr(l.token, build::LogMsg.DeclaredButNotUsed, l.node.Ident)
			}
		}
	}

	fn checkVars(mut self) {
		for _, v in self.table.Vars {
			if !v.Used && !v.Constant && !token::IsIgnoreIdent(v.Ident) && !token::IsAnonIdent(v.Ident) {
				self.s.pushErr(v.Token, build::LogMsg.DeclaredButNotUsed, v.Ident)
			}
		}
	}

	fn checkAliases(mut self) {
		for _, a in self.table.TypeAliases {
			if !a.Used && !token::IsIgnoreIdent(a.Ident) && !token::IsAnonIdent(a.Ident) {
				self.s.pushErr(a.Token, build::LogMsg.DeclaredButNotUsed, a.Ident)
			}
		}
	}

	// Checks scope tree.
	fn check(mut &self, mut &tree: &ast::ScopeTree, mut &s: &Scope) {
		s.Deferred = tree.Deferred
		s.Unsafety = tree.Unsafety

		errors := len(self.s.errors)

		self.tree = tree
		self.scope = s

		self.checkTree()

		// If we have new errors, don't check unused declarations.
		if errors == len(self.s.errors) {
			self.checkVars()
			self.checkAliases()

			if self.isRoot() {
				self.checkGotos()
				self.checkLabels()
			}
		}
	}

	fn newChildChecker(mut &self): &scopeChecker {
		mut base := newScopeCheckerBase(self.s, nil)
		base.parent = self
		base.labels = self.labels
		base.gotos = self.gotos
		base.childIndex = self.childIndex + 1
		ret base
	}
}

fn removeEqFromOp(op: token::Id): token::Id {
	match op {
	| token::Id.PlusEq:
		ret token::Id.Plus
	| token::Id.MinusEq:
		ret token::Id.Minus
	| token::Id.StarEq:
		ret token::Id.Star
	| token::Id.SolidusEq:
		ret token::Id.Solidus
	| token::Id.PercentEq:
		ret token::Id.Percent
	| token::Id.ShlEq:
		ret token::Id.Shl
	| token::Id.ShrEq:
		ret token::Id.Shr
	| token::Id.CaretEq:
		ret token::Id.Caret
	| token::Id.AmperEq:
		ret token::Id.Amper
	| token::Id.VlineEq:
		ret token::Id.Vline
	|:
		ret op
	}
}

// Makes data d as comptimeRange.
// If type is not supported, d.Decl will be true.
// If onlyComptime is true, only handles comptime types.
fn makeComptimeRange(mut &v: &Value, onlyComptime: bool) {
	match {
	| v.Type.comptimeStructFields() != nil:
		v.Type = &Type{Kind: &comptimeRange{v.Type.comptimeStructFields()}}
		ret
	| v.Type.comptimeEnumFields() != nil:
		v.Type = &Type{Kind: &comptimeRange{v.Type.comptimeEnumFields()}}
		ret
	| v.Type.comptimeTypeInfos() != nil:
		v.Type = &Type{Kind: &comptimeRange{v.Type.comptimeTypeInfos()}}
		ret
	| v.Type.comptimeParams() != nil:
		v.Type = &Type{Kind: &comptimeRange{v.Type.comptimeParams()}}
		ret
	| v.Type.comptimeStatics() != nil:
		v.Type = &Type{Kind: &comptimeRange{v.Type.comptimeStatics()}}
		ret
	| v.Type.comptimeFiles() != nil:
		v.Type = &Type{Kind: &comptimeRange{v.Type.comptimeFiles()}}
		ret
	| v.Type.comptimeDecls() != nil:
		v.Type = &Type{Kind: &comptimeRange{v.Type.comptimeDecls()}}
		ret
	| !onlyComptime && v.Type.Slice() != nil:
		match type v.Model {
		| &SliceExpr:
			mut s := (&SliceExpr)(v.Model)
			for _, e in s.Elems {
				if !e.IsConst() {
					goto fail
				}
			}
			v.Type = &Type{Kind: &comptimeRange{&comptimeSliceRange{s}}}
			ret
		}
	}
fail:
	// Flag for failure.
	v.Decl = true
}

// Reports whether v can match at comptime.
fn canComptimeMatch(mut &v: &Value): bool {
	// Do not allow value if has unsupported type for type infer.
	if !isGoodValueToInfer(v) {
		ret false
	}
	ret v.IsConst() || v.Type.comptimeTypeInfo() != nil
}

fn stmtIsDef(&stmt: Stmt): bool {
	match type stmt {
	| &Var:
		ret true
	| &MultiAssign:
		ma := (&MultiAssign)(stmt)
		ret len(ma.Decls) > 0
	|:
		ret false
	}
}

fn countMatchType(&m: &Match, &t: &Type): int {
	mut n := 0
loop:
	for _, c in m.Cases {
		if c == nil {
			continue
		}
		for _, expr in c.Exprs {
			// Break loop because this expression is not parsed yet.
			// So, parsed cases finished.
			if expr == nil {
				break loop
			}
			if t.Equal((&Type)(expr.Model)) {
				n++
			}
		}
	}
	ret n
}

// Returns label by identifier.
// Returns nil if not exist any label in this identifier.
// Lookups given scope and parent scopes.
fn findLabelParent(&ident: str, mut scope: &scopeChecker): &scopeLabel {
	mut label := scope.findLabelScope(ident)
	for label == nil {
		if scope.parent == nil || scope.owner != nil {
			ret nil
		}
		scope = scope.parent
		label = scope.findLabelScope(ident)
	}
	ret label
}

fn getExprs(mut &m: ast::ExprData): []ast::ExprData {
	match type m {
	| &ast::TupleExpr:
		mut tup := (&ast::TupleExpr)(m)
		mut models := make([]ast::ExprData, 0, len(tup.Expr))
		for (_, mut expr) in tup.Expr {
			models = append(models, expr.Kind)
		}
		ret models
	|:
		ret [m]
	}
}

fn checkAssignMut(mut &s: &sema, &left: &Value, mut right: &Value, op: &token::Token): (ok: bool) {
	match {
	| !left.Mutable:
		s.pushErr(op, build::LogMsg.AssignToNonMut)
		ret false
	| right != nil && !right.Mutable && right.Type.Mutable():
		s.pushErr(op, build::LogMsg.AssignNonMutToMut, right.Type.Str())
		ret false
	|:
		ret true
	}
}

fn checkAssign(mut &s: &sema, mut &left: &Value, mut right: &Value, op: &token::Token): (ok: bool) {
	f := left.Type.Func()
	if f != nil && f.Decl != nil && f.Decl.Global {
		s.pushErr(op, build::LogMsg.AssignTypeNotSupportValue)
		ret false
	}
	// Assignment to constant memory.
	if left.IsConst() {
		s.pushErr(op, build::LogMsg.AssignConst)
		s.pushSuggestion(build::LogMsg.RemoveConstToAssign)
		ret false
	}
	// Fast path: check whether value is lvalue.
	// If value is lvalue, it is ok.
	if !left.Lvalue {
		// Slow path: value is not lvalue. We need to check
		// special cases.
		match type left.Model {
		| &IndexingExpr:
			// Type is map. We need to check special case for maps.
			// Because map indexing is not considered lvalue.
			mut i := (&IndexingExpr)(left.Model)
			// Map type indexing. Map indexing is not considered lvalue.
			// But we can assign, so it is ok.
			if i.Expr.Type.Map() != nil {
				break
			}
			fall
		|:
			// Default case.
			s.pushErr(op, build::LogMsg.AssignRequireLvalue)
			ret false
		}
	}
	ret checkAssignMut(s, left, right, op)
}

fn isValidAstStForNextSt(mut &n: ast::StmtData): bool {
	match type n {
	| &ast::Assign:
		ret !(&ast::Assign)(n).Declarative
	| &ast::Expr:
		ret true
	|:
		ret false
	}
}

fn isValidStForNextSt(&st: Stmt): bool {
	match type st {
	| &Postfix
	| &Assign
	| &MultiAssign:
		ret true
	| &Value:
		match type (&Value)(st).Model {
		| &FuncCallExpr:
			ret true
		|:
			ret false
		}
	|:
		ret false
	}
}
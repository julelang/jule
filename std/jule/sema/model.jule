// Copyright 2023-2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/jule/constant"
use "std/jule/token"

// Expression model.
enum Expr: type {
	&Type,
	&constant::Const,
	&Var,
	&FnIns,
	&StructIns,
	&OperandExpr,
	&BinaryExpr,
	&UnaryExpr,
	&StructArgExpr,
	&StructLitExpr,
	&AllocStructLitExpr,
	&CastingExpr,
	&FnCallExpr,
	&SliceExpr,
	&IndexingExpr,
	&AnonFnExpr,
	&KeyValPairExpr,
	&MapExpr,
	&SlicingExpr,
	&TraitSubIdentExpr,
	&StructSubIdentExpr,
	&StructStaticIdentExpr,
	&ArrayExpr,
	&TupleExpr,
	&BuiltinPrintCallExpr,
	&BuiltinPrintlnCallExpr,
	&BuiltinNewCallExpr,
	&BuiltinPanicCallExpr,
	&BuiltinMakeCallExpr,
	&BuiltinAppendCallExpr,
	&BuiltinCopyCallExpr,
	&BuiltinLenCallExpr,
	&BuiltinCapCallExpr,
	&BuiltinDeleteCallExpr,
	&BuiltinErrorCallExpr,
	&SizeofExpr,
	&AlignofExpr,
	&RuneExpr,
	&BackendEmitExpr,
	&FreeExpr,
	&ChanRecv,
	&ChanSend,
	&BuiltinCloseCallExpr,
}

// Operand expression model.
struct OperandExpr {
	Type:  &Type
	Model: Expr
}

// Binary operation expression model.
struct BinaryExpr {
	Left:  &OperandExpr
	Right: &OperandExpr
	Op:    &token::Token
}

// Unary operation expression model.
struct UnaryExpr {
	Expr: &Data
	Op:   &token::Token
}

// Structure field argument expression model for constructors.
// For example: &MyStruct{10, false, "-"}
struct StructArgExpr {
	Token: &token::Token
	Field: &FieldIns
	Expr:  &Data
}

// Structure literal.
struct StructLitExpr {
	Strct: &StructIns
	Args:  []&StructArgExpr
}

// Heap allocated structure litral expression.
// For example: &MyStruct{}
struct AllocStructLitExpr {
	Lit: &StructLitExpr
}

// Casting expression model.
// For example: (int)(my_float)
struct CastingExpr {
	Token: &token::Token
	Expr:  &Data
	Type:  &Type
}

// Function call expression model.
struct FnCallExpr {
	Token:    &token::Token
	Func:     &FnIns
	IsCo:     bool
	Expr:     Expr
	Args:     []Expr
	Except:   &Scope
	Assigned: bool
}

// Slice expression model.
// For example: [1, 2, 3, 4, 5, 6, 8, 9, 10]
struct SliceExpr {
	ElemType: &Type
	Elems:    []&Data
}

// Indexing expression model.
// For example: slice[index]
struct IndexingExpr {
	Token: &token::Token
	Expr:  &Data
	Index: &Data
}

// Anonymous function expression model.
struct AnonFnExpr {
	Captured: []&Var
	Func:     &FnIns
	Global:   bool
}

// Key-value expression pair model.
struct KeyValPairExpr {
	Key: Expr
	Val: Expr
}

// Map expression model.
// For example; {0: false, 1: true}
struct MapExpr {
	Kind:    &Map
	Entries: []&KeyValPairExpr
}

// Slicing expression model.
// For example: mySlice[2:len(mySlice)-5]
struct SlicingExpr {
	Token: &token::Token

	// Expression to slicing.
	Expr: Expr

	// Left index expression.
	// Zero integer if expression have not left index.
	Left: Expr

	// Right index expression.
	// Nil if expression have not right index.
	Right: Expr
}

// Trait sub-ident expression model.
// For example: myTrait.subIdent
struct TraitSubIdentExpr {
	Token:  &token::Token
	Expr:   Expr
	Method: &Fn
	Trt:    &Trait
}

// Structure sub-ident expression model.
// For example: myStruct.subIdent
struct StructSubIdentExpr {
	Token:  &token::Token
	Expr:   &Data
	Method: &FnIns
	Field:  &FieldIns
	Owner:  &StructIns
}

// Structure static ident expression model.
// For example: MyStruct.mySubIdent
struct StructStaticIdentExpr {
	Structure: &StructIns
	Expr:      Expr
	Method:    &FnIns
}

// Array expression model.
// If array filled, elems field holds 2 data.
// First data is expression, second is nil, kind of mark to that array filled.
struct ArrayExpr {
	Kind:  &Arr
	Elems: []&Data
}

// Tuple expression model.
struct TupleExpr {
	Datas: []&Data
}

// Expression Model: for built-in print function calls.
struct BuiltinPrintCallExpr {
	Expr: &Data
}

// Expression Model: for built-in println function calls.
struct BuiltinPrintlnCallExpr {
	Expr: &Data
}

// Expression Model: for built-in new function calls.
struct BuiltinNewCallExpr {
	Type: &Type // Element type of smart pointer.
	Init: Expr  // Nil for not initialized.
}

// Expression Model: for built-in panic function calls.
struct BuiltinPanicCallExpr {
	Token: &token::Token
	Expr:  Expr
}

// Expression model: for channel receive.
struct ChanRecv {
	Token: &token::Token
	Expr:  &Data
}

// Expression mode: for channel send.
struct ChanSend {
	Token: &token::Token
	Chan:  &Data
	Data:  &Data
}

// Expression Model: for built-in close function calls.
struct BuiltinCloseCallExpr {
	Token: &token::Token
	Chan:  &Data
}

// Expression Model: for built-in make function calls.
// If Type is slice, the Len and Cap fields may be meaningful.
// If Type is channel, the buffer size specified in the Cap field if exist.
// The Len field is undefined for channel types.
struct BuiltinMakeCallExpr {
	Type: &Type
	Len:  Expr
	Cap:  Expr
}

// Expression Model: for built-in append function calls.
struct BuiltinAppendCallExpr {
	Dest:     Expr
	Elements: Expr
}

// Expression Model: for built-in len function calls.
struct BuiltinLenCallExpr {
	Expr: &Data
}

// Expression Model: for built-in cap function calls.
struct BuiltinCapCallExpr {
	Expr: &Data
}

// Expression Model: for built-in delete function calls.
struct BuiltinDeleteCallExpr {
	Dest: &Data
	Key:  &Data
}

// Expression Model: for built-in copy function calls.
struct BuiltinCopyCallExpr {
	Dest: &Data
	Src:  &Data
}

// Expression Model: for built-in error function calls.
struct BuiltinErrorCallExpr {
	Func: &FnIns
	Err:  &Data
}

// Expression Model: for sizeof expressions.
// For example, in C++: sizeof(int)
struct SizeofExpr {
	Expr: Expr
}

// Expression Model: for alignof expressions.
// For example, in C++: alignof(int)
struct AlignofExpr {
	Expr: Expr
}

// Rune literal expression model.
// For example: 'a'
struct RuneExpr {
	Code: rune
}

// Expression Model: for inline code emit to backend.
struct BackendEmitExpr {
	Code: str

	// Expression Model: for expression or type emit to backend from Jule source code.
	Exprs: []Expr
}

// Expression Model: for free calls.
// Function provided by: "std/mem"
struct FreeExpr {
	Expr: Expr
}
// Copyright 2023-2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

// This file reserved for types, type kinds and type build algorithms.
// This file haven't type compatibility checking algorithm or something else.

use conv for std::conv
use ast for std::jule::ast::{
    Ast,
    TypeDecl,
    GenericDecl,
    FnDecl,
    MapTypeDecl,
    PtrTypeDecl,
    SlcTypeDecl,
    ArrTypeDecl,
    ScopeTree,
    NamespaceTypeDecl,
    TypeDeclKind,
    TupleTypeDecl,
    SptrTypeDecl,
    IdentTypeDecl,
    SubIdentTypeDecl,
}
use std::jule::build::{Derive, LogMsg, Logf}
use std::jule::lex::{Token, TokenKind}
use types for std::jule::types
use strings for std::strings

type PrimKind: types::TypeKind

// Generic type for instance types.
struct InsGeneric {
    Kind:       &TypeKind
    Constraint: []&TypeKind
}

// Type alias.
struct TypeAlias {
    Scope:     &ScopeTree
    Public:    bool
    CppLinked: bool
    Used:      bool
    Generic:   bool
    Token:     &Token
    Ident:     str
    Kind:      &TypeSymbol
    Refers:    []any        // Referred identifiers, except cpp-linked ones.
    Generics:  []&TypeAlias // See developer reference (1).
}

// Kind of type declaration.
trait Kind {
    fn Str(self): str
    fn Equals(&self, other: &TypeKind): bool
}

// Evaluated type declaration.
struct TypeKind {
    CppIdent: str
    Generic:  bool
    Variadic: bool
    Kind:     Kind
}

impl Kind for TypeKind {
    // Returns kind as string.
    fn Str(self): str {
        if self.IsNil() {
            ret "nil"
        }

        let mut kind = ""

        if self.Variadic {
            kind += "..."
        }

        if self.CppLinked() {
            kind += "cpp."
            kind += self.CppIdent
        } else {
            kind += self.Kind.Str()
        }
        ret kind
    }

    // Reports whether types are same.
    fn Equals(&self, other: &TypeKind): bool {
        if self.IsNil() {
            ret other.IsNil()
        }
        if self.CppLinked() {
            ret other.CppLinked() &&
                self.CppIdent == other.CppIdent
        }
        ret self.Kind.Equals(other)
    }
}

impl TypeKind {
    // Reports whether type is cpp-linked kind.
    fn CppLinked(self): bool { ret len(self.CppIdent) != 0 }

    // Reports whether kind is "nil".
    fn IsNil(self): bool { ret self.Kind == nil }

    // Reports whether kind is "void".
    fn Void(self): bool {
        let prim = unsafe { (*(&self)).Prim() }
        ret prim != nil && prim.Kind == "void"
    }

    // Reports whether kind is comparable.
    fn Comparable(self): bool {
        unsafe {
            let mut _self = &self
            if _self.Struct() != nil {
                ret _self.Struct().Comparable
            }
            ret _self.Map() == nil && _self.Slc() == nil && _self.Fn() == nil
        }
    }

    // Reports whether kind is mutable.
    fn Mutable(self): bool {
        unsafe {
            let mut _self = &self
            if _self.Struct() != nil {
                ret _self.Struct().Mutable
            }
            if _self.Trait() != nil {
                ret _self.Trait().Mutable
            }
            if _self.Prim() != nil {
                let p = _self.Prim()
                ret p.IsAny()
            }
            if _self.Arr() != nil {
                ret _self.Arr().Elem.Mutable()
            }
            ret _self.Slc() != nil ||
                _self.Ptr() != nil ||
                _self.Sptr() != nil
        }
    }

    // Reports whether kind is nil compatible.
    fn NilCompatible(self): bool {
        unsafe {
            let mut _self = &self

            let prim = _self.Prim()
            if prim != nil && prim.IsAny() {
                ret true
            }

            ret _self.IsNil() ||
                _self.Fn() != nil ||
                _self.Sptr() != nil ||
                _self.Ptr() != nil ||
                _self.Trait() != nil ||
                _self.Slc() != nil ||
                _self.Map() != nil ||
                _self.TypeEnum() != nil
        }
    }

    // Reports whether kind performs reference-counting.
    fn PerformsRC(self): bool {
        unsafe {
            let mut _self = &self
            let prim = _self.Prim()
            if prim != nil {
                ret prim.IsAny()
            }
            ret _self.Sptr() != nil || _self.Slc() != nil || _self.Trait() != nil
        }
    }

    // Reports whether kind supports clonning via jule::Clone derive.
    fn SupportsCloning(self): bool {
        unsafe {
            let mut _self = &self
            match {
            | _self.Prim() != nil:
                ret !_self.Prim().IsAny()
            | _self.Enum() != nil:
                ret true
            | _self.Fn() != nil:
                ret true
            | _self.Ptr() != nil:
                ret true
            | _self.Slc() != nil:
                ret _self.Slc().Elem.SupportsCloning()
            | _self.Map() != nil:
                let m = _self.Map()
                ret m.Key.SupportsCloning() && m.Val.SupportsCloning()
            | _self.Arr() != nil:
                ret _self.Arr().Elem.SupportsCloning()
            | _self.Sptr() != nil:
                ret _self.Sptr().Elem.SupportsCloning()
            | _self.Struct() != nil:
                let mut s = _self.Struct()
                ret s.Decl != nil &&
                    !s.Decl.CppLinked &&
                    s.Decl.IsDerives(Derive.Clone)
            |:
                ret false
            }
        }
    }

    // Reports whether kind is variadicable.
    fn Variadicable(self): bool {
        unsafe {
            let mut _self = &self
            ret _self.Slc() != nil
        }
    }

    // Returns primitive type if kind is primitive type, nil reference if not.
    fn Prim(mut self): &Prim {
        match type self.Kind {
        | &Prim:
            ret (&Prim)(self.Kind)
        |:
            ret nil
        }
    }

    // Returns reference type if kind is smart pointer, nil reference if not.
    fn Sptr(mut self): &Sptr {
        match type self.Kind {
        | &Sptr:
            ret (&Sptr)(self.Kind)
        |:
            ret nil
        }
    }

    // Returns pointer type if kind is pointer, nil reference if not.
    fn Ptr(mut self): &Ptr {
        match type self.Kind {
        | &Ptr:
            ret (&Ptr)(self.Kind)
        |:
            ret nil
        }
    }

    // Returns enum type if kind is enum, nil reference if not.
    fn Enum(mut self): &Enum {
        match type self.Kind {
        | &Enum:
            ret (&Enum)(self.Kind)
        |:
            ret nil
        }
    }

    // Returns type enum if kind is type enum, nil reference if not.
    fn TypeEnum(mut self): &TypeEnum {
        match type self.Kind {
        | &TypeEnum:
            ret (&TypeEnum)(self.Kind)
        |:
            ret nil
        }
    }

    // Returns array type if kind is array, nil reference if not.
    fn Arr(mut self): &Arr {
        match type self.Kind {
        | &Arr:
            ret (&Arr)(self.Kind)
        |:
            ret nil
        }
    }

    // Returns slice type if kind is slice, nil reference if not.
    fn Slc(mut self): &Slc {
        match type self.Kind {
        | &Slc:
            ret (&Slc)(self.Kind)
        |:
            ret nil
        }
    }

    // Returns fn type if kind is function, nil reference if not.
    fn Fn(mut self): &FnIns {
        match type self.Kind {
        | &FnIns:
            ret (&FnIns)(self.Kind)
        |:
            ret nil
        }
    }

    // Returns struct type if kind is structure, nil reference if not.
    fn Struct(mut self): &StructIns {
        match type self.Kind {
        | &StructIns:
            ret (&StructIns)(self.Kind)
        |:
            ret nil
        }
    }

    // Returns trait type if kind is trait, nil reference if not.
    fn Trait(mut self): &Trait {
        match type self.Kind {
        | &Trait:
            ret (&Trait)(self.Kind)
        |:
            ret nil
        }
    }

    // Returns map type if kind is map, nil reference if not.
    fn Map(mut self): &Map {
        match type self.Kind {
        | &Map:
            ret (&Map)(self.Kind)
        |:
            ret nil
        }
    }

    // Returns tuple type if kind is tuple, nil reference if not.
    fn Tup(mut self): &Tuple {
        match type self.Kind {
        | &Tuple:
            ret (&Tuple)(self.Kind)
        |:
            ret nil
        }
    }
}

// Type.
struct TypeSymbol {
    Decl: &TypeDecl // Never changed by semantic analyzer.
    Kind: &TypeKind
}

impl TypeSymbol {
    // Reports whether type is checked already.
    fn checked(self): bool { ret self.Kind != nil }

    // Removes kind and ready to check.
    // checked() reports false after this function.
    fn removeKind(mut self) { self.Kind = nil }
}

// Primitive type.
struct Prim {
    Kind: str
}

impl Kind for Prim {
    // Returns kind.
    fn Str(self): str {
        ret self.Kind
    }

    // Reports whether types are same.
    fn Equals(&self, other: &TypeKind): bool {
        let prim = unsafe { (*(&other)).Prim() }
        if prim == nil {
            ret false
        }
        ret self.Kind == prim.Kind
    }
}

impl Prim {
    // Reports whether type is built-in constraint.
    fn IsConstraint(self): bool {
        ret !self.IsStr() &&
            !self.IsAny() &&
            !self.IsBool() &&
            !types::IsNum(self.Kind)
    }

    // Reports whether type is primitive i8.
    fn IsI8(self): bool { ret self.Kind == PrimKind.I8 }

    // Reports whether type is primitive i16.
    fn IsI16(self): bool { ret self.Kind == PrimKind.I16 }

    // Reports whether type is primitive i32.
    fn IsI32(self): bool { ret self.Kind == PrimKind.I32 }

    // Reports whether type is primitive i64.
    fn IsI64(self): bool { ret self.Kind == PrimKind.I64 }

    // Reports whether type is primitive u8.
    fn IsU8(self): bool { ret self.Kind == PrimKind.U8 }

    // Reports whether type is primitive u16.
    fn IsU16(self): bool { ret self.Kind == PrimKind.U16 }

    // Reports whether type is primitive u32.
    fn IsU32(self): bool { ret self.Kind == PrimKind.U32 }

    // Reports whether type is primitive u64.
    fn IsU64(self): bool { ret self.Kind == PrimKind.U64 }

    // Reports whether type is primitive f32.
    fn IsF32(self): bool { ret self.Kind == PrimKind.F32 }

    // Reports whether type is primitive f64.
    fn IsF64(self): bool { ret self.Kind == PrimKind.F64 }

    // Reports whether type is primitive int.
    fn IsInt(self): bool { ret self.Kind == PrimKind.Int }

    // Reports whether type is primitive uint.
    fn IsUint(self): bool { ret self.Kind == PrimKind.Uint }

    // Reports whether type is primitive uintptr.
    fn IsUintptr(self): bool { ret self.Kind == PrimKind.Uintptr }

    // Reports whether type is primitive bool.
    fn IsBool(self): bool { ret self.Kind == PrimKind.Bool }

    // Reports whether type is primitive str.
    fn IsStr(self): bool { ret self.Kind == PrimKind.Str }

    // Reports whether type is primitive any.
    fn IsAny(self): bool { ret self.Kind == PrimKind.Any }
}

// Smart pointer.
struct Sptr {
    Elem: &TypeKind
}

impl Kind for Sptr {
    // Returns smart pointer kind as string.
    fn Str(self): str { ret "&" + self.Elem.Str() }

    // Reports whether types are same.
    fn Equals(&self, other: &TypeKind): bool {
        let sptr = unsafe { (*(&other)).Sptr() }
        if sptr == nil {
            ret false
        }
        ret self.Elem.Equals(sptr.Elem)
    }
}

// Slice type.
struct Slc {
    Elem: &TypeKind
}

impl Kind for Slc {
    // Returns slice kind as string.
    fn Str(self): str { ret "[]" + self.Elem.Str() }

    // Reports whether types are same.
    fn Equals(&self, other: &TypeKind): bool {
        let slc = unsafe { (*(&other)).Slc() }
        if slc == nil {
            ret false
        }
        ret self.Elem.Equals(slc.Elem)
    }
}

// Tuple type.
struct Tuple {
    Types: []&TypeKind
}

impl Kind for Tuple {
    // Returns tuple kind as string.
    fn Str(self): str {
        let mut s = "("
        s += self.Types[0].Str()
        for _, t in self.Types[1:] {
            s += ","
            s += t.Str()
        }
        s += ")"
        ret s
    }

    // Reports whether types are same.
    fn Equals(&self, other: &TypeKind): bool {
        let tup = unsafe { (*(&other)).Tup() }
        if tup == nil {
            ret false
        }
        if len(self.Types) != len(tup.Types) {
            ret false
        }
        let mut i = 0
        for i < len(self.Types); i++ {
            if !self.Types[i].Equals(tup.Types[i]) {
                ret false
            }
        }

        ret true
    }
}

// Map type.
struct Map {
    Key: &TypeKind
    Val: &TypeKind
}

impl Kind for Map {
    // Returns map kind as string.
    fn Str(self): str {
        let mut s = "["
        s += self.Key.Str()
        s += ":"
        s += self.Val.Str()
        s += "]"
        ret s
    }

    // Reports whether types are same.
    fn Equals(&self, other: &TypeKind): bool {
        let m = unsafe { (*(&other)).Map() }
        if m == nil {
            ret false
        }
        ret self.Key.Equals(m.Key) && self.Val.Equals(m.Val)
    }
}

// Array type.
struct Arr {
    Auto: bool      // Auto-sized array.
    N:    int
    Elem: &TypeKind
}

impl Kind for Arr {
    // Returns array kind as string.
    fn Str(self): str {
        let mut s = "["
        s += conv::Itoa(self.N)
        s += "]"
        s += self.Elem.Str()
        ret s
    }

    // Reports whether types are same.
    fn Equals(&self, other: &TypeKind): bool {
        let arr = unsafe { (*(&other)).Arr() }
        if arr == nil {
            ret false
        }
        ret self.N == arr.N && self.Elem.Equals(arr.Elem)
    }
}

// Pointer type.
struct Ptr {
    Elem: &TypeKind
}

impl Kind for Ptr {
    // Returns pointer kind as string.
    fn Str(self): str {
        if self.IsUnsafe() {
            ret "*unsafe"
        }
        ret "*" + self.Elem.Str()
    }

    // Reports whether types are same.
    fn Equals(&self, other: &TypeKind): bool {
        let ptr = unsafe { (*(&other)).Ptr() }
        if ptr == nil {
            ret false
        }
        ret self.Elem.Equals(ptr.Elem)
    }
}

impl Ptr {
    // Reports whether pointer is unsafe pointer (*unsafe).
    fn IsUnsafe(self): bool { ret self.Elem == nil }
}

struct referencer {
    ident: str
    owner: any
    refs:  *[]any
}

// Checks type and builds result as kind.
// Removes kind if error occurs,
// so type is not reports true for checked state.
struct typeChecker {
    // Uses Sema for:
    //  - Push errors.
    s: &Sema

    // Uses Lookup for:
    //  - Lookup symbol tables for root specific.
    rootLookup: Lookup

    // Uses Lookup for:
    //  - Lookup symbol tables for current.
    //  - It might be change when evaluation of namespace selection or etc.
    lookup: Lookup

    // If this is not nil, appends referred ident types.
    // Also used as checker owner.
    referencer: &referencer

    // If this not nil, type dependencies will push into stack.
    refers: &ReferenceStack

    errorToken: &Token

    // This identifiers ignored and
    // appends as primitive type.
    //
    // Each dimension 2 array accepted as identifier group.
    ignoreGenerics: []&GenericDecl

    // Relevant type kinds that contains an ignored generic type.
    ignoredGenerics: *[]&TypeKind

    // This generics used as type alias for real kind.
    useGenerics: []&TypeAlias

    // Current checked type is not plain type.
    // Type is pointer, reference, slice or similar.
    notPlain: bool

    // Disallow/suppress Jule's built-in defines.
    disBuiltin: bool

    // Name selection is enabled.
    // No cpp-linked definitions, no generic type representation.
    // Only typename selection.
    //
    // If selection is a struct, returns invalid instance that only has decl field.
    selection: bool

    // See developer reference (4).
    ownerAlias: &TypeAlias

    // This generics are banned because of causes instantiation cycles.
    // Usually stores structure generics and method generics.
    // See developer reference (5).
    bannedGenerics: []&TypeAlias

    // Enable/Disable status of instantiation catching.
    // See developer reference (6).
    inscatch: bool
}

impl typeChecker {
    fn pushErr(mut self, token: &Token, fmt: LogMsg, args: ...any) {
        self.s.pushErr(token, fmt, args...)
    }

    fn allowBuiltin(mut self) {
        self.disBuiltin = false
    }

    fn disallowBuiltin(mut self) {
        self.disBuiltin = true
    }

    fn buildPrim(mut self, &decl: &IdentTypeDecl): &Prim {
        if !isPrim(decl.Ident) {
            self.pushErr(self.errorToken, LogMsg.InvalidType)
            ret nil
        }

        if len(decl.Generics) > 0 {
            self.pushErr(decl.Token, LogMsg.TypeNotSupportsGenerics, decl.Ident)
            ret nil
        }

        ret buildPrimType(decl.Ident)
    }

    fn pushReference[T](mut self, mut &t: T) {
        if self.refers == nil {
            ret
        }
        if self.refers.Exist[T](t) {
            ret
        }
        self.refers.Push(t)
    }

    fn pushReferenceByKind(mut self, mut &k: &TypeKind) {
        match {
        | k.Struct() != nil:
            let mut t = k.Struct()
            self.pushReference[&StructIns](t)
        | k.Trait() != nil:
            let mut t = k.Trait()
            self.pushReference[&Trait](t)
        }
    }

    fn pushCycleError(self, def1: any, def2: any, mut &message: str) {
        const Padding = 4
        let getIdent = fn(&def: any): str {
            match type def {
            | &TypeAlias:
                ret (&TypeAlias)(def).Ident
            | &Struct:
                ret (&Struct)(def).Ident
            |:
                ret ""
            }
        }
        let def1Ident = getIdent(def1)
        let def2Ident = getIdent(def2)
        let refersTo = Logf(LogMsg.RefersTo, def1Ident, def2Ident)
        message = strings::Repeat(" ", Padding) + refersTo + "\n" + message
    }

    fn checkCrossCycle(self, decl: any, mut &message: str): bool {
        match type decl {
        | &TypeAlias:
            let ta = (&TypeAlias)(decl)
            for _, d in ta.Refers {
                match {
                | self.referencer.owner == d:
                    self.pushCycleError(ta, d, message)
                    ret false
                | !self.checkCrossCycle(d, message):
                    self.pushCycleError(ta, d, message)
                    ret false
                }
            }
        | &Struct:
            let s = (&Struct)(decl)
            for _, d in s.Depends {
                match {
                | self.referencer.owner == d:
                    self.pushCycleError(s, d, message)
                    ret false
                | !self.checkCrossCycle(d, message):
                    self.pushCycleError(s, d, message)
                    ret false
                }
            }
        }
        ret true
    }

    // Checks type alias illegal cycles.
    // Appends reference to reference if there is no illegal cycle.
    // Returns true if self.referencer is nil reference.
    // Returns true if refers is nil.
    fn checkIllegalCycles(mut self, &ident: &IdentTypeDecl, mut decl: any): (ok: bool) {
        if self.referencer == nil {
            ret true
        }

        match type decl {
        | &Struct:
            if self.notPlain || (&Struct)(decl).CppLinked {
                ret true
            }
        | &TypeAlias:
            if (&TypeAlias)(decl).CppLinked {
                ret true
            }
        }

        // Check illegal cycle for itself.
        // Because refers's owner is decl.
        if self.referencer.owner == decl {
            self.pushErr(ident.Token, LogMsg.IllegalCycleRefersItself, self.referencer.ident)
            ret false
        }

        let mut message = ""

        if !self.checkCrossCycle(decl, message) {
            let mut errMsg = message
            message = ""
            self.pushCycleError(self.referencer.owner, decl, message)
            errMsg += message
            self.pushErr(ident.Token, LogMsg.IllegalCrossCycle, errMsg)
            ret false
        }

        match type self.referencer.owner {
        | &TypeAlias:
            unsafe {
                *self.referencer.refs = append(*self.referencer.refs, decl)
            }
        | &Struct:
            match type decl {
            | &Struct:
                let mut s = (&Struct)(self.referencer.owner)
                s.Depends = append(s.Depends, (&Struct)(decl))
            }
        }

        ret true
    }

    fn fromTypeAlias(mut self, &decl: &IdentTypeDecl, mut &ta: &TypeAlias): Kind {
        if !self.s.isAccessibleDefine(ta.Public, ta.Token) {
            self.pushErr(decl.Token, LogMsg.IdentNotExist, decl.Ident)
            ret nil
        }

        ta.Used = true

        if len(decl.Generics) > 0 {
            self.pushErr(decl.Token, LogMsg.TypeNotSupportsGenerics, decl.Ident)
            ret nil
        }

        // Enable instantiation cycle catching if type alias is
        // one of the banned generics.
        if !self.inscatch && self.bannedGenerics != nil {
            self.inscatch = true
            for _, bg in self.bannedGenerics {
                if bg == ta || ta.Kind.Kind != nil && ta.Kind.Kind.Equals(bg.Kind.Kind) {
                    self.inscatch = false
                    break
                }
            }
        }

        // Catch instantiation cycles.
        // See developer reference (5).
        if self.inscatch {
            for _, bg in self.bannedGenerics {
                if bg == ta {
                    self.pushErr(decl.Token, LogMsg.InitiationCycle, decl.Ident)
                    ret nil
                }
                for _, dg in ta.Generics {
                    if bg == dg {
                        self.pushErr(decl.Token, LogMsg.InitiationCycle, decl.Ident)
                        ret nil
                    }
                }
            }
        }

        let mut ok = self.checkIllegalCycles(decl, ta)
        if !ok {
            ret nil
        }

        // Build kind if not builded already.
        ok = self.s.checkTypeAliasDeclKind(ta, self.lookup)
        if !ok {
            ret nil
        }

        // Push generic reference to owner type alias.
        // See developer reference (3) and (4) for more information.
        if ta.Generic && self.ownerAlias != nil {
            self.ownerAlias.Generics = append(self.ownerAlias.Generics, ta)
        }

        let mut tk = &TypeKind{
            Generic: ta.Generic,
            Kind: ta.Kind.Kind.Kind,
        }
        self.pushReferenceByKind(tk)
        if ta.CppLinked {
            tk.CppIdent = ta.Ident
        } else {
            tk.CppIdent = ta.Kind.Kind.CppIdent
        }
        ret tk
    }

    fn fromEnum(mut self, &decl: &IdentTypeDecl, mut &e: &Enum): &Enum {
        if !self.s.isAccessibleDefine(e.Public, e.Token) {
            self.pushErr(decl.Token, LogMsg.IdentNotExist, decl.Ident)
            ret nil
        }
        if len(decl.Generics) > 0 {
            self.pushErr(decl.Token, LogMsg.TypeNotSupportsGenerics, decl.Ident)
            ret nil
        }
        ret e
    }

    fn fromTypeEnum(mut self, &decl: &IdentTypeDecl, mut &e: &TypeEnum): &TypeEnum {
        if !self.s.isAccessibleDefine(e.Public, e.Token) {
            self.pushErr(decl.Token, LogMsg.IdentNotExist, decl.Ident)
            ret nil
        }
        if len(decl.Generics) > 0 {
            self.pushErr(decl.Token, LogMsg.TypeNotSupportsGenerics, decl.Ident)
            ret nil
        }
        ret e
    }

    fn fromTrait(mut self, &decl: &IdentTypeDecl, mut &t: &Trait): &Trait {
        if !self.s.isAccessibleDefine(t.Public, t.Token) {
            self.pushErr(decl.Token, LogMsg.IdentNotExist, decl.Ident)
            ret nil
        }
        if len(decl.Generics) > 0 {
            self.pushErr(decl.Token, LogMsg.TypeNotSupportsGenerics, decl.Ident)
            ret nil
        }
        self.pushReference[&Trait](t)
        ret t
    }

    fn checkStructIns(mut self, mut &ins: &StructIns, mut &errorToken: &Token): (ok: bool) {
        if ins.Checked {
            ret true
        }
        ins.Checked = true

        // Break algorithm cycle.
        if self.referencer != nil && self.referencer.owner == ins.Decl {
            ret true
        }

        if !self.s.precheckStructIns(ins, errorToken) {
            ret false
        }
        if len(ins.Generics) > 0 {
            self.s.checkStructInsOperators(ins)
            self.s.checkStructIns(ins)
        }
        ret true
    }

    fn appendUsedStructReference(mut self, mut &s: &Struct) {
        if self.referencer == nil {
            ret
        }
        match type self.referencer.owner {
        | &Struct:
            let mut refS = (&Struct)(self.referencer.owner)
            if !refS.IsUses(s) {
                refS.Uses = append(refS.Uses, s)
            }
        }
    }

    fn buildStructInstance(mut self, mut &decl: &IdentTypeDecl, mut &s: &Struct): &StructIns {
        // Save configuration.
        let mut referencer = self.referencer
        self.referencer = nil
        let mut bannedGenerics = self.bannedGenerics

        // Set banned generics to catch initiation cycles.
        // This just necessary for root, therefore avoid set each time.
        if self.bannedGenerics == nil {
            match type self.lookup {
            | &scopeChecker:
                let mut sc = (&scopeChecker)(self.lookup)
                let mut hard = sc.getHardRoot()
                if hard.owner.Owner == nil || hard.owner.Owner.Decl != s {
                    break
                }
                let n = len(hard.owner.Generics) + len(hard.owner.Owner.Generics)
                // Add scope generics to to catch instantiation cycles.
                // See developer reference (5).
                self.bannedGenerics = hard.table.TypeAliases[:n]
            }
        } else {
            self.inscatch = true
        }

        // Use rootLookup to parse generics with current current.
        let mut lookup = self.lookup
        self.lookup = self.rootLookup

        // Build generics.
        let mut ins = s.instance()
        ins.Generics = make([]&InsGeneric, 0, len(decl.Generics))
        for (_, mut g) in decl.Generics {
            let mut kind = self.build(g.Kind)
            if kind == nil {
                ret nil
            }
            ins.Generics = append(ins.Generics, &InsGeneric{Kind: kind})
        }

        // Restore configuration.
        self.lookup = lookup
        self.bannedGenerics = bannedGenerics
        self.referencer = referencer

        ret ins
    }

    fn fromStruct(mut self, mut &decl: &IdentTypeDecl, mut &s: &Struct): &StructIns {
        if !self.s.isAccessibleDefine(s.Public, s.Token) {
            self.pushErr(decl.Token, LogMsg.IdentNotExist, decl.Ident)
            ret nil
        }

        // Name selection.
        // Return instance instantly.
        if self.selection {
            if len(decl.Generics) > 0 {
                self.pushErr(decl.Token, LogMsg.GenericsNotAllowed)
                ret nil
            }
            ret &StructIns{
                Decl: s,
            }
        }

        let mut ok = self.notPlain || self.checkIllegalCycles(decl, s)
        if !ok {
            ret nil
        }
        self.appendUsedStructReference(s)

        let mut ins = self.buildStructInstance(decl, s)
        if ins == nil {
            ret nil
        }

        ok = self.s.checkGenericQuantity(len(ins.Decl.Generics), len(ins.Generics), decl.Token)
        if !ok {
            ret nil
        }

        let mut existInstance = s.appendInstance(ins)
        if existInstance != nil {
            if !self.s.checkConstraintsStruct(ins, decl.Token, existInstance) {
                ret nil
            }
            // Already checked instance, did not appended.
            // So, this instance is not unique.
            self.pushReference[&StructIns](existInstance)
            ret existInstance
        }
        if !self.checkStructIns(ins, decl.Token) {
            ret nil
        }
        self.pushReference[&StructIns](ins)
        ret ins
    }

    // Returns identifier if found. Also checks founded identifier.
    // Uses internal lookup for all process except finding step of identifier.
    // Will find identifier in [l], not internal lookup.
    // Also finds in built-in lookup if allowed.
    // If another lookup nedeed, uses internal lookup, so any generic type build
    // process will use internal lookup. This might be useful for building
    // genericed type from another package.
    fn getDef(mut self, mut &decl: &IdentTypeDecl): Kind {
        for _, g in self.ignoreGenerics {
            if g.Ident == decl.Ident {
                ret buildPrimType(g.Ident)
            }
        }

        for (_, mut g) in self.useGenerics {
            if g.Ident == decl.Ident {
                if len(decl.Generics) > 0 {
                    self.pushErr(decl.Token, LogMsg.TypeNotSupportsGenerics, decl.Ident)
                    ret nil
                }
                let mut st = g.Kind.Kind.Struct()
                if st != nil {
                    let ok = self.checkIllegalCycles(decl, st.Decl)
                    if !ok {
                        ret nil
                    }
                }
                ret g.Kind.Kind.Kind
            }
        }

        if !decl.CppLinked {
            let mut e = self.lookup.FindEnum(decl.Ident)
            if e != nil {
                ret self.fromEnum(decl, e)
            }

            let mut te = self.lookup.FindTypeEnum(decl.Ident)
            if te != nil {
                ret self.fromTypeEnum(decl, te)
            }

            let mut t = self.lookup.FindTrait(decl.Ident)
            if t != nil {
                ret self.fromTrait(decl, t)
            }
        } else if self.selection {
            self.pushErr(decl.Token, LogMsg.CppLinkedTypeNotAllowed)
            ret nil
        }

        let mut s = self.lookup.FindStruct(decl.Ident, decl.CppLinked)
        if s != nil {
            ret self.fromStruct(decl, s)
        }

        let mut ta = self.lookup.FindTypeAlias(decl.Ident, decl.CppLinked)
        if ta == nil && !self.disBuiltin {
            ta = findBuiltinTypeAlias(decl.Ident)
        }
        if ta != nil {
            ret self.fromTypeAlias(decl, ta)
        }

        self.pushErr(decl.Token, LogMsg.IdentNotExist, decl.Ident)
        ret nil
    }

    fn buildIdent(mut self, mut decl: &IdentTypeDecl): Kind {
        match {
        | isPrim(decl.Ident):
            ret self.buildPrim(decl)
        |:
            ret self.getDef(decl)
        }
    }

    fn buildSubIdent(mut self, mut decl: &SubIdentTypeDecl): Kind {
        let mut ident = self.buildIdent(decl.Idents[0])
        if ident == nil {
            ret nil
        }
        match type ident {
        | &TypeEnum:
            break
        |:
            self.pushErr(self.errorToken, LogMsg.InvalidSyntax)
            ret nil
        }
        let mut t = (&TypeEnum)(ident)
        let mut idents = decl.Idents[1:]
        for i, id in idents {
            let mut item = t.FindItem(id.Ident)
            if item == nil {
                self.pushErr(id.Token, LogMsg.ObjHaveNotIdent, t.Ident, id.Ident)
                ret nil
            }
            if len(idents)-i == 1 {
                self.pushReferenceByKind(item.Kind.Kind)
                ret item.Kind.Kind
            }
            t = item.Kind.Kind.TypeEnum()
            if t == nil {
                self.pushErr(self.errorToken, LogMsg.InvalidSyntax)
                ret nil
            }
        }
        // Should be unreachable.
        ret nil
    }

    fn buildSptrFromType(mut self, mut &elem: &TypeKind): &Sptr {
        // Check special cases.
        match {
        | elem == nil:
            ret nil
        | elem.Struct() != nil:
            let s = elem.Struct()
            if s.Decl != nil && s.Decl.CppLinked {
                self.pushErr(self.errorToken, LogMsg.CppLinkedStructForRef)
                ret nil
            }
        | elem.Arr() != nil && elem.Arr().Auto:
            self.pushErr(self.errorToken, LogMsg.ArrayAutoSized)
            ret nil
        }
        ret &Sptr{
            Elem: elem,
        }
    }

    fn buildSptr(mut self, mut decl: &SptrTypeDecl): &Sptr {
        let notPlain = self.notPlain
        self.notPlain = true
        defer { self.notPlain = notPlain }

        let mut elem = self.checkDecl(decl.Elem)
        ret self.buildSptrFromType(elem)
    }

    fn buildPtrFromType(mut self, mut &elem: &TypeKind): &Ptr {
        // Check special cases.
        match {
        | elem == nil:
            ret nil
        | elem.Arr() != nil && elem.Arr().Auto:
            self.pushErr(self.errorToken, LogMsg.ArrayAutoSized)
            ret new(Ptr)
        }

        ret &Ptr{
            Elem: elem,
        }
    }

    fn buildPtr(mut self, mut decl: &PtrTypeDecl): &Ptr {
        let notPlain = self.notPlain
        self.notPlain = true
        defer { self.notPlain = notPlain }

        let mut elem: &TypeKind = nil

        if !decl.IsUnsafe() {
            elem = self.checkDecl(decl.Elem)
            ret self.buildPtrFromType(elem)
        }

        ret &Ptr{
            Elem: elem,
        }
    }

    fn buildSlc(mut self, mut decl: &SlcTypeDecl): &Slc {
        let notPlain = self.notPlain
        self.notPlain = true
        defer { self.notPlain = notPlain }

        let mut elem = self.checkDecl(decl.Elem)

        // Check special cases.
        match {
        | elem == nil:
            ret nil
        | elem.Arr() != nil && elem.Arr().Auto:
            self.pushErr(decl.Elem.Token, LogMsg.ArrayAutoSized)
            ret nil
        }

        ret &Slc{
            Elem: elem,
        }
    }

    fn buildArr(mut self, mut decl: &ArrTypeDecl): &Arr {
        let notPlain = self.notPlain
        self.notPlain = true
        defer { self.notPlain = notPlain }

        let mut n = 0

        if !decl.AutoSized() {
            let mut size = self.s.eval(self.lookup).evalExpr(decl.Size)
            if size == nil {
                ret nil
            }

            if !size.IsConst() {
                self.pushErr(decl.Size.Token, LogMsg.ExprNotConst)
                ret nil
            } else if size.Kind.Prim() == nil || !types::IsInt(size.Kind.Prim().Kind) {
                self.pushErr(decl.Size.Token, LogMsg.ArraySizeIsNotInt)
                ret nil
            }

            n = int(size.Constant.AsI64())
            if n < 0 {
                self.pushErr(decl.Elem.Token, LogMsg.ArraySizeIsNeg)
                ret nil
            } else if types::BitSize != 64 && f64(n) > types::Max(PrimKind.Int) {
                self.pushErr(decl.Size.Token, LogMsg.OverflowLimits)
                ret nil
            }
        }

        let mut elem = self.checkDecl(decl.Elem)

        // Check special cases.
        match {
        | elem == nil:
            ret nil
        | elem.Arr() != nil && elem.Arr().Auto:
            self.pushErr(decl.Elem.Token, LogMsg.ArrayAutoSized)
            ret nil
        }

        ret &Arr{
            Auto: decl.AutoSized(),
            N: n,
            Elem: elem,
        }
    }

    fn buildMap(mut self, mut decl: &MapTypeDecl): &Map {
        let notPlain = self.notPlain
        self.notPlain = true
        defer { self.notPlain = notPlain }

        let mut key = self.checkDecl(decl.Key)
        if key == nil {
            ret nil
        }

        let mut val = self.checkDecl(decl.Val)
        if val == nil {
            ret nil
        }
        if val.Enum() != nil {
            self.pushErr(decl.Val.Token, LogMsg.EnumAsMapVal)
        }

        ret &Map{
            Key: key,
            Val: val,
        }
    }

    fn buildTuple(mut self, mut decl: &TupleTypeDecl): &Tuple {
        let mut types = make([]&TypeKind, 0, len(decl.Types))
        for (_, mut t) in decl.Types {
            let mut kind = self.checkDecl(t)
            if kind == nil {
                ret nil
            }
            types = append(types, kind)
        }

        ret &Tuple{Types: types}
    }

    fn checkFnTypes(mut self, mut &f: &FnIns): (ok: bool) {
        for (_, mut p) in f.Params {
            p.Kind = self.build(p.Decl.Kind.Decl.Kind)
            ok = p.Kind != nil
            if !ok {
                ret false
            }
            self.s.checkFnParamKind(p)
        }

        if !f.Decl.IsVoid() {
            f.Result = self.build(f.Decl.Result.Kind.Decl.Kind)
            ret f.Result != nil
        }

        ret true
    }

    fn buildFn(mut self, mut decl: &FnDecl): &FnIns {
        if len(decl.Generics) > 0 {
            self.pushErr(decl.Token, LogMsg.GenericedFnAsAnonFn)
            ret nil
        }

        let mut f = buildFn(decl)

        let n = len(self.s.errors)
        self.s.checkFnDecl(f)
        if n != len(self.s.errors) {
            ret nil
        }

        let mut ins = f.instanceForce()
        ins.Anon = true

        let ok = self.checkFnTypes(ins)
        if !ok {
            ret nil
        }

        ret ins
    }

    fn buildByNamespace(mut self, mut decl: &NamespaceTypeDecl): Kind {
        let path = buildLinkPathByTokens(decl.Idents)
        let mut imp = self.lookup.SelectPackage(fn(imp: &ImportInfo): bool {
            if len(decl.Idents) == 1 && imp.Alias == path {
                ret true
            }
            ret imp.LinkPath == path && imp.isAccessibleViaSelection()
        })

        if imp == nil || !imp.isLookupable(TokenKind.Self) {
            self.pushErr(decl.Idents[0], LogMsg.NamespaceNotExist, path)
            ret nil
        }

        self.disallowBuiltin()
        let mut lookup = self.lookup
        self.lookup = imp
        let mut kind = self.checkDecl(decl.Kind)
        self.lookup = lookup
        self.allowBuiltin()
        ret kind
    }

    fn build(mut self, mut &declKind: TypeDeclKind): &TypeKind {
        let mut kind: Kind = nil
        match type declKind {
        | &IdentTypeDecl:
            let mut t = self.buildIdent((&IdentTypeDecl)(declKind))
            if t != nil {
                kind = t
            }
        | &SubIdentTypeDecl:
            let mut t = self.buildSubIdent((&SubIdentTypeDecl)(declKind))
            if t != nil {
                kind = t
            }
        | &SptrTypeDecl:
            self.inscatch = true
            let mut t = self.buildSptr((&SptrTypeDecl)(declKind))
            if t != nil {
                kind = t
            }
        | &PtrTypeDecl:
            self.inscatch = true
            let mut t = self.buildPtr((&PtrTypeDecl)(declKind))
            if t != nil {
                kind = t
            }
        | &SlcTypeDecl:
            self.inscatch = true
            let mut t = self.buildSlc((&SlcTypeDecl)(declKind))
            if t != nil {
                kind = t
            }
        | &ArrTypeDecl:
            self.inscatch = true
            let mut t = self.buildArr((&ArrTypeDecl)(declKind))
            if t != nil {
                kind = t
            }
        | &MapTypeDecl:
            self.inscatch = true
            let mut t = self.buildMap((&MapTypeDecl)(declKind))
            if t != nil {
                kind = t
            }
        | &TupleTypeDecl:
            self.inscatch = true
            let mut t = self.buildTuple((&TupleTypeDecl)(declKind))
            if t != nil {
                kind = t
            }
        | &FnDecl:
            self.inscatch = true
            let mut t = self.buildFn((&FnDecl)(declKind))
            if t != nil {
                kind = t
            }
        | &NamespaceTypeDecl:
            self.inscatch = true
            let mut t = self.buildByNamespace((&NamespaceTypeDecl)(declKind))
            if t != nil {
                kind = t
            }
        |:
            self.pushErr(self.errorToken, LogMsg.InvalidType)
            ret nil
        }
        if kind == nil {
            ret nil
        }
        match type kind {
        | &TypeKind:
            ret (&TypeKind)(kind)
        | &Prim:
            let mut tk = &TypeKind{Kind: kind}
            if self.ignoredGenerics != nil {
                unsafe { *self.ignoredGenerics = append(*self.ignoredGenerics, tk) }
            }
            ret tk
        |:
            ret &TypeKind{Kind: kind}
        }
    }

    fn checkDecl(mut self, mut &decl: &TypeDecl): &TypeKind {
        // Save current token.
        let mut errorToken = self.errorToken

        self.errorToken = decl.Token
        let mut kind = self.build(decl.Kind)
        self.errorToken = errorToken

        ret kind
    }

    fn check(mut self, mut &t: &TypeSymbol) {
        if t.Decl == nil {
            ret
        }
        let mut kind = self.checkDecl(t.Decl)
        if kind == nil {
            t.removeKind()
            ret
        }
        t.Kind = kind
    }
}

struct identTypeLookup {}

impl identTypeLookup {
    static fn prim(&ident: str, t: &Prim): bool {
        ret t.Kind == ident
    }

    static fn exist(&ident: str, mut &k: &TypeKind): bool {
        match {
        | k.Prim() != nil:
            ret identTypeLookup.prim(ident, k.Prim())
        | k.Sptr() != nil:
            let mut sptr = k.Sptr()
            ret identTypeLookup.exist(ident, sptr.Elem)
        | k.Ptr() != nil:
            let mut ptr = k.Ptr()
            ret identTypeLookup.exist(ident, ptr.Elem)
        | k.Slc() != nil:
            let mut slc = k.Slc()
            ret identTypeLookup.exist(ident, slc.Elem)
        | k.Arr() != nil:
            let mut arr = k.Arr()
            ret identTypeLookup.exist(ident, arr.Elem)
        | k.Map() != nil:
            let mut m = k.Map()
            ret identTypeLookup.exist(ident, m.Key) ||
                identTypeLookup.exist(ident, m.Val)
        | k.Struct() != nil:
            let mut s = k.Struct()
            for (_, mut g) in s.Generics {
                if identTypeLookup.exist(ident, g.Kind) {
                    ret true
                }
            }
            ret false
        | k.Fn() != nil:
            let mut f = k.Fn()
            for (_, mut p) in f.Params {
                if p.Decl.IsSelf() {
                    continue
                }
                if identTypeLookup.exist(ident, p.Kind) {
                    ret true
                }
            }
            if f.Result != nil {
                ret identTypeLookup.exist(ident, f.Result)
            }
            ret false
        | k.Tup() != nil:
            let mut tup = k.Tup()
            for (_, mut t) in tup.Types {
                if identTypeLookup.exist(ident, t) {
                    ret true
                }
            }
            ret false
        |:
            ret false
        }
    }
}

fn kindUsesGenerics(mut &k: &TypeKind, &generics: []&GenericDecl): bool {
    for _, g in generics {
        if identTypeLookup.exist(g.Ident, k) {
            ret true
        }
    }
    ret false
}

// Reports whether directive is exist.
fn hasDirective(mut &directives: []&ast::Directive, tag: str): bool {
    for (_, mut dr) in directives {
        if dr.Tag.Kind == tag {
            ret true
        }
    }
    ret false
}

fn canGetPtr(mut &d: &Data): bool {
    if !d.Lvalue || d.IsConst() {
        ret false
    }
    match {
    | d.Kind.Fn() != nil || d.Kind.Enum() != nil:
        ret false
    |:
        ret true
    }
}

// Reports kind is valid for smart pointer type such as &T.
fn isValidForSptrType(mut &t: &TypeKind): bool {
    let mut s = t.Struct()
    if s != nil && s.Decl != nil && s.Decl.CppLinked {
        ret false
    }
    ret true
}

// Reports kind is valid for reference such as reference variables.
fn isValidForRef(mut &t: &TypeKind): bool { ret t.Fn() == nil }

// Reports whether type has built-in string conversion support.
fn isBuiltinStrConvertable(mut &t: &TypeKind): bool {
    ret !t.Void() && t.Fn() == nil && t.Tup() == nil
}

fn buildLinkPathByTokens(&tokens: []&Token): str {
    let mut s = tokens[0].Kind
    for _, token in tokens[1:] {
        s += "::"
        s += token.Kind
    }
    ret s
}

fn buildPrimType(kind: str): &Prim {
    ret &Prim{
        Kind: kind,
    }
}

fn getStructFromKind(mut k: &TypeKind): &Struct {
    match {
    | k == nil:
        ret nil
    | k.Struct() != nil:
        ret k.Struct().Decl
    | k.Sptr() != nil:
        ret getStructFromKind(k.Sptr().Elem)
    | k.Slc() != nil:
        ret getStructFromKind(k.Slc().Elem)
    | k.Arr() != nil:
        ret getStructFromKind(k.Arr().Elem)
    | k.Ptr() != nil:
        // Pass pointers.
        // Cloning just copies pointer address.
        // There is no any illegal cycle risk.
        ret nil
    |:
        ret nil
    }
}

// Reports whether kind is primitive type.
fn isPrim(kind: str): bool {
    ret kind == TokenKind.I8 ||
        kind == TokenKind.I16 ||
        kind == TokenKind.I32 ||
        kind == TokenKind.I64 ||
        kind == TokenKind.U8 ||
        kind == TokenKind.U16 ||
        kind == TokenKind.U32 ||
        kind == TokenKind.U64 ||
        kind == TokenKind.F32 ||
        kind == TokenKind.F64 ||
        kind == TokenKind.Int ||
        kind == TokenKind.Uint ||
        kind == TokenKind.Uintptr ||
        kind == TokenKind.Bool ||
        kind == TokenKind.Str ||
        kind == TokenKind.Any
}

fn applyImplicitCast(mut &dest: &TypeKind, mut &d: &Data) {
    if d.Kind.IsNil() {
        ret
    }
    let destPrim = dest.Prim()
    let prim = d.Kind.Prim()
    if destPrim != nil {
        if destPrim.IsAny() {
            if prim == nil || !prim.IsAny() {
                applyCastKind(d, dest)
            }
            ret
        }
        if !d.Kind.CppLinked() &&
            !d.Kind.Variadic &&
            !d.Lvalue &&
            !d.IsConst() &&
            prim != nil &&
            types::IsNum(prim.Kind) {
            applyCastKind(d, dest)
        }
        ret
    }

    if dest.Trait() != nil && d.Kind.Trait() == nil {
        applyCastKindModel(d, dest)
        ret
    }

    if dest.TypeEnum() != nil && d.Kind.TypeEnum() == nil {
        applyCastKindModel(d, dest)
        ret
    }
}
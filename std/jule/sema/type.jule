// Copyright 2023-2025 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

// This file reserved for types, type kinds and type build algorithms.
// This file haven't type compatibility checking algorithm or something else.

use "std/conv"
use "std/jule/ast"
use "std/jule/build"
use "std/jule/token"
use "std/jule/types"
use "std/strings"

// Generic type for instance types.
struct InsGeneric {
	Type:       &Type
	Constraint: []&Type
}

// Type alias.
struct TypeAlias {
	Scope:    &ast::ScopeTree
	Strict:   bool
	Public:   bool
	Binded:   bool
	Used:     bool
	Generic:  bool
	Token:    &token::Token
	Ident:    str
	TypeSym:  &TypeSym
	Generics: []&TypeAlias // See developer reference (1).
}

// Kind of type declaration.
trait Kind {
	fn Str(self): str
	fn Equal(&self, other: &Type): bool
}

// Evaluated type declaration.
struct Type {
	Generic:  bool
	Variadic: bool
	Kind:     Kind
}

impl Kind for Type {
	// Returns kind as string.
	fn Str(self): str {
		if self.IsNil() {
			ret "nil"
		}

		mut kind := strings::Builder{}
		kind.Grow(1 << 4)

		if self.Variadic {
			kind.WriteStr("...")!
		}
		kind.WriteStr(self.Kind.Str())!
		ret kind.Str()
	}

	// Reports whether types are same.
	fn Equal(&self, other: &Type): bool {
		if self.IsNil() {
			ret other.IsNil()
		}
		ret self.Kind.Equal(other)
	}
}

impl Type {
	// Reports whether type is binded kind.
	fn Binded(self): bool {
		s, ok := self.Kind.(&StructIns)
		if ok {
			if s.Decl.Binded {
				ret true
			}
			if s.Source != nil {
				ret s.Source.Binded()
			}
		}
		ret false
	}

	// Reports whether kind is "nil".
	fn IsNil(self): bool { ret self.Kind == nil }

	// Reports whether actual kind is "void".
	fn Void(self): bool {
		prim := unsafe { (*(&self)).Prim() }
		ret prim != nil && prim.Kind == "void"
	}

	// Returns actual kind of the type, so returns the root type.
	// If kind is a struct, which is implemented by the type statement,
	// see developer reference (9) for details, returns the actual kind of
	// the source type of the struct.
	fn ActualKind(mut self): Kind {
		mut s, ok := self.Kind.(&StructIns)
		if ok && s.Source != nil {
			ret s.Source.ActualKind()
		}
		ret self.Kind
	}

	// Reports whether actual kinds are equal.
	fn ActualEqual(&self, other: &Type): bool {
		if self.IsNil() {
			ret other.IsNil()
		}
		if self.Binded() || other.Binded() {
			ret self.Equal(other)
		}
		l := unsafe { (*(&self)).ActualKind() }
		r := unsafe { (*(&other)).ActualKind() }
		lt := Type{Kind: l}
		rt := Type{Kind: r}
		ret (unsafe { (&Type)(&lt) }).Equal(unsafe { (&Type)(&rt) })
	}

	// Same as the ActualEqual, but ignores the binded types.
	fn deepActualEqual(&self, other: &Type): bool {
		if self.IsNil() {
			ret other.IsNil()
		}
		l := unsafe { (*(&self)).ActualKind() }
		r := unsafe { (*(&other)).ActualKind() }
		lt := Type{Kind: l}
		rt := Type{Kind: r}
		ret (unsafe { (&Type)(&lt) }).Equal(unsafe { (&Type)(&rt) })
	}

	// Reports whether actual kind is comparable.
	fn Comparable(self): bool {
		unsafe {
			mut _self := &self
			if _self.SoftStruct() != nil {
				ret _self.SoftStruct().Comparable
			}
			if _self.Array() != nil {
				ret _self.Array().Elem.Comparable()
			}
			ret _self.Map() == nil && _self.Slice() == nil && _self.Func() == nil
		}
	}

	// Reports whether actual kind is mutable.
	fn Mutable(self): bool {
		unsafe {
			mut _self := &self
			if _self.SoftStruct() != nil {
				ret _self.SoftStruct().Mutable
			}
			if _self.Chan() != nil {
				ret _self.Chan().Elem.Mutable()
			}
			if _self.Trait() != nil || _self.TypeEnum() != nil {
				ret true
			}
			if _self.Prim() != nil {
				p := _self.Prim()
				ret p.IsAny()
			}
			if _self.Array() != nil {
				ret _self.Array().Elem.Mutable()
			}
			if _self.Map() != nil {
				m := _self.Map()
				ret m.Key.Mutable() || m.Val.Mutable()
			}
			ret _self.Slice() != nil ||
				_self.Ptr() != nil ||
				_self.Sptr() != nil
		}
	}

	// Reports whether actual kind supports ordered constraint.
	fn Ordered(self): bool {
		unsafe {
			mut _self := &self
			prim := _self.Prim()
			if prim != nil {
				ret types::IsNum(prim.Kind) || prim.IsStr()
			}
			if _self.Ptr() != nil {
				ret true
			}
			mut enm := _self.Enum()
			if enm != nil {
				ret types::IsNum(enm.TypeSym.Type.Prim().Str())
			}
			ret false
		}
	}

	// Reports whether actual kind is nil compatible.
	fn NilCompatible(self): bool {
		unsafe {
			mut _self := &self

			prim := _self.Prim()
			if prim != nil && prim.IsAny() {
				ret true
			}

			ret _self.IsNil() ||
				_self.Func() != nil ||
				_self.Sptr() != nil ||
				_self.Ptr() != nil ||
				_self.Trait() != nil ||
				_self.Slice() != nil ||
				_self.Map() != nil ||
				_self.TypeEnum() != nil ||
				_self.Chan() != nil
		}
	}

	// Reports whether actual kind performs garbage collection.
	fn GC(self): bool {
		unsafe {
			mut _self := &self
			prim := _self.Prim()
			if prim != nil {
				ret prim.IsAny() || prim.IsStr()
			}
			ret _self.Sptr() != nil || _self.Slice() != nil || _self.Trait() != nil ||
				_self.TypeEnum() != nil || _self.Chan() != nil
		}
	}

	// Reports whether actual kind is variadicable.
	fn Variadicable(self): bool {
		mut _self := &self
		ret unsafe { _self.Slice() != nil }
	}

	// Returns primitive type if actual kind is primitive type, nil if not.
	fn Prim(mut self): &Prim {
		mut p, _ := self.ActualKind().(&Prim)
		ret p
	}

	// Returns channel type if actual kind is channel, nil if not.
	fn Chan(mut self): &Chan {
		mut c, _ := self.ActualKind().(&Chan)
		ret c
	}

	// Returns reference type if actual kind is smart pointer, nil if not.
	fn Sptr(mut self): &Sptr {
		mut p, _ := self.ActualKind().(&Sptr)
		ret p
	}

	// Returns pointer type if actual kind is pointer, nil if not.
	fn Ptr(mut self): &Ptr {
		mut p, _ := self.ActualKind().(&Ptr)
		ret p
	}

	// Returns enum type if actual kind is enum, nil if not.
	fn Enum(mut self): &Enum {
		mut e, _ := self.ActualKind().(&Enum)
		ret e
	}

	// Returns type enum if actual kind is type enum, nil if not.
	fn TypeEnum(mut self): &TypeEnum {
		mut e, _ := self.ActualKind().(&TypeEnum)
		ret e
	}

	// Returns array type if actual kind is array, nil if not.
	fn Array(mut self): &Array {
		mut a, _ := self.ActualKind().(&Array)
		ret a
	}

	// Returns slice type if actual kind is slice, nil if not.
	fn Slice(mut self): &Slice {
		mut s, _ := self.ActualKind().(&Slice)
		ret s
	}

	// Returns function type if actual kind is function, nil if not.
	fn Func(mut self): &FuncIns {
		mut f, _ := self.ActualKind().(&FuncIns)
		ret f
	}

	// Returns struct type if actual kind is structure, nil if not.
	fn Struct(mut self): &StructIns {
		mut s, _ := self.ActualKind().(&StructIns)
		ret s
	}

	// Returns struct type if actual kind is structure.
	// If type kind is the strict type alias source, returns the underlying
	// structure type of the strict type alias.
	fn SoftStruct(mut self): &StructIns {
		mut s, _ := self.Kind.(&StructIns)
		ret s
	}

	// Returns trait type if actual kind is trait, nil if not.
	fn Trait(mut self): &Trait {
		mut t, _ := self.ActualKind().(&Trait)
		ret t
	}

	// Returns map type if actual kind is map, nil if not.
	fn Map(mut self): &Map {
		mut m, _ := self.ActualKind().(&Map)
		ret m
	}

	// Returns tuple type if actual kind is tuple, nil if not.
	fn Tuple(mut self): &Tuple {
		mut t, _ := self.ActualKind().(&Tuple)
		ret t
	}

	// Reports whether kind is comptime type.
	// It will not check for the [comptimeRange].
	// Checks regular constant comptime expression types only.
	fn comptime(mut self): bool {
		ret self.comptimeTypeInfos() != nil ||
			self.comptimeTypeInfo() != nil ||
			self.comptimeStructFields() != nil ||
			self.comptimeStructField() != nil ||
			self.comptimeEnumFields() != nil ||
			self.comptimeEnumField() != nil ||
			self.comptimeStatics() != nil ||
			self.comptimeStatic() != nil ||
			self.comptimeParams() != nil ||
			self.comptimeParam() != nil ||
			self.comptimeValue() != nil ||
			self.comptimeFiles() != nil ||
			self.comptimeFile() != nil ||
			self.comptimeDecl() != nil ||
			self.comptimeDecls() != nil
	}

	fn comptimeStructFields(mut self): &comptimeStructFields {
		mut ct, _ := self.Kind.(&comptimeStructFields)
		ret ct
	}

	fn comptimeStructField(mut self): &comptimeStructField {
		mut ct, _ := self.Kind.(&comptimeStructField)
		ret ct
	}

	fn comptimeEnumFields(mut self): &comptimeEnumFields {
		mut ct, _ := self.Kind.(&comptimeEnumFields)
		ret ct
	}

	fn comptimeEnumField(mut self): &comptimeEnumField {
		mut ct, _ := self.Kind.(&comptimeEnumField)
		ret ct
	}

	fn comptimeParams(mut self): &comptimeParams {
		mut ct, _ := self.Kind.(&comptimeParams)
		ret ct
	}

	fn comptimeParam(mut self): &comptimeParam {
		mut ct, _ := self.Kind.(&comptimeParam)
		ret ct
	}

	fn comptimeRange(mut self): &comptimeRange {
		mut ct, _ := self.Kind.(&comptimeRange)
		ret ct
	}

	fn comptimeTypeInfos(mut self): &comptimeTypeInfos {
		mut ct, _ := self.Kind.(&comptimeTypeInfos)
		ret ct
	}

	fn comptimeTypeInfo(mut self): &comptimeTypeInfo {
		mut ct, _ := self.Kind.(&comptimeTypeInfo)
		ret ct
	}

	fn comptimeStatics(mut self): &comptimeStatics {
		mut ct, _ := self.Kind.(&comptimeStatics)
		ret ct
	}

	fn comptimeStatic(mut self): &comptimeStatic {
		mut ct, _ := self.Kind.(&comptimeStatic)
		ret ct
	}

	fn comptimeValue(mut self): &comptimeValue {
		mut ct, _ := self.Kind.(&comptimeValue)
		ret ct
	}

	fn comptimeDecl(mut self): &comptimeDecl {
		mut ct, _ := self.Kind.(&comptimeDecl)
		ret ct
	}

	fn comptimeDecls(mut self): &comptimeDecls {
		mut ct, _ := self.Kind.(&comptimeDecls)
		ret ct
	}

	fn comptimeFile(mut self): &comptimeFile {
		mut ct, _ := self.Kind.(&comptimeFile)
		ret ct
	}

	fn comptimeFiles(mut self): &comptimeFiles {
		mut ct, _ := self.Kind.(&comptimeFiles)
		ret ct
	}
}

// Type.
struct TypeSym {
	Decl: &ast::Type // Never changed by semantic analyzer.
	Type: &Type
}

impl TypeSym {
	// Reports whether type is checked already.
	fn checked(self): bool { ret self.Type != nil }

	// Removes kind and ready to check.
	// checked() reports false after this function.
	fn removeKind(mut self) { self.Type = nil }
}

// Primitive type.
struct Prim {
	Kind: str
}

impl Kind for Prim {
	// Returns kind.
	fn Str(self): str {
		ret self.Kind
	}

	// Reports whether types are same.
	fn Equal(&self, other: &Type): bool {
		p, ok := other.Kind.(&Prim)
		ret ok && self == p
	}
}

impl Prim {
	// Reports whether type is built-in constraint.
	fn IsConstraint(self): bool {
		ret !self.IsStr() &&
			!self.IsAny() &&
			!self.IsBool() &&
			!types::IsNum(self.Kind)
	}

	// Reports whether type is primitive i8.
	fn IsI8(self): bool { ret self.Kind == types::I8 }

	// Reports whether type is primitive i16.
	fn IsI16(self): bool { ret self.Kind == types::I16 }

	// Reports whether type is primitive i32.
	fn IsI32(self): bool { ret self.Kind == types::I32 }

	// Reports whether type is primitive i64.
	fn IsI64(self): bool { ret self.Kind == types::I64 }

	// Reports whether type is primitive u8.
	fn IsU8(self): bool { ret self.Kind == types::U8 }

	// Reports whether type is primitive u16.
	fn IsU16(self): bool { ret self.Kind == types::U16 }

	// Reports whether type is primitive u32.
	fn IsU32(self): bool { ret self.Kind == types::U32 }

	// Reports whether type is primitive u64.
	fn IsU64(self): bool { ret self.Kind == types::U64 }

	// Reports whether type is primitive f32.
	fn IsF32(self): bool { ret self.Kind == types::F32 }

	// Reports whether type is primitive f64.
	fn IsF64(self): bool { ret self.Kind == types::F64 }

	// Reports whether type is primitive int.
	fn IsInt(self): bool { ret self.Kind == types::Int }

	// Reports whether type is primitive uint.
	fn IsUint(self): bool { ret self.Kind == types::Uint }

	// Reports whether type is primitive uintptr.
	fn IsUintptr(self): bool { ret self.Kind == types::Uintptr }

	// Reports whether type is primitive bool.
	fn IsBool(self): bool { ret self.Kind == types::Bool }

	// Reports whether type is primitive str.
	fn IsStr(self): bool { ret self.Kind == types::Str }

	// Reports whether type is primitive any.
	fn IsAny(self): bool { ret self.Kind == types::Any }
}

// Channel type.
struct Chan {
	Recv: bool
	Send: bool
	Elem: &Type
}

impl Kind for Chan {
	// Returns smart pointer kind as string.
	fn Str(self): str {
		if self.Recv && self.Send {
			c, ok := self.Elem.Kind.(&Chan)
			if ok && c.Recv && !c.Send {
				ret "chan (" + self.Elem.Str() + ")"
			}
			ret "chan " + self.Elem.Str()
		} else if self.Recv {
			ret "<-chan " + self.Elem.Str()
		} else {
			ret "chan<- " + self.Elem.Str()
		}
	}

	// Reports whether types are same.
	fn Equal(&self, other: &Type): bool {
		c, ok := other.Kind.(&Chan)
		ret ok && self.Recv == c.Recv && self.Send == c.Send && self.Elem.Equal(c.Elem)
	}
}

// Smart pointer.
struct Sptr {
	Elem: &Type
}

impl Kind for Sptr {
	// Returns smart pointer kind as string.
	fn Str(self): str { ret "&" + self.Elem.Str() }

	// Reports whether types are same.
	fn Equal(&self, other: &Type): bool {
		p, ok := other.Kind.(&Sptr)
		ret ok && self.Elem.Equal(p.Elem)
	}
}

// Slice type.
struct Slice {
	Elem: &Type
}

impl Kind for Slice {
	// Returns slice kind as string.
	fn Str(self): str { ret "[]" + self.Elem.Str() }

	// Reports whether types are same.
	fn Equal(&self, other: &Type): bool {
		s, ok := other.Kind.(&Slice)
		ret ok && self.Elem.Equal(s.Elem)
	}
}

// Tuple type.
struct Tuple {
	Types: []&Type
}

impl Kind for Tuple {
	// Returns tuple kind as string.
	fn Str(self): str {
		mut s := strings::Builder{}
		s.Grow(1 << 4)
		s.WriteByte('(')!
		s.WriteStr(self.Types[0].Str())!
		for _, t in self.Types[1:] {
			s.WriteByte(',')!
			s.WriteStr(t.Str())!
		}
		s.WriteByte(')')!
		ret s.Str()
	}

	// Reports whether types are same.
	fn Equal(&self, other: &Type): bool {
		tup, ok := other.Kind.(&Tuple)
		if !ok || len(self.Types) != len(tup.Types) {
			ret false
		}
		mut i := 0
		for i < len(self.Types); i++ {
			if !self.Types[i].Equal(tup.Types[i]) {
				ret false
			}
		}
		ret true
	}
}

// Map type.
struct Map {
	Key: &Type
	Val: &Type
}

impl Kind for Map {
	// Returns map kind as string.
	fn Str(self): str {
		mut s := strings::Builder{}
		s.Grow(1 << 4)
		s.WriteStr("map[")!
		s.WriteStr(self.Key.Str())!
		s.WriteByte(']')!
		s.WriteStr(self.Val.Str())!
		ret s.Str()
	}

	// Reports whether types are same.
	fn Equal(&self, other: &Type): bool {
		m, ok := other.Kind.(&Map)
		ret ok && self.Key.Equal(m.Key) && self.Val.Equal(m.Val)
	}
}

// Array type.
struct Array {
	Auto: bool // Auto-sized array.
	N:    int
	Elem: &Type
}

impl Kind for Array {
	// Returns array kind as string.
	fn Str(self): str {
		mut s := strings::Builder{}
		s.Grow(1 << 4)
		s.WriteByte('[')!
		s.WriteStr(conv::Itoa(self.N))!
		s.WriteByte(']')!
		s.WriteStr(self.Elem.Str())!
		ret s.Str()
	}

	// Reports whether types are same.
	fn Equal(&self, other: &Type): bool {
		a, ok := other.Kind.(&Array)
		ret ok && self.N == a.N && self.Elem.Equal(a.Elem)
	}
}

// Pointer type.
struct Ptr {
	Elem: &Type
}

impl Kind for Ptr {
	// Returns pointer kind as string.
	fn Str(self): str {
		if self.IsUnsafe() {
			ret "*unsafe"
		}
		ret "*" + self.Elem.Str()
	}

	// Reports whether types are same.
	fn Equal(&self, other: &Type): bool {
		p, ok := other.Kind.(&Ptr)
		if !ok {
			ret false
		}
		match {
		| self.IsUnsafe():
			ret p.IsUnsafe()
		| p.IsUnsafe():
			ret self.IsUnsafe()
		|:
			ret self.Elem.Equal(p.Elem)
		}
	}
}

impl Ptr {
	// Reports whether pointer is unsafe pointer (*unsafe).
	fn IsUnsafe(self): bool { ret self.Elem == nil }
}

enum semaTypeKind: type {
	ast::TypeKind,
	&Type,
}

struct referencer {
	owner: any         // StructIns, TypeAlias.
	name:  str         // Name of the owner.
	tains: bool        // Whether owner is the TA-sensitive StructIns.
	oself: bool        // Only self references. It used to caught type alias cycles.
	prev:  &referencer // Previous referencer.
	next:  &referencer // Next referencer.
}

// Cycle state flags.
const cycleErrEnable = 0b01 // Enables error logging for cycle analysis.
const cycleErrFail = 0b10   // Means the last cycle analysis reports cycles exist.

// Type analysis tags.
// See developer reference (10).
const taNA = 0 << 0
const taNotComparable = 1 << 0
const taMutable = 1 << 1

// Checks type and builds result as kind.
// Removes kind if error occurs,
// so type is not reports true for checked state.
struct typeChecker {
	// Uses sema for:
	//	- Push errors.
	s: &sema

	// Uses Lookup for:
	//	- Lookup symbol tables for root specific.
	rootLookup: Lookup

	// Uses Lookup for:
	//	- Lookup symbol tables for current.
	//	- It might be change when evaluation of namespace selection or etc.
	lookup: Lookup

	// If this is not nil, appends referred ident types.
	// Also used as checker owner.
	referencer: &referencer

	// If this not nil, type dependencies will push into stack.
	refers: &ReferenceStack

	errorToken: &token::Token

	// This identifiers ignored and
	// appends as primitive type.
	//
	// Each dimension 2 array accepted as identifier group.
	ignoreGenerics: []&ast::Generic

	// Relevant type kinds that contains an ignored generic type.
	ignoredGenerics: *[]&Type

	// This generics used as type alias for real kind.
	useGenerics: []&TypeAlias

	cycleErr: int = cycleErrEnable

	// Disallow/suppress Jule's built-in defines.
	disBuiltin: bool

	// Name selection is enabled.
	// No binded definitions, no generic type representation.
	// Only typename selection.
	//
	// If selection is a struct, returns invalid instance that only has decl field.
	selection: bool

	// Disabled type analysis flags.
	disableTA: int
}

impl typeChecker {
	fn pushErr(mut self, token: &token::Token, fmt: build::LogMsg, args: ...any) {
		self.s.pushErr(token, fmt, args...)
	}

	fn allowBuiltin(mut self) {
		self.disBuiltin = false
	}

	fn disallowBuiltin(mut self) {
		self.disBuiltin = true
	}

	// Push type analysis flag to owner structure instance if exist.
	// See developer reference (10).
	fn pushTA(mut self, tags: int) {
		if self.referencer != nil && self.referencer.tains {
			mut s := (&StructIns)(nil)
			match type self.referencer.owner {
			| &StructIns:
				s = self.referencer.owner.(&StructIns)
			| &TypeAlias:
				s = self.referencer.owner.(&TypeAlias).TypeSym.Type.SoftStruct()
			|:
				panic("unreachable")
			}
			if self.disableTA&taNotComparable != taNotComparable {
				s.Comparable = s.Comparable && tags&taNotComparable != taNotComparable
			}
			if self.disableTA&taMutable != taMutable {
				s.Mutable = s.Mutable || tags&taMutable == taMutable
			}
		}
	}

	fn pushReference[T](mut self, mut &t: T) {
		if self.refers == nil {
			ret
		}
		if self.refers.Exist[T](t) {
			ret
		}
		self.refers.Push(t)
	}

	fn pushReferenceByKind(mut self, mut &k: &Type) {
		match {
		| k.SoftStruct() != nil:
			mut t := k.SoftStruct()
			self.pushReference[&StructIns](t)
		| k.Trait() != nil:
			mut t := k.Trait()
			self.pushReference[&Trait](t)
		}
	}

	fn pushCycleError(self, def1: str, def2: str, mut &message: strings::Builder) {
		const Padding = 7
		refersTo := build::Logf(build::LogMsg.RefersTo, def1, def2)
		message.WriteStr(strings::Repeat(" ", Padding))!
		message.WriteStr(refersTo)!
		message.WriteByte('\n')!
	}

	fn checkCrossCycle(mut self, mut decl: any, mut &message: strings::Builder): (ok: bool, oselfExist: bool) {
		// No cross risk, because referencer have not any previous node.
		// Referencer is the root referencer.
		// So, it is means there are only inline cycle possibility,
		// but it is already checked.
		if self.referencer.prev == nil {
			ret true, self.referencer.oself
		}
		mut r := self.referencer
		for r != nil && r.prev != nil; r = r.prev {
		}
		mut root := r
		printErr := fn(mut &message: strings::Builder) {
			r = root
			for r != nil && r.next != nil; r = r.next {
				unsafe { self.pushCycleError(r.name, r.next.name, message) }
			}
			unsafe { self.pushCycleError(r.name, root.name, message) }
		}
		mut oself := (&referencer)(nil)
		for r != nil; r = r.next {
			if oself != nil {
				if oself.owner == decl {
					printErr(message)
					ret false, oself != nil
				}
				continue
			}
			if r.oself {
				oself = r
			}
			if r.owner == decl {
				printErr(message)
				ret false, oself != nil
			}
		}
		ret true, oself != nil
	}

	// Returns referencer by case.
	// It may be returns nil.
	// This should be used only for safe places, when absolutely no cycles.
	fn getReferencer(mut self): &referencer {
		mut r := self.referencer
		for r != nil; r = r.prev {
			// If oself is true, return nil referencer.
			// Because there is no risk for type aliases and other things.
			// Just safe. Do not track references, no risk for cycles.
			if r.oself {
				ret nil
			}
		}
		ret self.referencer
	}

	fn checkIllegalCycles(mut self, &ident: &token::Token, mut decl: any): (ok: bool) {
		ret self.isIllegalCycleSafe(ident, decl, self.cycleErr&cycleErrEnable == cycleErrEnable)
	}

	fn isIllegalCycleSafe(mut self, &ident: &token::Token, mut decl: any, err: bool): (ok: bool) {
		self.cycleErr &= ^cycleErrFail
		if self.referencer == nil {
			ret true
		}

		match type decl {
		| &StructIns:
			s := decl.(&StructIns)
			if s.Decl != nil && s.Decl.Binded {
				ret true
			}
		| &TypeAlias:
			if decl.(&TypeAlias).Binded {
				ret true
			}
		}

		// Check illegal cycle for itself.
		{
			mut itself := false
			if self.referencer.oself {
				match type decl {
				| &TypeAlias:
					itself = self.referencer.owner == decl
				}
			} else {
				itself = self.referencer.owner == decl
			}
			if itself {
				if err {
					self.pushErr(ident, build::LogMsg.IllegalCycleRefersItself, self.referencer.name)
				}
				self.cycleErr |= cycleErrFail
				ret false
			}
		}

		mut message := strings::Builder{}
		ok, oselfExist := self.checkCrossCycle(decl, message)
		if !ok {
			if err {
				self.pushErr(ident, build::LogMsg.IllegalCrossCycle, message.Str())
			}
			self.cycleErr |= cycleErrFail
			ret false
		}

		// Append to structure depend collection if oself is not exist.
		// If oself exist, it means type is not plain.
		if !oselfExist {
			mut s, (ok) := self.referencer.owner.(&StructIns)
			if ok && s.Source == nil { // Play safe, ignore strict type alias structures.
				mut ds, (ok) := decl.(&StructIns)
				// Play safe, ignore strict type alias structures.
				if ok && ds.Source == nil && !s.Decl.depended(ds.Decl) {
					s.Decl.Depends = append(s.Decl.Depends, ds.Decl)
				}
			}
		}

		ret true
	}

	fn fromTypeAlias(mut self, mut &decl: &ast::IdentType, mut &ta: &TypeAlias): Kind {
		if !self.s.isAccessibleDefine(ta.Public, ta.Token) {
			self.pushErr(decl.Token, build::LogMsg.IdentNotExist, decl.Ident)
			ret nil
		}

		ta.Used = true

		if len(decl.Generics) > 0 {
			self.pushErr(decl.Token, build::LogMsg.TypeNotSupportsGenerics, decl.Ident)
			ret nil
		}

		{
			ok := self.checkIllegalCycles(decl.Token, ta)
			if !ok && self.cycleErr&cycleErrEnable == cycleErrEnable {
				ret nil
			}
		}

		// Build kind if not built already.
		// If this type alias is checking now, do not check again.
		if ta.TypeSym.Type == nil {
			// Use self.referencer instead of getReferencer.
			// Because we have to catch type alias cycles if exist.
			// So, do not use possible nil referencer.
			ok := self.s.checkTypeAliasDecl(ta, self.referencer, self.lookup)
			if !ok {
				ret nil
			}
		}

		if ta.Strict && self.s.step&stepFlag.ImplsImplemented == stepFlag.ImplsImplemented {
			// Check strict type structure if impl statements are implemented.
			// But do not check if source type is nil, it means type type alias is still checking.
			mut s := ta.TypeSym.Type.SoftStruct()
			if s.Source != nil && !s.Checked {
				ok := self.checkStructIns(s, decl.Token)
				if !ok {
					ret nil
				}
			}
		}

		// Push generic reference to owner type alias.
		// See developer reference (3) and (4) for more information.
		if ta.Generic && self.referencer != nil {
			mut rta, ok := self.referencer.owner.(&TypeAlias)
			if ok {
				rta.Generics = append(rta.Generics, ta)
			}
		}

		mut tk := &Type{
			Generic: ta.Generic,
			Kind: ta.TypeSym.Type.Kind,
		}
		self.pushReferenceByKind(tk)
		ret tk
	}

	fn fromEnum(mut self, &decl: &ast::IdentType, mut &e: &Enum): &Enum {
		if !self.s.isAccessibleDefine(e.Public, e.Token) {
			self.pushErr(decl.Token, build::LogMsg.IdentNotExist, decl.Ident)
			ret nil
		}
		if len(decl.Generics) > 0 {
			self.pushErr(decl.Token, build::LogMsg.TypeNotSupportsGenerics, decl.Ident)
			ret nil
		}
		ret e
	}

	fn fromTypeEnum(mut self, &decl: &ast::IdentType, mut &e: &TypeEnum): &TypeEnum {
		if !self.s.isAccessibleDefine(e.Public, e.Token) {
			self.pushErr(decl.Token, build::LogMsg.IdentNotExist, decl.Ident)
			ret nil
		}
		if len(decl.Generics) > 0 {
			self.pushErr(decl.Token, build::LogMsg.TypeNotSupportsGenerics, decl.Ident)
			ret nil
		}
		ret e
	}

	fn fromTrait(mut self, &decl: &ast::IdentType, mut &t: &Trait): &Trait {
		if !self.s.isAccessibleDefine(t.Public, t.Token) {
			self.pushErr(decl.Token, build::LogMsg.IdentNotExist, decl.Ident)
			ret nil
		}
		if len(decl.Generics) > 0 {
			self.pushErr(decl.Token, build::LogMsg.TypeNotSupportsGenerics, decl.Ident)
			ret nil
		}
		self.pushTA(taMutable)
		self.pushReference[&Trait](t)
		ret t
	}

	fn checkStructIns(mut self, mut &ins: &StructIns, mut &errorToken: &token::Token): (ok: bool) {
		if ins.Checked {
			ret true
		}
		ins.Checked = true
		// Break algorithm cycle.
		if self.referencer != nil && self.referencer.owner == ins.Decl {
			ret true
		}
		// Do not evaluate generic methods immediately. Just precheck.
		// Otherwise type issues may occur. For example:
		//
		//	struct Bar[T]{}
		//	struct Baz[t]{}
		//
		//	struct Foo[T] {
		//		br: Bar[T]
		//		bz: Baz[T]
		//	}
		//
		//	In this example code above, we assume Bar uses Foo's bz field, which is Baz.
		//	If generic method will be checked here immediately, the Foo's bz field's type
		//	may not be evaluated here. Because durint evaluation of Bar[T],
		//	it will refer to the bz field, which is not evaluated yet.
		//	So, do not evaluate to avoid this issue. End of the semantic analysis,
		//	algorithm should check all instances gether.
		//
		// Enable generic struct collection if instance coming from different package.
		// Collect them and other relevant dependencies for deferred analysis.
		// The deferred analysis is mandatory for this kind of generic defines,
		// because this package analysis will not check them, so we have to collect
		// them for deferred check analysis.
		gstructs := self.s.meta.flags & semametaGstruct
		if self.s != ins.Decl.sema && len(ins.Decl.Generics) > 0 {
			self.s.meta.flags |= semametaGstruct
		}
		ok = self.s.precheckStructIns(ins, self.getReferencer(), errorToken)
		if ok && len(ins.Decl.Generics) > 0 {
			// If gstruct collection mode already enabled for this sema,
			// just push this instance into the collection.
			// Otherwise, this semantic analysis process is the root gstruct collector.
			// Check collected generic structures waiting for deferred analysis.
			if gstructs == semametaGstruct {
				self.s.meta.gstructs = append(self.s.meta.gstructs, ins)
			} else if self.s != ins.Decl.sema { // Avoid checking generic defines of this sema.
				// We can check structures using this sema.
				// The checkStructIns method will check structure instance in
				// its environment and errors will be reflected to this sema.
				for (_, mut gins) in self.s.meta.gstructs {
					self.s.checkStructIns(gins)
				}
				self.s.checkStructIns(ins)
				// Remove gstruct collection items, they are checked.
				// But keep the capacity to reduce allocations.
				// Disable gstruct collection.
				self.s.meta.gstructs = self.s.meta.gstructs[:0]
				self.s.meta.flags &= ^semametaGstruct
			}
		}
		ret
	}

	// Returns whether instantiation cycle catch analysis required.
	// Also returns allowed generic type alias identifiers.
	// The identifier slice will not include method generics, if any.
	// Because we can't know exactly there is no cycle risk with no more analysis.
	// Keep it simple.
	fn inscatchNeeded(mut self, mut &s: &Struct): (yes: bool, letGenerics: []&ast::Generic) {
		if len(s.Generics) == 0 {
			ret false, nil
		}
		mut sc, mut ok := self.lookup.(&scopeChecker)
		if ok {
			root := sc.getHardRoot()
			yes = root != nil && root.owner != nil &&
				root.owner.Decl != nil && root.owner.Decl.Owner == s
			if yes {
				letGenerics = s.Generics
			}
			ret
		}
		mut r := self.referencer
		for r != nil; r = r.prev {
			si, (ok) := r.owner.(&StructIns)
			if ok && si.Decl == s {
				ret true, s.Generics
			}
		}
		ret false, nil
	}

	fn buildStructInstance(mut self, mut &decl: &ast::IdentType, mut &s: &Struct): &StructIns {
		// Easy case: non-generic structure, return an instance immediately.
		if len(s.Generics) == 0 {
			ret s.instance()
		}
		inscatch, letGenerics := self.inscatchNeeded(s)

		// Save configuration.
		mut referencer := self.referencer
		self.referencer = nil
		defer { self.referencer = referencer }

		// Always allow built-in defines here, because we may need to use them
		// for generic types. Restore current state after evaluation of generics.
		disBuiltin := self.disBuiltin
		self.disBuiltin = false
		defer { self.disBuiltin = disBuiltin }

		// Use rootLookup to parse generics with root lookup.
		mut lookup := self.lookup
		self.lookup = self.rootLookup
		defer { self.lookup = lookup }

		// Build generics.
		mut ins := s.instance()
		ins.Generics = make([]&InsGeneric, 0, len(decl.Generics))
		for (_, mut g) in decl.Generics {
			mut kind := self.build(g.Kind)
			if kind == nil {
				ret nil
			}
			// Catch initiation cycles here if needed.
			// If type is a type alias (strict or soft), it can cause cycle.
			// Handle them here and avoid to be in cycle.
			// If struct refers to itself in generics, it causes endless instantiatation.
			if inscatch {
				ks := kind.Struct()
				if ks != nil && ks.Decl == s {
					idt, ok := g.Kind.(&ast::IdentType)
					// If generic type is based identifier. Check if it's one of
					// self generic types. If so, there is no cycle risk.
					if ok {
						for _, lg in letGenerics {
							if lg.Ident == idt.Ident {
								goto Ok
							}
						}
					}
					self.pushErr(g.Token, build::LogMsg.InitiationCycle, decl.Ident)
					ret nil
				}
			Ok:
			}
			ins.Generics = append(ins.Generics, &InsGeneric{Type: kind})
		}

		ret ins
	}

	fn fromStructIns(mut self, mut &ins: &StructIns, mut token: &token::Token): &StructIns {
		mut existInstance := ins.Decl.appendInstance(ins)
		if existInstance != nil {
			if !self.s.checkConstraintsStruct(ins, token, existInstance) {
				ret nil
			}
			// Already checked instance, did not appended.
			// So, this instance is not unique.
			self.pushReference[&StructIns](existInstance)
			ret existInstance
		}
		if !self.checkStructIns(ins, token) {
			ret nil
		}
		self.pushReference[&StructIns](ins)
		ret ins
	}

	fn fromStruct(mut self, mut &decl: &ast::IdentType, mut &s: &Struct): &StructIns {
		if !self.s.isAccessibleDefine(s.Public, s.Token) {
			self.pushErr(decl.Token, build::LogMsg.IdentNotExist, decl.Ident)
			ret nil
		}

		// Name selection.
		// Return instance instantly.
		if self.selection {
			if len(decl.Generics) > 0 {
				self.pushErr(decl.Token, build::LogMsg.GenericsNotAllowed)
				ret nil
			}
			ret &StructIns{
				Decl: s,
			}
		}

		mut ins := self.buildStructInstance(decl, s)
		if ins == nil {
			ret nil
		}

		mut ok := self.s.checkGenericQuantity(len(ins.Decl.Generics), len(ins.Generics), decl.Token)
		if !ok {
			ret nil
		}

		ins = self.fromStructIns(ins, decl.Token)
		if ins != nil {
			if !ins.Comparable {
				self.pushTA(taNotComparable)
			}
			if ins.Mutable {
				self.pushTA(taMutable)
			}
			ok = self.checkIllegalCycles(decl.Token, ins)
			if !ok && self.cycleErr&cycleErrEnable == cycleErrEnable {
				ret nil
			}
		}
		ret ins
	}

	// Returns identifier if found. Also checks founded identifier.
	// Uses internal lookup for all process except finding step of identifier.
	// Will find identifier in [l], not internal lookup.
	// Also finds in built-in lookup if allowed.
	// If another lookup nedeed, uses internal lookup, so any generic type build
	// process will use internal lookup. This might be useful for building
	// genericed type from another package.
	fn getDef(mut self, mut &decl: &ast::IdentType): Kind {
		for _, g in self.ignoreGenerics {
			if g.Ident == decl.Ident {
				ret buildPrimType(g.Ident)
			}
		}

		for (_, mut g) in self.useGenerics {
			if g.Ident == decl.Ident {
				if len(decl.Generics) > 0 {
					self.pushErr(decl.Token, build::LogMsg.TypeNotSupportsGenerics, decl.Ident)
					ret nil
				}
				// If generic type is astruct, check illegal cycles here.
				// Because generic types are evaluated without referencer.
				// So, any dependency will not be collected for structures.
				// Also, type is already evaluated, so we have to check cycle risks.
				// Because type analysis will return the evaluated type immediately.
				// Cycle analysis required types should be handled here separately.
				//
				// Type aliases or type enums will not be handled,
				// because there is no risk for type cycles.
				mut st := g.TypeSym.Type.Struct()
				if st != nil {
					ok := self.checkIllegalCycles(decl.Token, st)
					if !ok && self.cycleErr&cycleErrEnable == cycleErrEnable {
						ret nil
					}
				}
				ret g.TypeSym.Type.Kind
			}
		}

		if !decl.Binded {
			mut e := self.lookup.FindEnum(decl.Ident)
			if e != nil {
				ret self.fromEnum(decl, e)
			}

			mut te := self.lookup.FindTypeEnum(decl.Ident)
			if te != nil {
				ret self.fromTypeEnum(decl, te)
			}

			mut t := self.lookup.FindTrait(decl.Ident)
			if t != nil {
				ret self.fromTrait(decl, t)
			}
		} else if self.selection {
			self.pushErr(decl.Token, build::LogMsg.BindedTypeNotAllowed)
			ret nil
		}

		mut s := self.lookup.FindStruct(decl.Ident, decl.Binded)
		if s != nil {
			ret self.fromStruct(decl, s)
		}

		mut ta := self.lookup.FindTypeAlias(decl.Ident, decl.Binded)
		if ta == nil && !self.disBuiltin {
			ta = findBuiltinTypeAlias(decl.Ident)
			if ta != nil && ta.Ident == types::Any {
				self.pushTA(taMutable)
			}
		}
		if ta != nil {
			ret self.fromTypeAlias(decl, ta)
		}

		self.pushErr(decl.Token, build::LogMsg.IdentNotExist, decl.Ident)
		ret nil
	}

	fn buildIdent(mut self, mut decl: &ast::IdentType): Kind {
		ret self.getDef(decl)
	}

	fn buildSptrFromType(mut self, mut &elem: &Type): &Sptr {
		// Check special cases.
		match {
		| elem == nil:
			ret nil
		| elem.Array() != nil && elem.Array().Auto:
			self.pushErr(self.errorToken, build::LogMsg.ArrayAutoSized)
			ret nil
		}
		ret &Sptr{
			Elem: elem,
		}
	}

	fn buildSptr(mut self, mut decl: &ast::SptrType): &Sptr {
		if self.referencer != nil {
			oself := self.referencer.oself
			self.referencer.oself = true
			defer { self.referencer.oself = oself }
		}

		self.pushTA(taMutable)

		disableTA := self.disableTA
		self.disableTA |= taMutable | taNotComparable
		defer { self.disableTA = disableTA }

		mut elem := self.checkDecl(decl.Elem)
		ret self.buildSptrFromType(elem)
	}

	fn buildChan(mut self, mut decl: &ast::ChanType): &Chan {
		if self.referencer != nil {
			oself := self.referencer.oself
			self.referencer.oself = true
			defer { self.referencer.oself = oself }
		}

		// Do not disable mutability analysis.
		// Element type of channel is directly affects the mutability of channel.
		disableTA := self.disableTA
		self.disableTA |= taNotComparable
		defer { self.disableTA = disableTA }

		mut elem := self.checkDecl(decl.Elem)
		if elem == nil {
			ret nil
		}
		if self.s.meta.runtime != nil {
			mut s := runtimeFindStruct(self.s.meta.runtime, "pchan")
			mut ins := s.instance()
			ins.Generics = [&InsGeneric{Type: elem}]
			ins = self.fromStructIns(ins, decl.Elem.Token)
			self.pushReference[&StructIns](ins)
		}
		if self.disableTA&taMutable != taMutable && elem.Mutable() {
			self.pushTA(taMutable)
		}
		ret &Chan{
			Recv: decl.Recv,
			Send: decl.Send,
			Elem: elem,
		}
	}

	fn buildPtrFromType(mut self, mut &elem: &Type): &Ptr {
		// Check special cases.
		match {
		| elem == nil:
			ret nil
		| elem.Array() != nil && elem.Array().Auto:
			self.pushErr(self.errorToken, build::LogMsg.ArrayAutoSized)
			ret new(Ptr)
		}

		ret &Ptr{
			Elem: elem,
		}
	}

	fn buildPtr(mut self, mut decl: &ast::PtrType): &Ptr {
		if self.referencer != nil {
			oself := self.referencer.oself
			self.referencer.oself = true
			defer { self.referencer.oself = oself }
		}

		self.pushTA(taMutable)

		disableTA := self.disableTA
		self.disableTA |= taMutable | taNotComparable
		defer { self.disableTA = disableTA }

		mut elem := (&Type)(nil)

		if !decl.IsUnsafe() {
			elem = self.checkDecl(decl.Elem)
			ret self.buildPtrFromType(elem)
		}

		ret &Ptr{
			Elem: elem,
		}
	}

	fn buildSlice(mut self, mut decl: &ast::SliceType): &Slice {
		if self.referencer != nil {
			oself := self.referencer.oself
			self.referencer.oself = true
			defer { self.referencer.oself = oself }
		}

		self.pushTA(taNotComparable | taMutable)

		disableTA := self.disableTA
		self.disableTA |= taMutable | taNotComparable
		defer { self.disableTA = disableTA }

		mut elem := self.checkDecl(decl.Elem)

		// Check special cases.
		match {
		| elem == nil:
			ret nil
		| elem.Array() != nil && elem.Array().Auto:
			self.pushErr(decl.Elem.Token, build::LogMsg.ArrayAutoSized)
			ret nil
		}

		ret &Slice{
			Elem: elem,
		}
	}

	fn buildArray(mut self, mut decl: &ast::ArrayType): &Array {
		mut n := 0
		if !decl.AutoSized() {
			mut size := self.s.eval(self.lookup).evalExpr(decl.Size, evalDefault|evalPhysicalMem|evalUnwrapUntyped)
			if size == nil {
				ret nil
			}

			if !size.IsConst() {
				self.pushErr(decl.Size.Token, build::LogMsg.ExprNotConst)
				ret nil
			} else if size.Type.Prim() == nil || !types::IsInt(size.Type.Prim().Kind) {
				self.pushErr(decl.Size.Token, build::LogMsg.ArraySizeIsNotInt)
				ret nil
			}

			n = int(size.Constant.AsI64())
			if n < 0 {
				self.pushErr(decl.Elem.Token, build::LogMsg.ArraySizeIsNeg)
				ret nil
			} else {
				max := types::MaxI(types::Int)
				if types::BitSize != 64 && i64(n) > max {
					self.pushErr(decl.Size.Token, build::LogMsg.ArraySizeOverflow,
						size.Constant.Str(), conv::FormatInt(max, 10))
					ret nil
				}
			}
		}

		// Do not disable mutability and comparable analysis.
		// Element type of array is directly affects the mutability and comparability of array.
		mut elem := self.checkDecl(decl.Elem)

		// Check special cases.
		match {
		| elem == nil:
			ret nil
		| elem.Array() != nil && elem.Array().Auto:
			self.pushErr(decl.Elem.Token, build::LogMsg.ArrayAutoSized)
			ret nil
		}

		if self.disableTA&taNotComparable != taNotComparable && !elem.Comparable() {
			self.pushTA(taNotComparable)
		}
		if self.disableTA&taMutable != taMutable && elem.Mutable() {
			self.pushTA(taMutable)
		}

		ret &Array{
			Auto: decl.AutoSized(),
			N: n,
			Elem: elem,
		}
	}

	fn buildMap(mut self, mut decl: &ast::MapType): &Map {
		self.pushTA(taNotComparable)

		// Do not disable mutability analysis.
		// Key and Value type of map is directly affects the mutability of map.
		disableTA := self.disableTA
		self.disableTA |= taNotComparable
		defer { self.disableTA = disableTA }

		// Evaluate key type like no cycle risk, do not log errors about it.
		// We have to do this for checking correct map type dependencies,
		// cycle types are prevents valid map key types. So, catch them but
		// do not log as cycle error, log as invalid key type error.
		cycleErr := self.cycleErr
		self.cycleErr &= ^cycleErrFail
		self.cycleErr &= ^cycleErrEnable
		if self.referencer != nil {
			oself := self.referencer.oself
			self.referencer.oself = true
			defer { self.referencer.oself = oself }
		}
		mut key := self.checkDecl(decl.Key)
		if key == nil {
			self.cycleErr = cycleErr
			ret nil
		}
		// Check whether key type is valid.
		// It should be comparable, if cycle analysis failed, we have cycles,
		// so we have a map type (this type, actually), so it is not comparable.
		if self.cycleErr&cycleErrFail == cycleErrFail || !key.Comparable() {
			self.cycleErr = cycleErr
			self.s.pushErr(decl.Key.Token, build::LogMsg.ConstraintFailed, key.Str(), "Key", str(builtinConstraint.Comparable))
			ret nil
		}
		self.cycleErr = cycleErr

		// Evaluate value type with no cycle risk.
		mut val := self.checkDecl(decl.Val)
		if val == nil {
			ret nil
		}
		if val.Enum() != nil {
			self.pushErr(decl.Val.Token, build::LogMsg.EnumAsMapVal)
		}

		if self.s.meta.runtime != nil {
			mut s := runtimeFindStruct(self.s.meta.runtime, "_Map")
			mut ins := s.instance()
			ins.Generics = [&InsGeneric{Type: key}, &InsGeneric{Type: val}]
			ins = self.fromStructIns(ins, decl.Key.Token)
			self.pushReference[&StructIns](ins)
		}

		if self.disableTA&taMutable != taMutable && (key.Mutable() || val.Mutable()) {
			self.pushTA(taMutable)
		}

		ret &Map{
			Key: key,
			Val: val,
		}
	}

	fn buildTuple(mut self, mut decl: &ast::TupleType): &Tuple {
		mut types := make([]&Type, 0, len(decl.Types))
		for (_, mut t) in decl.Types {
			mut kind := self.checkDecl(t)
			if kind == nil {
				ret nil
			}
			types = append(types, kind)
		}

		ret &Tuple{Types: types}
	}

	fn checkFuncTypes(mut self, mut &f: &FuncIns): (ok: bool) {
		for (_, mut p) in f.Params {
			p.Type = self.build(p.Decl.TypeSym.Decl.Kind)
			ok = p.Type != nil
			if !ok {
				ret false
			}
			self.s.checkFuncParamKind(p)
		}

		if !f.Decl.IsVoid() {
			f.Result = self.build(f.Decl.Result.TypeSym.Decl.Kind)
			ret f.Result != nil
		}

		ret true
	}

	fn buildFunc(mut self, mut decl: &ast::Func): &FuncIns {
		if self.referencer != nil {
			oself := self.referencer.oself
			self.referencer.oself = true
			defer { self.referencer.oself = oself }
		}

		self.pushTA(taNotComparable)

		disableTA := self.disableTA
		self.disableTA |= taMutable | taNotComparable
		defer { self.disableTA = disableTA }

		if len(decl.Generics) > 0 {
			self.pushErr(decl.Token, build::LogMsg.GenericedFuncAsAnonFunc)
			ret nil
		}

		mut f := buildFunc(decl)

		n := len(self.s.errors)
		self.s.checkAnonFuncDecl(f)
		if n != len(self.s.errors) {
			ret nil
		}

		mut ins := f.instanceForce()
		ins.Anon = true
		ins.AsAnon = true

		ok := self.checkFuncTypes(ins)
		if !ok {
			ret nil
		}

		ret ins
	}

	fn buildNamespace(mut self, mut ns: &ast::NamespaceType): Kind {
		mut imp := findNamespace(self.lookup, ns.Namespace.Kind)
		if imp == nil || !imp.isLookupable() {
			self.pushErr(ns.Namespace, build::LogMsg.NamespaceNotExist, ns.Namespace.Kind)
			ret nil
		}

		disableTA := self.disableTA
		self.disableTA |= taMutable | taNotComparable
		defer { self.disableTA = disableTA }

		self.disallowBuiltin()
		mut lookup := self.lookup
		self.lookup = imp
		mut kind := self.checkDecl(ns.Kind)
		self.lookup = lookup
		self.allowBuiltin()
		ret kind
	}

	fn build(mut self, mut declKind: semaTypeKind): &Type {
		let mut kind: Kind = nil
		match type declKind {
		| &Type:
			kind = declKind.(&Type)
		| &ast::IdentType:
			mut t := self.buildIdent(declKind.(&ast::IdentType))
			if t != nil {
				kind = t
			}
		| &ast::ChanType:
			mut t := self.buildChan(declKind.(&ast::ChanType))
			if t != nil {
				kind = t
			}
		| &ast::SptrType:
			mut t := self.buildSptr(declKind.(&ast::SptrType))
			if t != nil {
				kind = t
			}
		| &ast::PtrType:
			mut t := self.buildPtr(declKind.(&ast::PtrType))
			if t != nil {
				kind = t
			}
		| &ast::SliceType:
			mut t := self.buildSlice(declKind.(&ast::SliceType))
			if t != nil {
				kind = t
			}
		| &ast::ArrayType:
			mut t := self.buildArray(declKind.(&ast::ArrayType))
			if t != nil {
				kind = t
			}
		| &ast::MapType:
			mut t := self.buildMap(declKind.(&ast::MapType))
			if t != nil {
				kind = t
			}
		| &ast::TupleType:
			mut t := self.buildTuple(declKind.(&ast::TupleType))
			if t != nil {
				kind = t
			}
		| &ast::Func:
			mut t := self.buildFunc(declKind.(&ast::Func))
			if t != nil {
				kind = t
			}
		| &ast::NamespaceType:
			mut t := self.buildNamespace(declKind.(&ast::NamespaceType))
			if t != nil {
				kind = t
			}
		|:
			self.pushErr(self.errorToken, build::LogMsg.InvalidType)
			ret nil
		}
		if kind == nil {
			ret nil
		}
		match type kind {
		| &Type:
			ret kind.(&Type)
		|:
			mut tk := &Type{Kind: kind}
			match type kind {
			| &Prim:
				if self.ignoredGenerics != nil {
					unsafe { *self.ignoredGenerics = append(*self.ignoredGenerics, tk) }
				}
			}
			ret tk
		}
	}

	fn checkDecl(mut self, mut &decl: &ast::Type): &Type {
		// Save current token.
		mut errorToken := self.errorToken

		self.errorToken = decl.Token
		mut kind := self.build(decl.Kind)
		self.errorToken = errorToken

		ret kind
	}

	fn check(mut self, mut &t: &TypeSym) {
		if t.Decl == nil {
			ret
		}
		mut kind := self.checkDecl(t.Decl)
		if kind == nil {
			t.removeKind()
			ret
		}
		t.Type = kind
	}
}

struct identTypeLookup{}

impl identTypeLookup {
	static fn prim(&ident: str, t: &Prim): bool {
		ret t.Kind == ident
	}

	static fn exist(&ident: str, mut &k: &Type): bool {
		match {
		| k.Prim() != nil:
			ret identTypeLookup.prim(ident, k.Prim())
		| k.Chan() != nil:
			mut ch := k.Chan()
			ret identTypeLookup.exist(ident, ch.Elem)
		| k.Sptr() != nil:
			mut sptr := k.Sptr()
			ret identTypeLookup.exist(ident, sptr.Elem)
		| k.Ptr() != nil:
			mut ptr := k.Ptr()
			ret identTypeLookup.exist(ident, ptr.Elem)
		| k.Slice() != nil:
			mut slc := k.Slice()
			ret identTypeLookup.exist(ident, slc.Elem)
		| k.Array() != nil:
			mut arr := k.Array()
			ret identTypeLookup.exist(ident, arr.Elem)
		| k.Map() != nil:
			mut m := k.Map()
			ret identTypeLookup.exist(ident, m.Key) ||
				identTypeLookup.exist(ident, m.Val)
		| k.Struct() != nil:
			mut s := k.Struct()
			for (_, mut g) in s.Generics {
				if identTypeLookup.exist(ident, g.Type) {
					ret true
				}
			}
			ret false
		| k.Func() != nil:
			mut f := k.Func()
			for (_, mut p) in f.Params {
				if p.Decl.IsSelf() {
					continue
				}
				if identTypeLookup.exist(ident, p.Type) {
					ret true
				}
			}
			if f.Result != nil {
				ret identTypeLookup.exist(ident, f.Result)
			}
			ret false
		| k.Tuple() != nil:
			mut tup := k.Tuple()
			for (_, mut t) in tup.Types {
				if identTypeLookup.exist(ident, t) {
					ret true
				}
			}
			ret false
		|:
			ret false
		}
	}
}

fn kindUsesGenerics(mut &k: &Type, &generics: []&ast::Generic): bool {
	for _, g in generics {
		if identTypeLookup.exist(g.Ident, k) {
			ret true
		}
	}
	ret false
}

// Reports whether directive is exist.
fn hasDirective(mut &directives: []&ast::Directive, tag: str): bool {
	for (_, mut dr) in directives {
		if dr.Tag.Kind == tag {
			ret true
		}
	}
	ret false
}

fn canGetPtr(mut &v: &Value): bool { ret v.Lvalue }

// Reports whether type has built-in string conversion support.
fn isBuiltinStrConvertible(mut &t: &Type): bool {
	ret !t.Void() && t.Func() == nil && t.Tuple() == nil && !t.comptime()
}

fn buildPrimType(kind: str): &Prim {
	ret &Prim{
		Kind: kind,
	}
}

fn getStructFromKind(mut k: &Type): &Struct {
	match {
	| k == nil:
		ret nil
	| k.Struct() != nil:
		ret k.Struct().Decl
	| k.Sptr() != nil:
		ret getStructFromKind(k.Sptr().Elem)
	| k.Slice() != nil:
		ret getStructFromKind(k.Slice().Elem)
	| k.Array() != nil:
		ret getStructFromKind(k.Array().Elem)
	| k.Ptr() != nil:
		// Pass pointers.
		// Cloning just copies pointer address.
		// There is no any illegal cycle risk.
		ret nil
	|:
		ret nil
	}
}

// Reports whether type is valid for SizeOf/AlignOf functions.
fn validTypeForXof(mut &t: &Type): bool {
	ret !t.Void() && t.Func() == nil && t.Tuple() == nil && !t.comptime()
}

// Pseudo source type for strict type alias structure instances.
static mut pseudoSource = new(Type)

// Initializes new structure for strict types.
// See developer reference (9) for details.
fn initNewStructType(ident: str, mut source: &Type): &StructIns {
	mut s := new(Struct)
	s.Ident = ident
	mut ins := s.instance()
	s.appendInstance(ins)
	ins.setSource(source)
	ret ins
}
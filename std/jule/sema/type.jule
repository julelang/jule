// Copyright 2023-2025 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

// This file reserved for types, type kinds and type build algorithms.
// This file haven't type compatibility checking algorithm or something else.

use "std/conv"
use "std/jule/ast"
use "std/jule/build"
use "std/jule/token"
use "std/jule/types"
use "std/strings"

// Generic type for instance types.
struct InsGeneric {
	Type:       &Type
	Constraint: []&Type
}

// Type alias.
struct TypeAlias {
	Scope:    &ast::ScopeTree
	Strict:   bool
	Public:   bool
	Binded:   bool
	Used:     bool
	Generic:  bool
	Token:    &token::Token
	Ident:    str
	TypeSym:  &TypeSym
	Refers:   []any        // Referred identifiers, except binded ones.
	Generics: []&TypeAlias // See developer reference (1).
}

// Kind of type declaration.
trait Kind {
	fn Str(self): str
	fn Equal(&self, other: &Type): bool
}

// Evaluated type declaration.
struct Type {
	Generic:  bool
	Variadic: bool
	Kind:     Kind
}

impl Kind for Type {
	// Returns kind as string.
	fn Str(self): str {
		if self.IsNil() {
			ret "nil"
		}

		mut kind := strings::Builder{}
		kind.Grow(1 << 4)

		if self.Variadic {
			kind.WriteStr("...")!
		}
		kind.WriteStr(self.Kind.Str())!
		ret kind.Str()
	}

	// Reports whether types are same.
	fn Equal(&self, other: &Type): bool {
		if self.IsNil() {
			ret other.IsNil()
		}
		ret self.Kind.Equal(other)
	}
}

impl Type {
	// Reports whether type is binded kind.
	fn Binded(self): bool {
		match type self.Kind {
		| &StructIns:
			s := (&StructIns)(self.Kind)
			if s.Decl.Binded {
				ret true
			}
			if s.Source != nil {
				ret s.Source.Binded()
			}
		}
		ret false
	}

	// Reports whether kind is "nil".
	fn IsNil(self): bool { ret self.Kind == nil }

	// Reports whether actual kind is "void".
	fn Void(self): bool {
		prim := unsafe { (*(&self)).Prim() }
		ret prim != nil && prim.Kind == "void"
	}

	// Returns actual kind of the type, so returns the root type.
	// If kind is a struct, which is implemented by the type statement,
	// see developer reference (11) for details, returns the actual kind of
	// the source type of the struct.
	fn ActualKind(mut self): Kind {
		match type self.Kind {
		| &StructIns:
			mut s := (&StructIns)(self.Kind)
			if s.Source != nil {
				ret s.Source.ActualKind()
			}
		}
		ret self.Kind
	}

	// Reports whether actual kinds are equal.
	fn ActualEqual(&self, other: &Type): bool {
		if self.IsNil() {
			ret other.IsNil()
		}
		if self.Binded() || other.Binded() {
			ret self.Equal(other)
		}
		l := unsafe { (*(&self)).ActualKind() }
		r := unsafe { (*(&other)).ActualKind() }
		lt := Type{Kind: l}
		rt := Type{Kind: r}
		ret (unsafe { (&Type)(&lt) }).Equal(unsafe { (&Type)(&rt) })
	}

	// Same as the ActualEqual, but ignores the binded types.
	fn deepActualEqual(&self, other: &Type): bool {
		if self.IsNil() {
			ret other.IsNil()
		}
		l := unsafe { (*(&self)).ActualKind() }
		r := unsafe { (*(&other)).ActualKind() }
		lt := Type{Kind: l}
		rt := Type{Kind: r}
		ret (unsafe { (&Type)(&lt) }).Equal(unsafe { (&Type)(&rt) })
	}

	// Reports whether actual kind is comparable.
	fn Comparable(self): bool {
		unsafe {
			mut _self := &self
			if _self.Struct() != nil {
				ret _self.Struct().Comparable
			}
			if _self.Array() != nil {
				ret _self.Array().Elem.Comparable()
			}
			ret _self.Map() == nil && _self.Slice() == nil && _self.Func() == nil
		}
	}

	// Reports whether actual kind is mutable.
	fn Mutable(self): bool {
		unsafe {
			mut _self := &self
			if _self.Struct() != nil {
				ret _self.Struct().Mutable
			}
			if _self.Chan() != nil {
				ret _self.Chan().Elem.Mutable()
			}
			if _self.Trait() != nil {
				ret true
			}
			if _self.Prim() != nil {
				p := _self.Prim()
				ret p.IsAny()
			}
			if _self.Array() != nil {
				ret _self.Array().Elem.Mutable()
			}
			ret _self.Slice() != nil ||
				_self.Ptr() != nil ||
				_self.Sptr() != nil
		}
	}

	// Reports whether actual kind supports ordered constrait.
	fn Ordered(self): bool {
		unsafe {
			mut _self := &self
			prim := _self.Prim()
			if prim != nil {
				ret types::IsNum(prim.Kind) || prim.IsStr()
			}
			if _self.Ptr() != nil {
				ret true
			}
			mut enm := _self.Enum()
			if enm != nil {
				ret types::IsNum(enm.TypeSym.Type.Prim().Str())
			}
			ret false
		}
	}

	// Reports whether actual kind is nil compatible.
	fn NilCompatible(self): bool {
		unsafe {
			mut _self := &self

			prim := _self.Prim()
			if prim != nil && prim.IsAny() {
				ret true
			}

			ret _self.IsNil() ||
				_self.Func() != nil ||
				_self.Sptr() != nil ||
				_self.Ptr() != nil ||
				_self.Trait() != nil ||
				_self.Slice() != nil ||
				_self.Map() != nil ||
				_self.TypeEnum() != nil ||
				_self.Chan() != nil
		}
	}

	// Reports whether actual kind performs garbage collection.
	fn GC(self): bool {
		unsafe {
			mut _self := &self
			prim := _self.Prim()
			if prim != nil {
				ret prim.IsAny() || prim.IsStr()
			}
			ret _self.Sptr() != nil || _self.Slice() != nil || _self.Trait() != nil ||
				_self.TypeEnum() != nil || _self.Chan() != nil
		}
	}

	// Reports whether actual kind is variadicable.
	fn Variadicable(self): bool {
		mut _self := &self
		ret unsafe { _self.Slice() != nil }
	}

	// Returns primitive type if actual kind is primitive type, nil if not.
	fn Prim(mut self): &Prim {
		mut kind := self.ActualKind()
		match type kind {
		| &Prim:
			ret (&Prim)(kind)
		|:
			ret nil
		}
	}

	// Returns channel type if actual kind is channel, nil if not.
	fn Chan(mut self): &Chan {
		mut kind := self.ActualKind()
		match type kind {
		| &Chan:
			ret (&Chan)(kind)
		|:
			ret nil
		}
	}

	// Returns reference type if actual kind is smart pointer, nil if not.
	fn Sptr(mut self): &Sptr {
		mut kind := self.ActualKind()
		match type kind {
		| &Sptr:
			ret (&Sptr)(kind)
		|:
			ret nil
		}
	}

	// Returns pointer type if actual kind is pointer, nil if not.
	fn Ptr(mut self): &Ptr {
		mut kind := self.ActualKind()
		match type kind {
		| &Ptr:
			ret (&Ptr)(kind)
		|:
			ret nil
		}
	}

	// Returns enum type if actual kind is enum, nil if not.
	fn Enum(mut self): &Enum {
		mut kind := self.ActualKind()
		match type kind {
		| &Enum:
			ret (&Enum)(kind)
		|:
			ret nil
		}
	}

	// Returns type enum if actual kind is type enum, nil if not.
	fn TypeEnum(mut self): &TypeEnum {
		mut kind := self.ActualKind()
		match type kind {
		| &TypeEnum:
			ret (&TypeEnum)(kind)
		|:
			ret nil
		}
	}

	// Returns array type if actual kind is array, nil if not.
	fn Array(mut self): &Array {
		mut kind := self.ActualKind()
		match type kind {
		| &Array:
			ret (&Array)(kind)
		|:
			ret nil
		}
	}

	// Returns slice type if actual kind is slice, nil if not.
	fn Slice(mut self): &Slice {
		mut kind := self.ActualKind()
		match type kind {
		| &Slice:
			ret (&Slice)(kind)
		|:
			ret nil
		}
	}

	// Returns function type if actual kind is function, nil if not.
	fn Func(mut self): &FuncIns {
		mut kind := self.ActualKind()
		match type kind {
		| &FuncIns:
			ret (&FuncIns)(kind)
		|:
			ret nil
		}
	}

	// Returns struct type if actual kind is structure, nil if not.
	fn Struct(mut self): &StructIns {
		mut kind := self.ActualKind()
		match type kind {
		| &StructIns:
			ret (&StructIns)(kind)
		|:
			ret nil
		}
	}

	fn softStruct(mut self): &StructIns {
		match type self.Kind {
		| &StructIns:
			ret (&StructIns)(self.Kind)
		|:
			ret nil
		}
	}

	// Returns trait type if actual kind is trait, nil if not.
	fn Trait(mut self): &Trait {
		mut kind := self.ActualKind()
		match type kind {
		| &Trait:
			ret (&Trait)(kind)
		|:
			ret nil
		}
	}

	// Returns map type if actual kind is map, nil if not.
	fn Map(mut self): &Map {
		mut kind := self.ActualKind()
		match type kind {
		| &Map:
			ret (&Map)(kind)
		|:
			ret nil
		}
	}

	// Returns tuple type if actual kind is tuple, nil if not.
	fn Tuple(mut self): &Tuple {
		mut kind := self.ActualKind()
		match type kind {
		| &Tuple:
			ret (&Tuple)(kind)
		|:
			ret nil
		}
	}

	// Reports whether kind is comptime type.
	// It will not check for the [comptimeRange].
	// Checks regular constant comptime expression types only.
	fn comptime(mut self): bool {
		ret self.comptimeTypeInfos() != nil ||
			self.comptimeTypeInfo() != nil ||
			self.comptimeStructFields() != nil ||
			self.comptimeStructField() != nil ||
			self.comptimeEnumFields() != nil ||
			self.comptimeEnumField() != nil ||
			self.comptimeStatics() != nil ||
			self.comptimeStatic() != nil ||
			self.comptimeParams() != nil ||
			self.comptimeParam() != nil ||
			self.comptimeValue() != nil ||
			self.comptimeFiles() != nil ||
			self.comptimeFile() != nil ||
			self.comptimeDecl() != nil ||
			self.comptimeDecls() != nil
	}

	fn comptimeStructFields(mut self): &comptimeStructFields {
		match type self.Kind {
		| &comptimeStructFields:
			ret (&comptimeStructFields)(self.Kind)
		|:
			ret nil
		}
	}

	fn comptimeStructField(mut self): &comptimeStructField {
		match type self.Kind {
		| &comptimeStructField:
			ret (&comptimeStructField)(self.Kind)
		|:
			ret nil
		}
	}

	fn comptimeEnumFields(mut self): &comptimeEnumFields {
		match type self.Kind {
		| &comptimeEnumFields:
			ret (&comptimeEnumFields)(self.Kind)
		|:
			ret nil
		}
	}

	fn comptimeEnumField(mut self): &comptimeEnumField {
		match type self.Kind {
		| &comptimeEnumField:
			ret (&comptimeEnumField)(self.Kind)
		|:
			ret nil
		}
	}

	fn comptimeParams(mut self): &comptimeParams {
		match type self.Kind {
		| &comptimeParams:
			ret (&comptimeParams)(self.Kind)
		|:
			ret nil
		}
	}

	fn comptimeParam(mut self): &comptimeParam {
		match type self.Kind {
		| &comptimeParam:
			ret (&comptimeParam)(self.Kind)
		|:
			ret nil
		}
	}

	fn comptimeRange(mut self): &comptimeRange {
		match type self.Kind {
		| &comptimeRange:
			ret (&comptimeRange)(self.Kind)
		|:
			ret nil
		}
	}

	fn comptimeTypeInfos(mut self): &comptimeTypeInfos {
		match type self.Kind {
		| &comptimeTypeInfos:
			ret (&comptimeTypeInfos)(self.Kind)
		|:
			ret nil
		}
	}

	fn comptimeTypeInfo(mut self): &comptimeTypeInfo {
		match type self.Kind {
		| &comptimeTypeInfo:
			ret (&comptimeTypeInfo)(self.Kind)
		|:
			ret nil
		}
	}

	fn comptimeStatics(mut self): &comptimeStatics {
		match type self.Kind {
		| &comptimeStatics:
			ret (&comptimeStatics)(self.Kind)
		|:
			ret nil
		}
	}

	fn comptimeStatic(mut self): &comptimeStatic {
		match type self.Kind {
		| &comptimeStatic:
			ret (&comptimeStatic)(self.Kind)
		|:
			ret nil
		}
	}

	fn comptimeValue(mut self): &comptimeValue {
		match type self.Kind {
		| &comptimeValue:
			ret (&comptimeValue)(self.Kind)
		|:
			ret nil
		}
	}

	fn comptimeDecl(mut self): &comptimeDecl {
		match type self.Kind {
		| &comptimeDecl:
			ret (&comptimeDecl)(self.Kind)
		|:
			ret nil
		}
	}

	fn comptimeDecls(mut self): &comptimeDecls {
		match type self.Kind {
		| &comptimeDecls:
			ret (&comptimeDecls)(self.Kind)
		|:
			ret nil
		}
	}

	fn comptimeFile(mut self): &comptimeFile {
		match type self.Kind {
		| &comptimeFile:
			ret (&comptimeFile)(self.Kind)
		|:
			ret nil
		}
	}

	fn comptimeFiles(mut self): &comptimeFiles {
		match type self.Kind {
		| &comptimeFiles:
			ret (&comptimeFiles)(self.Kind)
		|:
			ret nil
		}
	}
}

// Type.
struct TypeSym {
	Decl: &ast::Type // Never changed by semantic analyzer.
	Type: &Type
}

impl TypeSym {
	// Reports whether type is checked already.
	fn checked(self): bool { ret self.Type != nil }

	// Removes kind and ready to check.
	// checked() reports false after this function.
	fn removeKind(mut self) { self.Type = nil }
}

// Primitive type.
struct Prim {
	Kind: str
}

impl Kind for Prim {
	// Returns kind.
	fn Str(self): str {
		ret self.Kind
	}

	// Reports whether types are same.
	fn Equal(&self, other: &Type): bool {
		match type other.Kind {
		| &Prim:
			ret self.Kind == (&Prim)(other.Kind).Kind
		}
		ret false
	}
}

impl Prim {
	// Reports whether type is built-in constraint.
	fn IsConstraint(self): bool {
		ret !self.IsStr() &&
			!self.IsAny() &&
			!self.IsBool() &&
			!types::IsNum(self.Kind)
	}

	// Reports whether type is primitive i8.
	fn IsI8(self): bool { ret self.Kind == types::Kind.I8 }

	// Reports whether type is primitive i16.
	fn IsI16(self): bool { ret self.Kind == types::Kind.I16 }

	// Reports whether type is primitive i32.
	fn IsI32(self): bool { ret self.Kind == types::Kind.I32 }

	// Reports whether type is primitive i64.
	fn IsI64(self): bool { ret self.Kind == types::Kind.I64 }

	// Reports whether type is primitive u8.
	fn IsU8(self): bool { ret self.Kind == types::Kind.U8 }

	// Reports whether type is primitive u16.
	fn IsU16(self): bool { ret self.Kind == types::Kind.U16 }

	// Reports whether type is primitive u32.
	fn IsU32(self): bool { ret self.Kind == types::Kind.U32 }

	// Reports whether type is primitive u64.
	fn IsU64(self): bool { ret self.Kind == types::Kind.U64 }

	// Reports whether type is primitive f32.
	fn IsF32(self): bool { ret self.Kind == types::Kind.F32 }

	// Reports whether type is primitive f64.
	fn IsF64(self): bool { ret self.Kind == types::Kind.F64 }

	// Reports whether type is primitive int.
	fn IsInt(self): bool { ret self.Kind == types::Kind.Int }

	// Reports whether type is primitive uint.
	fn IsUint(self): bool { ret self.Kind == types::Kind.Uint }

	// Reports whether type is primitive uintptr.
	fn IsUintptr(self): bool { ret self.Kind == types::Kind.Uintptr }

	// Reports whether type is primitive bool.
	fn IsBool(self): bool { ret self.Kind == types::Kind.Bool }

	// Reports whether type is primitive str.
	fn IsStr(self): bool { ret self.Kind == types::Kind.Str }

	// Reports whether type is primitive any.
	fn IsAny(self): bool { ret self.Kind == types::Kind.Any }
}

// Channel type.
struct Chan {
	Recv: bool
	Send: bool
	Elem: &Type
}

impl Kind for Chan {
	// Returns smart pointer kind as string.
	fn Str(self): str {
		if self.Recv && self.Send {
			match type self.Elem.Kind {
			| &Chan:
				c := (&Chan)(self.Elem.Kind)
				if c.Recv && !c.Send {
					ret "chan (" + self.Elem.Str() + ")"
				}
			}
			ret "chan " + self.Elem.Str()
		} else if self.Recv {
			ret "<-chan " + self.Elem.Str()
		} else {
			ret "chan<- " + self.Elem.Str()
		}
	}

	// Reports whether types are same.
	fn Equal(&self, other: &Type): bool {
		match type other.Kind {
		| &Chan:
			c := (&Chan)(other.Kind)
			ret self.Recv == c.Recv && self.Send == c.Send && self.Elem.Equal(c.Elem)
		}
		ret false
	}
}

// Smart pointer.
struct Sptr {
	Elem: &Type
}

impl Kind for Sptr {
	// Returns smart pointer kind as string.
	fn Str(self): str { ret "&" + self.Elem.Str() }

	// Reports whether types are same.
	fn Equal(&self, other: &Type): bool {
		match type other.Kind {
		| &Sptr:
			ret self.Elem.Equal((&Sptr)(other.Kind).Elem)
		}
		ret false
	}
}

// Slice type.
struct Slice {
	Elem: &Type
}

impl Kind for Slice {
	// Returns slice kind as string.
	fn Str(self): str { ret "[]" + self.Elem.Str() }

	// Reports whether types are same.
	fn Equal(&self, other: &Type): bool {
		match type other.Kind {
		| &Slice:
			ret self.Elem.Equal((&Slice)(other.Kind).Elem)
		}
		ret false
	}
}

// Tuple type.
struct Tuple {
	Types: []&Type
}

impl Kind for Tuple {
	// Returns tuple kind as string.
	fn Str(self): str {
		mut s := strings::Builder{}
		s.Grow(1 << 4)
		s.WriteByte('(')!
		s.WriteStr(self.Types[0].Str())!
		for _, t in self.Types[1:] {
			s.WriteByte(',')!
			s.WriteStr(t.Str())!
		}
		s.WriteByte(')')!
		ret s.Str()
	}

	// Reports whether types are same.
	fn Equal(&self, other: &Type): bool {
		match type other.Kind {
		| &Tuple:
			tup := (&Tuple)(other.Kind)
			if len(self.Types) != len(tup.Types) {
				ret false
			}
			mut i := 0
			for i < len(self.Types); i++ {
				if !self.Types[i].Equal(tup.Types[i]) {
					ret false
				}
			}
			ret true
		}
		ret false
	}
}

// Map type.
struct Map {
	Key: &Type
	Val: &Type
}

impl Kind for Map {
	// Returns map kind as string.
	fn Str(self): str {
		mut s := strings::Builder{}
		s.Grow(1 << 4)
		s.WriteStr("map[")!
		s.WriteStr(self.Key.Str())!
		s.WriteByte(']')!
		s.WriteStr(self.Val.Str())!
		ret s.Str()
	}

	// Reports whether types are same.
	fn Equal(&self, other: &Type): bool {
		match type other.Kind {
		| &Map:
			m := (&Map)(other.Kind)
			ret self.Key.Equal(m.Key) && self.Val.Equal(m.Val)
		}
		ret false
	}
}

// Array type.
struct Array {
	Auto: bool // Auto-sized array.
	N:    int
	Elem: &Type
}

impl Kind for Array {
	// Returns array kind as string.
	fn Str(self): str {
		mut s := strings::Builder{}
		s.Grow(1 << 4)
		s.WriteByte('[')!
		s.WriteStr(conv::Itoa(self.N))!
		s.WriteByte(']')!
		s.WriteStr(self.Elem.Str())!
		ret s.Str()
	}

	// Reports whether types are same.
	fn Equal(&self, other: &Type): bool {
		match type other.Kind {
		| &Array:
			arr := (&Array)(other.Kind)
			ret self.N == arr.N && self.Elem.Equal(arr.Elem)
		}
		ret false
	}
}

// Pointer type.
struct Ptr {
	Elem: &Type
}

impl Kind for Ptr {
	// Returns pointer kind as string.
	fn Str(self): str {
		if self.IsUnsafe() {
			ret "*unsafe"
		}
		ret "*" + self.Elem.Str()
	}

	// Reports whether types are same.
	fn Equal(&self, other: &Type): bool {
		match type other.Kind {
		| &Ptr:
			ptr := (&Ptr)(other.Kind)
			match {
			| self.IsUnsafe():
				ret ptr.IsUnsafe()
			| ptr.IsUnsafe():
				ret self.IsUnsafe()
			|:
				ret self.Elem.Equal(ptr.Elem)
			}
		}
		ret false
	}
}

impl Ptr {
	// Reports whether pointer is unsafe pointer (*unsafe).
	fn IsUnsafe(self): bool { ret self.Elem == nil }
}

struct referencer {
	ident: str
	owner: any
	refs:  *[]any
}

const cycleErrEnable = 0b01 // Enables error logging for cycle analysis.
const cycleErrFail = 0b10   // Means the last cycle analysis reports cycles exist.

// Checks type and builds result as kind.
// Removes kind if error occurs,
// so type is not reports true for checked state.
struct typeChecker {
	// Uses sema for:
	//  - Push errors.
	s: &sema

	// Uses Lookup for:
	//  - Lookup symbol tables for root specific.
	rootLookup: Lookup

	// Uses Lookup for:
	//  - Lookup symbol tables for current.
	//  - It might be change when evaluation of namespace selection or etc.
	lookup: Lookup

	// If this is not nil, appends referred ident types.
	// Also used as checker owner.
	referencer: &referencer

	// If this not nil, type dependencies will push into stack.
	refers: &ReferenceStack

	errorToken: &token::Token

	// This identifiers ignored and
	// appends as primitive type.
	//
	// Each dimension 2 array accepted as identifier group.
	ignoreGenerics: []&ast::Generic

	// Relevant type kinds that contains an ignored generic type.
	ignoredGenerics: *[]&Type

	// This generics used as type alias for real kind.
	useGenerics: []&TypeAlias

	// Current checked type is risky for cycles.
	// If this field is true, cycle analysis will be executed for type.
	cycleRisk: bool = true
	cycleErr:  int = cycleErrEnable

	// Disallow/suppress Jule's built-in defines.
	disBuiltin: bool

	// Name selection is enabled.
	// No binded definitions, no generic type representation.
	// Only typename selection.
	//
	// If selection is a struct, returns invalid instance that only has decl field.
	selection: bool

	// See developer reference (4).
	ownerAlias: &TypeAlias

	// This generics are banned because of causes instantiation cycles.
	// Usually stores structure generics and method generics.
	// See developer reference (5).
	bannedGenerics: []&TypeAlias

	// Enable/Disable status of instantiation catching.
	// See developer reference (6).
	inscatch: bool
}

impl typeChecker {
	fn pushErr(mut self, token: &token::Token, fmt: build::LogMsg, args: ...any) {
		self.s.pushErr(token, fmt, args...)
	}

	fn allowBuiltin(mut self) {
		self.disBuiltin = false
	}

	fn disallowBuiltin(mut self) {
		self.disBuiltin = true
	}

	fn pushReference[T](mut self, mut &t: T) {
		if self.refers == nil {
			ret
		}
		if self.refers.Exist[T](t) {
			ret
		}
		self.refers.Push(t)
	}

	fn pushReferenceByKind(mut self, mut &k: &Type) {
		match {
		| k.softStruct() != nil:
			mut t := k.softStruct()
			self.pushReference[&StructIns](t)
		| k.Trait() != nil:
			mut t := k.Trait()
			self.pushReference[&Trait](t)
		}
	}

	fn pushCycleError(self, def1: any, def2: any, mut &message: strings::Builder) {
		const Padding = 7
		getIdent := fn(&def: any): str {
			match type def {
			| &TypeAlias:
				ret (&TypeAlias)(def).Ident
			| &Struct:
				ret (&Struct)(def).Ident
			|:
				ret ""
			}
		}
		m := message.Str()
		def1Ident := getIdent(def1)
		def2Ident := getIdent(def2)
		refersTo := build::Logf(build::LogMsg.RefersTo, def1Ident, def2Ident)
		message.WriteStr(strings::Repeat(" ", Padding))!
		message.WriteStr(refersTo)!
		message.WriteByte('\n')!
		message.WriteStr(m)!
	}

	fn checkCrossCycle(self, decl: any, mut &message: strings::Builder): bool {
		match type decl {
		| &TypeAlias:
			ta := (&TypeAlias)(decl)
			for _, d in ta.Refers {
				match {
				| self.referencer.owner == d:
					self.pushCycleError(ta, d, message)
					ret false
				| !self.checkCrossCycle(d, message):
					self.pushCycleError(ta, d, message)
					ret false
				}
			}
		| &Struct:
			s := (&Struct)(decl)
			for _, d in s.Depends {
				match {
				| self.referencer.owner == d:
					self.pushCycleError(s, d, message)
					ret false
				| !self.checkCrossCycle(d, message):
					self.pushCycleError(s, d, message)
					ret false
				}
			}
		}
		ret true
	}

	// Calls isIllegalCycle with error logs.
	fn checkIllegalCycles(mut self, &ident: &token::Token, mut decl: any): (ok: bool) {
		ret self.isIllegalCycleSafe(ident, decl, self.cycleErr&cycleErrEnable == cycleErrEnable)
	}

	// Reports illegal cycles for supported declarations, whether it not exist.
	// Appends reference to reference if there is no illegal cycle.
	// Returns true if self.referencer is nil.
	// Returns true if refers is nil.
	// If err is true, logs error about cycles.
	fn isIllegalCycleSafe(mut self, &ident: &token::Token, mut decl: any, err: bool): (ok: bool) {
		self.cycleErr &= ^cycleErrFail
		if self.referencer == nil || !self.cycleRisk {
			ret true
		}

		match type decl {
		| &Struct:
			if (&Struct)(decl).Binded {
				ret true
			}
		| &TypeAlias:
			if (&TypeAlias)(decl).Binded {
				ret true
			}
		}

		// Check illegal cycle for itself.
		// Because refers's owner is decl.
		if self.referencer.owner == decl {
			if err {
				self.pushErr(ident, build::LogMsg.IllegalCycleRefersItself, self.referencer.ident)
			}
			self.cycleErr |= cycleErrFail
			ret false
		}

		mut message := strings::Builder{}
		message.Grow(1 << 5)

		if !self.checkCrossCycle(decl, message) {
			if err {
				mut errMsg := message.Str()
				message.Clear()
				self.pushCycleError(self.referencer.owner, decl, message)
				errMsg += message.Str()
				self.pushErr(ident, build::LogMsg.IllegalCrossCycle, errMsg)
			}
			self.cycleErr |= cycleErrFail
			ret false
		}

		match type self.referencer.owner {
		| &TypeAlias:
			unsafe {
				*self.referencer.refs = append(*self.referencer.refs, decl)
			}
		| &Struct:
			match type decl {
			| &Struct:
				mut s := (&Struct)(self.referencer.owner)
				s.Depends = append(s.Depends, (&Struct)(decl))
			}
		}

		ret true
	}

	fn fromTypeAlias(mut self, mut &decl: &ast::IdentType, mut &ta: &TypeAlias): Kind {
		if !self.s.isAccessibleDefine(ta.Public, ta.Token) {
			self.pushErr(decl.Token, build::LogMsg.IdentNotExist, decl.Ident)
			ret nil
		}

		ta.Used = true

		if len(decl.Generics) > 0 {
			self.pushErr(decl.Token, build::LogMsg.TypeNotSupportsGenerics, decl.Ident)
			ret nil
		}

		// Enable instantiation cycle catching if type alias is
		// one of the banned generics.
		if !self.inscatch && self.bannedGenerics != nil {
			self.inscatch = true
			for _, bg in self.bannedGenerics {
				if bg == ta || ta.TypeSym.Type != nil && ta.TypeSym.Type.Equal(bg.TypeSym.Type) {
					self.inscatch = false
					break
				}
			}
		}

		// Catch instantiation cycles.
		// See developer reference (5).
		if self.inscatch {
			for _, bg in self.bannedGenerics {
				if bg == ta {
					self.pushErr(decl.Token, build::LogMsg.InitiationCycle, decl.Ident)
					ret nil
				}
				for _, dg in ta.Generics {
					if bg == dg {
						self.pushErr(decl.Token, build::LogMsg.InitiationCycle, decl.Ident)
						ret nil
					}
				}
			}
		}

		// Build kind if not builded already.
		if ta.TypeSym.Type == nil {
			ok := self.s.checkTypeAliasDecl(ta, self.lookup)
			if !ok {
				ret nil
			}
		}

		if ta.Strict && self.s.step&stepFlag.ImplsImplemented == stepFlag.ImplsImplemented {
			// Check strict type structure if impl statements are implemented.
			mut s := ta.TypeSym.Type.softStruct()
			if !s.Checked {
				ok := self.checkStructIns(s, decl.Token)
				if !ok {
					ret nil
				}
			}
		}

		{
			mut s := ta.TypeSym.Type.Struct()
			if s != nil {
				ok := self.checkIllegalCycles(decl.Token, s.Decl)
				if !ok && self.cycleErr&cycleErrEnable == cycleErrEnable {
					ret nil
				}
			}
		}

		// Push generic reference to owner type alias.
		// See developer reference (3) and (4) for more information.
		if ta.Generic && self.ownerAlias != nil {
			self.ownerAlias.Generics = append(self.ownerAlias.Generics, ta)
		}

		mut tk := &Type{
			Generic: ta.Generic,
			Kind: ta.TypeSym.Type.Kind,
		}
		self.pushReferenceByKind(tk)
		ret tk
	}

	fn fromEnum(mut self, &decl: &ast::IdentType, mut &e: &Enum): &Enum {
		if !self.s.isAccessibleDefine(e.Public, e.Token) {
			self.pushErr(decl.Token, build::LogMsg.IdentNotExist, decl.Ident)
			ret nil
		}
		if len(decl.Generics) > 0 {
			self.pushErr(decl.Token, build::LogMsg.TypeNotSupportsGenerics, decl.Ident)
			ret nil
		}
		ret e
	}

	fn fromTypeEnum(mut self, &decl: &ast::IdentType, mut &e: &TypeEnum): &TypeEnum {
		if !self.s.isAccessibleDefine(e.Public, e.Token) {
			self.pushErr(decl.Token, build::LogMsg.IdentNotExist, decl.Ident)
			ret nil
		}
		if len(decl.Generics) > 0 {
			self.pushErr(decl.Token, build::LogMsg.TypeNotSupportsGenerics, decl.Ident)
			ret nil
		}
		ret e
	}

	fn fromTrait(mut self, &decl: &ast::IdentType, mut &t: &Trait): &Trait {
		if !self.s.isAccessibleDefine(t.Public, t.Token) {
			self.pushErr(decl.Token, build::LogMsg.IdentNotExist, decl.Ident)
			ret nil
		}
		if len(decl.Generics) > 0 {
			self.pushErr(decl.Token, build::LogMsg.TypeNotSupportsGenerics, decl.Ident)
			ret nil
		}
		self.pushReference[&Trait](t)
		ret t
	}

	fn checkStructIns(mut self, mut &ins: &StructIns, mut &errorToken: &token::Token): (ok: bool) {
		if ins.Checked {
			ret true
		}
		ins.Checked = true

		// Break algorithm cycle.
		if self.referencer != nil && self.referencer.owner == ins.Decl {
			ret true
		}

		if !self.s.precheckStructIns(ins, errorToken) {
			ret false
		}
		if len(ins.Generics) > 0 {
			self.s.checkStructIns(ins)
		}
		ret true
	}

	fn appendUsedStructReference(mut self, mut &s: &Struct) {
		if self.referencer == nil {
			ret
		}
		match type self.referencer.owner {
		| &Struct:
			mut refS := (&Struct)(self.referencer.owner)
			if !refS.IsUses(s) {
				refS.Uses = append(refS.Uses, s)
			}
		}
	}

	fn buildStructInstance(mut self, mut &decl: &ast::IdentType, mut &s: &Struct): &StructIns {
		// Save configuration.
		mut referencer := self.referencer
		self.referencer = nil
		mut bannedGenerics := self.bannedGenerics

		// Set banned generics to catch initiation cycles.
		// This just necessary for root, therefore avoid set each time.
		if self.bannedGenerics == nil {
			match type self.lookup {
			| &scopeChecker:
				mut sc := (&scopeChecker)(self.lookup)
				mut hard := sc.getHardRoot()
				if hard.owner.Owner == nil || hard.owner.Owner.Decl != s {
					break
				}
				n := len(hard.owner.Generics) + len(hard.owner.Owner.Generics)
				// Add scope generics to to catch instantiation cycles.
				// See developer reference (5).
				self.bannedGenerics = hard.table.TypeAliases[:n]
			}
		} else {
			self.inscatch = true
		}

		// Use rootLookup to parse generics with current current.
		mut lookup := self.lookup
		self.lookup = self.rootLookup

		// Build generics.
		mut ins := s.instance()
		ins.Generics = make([]&InsGeneric, 0, len(decl.Generics))
		for (_, mut g) in decl.Generics {
			mut kind := self.build(g.Kind)
			if kind == nil {
				ret nil
			}
			ins.Generics = append(ins.Generics, &InsGeneric{Type: kind})
		}

		// Restore configuration.
		self.lookup = lookup
		self.bannedGenerics = bannedGenerics
		self.referencer = referencer

		ret ins
	}

	fn fromStructIns(mut self, mut &ins: &StructIns, mut token: &token::Token): &StructIns {
		mut existInstance := ins.Decl.appendInstance(ins)
		if existInstance != nil {
			if !self.s.checkConstraintsStruct(ins, token, existInstance) {
				ret nil
			}
			// Already checked instance, did not appended.
			// So, this instance is not unique.
			self.pushReference[&StructIns](existInstance)
			ret existInstance
		}
		if !self.checkStructIns(ins, token) {
			ret nil
		}
		self.pushReference[&StructIns](ins)
		ret ins
	}

	fn fromStruct(mut self, mut &decl: &ast::IdentType, mut &s: &Struct): &StructIns {
		if !self.s.isAccessibleDefine(s.Public, s.Token) {
			self.pushErr(decl.Token, build::LogMsg.IdentNotExist, decl.Ident)
			ret nil
		}

		// Name selection.
		// Return instance instantly.
		if self.selection {
			if len(decl.Generics) > 0 {
				self.pushErr(decl.Token, build::LogMsg.GenericsNotAllowed)
				ret nil
			}
			ret &StructIns{
				Decl: s,
			}
		}

		mut ok := self.checkIllegalCycles(decl.Token, s)
		if !ok && self.cycleErr&cycleErrEnable == cycleErrEnable {
			ret nil
		}
		self.appendUsedStructReference(s)

		mut ins := self.buildStructInstance(decl, s)
		if ins == nil {
			ret nil
		}

		ok = self.s.checkGenericQuantity(len(ins.Decl.Generics), len(ins.Generics), decl.Token)
		if !ok {
			ret nil
		}

		ret self.fromStructIns(ins, decl.Token)
	}

	// Returns identifier if found. Also checks founded identifier.
	// Uses internal lookup for all process except finding step of identifier.
	// Will find identifier in [l], not internal lookup.
	// Also finds in built-in lookup if allowed.
	// If another lookup nedeed, uses internal lookup, so any generic type build
	// process will use internal lookup. This might be useful for building
	// genericed type from another package.
	fn getDef(mut self, mut &decl: &ast::IdentType): Kind {
		for _, g in self.ignoreGenerics {
			if g.Ident == decl.Ident {
				ret buildPrimType(g.Ident)
			}
		}

		for (_, mut g) in self.useGenerics {
			if g.Ident == decl.Ident {
				if len(decl.Generics) > 0 {
					self.pushErr(decl.Token, build::LogMsg.TypeNotSupportsGenerics, decl.Ident)
					ret nil
				}
				mut st := g.TypeSym.Type.Struct()
				if st != nil {
					ok := self.checkIllegalCycles(decl.Token, st.Decl)
					if !ok && self.cycleErr&cycleErrEnable == cycleErrEnable {
						ret nil
					}
				}
				ret g.TypeSym.Type.Kind
			}
		}

		if !decl.Binded {
			mut e := self.lookup.FindEnum(decl.Ident)
			if e != nil {
				ret self.fromEnum(decl, e)
			}

			mut te := self.lookup.FindTypeEnum(decl.Ident)
			if te != nil {
				ret self.fromTypeEnum(decl, te)
			}

			mut t := self.lookup.FindTrait(decl.Ident)
			if t != nil {
				ret self.fromTrait(decl, t)
			}
		} else if self.selection {
			self.pushErr(decl.Token, build::LogMsg.BindedTypeNotAllowed)
			ret nil
		}

		mut s := self.lookup.FindStruct(decl.Ident, decl.Binded)
		if s != nil {
			ret self.fromStruct(decl, s)
		}

		mut ta := self.lookup.FindTypeAlias(decl.Ident, decl.Binded)
		if ta == nil && !self.disBuiltin {
			ta = findBuiltinTypeAlias(decl.Ident)
		}
		if ta != nil {
			ret self.fromTypeAlias(decl, ta)
		}

		self.pushErr(decl.Token, build::LogMsg.IdentNotExist, decl.Ident)
		ret nil
	}

	fn buildIdent(mut self, mut decl: &ast::IdentType): Kind {
		ret self.getDef(decl)
	}

	fn buildSubIdent(mut self, mut decl: &ast::SubIdentType): Kind {
		mut ident := self.buildIdent(decl.Idents[0])
		if ident == nil {
			ret nil
		}
		match type ident {
		| &TypeEnum:
			break
		|:
			self.pushErr(self.errorToken, build::LogMsg.InvalidSyntax)
			ret nil
		}
		mut t := (&TypeEnum)(ident)
		mut idents := decl.Idents[1:]
		for i, id in idents {
			mut item := t.FindItem(id.Ident)
			if item == nil {
				self.pushErr(id.Token, build::LogMsg.ObjHaveNotIdent, t.Ident, id.Ident)
				ret nil
			}
			if len(idents)-i == 1 {
				self.pushReferenceByKind(item.TypeSym.Type)
				ret item.TypeSym.Type
			}
			t = item.TypeSym.Type.TypeEnum()
			if t == nil {
				self.pushErr(self.errorToken, build::LogMsg.InvalidSyntax)
				ret nil
			}
		}
		// Should be unreachable.
		ret nil
	}

	fn buildSptrFromType(mut self, mut &elem: &Type): &Sptr {
		// Check special cases.
		match {
		| elem == nil:
			ret nil
		| elem.Array() != nil && elem.Array().Auto:
			self.pushErr(self.errorToken, build::LogMsg.ArrayAutoSized)
			ret nil
		}
		ret &Sptr{
			Elem: elem,
		}
	}

	fn buildSptr(mut self, mut decl: &ast::SptrType): &Sptr {
		cycleRisk := self.cycleRisk
		self.cycleRisk = false
		defer { self.cycleRisk = cycleRisk }

		mut elem := self.checkDecl(decl.Elem)
		ret self.buildSptrFromType(elem)
	}

	fn buildChan(mut self, mut decl: &ast::ChanType): &Chan {
		cycleRisk := self.cycleRisk
		self.cycleRisk = false
		defer { self.cycleRisk = cycleRisk }

		mut elem := self.checkDecl(decl.Elem)
		if elem == nil {
			ret nil
		}
		if self.s.meta.runtime != nil {
			mut s := runtimeFindStruct(self.s.meta.runtime, "pchan")
			self.appendUsedStructReference(s)
			mut ins := s.instance()
			ins.Generics = [&InsGeneric{Type: elem}]
			_ = self.fromStructIns(ins, decl.Elem.Token)
		}
		ret &Chan{
			Recv: decl.Recv,
			Send: decl.Send,
			Elem: elem,
		}
	}

	fn buildPtrFromType(mut self, mut &elem: &Type): &Ptr {
		// Check special cases.
		match {
		| elem == nil:
			ret nil
		| elem.Array() != nil && elem.Array().Auto:
			self.pushErr(self.errorToken, build::LogMsg.ArrayAutoSized)
			ret new(Ptr)
		}

		ret &Ptr{
			Elem: elem,
		}
	}

	fn buildPtr(mut self, mut decl: &ast::PtrType): &Ptr {
		cycleRisk := self.cycleRisk
		self.cycleRisk = false
		defer { self.cycleRisk = cycleRisk }

		mut elem := (&Type)(nil)

		if !decl.IsUnsafe() {
			elem = self.checkDecl(decl.Elem)
			ret self.buildPtrFromType(elem)
		}

		ret &Ptr{
			Elem: elem,
		}
	}

	fn buildSlice(mut self, mut decl: &ast::SliceType): &Slice {
		cycleRisk := self.cycleRisk
		self.cycleRisk = false
		defer { self.cycleRisk = cycleRisk }

		mut elem := self.checkDecl(decl.Elem)

		// Check special cases.
		match {
		| elem == nil:
			ret nil
		| elem.Array() != nil && elem.Array().Auto:
			self.pushErr(decl.Elem.Token, build::LogMsg.ArrayAutoSized)
			ret nil
		}

		ret &Slice{
			Elem: elem,
		}
	}

	fn buildArray(mut self, mut decl: &ast::ArrayType): &Array {
		mut n := 0

		if !decl.AutoSized() {
			mut size := self.s.eval(self.lookup).evalExpr(decl.Size)
			if size == nil {
				ret nil
			}

			if !size.IsConst() {
				self.pushErr(decl.Size.Token, build::LogMsg.ExprNotConst)
				ret nil
			} else if size.Type.Prim() == nil || !types::IsInt(size.Type.Prim().Kind) {
				self.pushErr(decl.Size.Token, build::LogMsg.ArraySizeIsNotInt)
				ret nil
			}

			n = int(size.Constant.AsI64())
			if n < 0 {
				self.pushErr(decl.Elem.Token, build::LogMsg.ArraySizeIsNeg)
				ret nil
			} else {
				max := types::MaxI(types::Kind.Int)
				if types::BitSize != 64 && i64(n) > max {
					self.pushErr(decl.Size.Token, build::LogMsg.ArraySizeOverflow,
						constoa(size.Constant), conv::FmtInt(max, 10))
					ret nil
				}
			}
		}

		mut elem := self.checkDecl(decl.Elem)

		// Check special cases.
		match {
		| elem == nil:
			ret nil
		| elem.Array() != nil && elem.Array().Auto:
			self.pushErr(decl.Elem.Token, build::LogMsg.ArrayAutoSized)
			ret nil
		}

		ret &Array{
			Auto: decl.AutoSized(),
			N: n,
			Elem: elem,
		}
	}

	fn buildMap(mut self, mut decl: &ast::MapType): &Map {
		// Evaluate key type with cycle risk, but do not log errors about it.
		// We have to do this for checking correct map type dependencies,
		// cycle types are prevents valid map key types. So, caught them but
		// do not log as cycle error, log as invalid key type error.
		// Also remove appended references or depencies after analysis for types.
		cycleErr := self.cycleErr
		self.cycleErr &= ^cycleErrFail
		self.cycleErr &= ^cycleErrEnable
		mut refCount := 0
		if self.referencer != nil {
			match type self.referencer.owner {
			| &TypeAlias:
				refCount = unsafe { len(*self.referencer.refs) }
			| &Struct:
				refCount = len((&Struct)(self.referencer.owner).Depends)
			}
		}
		mut key := self.checkDecl(decl.Key)
		if self.referencer != nil {
			match type self.referencer.owner {
			| &TypeAlias:
				unsafe { *self.referencer.refs = (*self.referencer.refs)[:refCount] }
			| &Struct:
				mut s := (&Struct)(self.referencer.owner)
				s.Depends = s.Depends[:refCount]
			}
		}
		if key == nil {
			self.cycleErr = cycleErr
			ret nil
		}
		// Check wther key type is valid.
		// It should be comparable, if cycle analysis failed, we have cycles,
		// so we have a map type (this type, actually), so it is not comparable.
		if self.cycleErr&cycleErrFail == cycleErrFail || !key.Comparable() {
			self.cycleErr = cycleErr
			self.s.pushErr(decl.Key.Token, build::LogMsg.ConstraintFailed, key.Str(), "Key", str(builtinConstraint.Comparable))
			ret nil
		}
		self.cycleErr = cycleErr

		// Evaluate value type with no cycle risk.
		cycleRisk := self.cycleRisk
		self.cycleRisk = false
		mut val := self.checkDecl(decl.Val)
		self.cycleRisk = cycleRisk
		if val == nil {
			ret nil
		}
		if val.Enum() != nil {
			self.pushErr(decl.Val.Token, build::LogMsg.EnumAsMapVal)
		}

		if self.s.meta.runtime != nil {
			mut s := runtimeFindStruct(self.s.meta.runtime, "_Map")
			self.appendUsedStructReference(s)
			mut ins := s.instance()
			ins.Generics = [&InsGeneric{Type: key}, &InsGeneric{Type: val}]
			_ = self.fromStructIns(ins, decl.Key.Token)
		}

		ret &Map{
			Key: key,
			Val: val,
		}
	}

	fn buildTuple(mut self, mut decl: &ast::TupleType): &Tuple {
		mut types := make([]&Type, 0, len(decl.Types))
		for (_, mut t) in decl.Types {
			mut kind := self.checkDecl(t)
			if kind == nil {
				ret nil
			}
			types = append(types, kind)
		}

		ret &Tuple{Types: types}
	}

	fn checkFuncTypes(mut self, mut &f: &FuncIns): (ok: bool) {
		for (_, mut p) in f.Params {
			p.Type = self.build(p.Decl.TypeSym.Decl.Kind)
			ok = p.Type != nil
			if !ok {
				ret false
			}
			self.s.checkFuncParamKind(p)
		}

		if !f.Decl.IsVoid() {
			f.Result = self.build(f.Decl.Result.TypeSym.Decl.Kind)
			ret f.Result != nil
		}

		ret true
	}

	fn buildFunc(mut self, mut decl: &ast::Func): &FuncIns {
		cycleRisk := self.cycleRisk
		self.cycleRisk = false
		defer { self.cycleRisk = cycleRisk }

		if len(decl.Generics) > 0 {
			self.pushErr(decl.Token, build::LogMsg.GenericedFuncAsAnonFunc)
			ret nil
		}

		mut f := buildFunc(decl)

		n := len(self.s.errors)
		self.s.checkAnonFuncDecl(f)
		if n != len(self.s.errors) {
			ret nil
		}

		mut ins := f.instanceForce()
		ins.Anon = true
		ins.AsAnon = true

		ok := self.checkFuncTypes(ins)
		if !ok {
			ret nil
		}

		ret ins
	}

	fn buildNamespace(mut self, mut ns: &ast::NamespaceType): Kind {
		mut imp := findNamespace(self.lookup, ns.Namespace.Kind)
		if imp == nil || !imp.isLookupable() {
			self.pushErr(ns.Namespace, build::LogMsg.NamespaceNotExist, ns.Namespace.Kind)
			ret nil
		}

		self.disallowBuiltin()
		mut lookup := self.lookup
		self.lookup = imp
		mut kind := self.checkDecl(ns.Kind)
		self.lookup = lookup
		self.allowBuiltin()
		ret kind
	}

	fn build(mut self, mut &declKind: ast::TypeKind): &Type {
		let mut kind: Kind = nil
		match type declKind {
		| &ast::IdentType:
			mut t := self.buildIdent((&ast::IdentType)(declKind))
			if t != nil {
				kind = t
			}
		| &ast::SubIdentType:
			mut t := self.buildSubIdent((&ast::SubIdentType)(declKind))
			if t != nil {
				kind = t
			}
		| &ast::ChanType:
			self.inscatch = true
			mut t := self.buildChan((&ast::ChanType)(declKind))
			if t != nil {
				kind = t
			}
		| &ast::SptrType:
			self.inscatch = true
			mut t := self.buildSptr((&ast::SptrType)(declKind))
			if t != nil {
				kind = t
			}
		| &ast::PtrType:
			self.inscatch = true
			mut t := self.buildPtr((&ast::PtrType)(declKind))
			if t != nil {
				kind = t
			}
		| &ast::SliceType:
			self.inscatch = true
			mut t := self.buildSlice((&ast::SliceType)(declKind))
			if t != nil {
				kind = t
			}
		| &ast::ArrayType:
			self.inscatch = true
			mut t := self.buildArray((&ast::ArrayType)(declKind))
			if t != nil {
				kind = t
			}
		| &ast::MapType:
			self.inscatch = true
			mut t := self.buildMap((&ast::MapType)(declKind))
			if t != nil {
				kind = t
			}
		| &ast::TupleType:
			self.inscatch = true
			mut t := self.buildTuple((&ast::TupleType)(declKind))
			if t != nil {
				kind = t
			}
		| &ast::Func:
			self.inscatch = true
			mut t := self.buildFunc((&ast::Func)(declKind))
			if t != nil {
				kind = t
			}
		| &ast::NamespaceType:
			self.inscatch = true
			mut t := self.buildNamespace((&ast::NamespaceType)(declKind))
			if t != nil {
				kind = t
			}
		|:
			self.pushErr(self.errorToken, build::LogMsg.InvalidType)
			ret nil
		}
		if kind == nil {
			ret nil
		}
		match type kind {
		| &Type:
			ret (&Type)(kind)
		|:
			mut tk := &Type{Kind: kind}
			match type kind {
			| &Prim:
				if self.ignoredGenerics != nil {
					unsafe { *self.ignoredGenerics = append(*self.ignoredGenerics, tk) }
				}
			}
			ret tk
		}
	}

	fn checkDecl(mut self, mut &decl: &ast::Type): &Type {
		// Save current token.
		mut errorToken := self.errorToken

		self.errorToken = decl.Token
		mut kind := self.build(decl.Kind)
		self.errorToken = errorToken

		ret kind
	}

	fn check(mut self, mut &t: &TypeSym) {
		if t.Decl == nil {
			ret
		}
		mut kind := self.checkDecl(t.Decl)
		if kind == nil {
			t.removeKind()
			ret
		}
		t.Type = kind
	}
}

struct identTypeLookup{}

impl identTypeLookup {
	static fn prim(&ident: str, t: &Prim): bool {
		ret t.Kind == ident
	}

	static fn exist(&ident: str, mut &k: &Type): bool {
		match {
		| k.Prim() != nil:
			ret identTypeLookup.prim(ident, k.Prim())
		| k.Chan() != nil:
			mut ch := k.Chan()
			ret identTypeLookup.exist(ident, ch.Elem)
		| k.Sptr() != nil:
			mut sptr := k.Sptr()
			ret identTypeLookup.exist(ident, sptr.Elem)
		| k.Ptr() != nil:
			mut ptr := k.Ptr()
			ret identTypeLookup.exist(ident, ptr.Elem)
		| k.Slice() != nil:
			mut slc := k.Slice()
			ret identTypeLookup.exist(ident, slc.Elem)
		| k.Array() != nil:
			mut arr := k.Array()
			ret identTypeLookup.exist(ident, arr.Elem)
		| k.Map() != nil:
			mut m := k.Map()
			ret identTypeLookup.exist(ident, m.Key) ||
				identTypeLookup.exist(ident, m.Val)
		| k.Struct() != nil:
			mut s := k.Struct()
			for (_, mut g) in s.Generics {
				if identTypeLookup.exist(ident, g.Type) {
					ret true
				}
			}
			ret false
		| k.Func() != nil:
			mut f := k.Func()
			for (_, mut p) in f.Params {
				if p.Decl.IsSelf() {
					continue
				}
				if identTypeLookup.exist(ident, p.Type) {
					ret true
				}
			}
			if f.Result != nil {
				ret identTypeLookup.exist(ident, f.Result)
			}
			ret false
		| k.Tuple() != nil:
			mut tup := k.Tuple()
			for (_, mut t) in tup.Types {
				if identTypeLookup.exist(ident, t) {
					ret true
				}
			}
			ret false
		|:
			ret false
		}
	}
}

fn kindUsesGenerics(mut &k: &Type, &generics: []&ast::Generic): bool {
	for _, g in generics {
		if identTypeLookup.exist(g.Ident, k) {
			ret true
		}
	}
	ret false
}

// Reports whether directive is exist.
fn hasDirective(mut &directives: []&ast::Directive, tag: str): bool {
	for (_, mut dr) in directives {
		if dr.Tag.Kind == tag {
			ret true
		}
	}
	ret false
}

fn canGetPtr(mut &d: &Data): bool { ret d.Lvalue }

// Reports whether type has built-in string conversion support.
fn isBuiltinStrConvertable(mut &t: &Type): bool {
	ret !t.Void() && t.Func() == nil && t.Tuple() == nil && !t.comptime()
}

fn buildPrimType(kind: str): &Prim {
	ret &Prim{
		Kind: kind,
	}
}

fn getStructFromKind(mut k: &Type): &Struct {
	match {
	| k == nil:
		ret nil
	| k.Struct() != nil:
		ret k.Struct().Decl
	| k.Sptr() != nil:
		ret getStructFromKind(k.Sptr().Elem)
	| k.Slice() != nil:
		ret getStructFromKind(k.Slice().Elem)
	| k.Array() != nil:
		ret getStructFromKind(k.Array().Elem)
	| k.Ptr() != nil:
		// Pass pointers.
		// Cloning just copies pointer address.
		// There is no any illegal cycle risk.
		ret nil
	|:
		ret nil
	}
}

fn applyImplicitCast(mut &s: &sema, mut &dest: &Type, mut &d: &Data,
	mut &token: &token::Token, mut refers: &ReferenceStack) {
	if d.Type.IsNil() {
		ret
	}
	destPrim := dest.Prim()
	if destPrim != nil && destPrim.IsAny() {
		prim := d.Type.Prim()
		if prim == nil || !prim.IsAny() {
			applyCastKind(s, d, dest, token, refers)
		}
		ret
	}

	dt := dest.Trait()
	if dt != nil {
		bt := d.Type.Trait()
		if bt == nil || bt != dt {
			applyCastKindModel(s, d, dest, token, refers)
			ret
		}
	}

	if dest.TypeEnum() != nil && d.Type.TypeEnum() == nil {
		applyCastKindModel(s, d, dest, token, refers)
		ret
	}
}

// Reports whether type is valid for SizeOf/AlignOf functions.
fn validTypeForXof(mut &t: &Type): bool {
	ret !t.Void() && t.Func() == nil && t.Tuple() == nil && !t.comptime()
}

// Initializes new structure for strict types.
// See developer reference (11) for details.
fn initNewStructType(ident: str, mut source: &Type): &StructIns {
	mut s := new(Struct)
	s.Ident = ident
	mut ins := s.instance()
	s.appendInstance(ins)
	ins.Source = source
	ins.Comparable = source.Comparable()
	ins.Mutable = source.Mutable()
	ret ins
}
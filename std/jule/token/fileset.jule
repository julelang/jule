// Copyright 2023-2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/unsafe"
use "std/os/filepath"

// Fileset for lexing.
struct Fileset {
	// Data should be private, because lexical analysis uses same allocation as much as possible.
	// And mutating this field may cause mutations of string copies.
	data: []byte

	Path:   str
	Tokens: []&Token
}

impl Fileset {
	// Returns new Fileset with path.
	static fn New(path: str): &Fileset {
		ret &Fileset{
			Path: path,
		}
	}

	// Fills data.
	// Not uses mutable copy of data, allocates new copy.
	fn Fill(mut self, data: []byte) {
		self.data = append(make([]byte, 0, len(data)), data...)
	}

	// Fills data.
	// Uses mutable copy of data, not allocated new copy.
	// But it is unsafe, because any mutation on the data may cause inconsistent results.
	// However, it is efficient way to use already allocated datas.
	unsafe fn FillMut(mut self, mut data: []byte) {
		self.data = data
	}

	// Returns directory of file's path.
	fn Dir(self): str {
		ret filepath::Dir(self.Path)
	}

	// Returns filename.
	fn Name(self): str {
		ret filepath::Base(self.Path)
	}

	// Returns self as uintptr.
	fn Addr(self): uintptr {
		ret uintptr(&self)
	}

	// Returns line (not include new-line char) by row.
	// Returns empty string if line is not buffer.
	fn GetRow(self, row: int): str {
		mut n := 0
		mut lineStart := 0
		mut i := 0
		for i < len(self.data); i++ {
			if self.data[i] != '\n' {
				continue
			}
			n++
			if n == row {
				ret unsafe::StrFromBytes(self.data[lineStart:i])
			}
			lineStart = i + 1
		}
		ret ""
	}
}
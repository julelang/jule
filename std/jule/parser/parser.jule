// Copyright 2023-2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/fs/path"
use "std/jule/ast"
use "std/jule/build"
use "std/jule/internal/mod"
use "std/jule/token"
use "std/strings"

fn makeErr(row: int, col: int, &f: &token::Fileset, fmt: build::LogMsg, args: ...any): build::Log {
	ret build::Log{
		Kind: build::LogKind.Error,
		Row: row,
		Column: col,
		Path: f.Path,
		Text: build::Logf(fmt, args...),
	}
}

// Returns between of open and close ranges.
// Starts selection at i.
// Increases i for each selected token.
// i points to close range token after selection.
//
// Special cases are:
//  range(i, open, close, tokens) = nil if i > len(tokens)
//  range(i, open, close, tokens) = nil if tokens[i].Id != open
fn range(mut &i: int, open: token::Id, close: token::Id, mut &tokens: []&token::Token): []&token::Token {
	if i >= len(tokens) {
		ret nil
	}
	tok := tokens[i]
	if tok.Id != open {
		ret nil
	}
	i++
	mut rangeN := 1
	start := i
	for rangeN != 0 && i < len(tokens); i++ {
		token := tokens[i]
		match token.Id {
		| open:
			rangeN++
		| close:
			rangeN--
		}
	}
	ret tokens[start:i-1]
}

// rangeLast returns last range from tokens.
// Returns tokens without range tokens and range tokens.
// Range tokens includes left and right range tokens.
//
// Special cases are;
//  rangeLast(tokens) = tokens, nil if len(tokens) == 0
//  rangeLast(tokens) = tokens, nil if tokens is not has range at last
fn rangeLast(mut &tokens: []&token::Token): (cutted: []&token::Token, cut: []&token::Token) {
	if len(tokens) == 0 {
		ret tokens, nil
	}
	first := tokens[len(tokens)-1].Id
	if first != token::Id.RBrace &&
		first != token::Id.LBracket &&
		first != token::Id.RParent {
		ret tokens, nil
	}
	mut braceN := 0
	mut i := len(tokens) - 1
	for i >= 0; i-- {
		token := tokens[i]
		match token.Id {
		| token::Id.RBrace
		| token::Id.RBracket
		| token::Id.RParent:
			braceN++
			continue
		| token::Id.LBrace
		| token::Id.LBracket
		| token::Id.LParent:
			braceN--
		}
		if braceN == 0 {
			ret tokens[:i], tokens[i:]
		}
	}
	ret tokens, nil
}

// Returns parts separated by given token identifier.
// It's skips parentheses ranges.
// Logs missing_expr if exprMust == true and not exist any expression for part.
//
// Special case is;
//  parts(tokens) = nil if len(tokens) == 0
fn parts(mut &tokens: []&token::Token, id: token::Id, exprMust: bool): (parts: [][]&token::Token, errors: []build::Log) {
	if len(tokens) == 0 {
		ret nil, nil
	}
	mut rangeN := 0
	mut last := 0
	for i, token in tokens {
		match token.Id {
		| token::Id.LBrace | token::Id.LBracket | token::Id.LParent:
			rangeN++
		| token::Id.RBrace | token::Id.RBracket | token::Id.RParent:
			rangeN--
		| id:
			if rangeN > 0 {
				continue
			}
			if exprMust && i-last <= 0 {
				err := makeErr(token.Row, token.Column, token.File, build::LogMsg.MissingExpr)
				errors = append(errors, err)
			}
			parts = append(parts, tokens[last:i])
			last = i + 1
		}
	}
	if last < len(tokens) {
		parts = append(parts, tokens[last:])
	}
	ret
}

fn getCloseOfBrace(left: token::Id): token::Id {
	match left {
	| token::Id.RParent:
		ret token::Id.LParent
	| token::Id.RBrace:
		ret token::Id.LBrace
	| token::Id.RBracket:
		ret token::Id.LBracket
	|:
		ret left
	}
}

fn compilerErr(&token: &token::Token, &fmt: build::LogMsg, args: ...any): build::Log {
	ret build::Log{
		Kind: build::LogKind.Error,
		Row: token.Row,
		Column: token.Column,
		Path: token.File.Path,
		Text: build::Logf(fmt, args...),
		Line: token.File.GetRow(token.Row),
	}
}

unsafe fn pushSuggestion(mut log: *build::Log, fmt: build::LogMsg, args: ...any) {
	log.Suggestion = build::Logf(fmt, args...)
}

struct parser {
	ast:        &ast::AST
	directives: []&ast::Directive
	errors:     []build::Log

	ep: &exprBuilder
}

impl parser {
	fn stop(mut self) { self.ast = nil }
	fn stopped(self): bool { ret self.ast == nil }

	// Appends error by specified token, key and args.
	fn pushErr(mut self, token: &token::Token, fmt: build::LogMsg, args: ...any) {
		self.errors = append(self.errors, compilerErr(token, fmt, args...))
	}

	// Push suggestion to last log.
	fn pushSuggestion(mut self, fmt: build::LogMsg, args: ...any) {
		unsafe { pushSuggestion(&self.errors[len(self.errors)-1], fmt, args...) }
	}

	fn buildExpr(mut &self, mut &tokens: []&token::Token): &ast::Expr {
		ret self.ep.buildFromTokens(tokens)
	}

	fn buildDirective(mut self, mut tokens: []&token::Token): &ast::Directive {
		if len(tokens) == 1 {
			self.pushErr(tokens[0], build::LogMsg.InvalidSyntax)
			ret nil
		}
		if tokens[1].Column != tokens[0].Column+1 {
			self.pushErr(tokens[0], build::LogMsg.InvalidSyntax)
			ret nil
		}
		ret &ast::Directive{
			Tag: tokens[1],
			Args: tokens[2:], // Start 2 to skip '#', and tag tokens. 
		}
	}

	fn pushDirective(mut self, mut d: &ast::Directive) {
		if d == nil {
			ret
		}
		// Don't append if already added this directive.
		for _, pd in self.directives {
			if d.Tag.Kind == pd.Tag.Kind {
				ret
			}
		}
		self.directives = append(self.directives, d)
	}

	fn buildScope(mut &self, mut &tokens: []&token::Token, mut end: &token::Token): &ast::ScopeTree {
		mut s := newScope()
		s.End = end
		mut sp := scopeParser{
			p: self,
		}
		sp.build(tokens, s)
		ret s
	}

	unsafe fn _buildType(mut &self, mut &tokens: []&token::Token,
		mut i: *int, err: bool): (&ast::TypeDecl, bool) {
		mut tb := typeBuilder{
			p: self,
			tokens: tokens,
			i: i,
			err: err,
		}
		ret tb.build()
	}

	// Builds AST model of data-type.
	unsafe fn buildType(mut &self, mut &tokens: []&token::Token,
		mut i: *int, err: bool): (&ast::TypeDecl, bool) {
		token := tokens[*i]
		mut t, ok := self._buildType(tokens, i, err)
		if err && !ok {
			self.pushErr(token, build::LogMsg.InvalidType)
		}
		ret t, ok
	}

	fn buildTypeAliasDecl(mut &self, mut &tokens: []&token::Token): &ast::TypeAliasDecl {
		mut i := 1 // Skip "type" keyword.
		if i >= len(tokens) {
			self.pushErr(tokens[i-1], build::LogMsg.InvalidSyntax)
			ret nil
		}
		mut tad := &ast::TypeAliasDecl{
			Token: tokens[1],
			Ident: tokens[1].Kind,
		}
		mut token := tokens[i]
		if token.Id != token::Id.Ident {
			self.pushErr(token, build::LogMsg.InvalidSyntax)
			self.pushSuggestion(build::LogMsg.ExpectedIdentifier)
		}
		i++
		if i >= len(tokens) {
			self.pushErr(tokens[i-1], build::LogMsg.InvalidSyntax)
			ret tad
		}
		token = tokens[i]
		if token.Id != token::Id.Colon {
			self.pushErr(tokens[i-1], build::LogMsg.InvalidSyntax)
			self.pushSuggestion(build::LogMsg.ExpectedColon)
			ret tad
		}
		i++
		if i >= len(tokens) {
			self.pushErr(tokens[i-1], build::LogMsg.MissingType)
			ret tad
		}
		mut t, ok := unsafe { self.buildType(tokens, &i, true) }
		tad.Kind = t
		if ok && i < len(tokens) {
			self.pushErr(tokens[i], build::LogMsg.InvalidSyntax)
		}
		tad.Public = mod::IsPub(tad.Ident)
		ret tad
	}

	fn buildVarTypeAndExpr(mut &self, mut &v: &ast::VarDecl, mut &tokens: []&token::Token) {
		mut i := 0
		mut tok := tokens[i]
		if tok.Id == token::Id.Colon {
			i++ // Skip type annotation operator (:)
			if i >= len(tokens) || tokens[i].Id == token::Id.Eq {
				self.pushErr(tok, build::LogMsg.MissingType)
				ret
			}
			mut t, ok := unsafe { self.buildType(tokens, &i, true) }
			if ok {
				v.Kind = t
				if i >= len(tokens) {
					ret
				}
				tok = tokens[i]
			}
		}

		if tok.Id != token::Id.Eq {
			self.pushErr(tok, build::LogMsg.InvalidSyntax)
			ret
		}
		v.Setter = tok

		mut exprTokens := tokens[i+1:]
		if len(exprTokens) == 0 {
			self.pushErr(tok, build::LogMsg.MissingExpr)
			ret
		}
		v.Expr = self.buildExpr(exprTokens)
	}

	fn buildVarCommon(mut &self, mut &v: &ast::VarDecl, mut tokens: []&token::Token) {
		v.Token = tokens[0]
		if v.Token.Id != token::Id.Ident {
			self.pushErr(v.Token, build::LogMsg.InvalidSyntax)
			self.pushSuggestion(build::LogMsg.ExpectedIdentifier)
			ret
		}
		v.Ident = v.Token.Kind
		v.Public = mod::IsPub(v.Ident)
		v.Kind = nil // For auto-type.
		if len(tokens) > 1 {
			tokens = tokens[1:] // Remove identifier.
			self.buildVarTypeAndExpr(v, tokens)
		}
	}

	fn buildVarBegin(mut self, mut &v: &ast::VarDecl, mut &tokens: []&token::Token) {
		tok := tokens[0]
		match tok.Id {
		| token::Id.Static:
			v.Statically = true
			fall
		| token::Id.Let:
			// Initialize 1 for skip the let keyword
			if len(tokens) == 1 {
				tokens = nil
				self.pushErr(tok, build::LogMsg.InvalidSyntax)
				ret
			}
			tokens = tokens[1:]
			if tokens[0].Id == token::Id.Mut {
				v.Mutable = true
				// Skip the mut keyword
				tokens = tokens[1:]
			}
		| token::Id.Const:
			v.Constant = true
			tokens = tokens[1:]
		|:
			tokens = nil
			self.pushErr(tok, build::LogMsg.InvalidSyntax)
		}
	}

	fn buildVar(mut &self, mut tokens: []&token::Token): &ast::VarDecl {
		mut v := &ast::VarDecl{
			Token: tokens[0],
		}
		self.buildVarBegin(v, tokens)
		if len(tokens) == 0 {
			ret nil
		}
		if tokens[0].Id == token::Id.Amper {
			v.Reference = true
			if len(tokens) == 1 {
				ret nil
			}
			tokens = tokens[1:]
		}
		self.buildVarCommon(v, tokens)
		ret v
	}

	fn buildGeneric(mut &self, mut &tokens: []&token::Token): &ast::GenericDecl {
		mut g := &ast::GenericDecl{
			Token: tokens[0],
		}
		if g.Token.Id != token::Id.Ident {
			self.pushErr(g.Token, build::LogMsg.InvalidSyntax)
			self.pushSuggestion(build::LogMsg.ExpectedIdentifier)
		}
		g.Ident = g.Token.Kind
		if len(tokens) > 1 {
			if tokens[1].Id != token::Id.Colon {
				self.pushErr(tokens[1], build::LogMsg.InvalidSyntax)
				ret nil
			}
			if len(tokens) == 2 {
				self.pushErr(tokens[1], build::LogMsg.MissingExpr)
				ret nil
			}
			mut constraintTokens := tokens[2:]
			mut parts, errors := parts(constraintTokens, token::Id.Vline, true)
			if len(errors) > 0 {
				self.errors = append(self.errors, errors...)
				ret nil
			}
			g.Constraint = &ast::Constraint{Mask: make([]&ast::TypeDecl, 0, len(parts))}
			for (_, mut part) in parts {
				mut i := 0
				mut kind, _ := unsafe { self.buildType(part, &i, true) }
				g.Constraint.Mask = append(g.Constraint.Mask, kind)
				if i < len(part) {
					self.pushErr(part[i], build::LogMsg.InvalidSyntax)
				}
			}
		}
		ret g
	}

	fn buildGenerics(mut &self, mut &tokens: []&token::Token, &errorToken: &token::Token): []&ast::GenericDecl {
		if len(tokens) == 0 {
			self.pushErr(errorToken, build::LogMsg.MissingExpr)
			ret nil
		}

		mut parts, errors := parts(tokens, token::Id.Comma, true)
		if len(errors) > 0 {
			self.errors = append(self.errors, errors...)
			ret nil
		}

		mut generics := make([]&ast::GenericDecl, 0, len(parts))
		for (_, mut part) in parts {
			generics = append(generics, self.buildGeneric(part))
		}

		ret generics
	}

	fn buildSelfParam(mut self, mut tokens: []&token::Token): &ast::ParamDecl {
		if len(tokens) == 0 {
			ret nil
		}

		mut param := new(ast::ParamDecl)

		// Detects mut keyword.
		if tokens[0].Id == token::Id.Mut {
			param.Mutable = true
			if len(tokens) == 1 {
				self.pushErr(tokens[0], build::LogMsg.InvalidSyntax)
				ret nil
			}
			tokens = tokens[1:]
		}

		mut ident := strings::Builder.New(5)

		if tokens[0].Id == token::Id.Amper {
			ident.WriteStr(token::Kind.Amper)
			if len(tokens) == 1 {
				self.pushErr(tokens[0], build::LogMsg.InvalidSyntax)
				ret nil
			}
			tokens = tokens[1:]
		}

		if tokens[0].Id == token::Id.Self {
			ident.WriteStr(token::Kind.Self)
			param.Token = tokens[0]
			if len(tokens) != 1 {
				self.pushErr(tokens[1], build::LogMsg.InvalidSyntax)
			}
		}

		param.Ident = ident.Str()
		ret param
	}

	fn paramTypeBegin(mut self, mut &param: &ast::ParamDecl, mut &i: int, &tokens: []&token::Token) {
		for i < len(tokens); i++ {
			token := tokens[i]
			if token.Id != token::Id.TripleDot {
				ret
			}

			if param.Variadic {
				self.pushErr(token, build::LogMsg.AlreadyVariadic)
				continue
			}
			param.Variadic = true
		}
	}

	fn buildParamType(mut &self, mut &param: &ast::ParamDecl, mut &tokens: []&token::Token) {
		mut i := 0
		self.paramTypeBegin(param, i, tokens)
		if i >= len(tokens) {
			ret
		}

		param.Kind, _ = unsafe { self.buildType(tokens, &i, true) }
		if i < len(tokens) {
			self.pushErr(tokens[i], build::LogMsg.InvalidSyntax)
		}
	}

	fn buildParamBody(mut &self, mut &param: &ast::ParamDecl, mut tokens: []&token::Token) {
		mut tok := tokens[0]
		if len(tokens) == 1 {
			// Just identifier token.
			param.Ident = tok.Kind
			ret
		} else if len(tokens) < 3 {
			self.pushErr(tok, build::LogMsg.MissingType)
			ret
		}
		if tokens[1].Id != token::Id.Colon {
			param.Ident = token::Ident.Anon
			self.buildParamType(param, tokens)
			ret
		}
		param.Ident = tok.Kind
		tokens = tokens[2:] // Skip colon
		self.buildParamType(param, tokens)
	}

	fn buildParam(mut &self, mut tokens: []&token::Token): &ast::ParamDecl {
		mut param := &ast::ParamDecl{
			Token: tokens[0],
		}

		// Detects mut keyword.
		if param.Token.Id == token::Id.Mut {
			param.Mutable = true
			if len(tokens) == 1 {
				self.pushErr(tokens[0], build::LogMsg.InvalidSyntax)
				ret nil
			}
			tokens = tokens[1:]
			param.Token = tokens[0]
		}

		// Catch reference parameters.
		if len(tokens) >= 3 {
			if param.Token.Id == token::Id.Amper {
				if len(tokens) == 1 {
					self.pushErr(tokens[0], build::LogMsg.InvalidSyntax)
					ret nil
				}

				if tokens[1].Id == token::Id.Ident && tokens[2].Id == token::Id.Colon {
					param.Reference = true
					tokens = tokens[1:]
					param.Token = tokens[0]
				}
			}
		}

		if param.Token.Id != token::Id.Ident {
			// Just data type
			param.Ident = token::Ident.Anon
			self.buildParamType(param, tokens)
		} else {
			self.buildParamBody(param, tokens)
		}

		ret param
	}

	fn checkParams(mut self, mut &params: []&ast::ParamDecl) {
		for (_, mut param) in params {
			if param.IsSelf() || param.Kind != nil {
				continue
			}
			if param.Token == nil {
				self.pushErr(param.Token, build::LogMsg.MissingType)
			} else {
				param.Kind = &ast::TypeDecl{
					Token: param.Token,
					Kind: &ast::IdentTypeDecl{
						Token: param.Token,
						Ident: param.Token.Kind,
					},
				}
				param.Ident = token::Ident.Anon
			}
		}
	}

	fn buildParams(mut &self, mut &tokens: []&token::Token, method: bool): []&ast::ParamDecl {
		mut parts, errs := parts(tokens, token::Id.Comma, true)
		self.errors = append(self.errors, errs...)
		if len(parts) == 0 {
			ret nil
		}

		let mut params: []&ast::ParamDecl = nil
		if method && len(parts) > 0 {
			mut param := self.buildSelfParam(parts[0])
			if param != nil && param.IsSelf() {
				params = append(params, param)
				parts = parts[1:]
			}
		}

		for (_, mut part) in parts {
			if len(part) == 0 {
				continue
			}
			mut param := self.buildParam(part)
			if param != nil {
				params = append(params, param)
			}
		}

		self.checkParams(params)
		ret params
	}

	fn buildMultiRetType(mut &self, mut &tokens: []&token::Token, mut &i: int): (t: &ast::RetTypeDecl, ok: bool) {
		t = new(ast::RetTypeDecl)
		i++
		if i >= len(tokens) {
			i--
			t.Kind, ok = unsafe { self.buildType(tokens, &i, false) }
			ret
		}

		i-- // For point to parentheses - ( -
		mut rangeTokens := range(i, token::Id.LParent, token::Id.RParent, tokens)

		mut parts, errs := parts(rangeTokens, token::Id.Comma, true)
		self.errors = append(self.errors, errs...)
		if len(parts) == 0 {
			ret
		}

		mut types := make([]&ast::TypeDecl, 0, len(parts))
		t.Idents = make([]&token::Token, 0, len(parts))
		for (_, mut part) in parts {
			if len(part) == 0 {
				continue
			}
			mut token := part[0]
			mut offset := 0

			// Check type annotation.
			if len(part) > 1 {
				token = part[1]
				if token.Id == token::Id.Colon {
					offset = 2
					if len(part) < 3 {
						self.pushErr(token, build::LogMsg.MissingType)
						continue
					}
				}
			}

			token = part[0]
			if offset != 2 {
				mut newToken := new(token::Token, *token)
				newToken.Kind = token::Ident.Anon
				t.Idents = append(t.Idents, newToken)
			} else {
				t.Idents = append(t.Idents, token)
			}

			mut tk, _ := unsafe { self.buildType(part, &offset, true) }
			if offset < len(part) {
				self.pushErr(part[offset], build::LogMsg.InvalidSyntax)
			}
			types = append(types, tk)
		}

		if len(types) > 1 {
			t.Kind = &ast::TypeDecl{
				Token: tokens[0],
				Kind: &ast::TupleTypeDecl{
					Types: types,
				},
			}
		} else {
			t.Kind = types[0]
		}

		ok = true
		ret
	}

	// Builds function return type from tokens.
	fn buildRetType(mut &self, mut &tokens: []&token::Token, mut &i: int): (t: &ast::RetTypeDecl, ok: bool) {
		t = new(ast::RetTypeDecl)
		if i >= len(tokens) {
			ret
		}

		mut token := tokens[i]
		match token.Id {
		| token::Id.LBrace:
			ret
		| token::Id.Eq:
			ret
		| token::Id.Colon:
			if i+1 >= len(tokens) {
				self.pushErr(token, build::LogMsg.MissingType)
				ret
			}

			i++
			token = tokens[i]
			match token.Id {
			| token::Id.LParent:
				t, ok = self.buildMultiRetType(tokens, i)
				ret
			| token::Id.LBrace:
				self.pushErr(token, build::LogMsg.MissingType)
				ret
			}
			t.Kind, ok = unsafe { self.buildType(tokens, &i, true) }
			ret
		}
		i++
		self.pushErr(token, build::LogMsg.InvalidSyntax)
		ret
	}

	// Build function prototype.
	// Body is not necessary for successfull parsing.
	// Just declration.
	fn buildFnPrototype(mut &self, mut &tokens: []&token::Token, mut &i: int, method: bool): &ast::FnDecl {
		mut f := &ast::FnDecl{
			Token: tokens[i],
		}

		// Detect static keyword.
		if f.Token.Id == token::Id.Static {
			f.Statically = true
			i++
			if i >= len(tokens) {
				self.pushErr(f.Token, build::LogMsg.InvalidSyntax)
				ret nil
			}
			f.Token = tokens[i]
		}

		// Detect unsafe keyword.
		if f.Token.Id == token::Id.Unsafe {
			f.Unsafety = true
			i++
			if i >= len(tokens) {
				self.pushErr(f.Token, build::LogMsg.InvalidSyntax)
				ret nil
			}
			f.Token = tokens[i]
		}

		// Skips fn token.
		i++
		if i >= len(tokens) {
			self.pushErr(f.Token, build::LogMsg.InvalidSyntax)
			ret nil
		}

		tok := tokens[i]
		if tok.Id == token::Id.Ident {
			i++
			if i >= len(tokens) {
				self.pushErr(f.Token, build::LogMsg.InvalidSyntax)
				ret nil
			}
			f.Ident = tok.Kind
		} else {
			f.Ident = token::Ident.Anon
		}

		errorToken := tokens[i]
		mut genericsTokens := range(i, token::Id.LBracket, token::Id.RBracket, tokens)
		if genericsTokens != nil {
			f.Generics = self.buildGenerics(genericsTokens, errorToken)
		}

		if tokens[i].Id != token::Id.LParent {
			self.pushErr(tokens[i], build::LogMsg.MissingFnParentheses)
			ret nil
		}

		mut paramsToks := range(i, token::Id.LParent, token::Id.RParent, tokens)
		if len(paramsToks) > 0 {
			f.Params = self.buildParams(paramsToks, method)
		}

		if i < len(tokens) {
			token := tokens[i]
			if token.Id == token::Id.Excl {
				f.Exceptional = true
				i++
			}
		}

		f.Public = mod::IsPub(f.Ident)
		f.Result, _ = self.buildRetType(tokens, i)
		ret f
	}

	// Parses function define.
	// Prototype and body.
	fn buildFn(mut &self, mut &tokens: []&token::Token, method: bool, prototype: bool): &ast::FnDecl {
		mut i := 0
		mut f := self.buildFnPrototype(tokens, i, method)
		if prototype {
			if i < len(tokens) {
				self.pushErr(tokens[i+1], build::LogMsg.InvalidSyntax)
			}
			ret f
		} else if f == nil {
			ret f
		}

		if i >= len(tokens) {
			self.stop()
			self.pushErr(f.Token, build::LogMsg.BodyNotExist)
			self.pushSuggestion(build::LogMsg.ExpectedBody)
			ret nil
		}
		mut blockTokens := range(i, token::Id.LBrace, token::Id.RBrace, tokens)
		if blockTokens != nil {
			f.Scope = self.buildScope(blockTokens, tokens[i-1])
			f.Scope.Unsafety = f.Unsafety
			if i < len(tokens) {
				self.pushErr(tokens[i], build::LogMsg.InvalidSyntax)
			}
		} else {
			self.stop()
			self.pushErr(f.Token, build::LogMsg.BodyNotExist)
			self.pushSuggestion(build::LogMsg.ExpectedBody)
			ret nil
		}
		ret f
	}

	fn buildBindUseDecl(mut self, mut &decl: &ast::UseDecl, mut &tokens: []&token::Token) {
		if len(tokens) > 1 {
			self.pushErr(tokens[1], build::LogMsg.InvalidSyntax)
		}
		mut token := tokens[0]
		if token.Id != token::Id.Lit || !token::IsStr(token.Kind) || token::IsRawStr(token.Kind) {
			self.pushErr(token, build::LogMsg.InvalidExpr)
			ret
		}
		decl.Binded = true
		decl.Path = token
	}

	fn parseUseDecl(mut self, mut &decl: &ast::UseDecl, mut tokens: []&token::Token) {
		if decl.Binded {
			self.buildBindUseDecl(decl, tokens)
			ret
		}

		mut token := tokens[0]
		if token.Id != token::Id.Ident && token.Id != token::Id.Lit &&
			!token::IsStr(token.Kind) || token::IsRawStr(token.Kind) {
			self.pushErr(token, build::LogMsg.InvalidSyntax)
			ret
		}

		if token.Id == token::Id.Ident { // custom alias exist
			decl.Alias = token
			tokens = tokens[1:]
			if len(tokens) == 0 {
				self.pushErr(token, build::LogMsg.InvalidSyntax)
				ret
			}
			token = tokens[0]
			if token.Id != token::Id.Lit || !token::IsStr(token.Kind) {
				self.pushErr(token, build::LogMsg.InvalidSyntax)
				ret
			}
		}

		decl.Path = token
	}

	fn buildUseDecl(mut self, mut tokens: []&token::Token, binded: bool): &ast::UseDecl {
		mut decl := &ast::UseDecl{
			Token: tokens[0], // See developer reference (9).
			Binded: binded,
		}
		if len(tokens) < 2 {
			self.pushErr(decl.Token, build::LogMsg.MissingUsePath)
			ret nil
		}
		tokens = tokens[1:] // Skip "use" keyword.
		self.parseUseDecl(decl, tokens)
		ret decl
	}

	fn buildTypeEnumItemKind(mut &self, mut &i: int, mut &tokens: []&token::Token): &ast::TypeDecl {
		mut braceN := 0
		exprStart := i
		for i < len(tokens); i++ {
			t := tokens[i]
			match t.Id {
			| token::Id.LBrace
			| token::Id.LBracket
			| token::Id.LParent:
				braceN++
				continue
			| token::Id.RBrace
			| token::Id.RBracket
			| token::Id.RParent:
				braceN--
			}
			if braceN > 0 {
				continue
			}
			if t.Id == token::Id.Comma || i+1 >= len(tokens) {
				let mut kindTokens: []&token::Token = nil
				if t.Id == token::Id.Comma {
					kindTokens = tokens[exprStart:i]
				} else {
					kindTokens = tokens[exprStart:]
				}
				mut j := 0
				mut kind, _ := unsafe { self.buildType(kindTokens, &j, true) }
				if j < len(kindTokens) {
					self.pushErr(kindTokens[j], build::LogMsg.InvalidSyntax)
				}
				ret kind
			}
		}
		ret nil
	}

	fn buildTypeEnumItems(mut &self, mut &tokens: []&token::Token): []&ast::TypeEnumItemDecl {
		mut items := make([]&ast::TypeEnumItemDecl, 0, 1)
		mut i := 0
		for i < len(tokens); i++ {
			mut t := tokens[i]
			mut item := new(ast::TypeEnumItemDecl)
			item.Token = t
			if item.Token.Id == token::Id.Ident && len(tokens)-i > 2 {
				t = tokens[i+1]
				if t.Id == token::Id.Colon {
					item.Ident = item.Token.Kind
					i += 2
					if i >= len(tokens) || tokens[i].Id == token::Id.Comma {
						self.pushErr(t, build::LogMsg.MissingType)
						continue
					}
				}
			}
			item.Kind = self.buildTypeEnumItemKind(i, tokens)
			items = append(items, item)
		}
		ret items
	}

	fn buildTypeEnumDecl(mut &self, mut &tokens: []&token::Token): &ast::TypeEnumDecl {
		mut i := 1
		mut e := &ast::TypeEnumDecl{
			// Skip "enum" tokens.
			Token: tokens[i],
		}
		if e.Token.Id != token::Id.Ident {
			self.pushErr(e.Token, build::LogMsg.InvalidSyntax)
			self.pushSuggestion(build::LogMsg.ExpectedIdentifier)
		}
		e.Ident = e.Token.Kind
		i += 3 // Skip "identifier: type" tokens.
		mut itemTokens := range(i, token::Id.LBrace, token::Id.RBrace, tokens)
		if itemTokens == nil {
			self.stop()
			self.pushErr(e.Token, build::LogMsg.BodyNotExist)
			self.pushSuggestion(build::LogMsg.ExpectedBody)
			ret e
		} else if i < len(tokens) {
			self.pushErr(tokens[i], build::LogMsg.InvalidSyntax)
		}
		e.Public = mod::IsPub(e.Ident)
		e.End = tokens[i-1]
		e.Items = self.buildTypeEnumItems(itemTokens)
		ret e
	}

	fn buildEnumItemExpr(mut &self, mut &i: int, mut &tokens: []&token::Token): &ast::Expr {
		mut braceN := 0
		exprStart := i
		for i < len(tokens); i++ {
			t := tokens[i]
			match t.Id {
			| token::Id.LBrace
			| token::Id.LBracket
			| token::Id.LParent:
				braceN++
				continue
			| token::Id.RBrace
			| token::Id.RBracket
			| token::Id.RParent:
				braceN--
			}
			if braceN > 0 {
				continue
			}
			if t.Id == token::Id.Comma || i+1 >= len(tokens) {
				let mut exprTokens: []&token::Token = nil
				if t.Id == token::Id.Comma {
					exprTokens = tokens[exprStart:i]
				} else {
					exprTokens = tokens[exprStart:]
				}
				ret self.buildExpr(exprTokens)
			}
		}
		ret nil
	}

	fn buildEnumItems(mut &self, mut &tokens: []&token::Token): []&ast::EnumItemDecl {
		mut items := make([]&ast::EnumItemDecl, 0, 1)
		mut i := 0
		for i < len(tokens); i++ {
			mut t := tokens[i]
			mut item := new(ast::EnumItemDecl)
			item.Token = t
			if item.Token.Id != token::Id.Ident {
				self.pushErr(item.Token, build::LogMsg.InvalidSyntax)
				self.pushSuggestion(build::LogMsg.ExpectedIdentifier)
			}
			item.Ident = item.Token.Kind
			if i+1 >= len(tokens) || tokens[i+1].Id == token::Id.Comma {
				if i+1 < len(tokens) {
					i++
				}
				items = append(items, item)
				continue
			}
			i++
			t = tokens[i]
			i++
			if t.Id != token::Id.Colon {
				self.pushErr(t, build::LogMsg.InvalidSyntax)
				self.pushSuggestion(build::LogMsg.ExpectedColonForAssign)
				continue
			}
			if i >= len(tokens) || tokens[i].Id == token::Id.Comma {
				self.pushErr(t, build::LogMsg.MissingExpr)
				continue
			}
			item.Expr = self.buildEnumItemExpr(i, tokens)
			items = append(items, item)
		}
		ret items
	}

	fn buildEnumDecl(mut &self, mut &tokens: []&token::Token): &ast::EnumDecl {
		if len(tokens) < 3 {
			self.pushErr(tokens[0], build::LogMsg.InvalidSyntax)
			ret nil
		}
		mut e := &ast::EnumDecl{
			Token: tokens[1],
		}
		if e.Token.Id != token::Id.Ident {
			self.pushErr(e.Token, build::LogMsg.InvalidSyntax)
			self.pushSuggestion(build::LogMsg.ExpectedIdentifier)
		}
		e.Ident = e.Token.Kind
		mut i := 2
		if tokens[i].Id == token::Id.Colon {
			i++
			if i >= len(tokens) {
				self.pushErr(tokens[i-1], build::LogMsg.InvalidSyntax)
				ret e
			}
			e.Kind, _ = unsafe { self.buildType(tokens, &i, true) }
			if i >= len(tokens) {
				self.stop()
				self.pushErr(e.Token, build::LogMsg.BodyNotExist)
				self.pushSuggestion(build::LogMsg.ExpectedBody)
				ret e
			}
		} else {
			e.Kind = nil
		}
		mut itemTokens := range(i, token::Id.LBrace, token::Id.RBrace, tokens)
		if itemTokens == nil {
			self.stop()
			self.pushErr(e.Token, build::LogMsg.BodyNotExist)
			self.pushSuggestion(build::LogMsg.ExpectedBody)
			ret e
		} else if i < len(tokens) {
			self.pushErr(tokens[i], build::LogMsg.InvalidSyntax)
		}
		e.Public = mod::IsPub(e.Ident)
		e.End = tokens[i-1]
		e.Items = self.buildEnumItems(itemTokens)
		ret e
	}

	fn buildNodeEnumDecl(mut &self, mut &tokens: []&token::Token): ast::NodeData {
		if len(tokens) > 3 && tokens[2].Id == token::Id.Colon {
			if tokens[3].Id == token::Id.Type {
				ret self.buildTypeEnumDecl(tokens)
			}
		}
		ret self.buildEnumDecl(tokens)
	}

	fn buildField(mut &self, mut tokens: []&token::Token): &ast::FieldDecl {
		mut f := new(ast::FieldDecl)

		f.Mutable = tokens[0].Id == token::Id.Mut
		if f.Mutable {
			if len(tokens) == 1 {
				self.pushErr(tokens[0], build::LogMsg.InvalidSyntax)
				ret nil
			}
			tokens = tokens[1:]
		}

		f.Token = tokens[0]
		if f.Token.Id != token::Id.Ident {
			self.pushErr(f.Token, build::LogMsg.InvalidSyntax)
			self.pushSuggestion(build::LogMsg.ExpectedIdentifier)
			ret nil
		}
		f.Ident = f.Token.Kind

		if len(tokens) == 1 {
			self.pushErr(tokens[0], build::LogMsg.MissingType)
			ret nil
		} else if len(tokens) < 3 || tokens[1].Id != token::Id.Colon {
			self.pushErr(tokens[1], build::LogMsg.MissingType)
			ret nil
		}

		tokens = tokens[2:] // Remove identifier and colon tokens.
		mut i := 0
		f.Kind, _ = unsafe { self.buildType(tokens, &i, true) }
		if i < len(tokens) {
			token := tokens[i]
			if token.Id != token::Id.Eq {
				self.pushErr(tokens[i], build::LogMsg.InvalidSyntax)
				ret nil
			}
			i++
			if i >= len(tokens) {
				self.pushErr(token, build::LogMsg.MissingExpr)
				ret nil
			}
			tokens = tokens[i:]
			f.Default = self.buildExpr(tokens)
		}
		f.Public = mod::IsPub(f.Ident)
		ret f
	}

	fn buildStructDeclFields(mut &self, mut tokens: []&token::Token): []&ast::FieldDecl {
		let mut fields: []&ast::FieldDecl = nil
		mut stmts := splitStmts(tokens)
		for (_, mut stmt) in stmts {
			tokens = stmt.tokens
			mut f := self.buildField(tokens)
			fields = append(fields, f)
		}
		ret fields
	}

	fn buildStructDecl(mut &self, mut &tokens: []&token::Token): &ast::StructDecl {
		if len(tokens) < 3 {
			self.pushErr(tokens[0], build::LogMsg.InvalidSyntax)
			ret nil
		}

		mut i := 1
		mut s := &ast::StructDecl{
			Token: tokens[i],
		}
		if s.Token.Id != token::Id.Ident {
			self.pushErr(s.Token, build::LogMsg.InvalidSyntax)
			self.pushSuggestion(build::LogMsg.ExpectedIdentifier)
		}
		i++
		if i >= len(tokens) {
			self.pushErr(tokens[i], build::LogMsg.InvalidSyntax)
			ret s
		}
		s.Ident = s.Token.Kind

		errorToken := tokens[i]
		mut genericsTokens := range(i, token::Id.LBracket, token::Id.RBracket, tokens)
		if genericsTokens != nil {
			s.Generics = self.buildGenerics(genericsTokens, errorToken)
		}
		if i >= len(tokens) {
			self.pushErr(tokens[i-1], build::LogMsg.BodyNotExist)
			self.pushSuggestion(build::LogMsg.ExpectedBody)
			ret s
		}

		mut bodyTokens := range(i, token::Id.LBrace, token::Id.RBrace, tokens)
		if bodyTokens == nil {
			self.stop()
			self.pushErr(s.Token, build::LogMsg.BodyNotExist)
			self.pushSuggestion(build::LogMsg.ExpectedBody)
			ret s
		}
		if i < len(tokens) {
			self.pushErr(tokens[i], build::LogMsg.InvalidSyntax)
		}
		s.Public = mod::IsPub(s.Ident)
		s.Fields = self.buildStructDeclFields(bodyTokens)
		s.End = tokens[i-1]
		ret s
	}

	fn checkMethodReceiver(mut self, &f: &ast::FnDecl) {
		// Static methods cannot have receiver.
		if f.Statically {
			if len(f.Params) > 0 && f.Params[0].IsSelf() {
				self.pushErr(f.Token, build::LogMsg.StaticFnHasReceiver)
			}
			ret
		}
		if len(f.Params) == 0 {
			self.pushErr(f.Token, build::LogMsg.MissingReceiver)
			ret
		}
		param := f.Params[0]
		if !param.IsSelf() {
			self.pushErr(f.Token, build::LogMsg.MissingReceiver)
			ret
		}
	}

	fn buildTraitBody(mut &self, mut &t: &ast::TraitDecl, mut tokens: []&token::Token) {
		mut stmts := splitStmts(tokens)
		for (_, mut stmt) in stmts {
			tokens = stmt.tokens
			if len(tokens) == 0 {
				continue
			}
			match tokens[0].Id {
			| token::Id.Fn:
				mut f := self.buildFn(tokens, true, true)
				if f == nil {
					break
				}
				self.checkMethodReceiver(f)
				if len(f.Generics) > 0 {
					self.pushErr(f.Token, build::LogMsg.TraitMethodHasGenerics)
				}
				t.Methods = append(t.Methods, f)
			|:
				mut i := 0
				mut ti, ok := unsafe { self.buildType(tokens, &i, true) }
				if !ok {
					break
				}
				if i < len(tokens) {
					self.pushErr(tokens[i], build::LogMsg.InvalidSyntax)
				}
				t.Inherits = append(t.Inherits, ti)
			}
		}
	}

	fn buildTraitDecl(mut &self, mut &tokens: []&token::Token): &ast::TraitDecl {
		if len(tokens) < 3 {
			self.pushErr(tokens[0], build::LogMsg.InvalidSyntax)
			ret nil
		}
		mut t := &ast::TraitDecl{
			Token: tokens[1],
		}
		if t.Token.Id != token::Id.Ident {
			self.pushErr(t.Token, build::LogMsg.InvalidSyntax)
			self.pushSuggestion(build::LogMsg.ExpectedIdentifier)
		}
		t.Ident = t.Token.Kind
		mut i := 2
		mut bodyTokens := range(i, token::Id.LBrace, token::Id.RBrace, tokens)
		if bodyTokens == nil {
			self.stop()
			self.pushErr(t.Token, build::LogMsg.BodyNotExist)
			self.pushSuggestion(build::LogMsg.ExpectedBody)
			ret nil
		}
		if i < len(tokens) {
			self.pushErr(tokens[i], build::LogMsg.InvalidSyntax)
		}
		t.Public = mod::IsPub(t.Ident)
		self.buildTraitBody(t, bodyTokens)
		t.End = tokens[i-1]
		ret t
	}

	fn buildBindFn(mut &self, mut tokens: []&token::Token): &ast::FnDecl {
		tokens = tokens[1:] // Remove "cpp" keyword.
		mut f := self.buildFn(tokens, false, true)
		if f != nil {
			f.Public = false
			f.Binded = true
		}
		ret f
	}

	fn buildBindVar(mut &self, mut tokens: []&token::Token): &ast::VarDecl {
		tokens = tokens[1:] // Remove "cpp" keyword.
		mut v := self.buildVar(tokens)
		if v != nil {
			v.Public = false
			v.Binded = true
			if v.Expr != nil {
				self.pushErr(v.Token, build::LogMsg.BindedVarHasExpr)
			}
		}
		ret v
	}

	fn buildBindStruct(mut &self, mut tokens: []&token::Token): &ast::StructDecl {
		tokens = tokens[1:] // Remove "cpp" keyword.
		mut s := self.buildStructDecl(tokens)
		if s != nil {
			s.Public = false
			for (_, mut f) in s.Fields {
				// Binded structure's fields are always public by default.
				f.Public = true
			}
			s.Binded = true
		}
		ret s
	}

	fn buildBindTypeAlias(mut &self, mut tokens: []&token::Token): &ast::TypeAliasDecl {
		tokens = tokens[1:] // Remove "cpp" keyword.
		mut t := self.buildTypeAliasDecl(tokens)
		if t != nil {
			t.Public = false
			t.Binded = true
		}
		ret t
	}

	fn buildBindUse(mut &self, mut tokens: []&token::Token): &ast::UseDecl {
		if len(tokens) == 1 {
			self.pushErr(tokens[0], build::LogMsg.InvalidSyntax)
			ret nil
		}
		tokens = tokens[1:] // Remove the bind keyword.

		const Binded = true
		ret self.buildUseDecl(tokens, Binded)
	}

	fn buildBind(mut &self, mut &tokens: []&token::Token): ast::NodeData {
		mut token := tokens[0]
		if len(tokens) == 1 {
			self.pushErr(token, build::LogMsg.InvalidSyntax)
			ret nil
		}
		token = tokens[1]
		match token.Id {
		| token::Id.Fn
		| token::Id.Unsafe:
			ret self.buildBindFn(tokens)
		| token::Id.Const
		| token::Id.Let:
			ret self.buildBindVar(tokens)
		| token::Id.Struct:
			ret self.buildBindStruct(tokens)
		| token::Id.Type:
			ret self.buildBindTypeAlias(tokens)
		|:
			self.pushErr(token, build::LogMsg.InvalidSyntax)
		}
		ret nil
	}

	fn getMethod(mut &self, mut &tokens: []&token::Token): &ast::FnDecl {
		mut i := 0
		mut token := tokens[i]
		if token.Id == token::Id.Static {
			if i+1 >= len(tokens) {
				self.pushErr(token, build::LogMsg.InvalidSyntax)
				ret nil
			}
			i++
			token = tokens[i]
		}

		if token.Id == token::Id.Unsafe {
			if i+1 >= len(tokens) {
				self.pushErr(token, build::LogMsg.InvalidSyntax)
				ret nil
			}
			i++
			token = tokens[i]
		}

		if token.Id != token::Id.Fn {
			self.pushErr(token, build::LogMsg.InvalidSyntax)
			ret nil
		}

		ret self.buildFn(tokens, true, false)
	}

	fn parseImplBody(mut &self, mut &ipl: &ast::Impl, mut &tokens: []&token::Token) {
		mut stmts := splitStmts(tokens)
		for (_, mut stmt) in stmts {
			tokens = stmt.tokens
			mut token := tokens[0]
			match token.Id {
			| token::Id.Hash:
				self.pushDirective(self.buildDirective(tokens))
				continue
			}

			match token.Id {
			| token::Id.Const:
				mut v := self.buildVar(tokens)
				if v != nil {
					ipl.Statics = append(ipl.Statics, v)
				}
			| token::Id.Static
			| token::Id.Fn
			| token::Id.Unsafe:
				mut f := self.getMethod(tokens)
				if f != nil {
					self.checkMethodReceiver(f)
					self.applyFnMeta(f)
					ipl.Methods = append(ipl.Methods, f)
				}
			|:
				self.pushErr(token, build::LogMsg.InvalidSyntax)
				continue
			}
		}
	}

	fn buildImpl(mut &self, mut tokens: []&token::Token): &ast::Impl {
		mut token := tokens[0]
		if len(tokens) < 2 {
			self.pushErr(token, build::LogMsg.InvalidSyntax)
			ret nil
		}

		mut i := 1

		mut base, mut ok := unsafe { self.buildType(tokens, &i, true) }
		if !ok {
			ret nil
		}
		if i >= len(tokens) {
			self.pushErr(token, build::LogMsg.InvalidSyntax)
			ret nil
		}

		mut ipl := &ast::Impl{
			Base: base,
		}

		token = tokens[i]
		if token.Id != token::Id.For {
			if token.Id == token::Id.LBrace {
				// This implementation is single.
				// Just implements to destination.
				// Therefore, swap Base and Dest tokens.
				ipl.Base, ipl.Dest = ipl.Dest, ipl.Base
				goto body
			}
			self.stop()
			self.pushErr(token, build::LogMsg.BodyNotExist)
			self.pushSuggestion(build::LogMsg.ExpectedBody)
			ret nil
		}
		i++
		if i >= len(tokens) {
			self.stop()
			self.pushErr(token, build::LogMsg.BodyNotExist)
			self.pushSuggestion(build::LogMsg.ExpectedBody)
			ret nil
		}

		ipl.Dest, ok = unsafe { self.buildType(tokens, &i, true) }
		if !ok {
			ret nil
		}
		if i >= len(tokens) {
			self.stop()
			self.pushErr(token, build::LogMsg.BodyNotExist)
			self.pushSuggestion(build::LogMsg.ExpectedBody)
			ret nil
		}

	body:
		mut bodyTokens := range(i, token::Id.LBrace, token::Id.RBrace, tokens)
		if bodyTokens == nil {
			self.stop()
			self.pushErr(token, build::LogMsg.BodyNotExist)
			self.pushSuggestion(build::LogMsg.ExpectedBody)
			ret nil
		}
		if i < len(tokens) {
			self.pushErr(tokens[i], build::LogMsg.InvalidSyntax)
		}
		ipl.End = tokens[i-1]
		self.parseImplBody(ipl, bodyTokens)
		ret ipl
	}

	fn buildNodeData(mut &self, mut &tokens: []&token::Token): ast::NodeData {
		mut token := tokens[0]
		match token.Id {
		| token::Id.Fn
		| token::Id.Unsafe:
			mut f := self.buildFn(tokens, false, false)
			if f != nil {
				f.Global = true
			}
			ret f
		| token::Id.Let
		| token::Id.Const
		| token::Id.Mut
		| token::Id.Static:
			ret self.buildVar(tokens)
		| token::Id.Type:
			ret self.buildTypeAliasDecl(tokens)
		| token::Id.Enum:
			ret self.buildNodeEnumDecl(tokens)
		| token::Id.Struct:
			ret self.buildStructDecl(tokens)
		| token::Id.Trait:
			ret self.buildTraitDecl(tokens)
		| token::Id.Impl:
			ret self.buildImpl(tokens)
		| token::Id.Cpp:
			ret self.buildBind(tokens)
		|:
			self.pushErr(token, build::LogMsg.InvalidSyntax)
			ret nil
		}
	}

	fn applyFnMeta(mut self, mut &f: &ast::FnDecl) {
		f.Directives = self.directives
		self.directives = nil
	}

	fn applyMeta(mut self, mut &node: ast::Node) {
		match type node.Data {
		| &ast::VarDecl:
			mut v := (&ast::VarDecl)(node.Data)
			if v == nil {
				ret
			}
			v.Directives = self.directives
			self.directives = nil
		| &ast::FnDecl:
			mut f := (&ast::FnDecl)(node.Data)
			if f == nil {
				ret
			}
			self.applyFnMeta(f)
		| &ast::StructDecl:
			mut sd := (&ast::StructDecl)(node.Data)
			if sd == nil {
				ret
			}
			sd.Directives = self.directives
			self.directives = nil
		}
	}

	fn pushUseDecl(mut &self, mut &decl: &ast::UseDecl) {
		self.ast.UseDecls = append(self.ast.UseDecls, decl)
		if len(self.ast.Nodes) > 0 {
			self.pushErr(decl.Token, build::LogMsg.UseDeclAtBody)
			self.pushSuggestion(build::LogMsg.MoveUseDeclToTopOfFile)
		}
	}

	fn pushMetaNodes(mut &self, mut &tokens: []&token::Token): bool {
		match tokens[0].Id {
		| token::Id.Use:
			const Binded = false
			mut decl := self.buildUseDecl(tokens, Binded)
			self.pushUseDecl(decl)
			ret true
		| token::Id.Cpp:
			if len(tokens) > 1 && tokens[1].Id == token::Id.Use {
				mut decl := self.buildBindUse(tokens)
				self.pushUseDecl(decl)
				ret true
			}
		| token::Id.Hash:
			self.pushDirective(self.buildDirective(tokens))
			ret true
		}
		ret false
	}

	fn parseNode(mut &self, mut &st: []&token::Token): ast::Node {
		mut node := ast::Node{
			Token: st[0],
		}

		if self.pushMetaNodes(st) {
			ret node
		}

		mut data := self.buildNodeData(st)
		if data == nil {
			ret node
		}

		node.Data = data

		self.applyMeta(node)
		if len(self.directives) != 0 {
			self.pushErr(self.directives[0].Tag, build::LogMsg.UnusedDirective)
		}
		self.directives = nil
		ret node
	}

	fn appendNode(mut &self, mut &st: []&token::Token) {
		if len(st) == 0 {
			ret
		}
		mut node := self.parseNode(st)
		if node.Data != nil && !self.stopped() {
			self.ast.Nodes = append(self.ast.Nodes, node)
		}
	}

	fn removeRange(self, mut i: int, id: token::Id, &tokens: []&token::Token, mut &ranges: []int) {
		close := getCloseOfBrace(id)
		for i >= 0; i-- {
			tok := tokens[ranges[i]]
			if tok.Id != close {
				continue
			}
			ranges = append(ranges[:i], ranges[i+1:]...)
			break
		}
	}

	fn pushWrongOrderCloseErr(mut self, &t: &token::Token, &tokens: []&token::Token, &ranges: []int) {
		match tokens[ranges[len(ranges)-1]].Id {
		| token::Id.LParent:
			self.pushErr(t, build::LogMsg.ExpectedParentClose)
		| token::Id.LBrace:
			self.pushErr(t, build::LogMsg.ExpectedBraceClose)
		| token::Id.LBracket:
			self.pushErr(t, build::LogMsg.ExpectedBracketClose)
		}
	}

	fn pushRangeClose(mut self, t: &token::Token, left: token::Id, &tokens: []&token::Token, mut &ranges: []int) {
		n := len(ranges)
		if n == 0 {
			match t.Id {
			| token::Id.RBracket:
				self.pushErr(t, build::LogMsg.ExtraClosedBracket)
			| token::Id.RBrace:
				self.pushErr(t, build::LogMsg.ExtraClosedBrace)
			| token::Id.RParent:
				self.pushErr(t, build::LogMsg.ExtraClosedParent)
			}
			ret
		} else if tokens[ranges[n-1]].Id != left {
			self.pushWrongOrderCloseErr(t, tokens, ranges)
		}
		self.removeRange(n-1, t.Id, tokens, ranges)
	}

	fn checkRanges(mut self, &tokens: []&token::Token) {
		let mut ranges: []int = nil

		for i, token in tokens {
			match token.Id {
			| token::Id.LParent
			| token::Id.LBrace
			| token::Id.LBracket:
				ranges = append(ranges, i)
			| token::Id.RParent:
				self.pushRangeClose(token, token::Id.LParent, tokens, ranges)
			| token::Id.RBrace:
				self.pushRangeClose(token, token::Id.LBrace, tokens, ranges)
			| token::Id.RBracket:
				self.pushRangeClose(token, token::Id.LBracket, tokens, ranges)
			}
		}

		for _, i in ranges {
			token := tokens[i]
			match token.Id {
			| token::Id.LParent:
				self.pushErr(token, build::LogMsg.WaitCloseParent)
			| token::Id.LBrace:
				self.pushErr(token, build::LogMsg.WaitCloseBrace)
			| token::Id.LBracket:
				self.pushErr(token, build::LogMsg.WaitCloseBracket)
			}
		}
	}

	fn parse(mut &self, mut &f: &token::Fileset) {
		self.ast = &ast::AST{
			File: f,
		}
		self.ep = &exprBuilder{
			p: self,
		}

		self.checkRanges(f.Tokens)
		if len(self.errors) > 0 {
			ret
		}

		mut stmts := splitStmts(f.Tokens)

		// Get top directives.
		mut i := 0
		for i < len(stmts); i++ {
			mut stmt := stmts[i]
			if len(stmt.tokens) < 2 {
				ret
			}
			if stmt.tokens[0].Id != token::Id.Hash {
				break
			}
			if !build::IsTopDirective(stmt.tokens[1].Kind) {
				break
			}
			self.ast.TopDirectives = append(self.ast.TopDirectives, self.buildDirective(stmt.tokens))
		}

		// Remove all errors.
		self.errors = nil

		for i < len(stmts) && !self.stopped(); i++ {
			mut stmt := stmts[i]
			self.appendNode(stmt.tokens)
		}

		if len(self.directives) != 0 {
			self.pushErr(self.directives[0].Tag, build::LogMsg.UnusedDirective)
		}
	}
}
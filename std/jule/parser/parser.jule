// Copyright 2023-2025 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/jule"
use "std/jule/ast"
use "std/jule/build"
use "std/jule/directive"
use "std/jule/internal/mod"
use "std/jule/log"
use "std/jule/token"
use "std/os/filepath"
use "std/strings"

fn makeErr(row: int, col: int, &f: &token::FileSet, fmt: str, args: ...any): log::Log {
	ret log::Log{
		Kind: log::Error,
		Row: row,
		Column: col,
		Path: f.Path,
		Text: log::Logf(fmt, args...),
	}
}

// Returns between of open and close ranges.
// Starts selection at i.
// Increases i for each selected token.
// i points to close range token after selection.
//
// Special cases are:
//	range(i, open, close, tokens) = nil if i > len(tokens)
//	range(i, open, close, tokens) = nil if tokens[i].Id != open
fn range(mut &i: int, open: int, close: int, mut &tokens: []&token::Token): []&token::Token {
	if i >= len(tokens) {
		ret nil
	}
	tok := tokens[i]
	if tok.Id != open {
		ret nil
	}
	i++
	mut rangeN := 1
	start := i
	for rangeN != 0 && i < len(tokens); i++ {
		token := tokens[i]
		match token.Id {
		| open:
			rangeN++
		| close:
			rangeN--
		}
	}
	ret tokens[start : i-1]
}

// Returns last range from tokens.
// Returns tokens without range tokens and range tokens.
// Range tokens includes left and right range tokens.
//
// Special cases are;
//	rangeLast(tokens) = tokens, nil if len(tokens) == 0
//	rangeLast(tokens) = tokens, nil if tokens is not has range at last
fn rangeLast(mut &tokens: []&token::Token): (rest: []&token::Token, cut: []&token::Token) {
	if len(tokens) == 0 {
		ret tokens, nil
	}
	first := tokens[len(tokens)-1].Id
	if first != token::RBrace &&
		first != token::LBracket &&
		first != token::RParent {
		ret tokens, nil
	}
	mut braceN := 0
	mut i := len(tokens) - 1
	for i >= 0; i-- {
		token := tokens[i]
		match token.Id {
		| token::RBrace
		| token::RBracket
		| token::RParent:
			braceN++
			continue
		| token::LBrace
		| token::LBracket
		| token::LParent:
			braceN--
		}
		if braceN == 0 {
			ret tokens[:i], tokens[i:]
		}
	}
	ret tokens, nil
}

// Returns parts separated by given token identifier.
// It's skips parentheses ranges.
// Logs missing_expr if exprMust == true and not exist any expression for part.
//
// Special case is;
//	parts(tokens) = nil if len(tokens) == 0
fn parts(mut &tokens: []&token::Token, id: int, exprMust: bool): (parts: [][]&token::Token, errors: []log::Log) {
	if len(tokens) == 0 {
		ret nil, nil
	}
	mut rangeN := 0
	mut last := 0
	for i, token in tokens {
		match token.Id {
		| token::LBrace | token::LBracket | token::LParent:
			rangeN++
		| token::RBrace | token::RBracket | token::RParent:
			rangeN--
		| id:
			if rangeN > 0 {
				continue
			}
			if exprMust && i-last <= 0 {
				err := makeErr(token.Row, token.Column, token.File, log::MissingExpr)
				errors = append(errors, err)
			}
			parts = append(parts, tokens[last:i])
			last = i + 1
		}
	}
	if last < len(tokens) {
		parts = append(parts, tokens[last:])
	}
	ret
}

fn getCloseOfBrace(left: int): int {
	match left {
	| token::RParent:
		ret token::LParent
	| token::RBrace:
		ret token::LBrace
	| token::RBracket:
		ret token::LBracket
	|:
		ret left
	}
}

fn compilerErr(&token: &token::Token, &fmt: str, args: ...any): log::Log {
	ret log::Log{
		Kind: log::Error,
		Row: token.Row,
		Column: token.Column,
		Path: token.File.Path,
		Text: log::Logf(fmt, args...),
		Line: token.File.GetRow(token.Row),
	}
}

unsafe fn pushSuggestion(mut log: *log::Log, fmt: str, args: ...any) {
	log.Suggestion = log::Logf(fmt, args...)
}

// Parser modes.
const (
	allowKeywordIdentifiers = 1 << iota // supported by: functions, structs, and type aliases
)

struct parser {
	mode:       int
	ast:        &ast::AST
	directives: []&ast::Directive
	errors:     []log::Log

	ep: &exprBuilder
}

impl parser {
	fn stop(mut self) { self.ast = nil }
	fn stopped(self): bool { ret self.ast == nil }

	// Appends error by specified token, key and args.
	fn pushErr(mut self, token: &token::Token, fmt: str, args: ...any) {
		self.errors = append(self.errors, compilerErr(token, fmt, args...))
	}

	// Push suggestion to last log.
	fn pushSuggestion(mut self, fmt: str, args: ...any) {
		unsafe { pushSuggestion(&self.errors[len(self.errors)-1], fmt, args...) }
	}

	// Reports whether tok is identifier.
	// Must be used by definitions that must support the AllowKeywordIdentifiers mode.
	fn isIdent(mut self, &tok: &token::Token): bool {
		ret tok.Id == token::Name ||
			self.mode&allowKeywordIdentifiers == allowKeywordIdentifiers && token::IsKeyword(tok.Kind)
	}

	fn buildExpr(mut &self, mut &tokens: []&token::Token): &ast::Expr {
		ret self.ep.buildFromTokens(tokens)
	}

	fn buildDirective(mut self, mut tokens: []&token::Token): &ast::Directive {
		if len(tokens) == 1 {
			self.pushErr(tokens[0], log::InvalidSyntax)
			ret nil
		}
		if tokens[1].Column != tokens[0].Column+1 {
			self.pushErr(tokens[0], log::InvalidSyntax)
			ret nil
		}
		ret &ast::Directive{
			Tag: tokens[1],
			Args: tokens[2:], // Start 2 to skip '#', and tag tokens.
		}
	}

	fn pushDirective(mut self, mut d: &ast::Directive) {
		if d == nil {
			ret
		}
		// Don't append if already added this directive.
		for _, pd in self.directives {
			if d.Tag.Kind == pd.Tag.Kind {
				self.pushErr(d.Tag, log::ReuseDirective, d.Tag.Kind)
				ret
			}
		}
		self.directives = append(self.directives, d)
	}

	fn buildScope(mut &self, mut &tokens: []&token::Token, mut end: &token::Token): &ast::ScopeTree {
		mut s := newScope()
		s.End = end
		mut sp := scopeParser{
			p: self,
		}
		sp.build(tokens, s)
		ret s
	}

	unsafe fn _buildType(mut &self, mut &tokens: []&token::Token,
		mut i: *int, err: bool): (&ast::Type, bool) {
		mut tb := typeBuilder{
			p: self,
			tokens: tokens,
			i: i,
			err: err,
		}
		ret tb.build()
	}

	// Builds AST model of data-type.
	unsafe fn buildType(mut &self, mut &tokens: []&token::Token,
		mut i: *int, err: bool): (&ast::Type, bool) {
		ret self._buildType(tokens, i, err)
	}

	fn buildTypeAliasDecl(mut &self, mut &tokens: []&token::Token): &ast::TypeAlias {
		mut i := 1 // Skip "type" keyword.
		if i >= len(tokens) {
			self.pushErr(tokens[i-1], log::InvalidSyntax)
			ret nil
		}
		mut tad := &ast::TypeAlias{
			Token: tokens[1],
			Ident: tokens[1].Kind,
		}
		mut token := tokens[i]
		if !self.isIdent(token) {
			self.pushErr(token, log::InvalidSyntax)
			self.pushSuggestion(log::ExpectedIdentifier)
		}
		i++
		if i >= len(tokens) {
			self.pushErr(tokens[i-1], log::InvalidSyntax)
			ret tad
		}
		token = tokens[i]
		match token.Id {
		| token::Colon:
			tad.Strict = true
			break
		| token::Eq:
			break
		|:
			self.pushErr(tokens[i-1], log::InvalidSyntax)
			self.pushSuggestion(log::ExpectedColon)
			ret tad
		}
		i++
		if i >= len(tokens) {
			self.pushErr(tokens[i-1], log::MissingType)
			ret tad
		}
		mut t, ok := unsafe { self.buildType(tokens, &i, true) }
		tad.Kind = t
		if ok && i < len(tokens) {
			self.pushErr(tokens[i], log::InvalidSyntax)
		}
		tad.Public = mod::IsPub(tad.Ident)
		ret tad
	}

	fn buildConstVarGroup(mut &self, mut &tokens: []&token::Token): &ast::Var {
		mut i := 1 // Point to open parentheses.
		mut rangeTokens := range(i, token::LParent, token::RParent, tokens)
		if i < len(tokens) {
			self.pushErr(tokens[i], log::InvalidSyntax)
		}
		mut stmts := splitStmts(rangeTokens)
		if len(stmts) == 0 {
			self.pushErr(tokens[0], log::EmptyGroup)
			ret nil
		}
		mut group := make([]&ast::Var, 0, len(stmts))
		for (_, mut stmt) in stmts {
			mut v := &ast::Var{
				Constant: true,
				Token: tokens[0],
			}
			self.buildVarCommon(v, stmt.tokens)
			group = append(group, v)
		}
		// Setup group metadata.
		for (j, mut v) in group {
			v.GroupIndex = j
			v.Group = group
		}
		ret group[0]
	}

	fn buildVarTypeAndExpr(mut &self, mut &v: &ast::Var, mut &tokens: []&token::Token) {
		mut i := 0
		mut tok := tokens[i]
		if tok.Id == token::Colon {
			i++ // Skip type annotation operator (:)
			if i >= len(tokens) || tokens[i].Id == token::Eq {
				self.pushErr(tok, log::MissingType)
				ret
			}
			mut t, ok := unsafe { self.buildType(tokens, &i, true) }
			if ok {
				v.Kind = t
				if i >= len(tokens) {
					ret
				}
				tok = tokens[i]
			}
		}

		if tok.Id != token::Eq {
			self.pushErr(tok, log::InvalidSyntax)
			ret
		}
		v.Setter = tok

		mut exprTokens := tokens[i+1:]
		if len(exprTokens) == 0 {
			self.pushErr(tok, log::MissingExpr)
			ret
		}
		v.Expr = self.buildExpr(exprTokens)
	}

	fn buildVarCommon(mut &self, mut &v: &ast::Var, mut tokens: []&token::Token) {
		v.Token = tokens[0]
		if !self.isIdent(v.Token) {
			self.pushErr(v.Token, log::InvalidSyntax)
			self.pushSuggestion(log::ExpectedIdentifier)
			ret
		}
		v.Ident = v.Token.Kind
		v.Public = mod::IsPub(v.Ident)
		v.Kind = nil // For auto-type.
		if len(tokens) > 1 {
			tokens = tokens[1:] // Remove identifier.
			self.buildVarTypeAndExpr(v, tokens)
		}
	}

	fn buildVarBegin(mut self, mut &v: &ast::Var, mut &tokens: []&token::Token) {
		tok := tokens[0]
		match tok.Id {
		| token::Static:
			v.Statically = true
			fall
		| token::Let:
			// Initialize 1 for skip the let keyword
			if len(tokens) == 1 {
				tokens = nil
				self.pushErr(tok, log::InvalidSyntax)
				ret
			}
			tokens = tokens[1:]
			if tokens[0].Id == token::Mut {
				v.Mutable = true
				// Skip the mut keyword
				tokens = tokens[1:]
			}
		| token::Const:
			v.Constant = true
			tokens = tokens[1:]
		|:
			tokens = nil
			self.pushErr(tok, log::InvalidSyntax)
		}
	}

	fn buildVar(mut &self, mut tokens: []&token::Token): &ast::Var {
		// Catch constant groups
		if len(tokens) >= 2 && tokens[0].Id == token::Const && tokens[1].Id == token::LParent {
			ret self.buildConstVarGroup(tokens)
		}
		mut v := &ast::Var{
			Token: tokens[0],
		}
		self.buildVarBegin(v, tokens)
		if len(tokens) == 0 {
			if tokens != nil {
				// Log error if tokens != nil, if tokens is nil, an error already logged.
				// Avoid duplicated errors.
				self.pushErr(v.Token, log::InvalidSyntax)
			}
			ret nil
		}
		if tokens[0].Id == token::Amper {
			v.Reference = true
			if len(tokens) == 1 {
				ret nil
			}
			tokens = tokens[1:]
		}
		self.buildVarCommon(v, tokens)
		ret v
	}

	fn buildGeneric(mut &self, mut &tokens: []&token::Token): &ast::Generic {
		mut g := &ast::Generic{
			Token: tokens[0],
		}
		if g.Token.Id != token::Name {
			self.pushErr(g.Token, log::InvalidSyntax)
			self.pushSuggestion(log::ExpectedIdentifier)
		}
		g.Ident = g.Token.Kind
		if len(tokens) > 1 {
			if tokens[1].Id != token::Colon {
				self.pushErr(tokens[1], log::InvalidSyntax)
				ret nil
			}
			if len(tokens) == 2 {
				self.pushErr(tokens[1], log::MissingExpr)
				ret nil
			}
			mut constraintTokens := tokens[2:]
			mut parts, errors := parts(constraintTokens, token::Vline, true)
			if len(errors) > 0 {
				self.errors = append(self.errors, errors...)
				ret nil
			}
			g.Constraint = &ast::Constraint{Mask: make([]&ast::Type, 0, len(parts))}
			for (_, mut part) in parts {
				mut i := 0
				mut kind, _ := unsafe { self.buildType(part, &i, true) }
				g.Constraint.Mask = append(g.Constraint.Mask, kind)
				if i < len(part) {
					self.pushErr(part[i], log::InvalidSyntax)
				}
			}
		}
		ret g
	}

	fn buildGenerics(mut &self, mut &tokens: []&token::Token, &errorToken: &token::Token): []&ast::Generic {
		if len(tokens) == 0 {
			self.pushErr(errorToken, log::MissingExpr)
			ret nil
		}

		mut parts, errors := parts(tokens, token::Comma, true)
		if len(errors) > 0 {
			self.errors = append(self.errors, errors...)
			ret nil
		}

		mut generics := make([]&ast::Generic, 0, len(parts))
		for (_, mut part) in parts {
			generics = append(generics, self.buildGeneric(part))
		}

		ret generics
	}

	fn buildSelfParam(mut self, mut tokens: []&token::Token): &ast::Param {
		if len(tokens) == 0 {
			ret nil
		}

		mut param := new(ast::Param)

		// Detects mut keyword.
		if tokens[0].Id == token::Mut {
			param.Mutable = true
			if len(tokens) == 1 {
				self.pushErr(tokens[0], log::InvalidSyntax)
				ret nil
			}
			tokens = tokens[1:]
		}

		mut ident := strings::Builder{}
		ident.Grow(5)

		if tokens[0].Id == token::Amper {
			ident.WriteStr("&")!
			if len(tokens) == 1 {
				self.pushErr(tokens[0], log::InvalidSyntax)
				ret nil
			}
			tokens = tokens[1:]
		}

		if tokens[0].Id == token::Self {
			ident.WriteStr("self")!
			param.Token = tokens[0]
			if len(tokens) != 1 {
				self.pushErr(tokens[1], log::InvalidSyntax)
			}
		}

		param.Ident = ident.Str()
		ret param
	}

	fn paramTypeBegin(mut self, mut &param: &ast::Param, mut &i: int, &tokens: []&token::Token) {
		for i < len(tokens); i++ {
			token := tokens[i]
			if token.Id != token::TripleDot {
				ret
			}

			if param.Variadic {
				self.pushErr(token, log::AlreadyVariadic)
				continue
			}
			param.Variadic = true
		}
	}

	fn buildParamType(mut &self, mut &param: &ast::Param, mut &tokens: []&token::Token) {
		mut i := 0
		self.paramTypeBegin(param, i, tokens)
		if i >= len(tokens) {
			ret
		}

		param.Kind, _ = unsafe { self.buildType(tokens, &i, true) }
		if i < len(tokens) {
			self.pushErr(tokens[i], log::InvalidSyntax)
		}
	}

	fn buildParamBody(mut &self, mut &param: &ast::Param, mut tokens: []&token::Token) {
		mut tok := tokens[0]
		if len(tokens) == 1 {
			// Just identifier token.
			param.Ident = tok.Kind
			ret
		} else if len(tokens) < 3 {
			self.pushErr(tok, log::MissingType)
			ret
		}
		if tokens[1].Id != token::Colon {
			param.Ident = jule::Anon
			self.buildParamType(param, tokens)
			ret
		}
		param.Ident = tok.Kind
		tokens = tokens[2:] // Skip colon
		self.buildParamType(param, tokens)
	}

	fn buildParam(mut &self, mut tokens: []&token::Token): &ast::Param {
		mut param := &ast::Param{
			Token: tokens[0],
		}

		// Detects mut keyword.
		if param.Token.Id == token::Mut {
			param.Mutable = true
			if len(tokens) == 1 {
				self.pushErr(tokens[0], log::InvalidSyntax)
				ret nil
			}
			tokens = tokens[1:]
			param.Token = tokens[0]
		}

		// Catch reference parameters.
		if len(tokens) >= 3 {
			if param.Token.Id == token::Amper {
				if len(tokens) == 1 {
					self.pushErr(tokens[0], log::InvalidSyntax)
					ret nil
				}

				if tokens[1].Id == token::Name && tokens[2].Id == token::Colon {
					param.Reference = true
					tokens = tokens[1:]
					param.Token = tokens[0]
				}
			}
		}

		if param.Token.Id != token::Name {
			// Just data type
			param.Ident = jule::Anon
			self.buildParamType(param, tokens)
		} else {
			self.buildParamBody(param, tokens)
		}

		ret param
	}

	fn checkParams(mut self, mut &params: []&ast::Param) {
		for (_, mut param) in params {
			if param.IsSelf() || param.Kind != nil {
				continue
			}
			if param.Token == nil {
				self.pushErr(param.Token, log::MissingType)
			} else {
				param.Kind = &ast::Type{
					Token: param.Token,
					Kind: &ast::IdentType{
						Token: param.Token,
						Ident: param.Token.Kind,
					},
				}
				param.Ident = jule::Anon
			}
		}
	}

	fn buildParams(mut &self, mut &tokens: []&token::Token, method: bool): []&ast::Param {
		mut parts, errs := parts(tokens, token::Comma, true)
		self.errors = append(self.errors, errs...)
		if len(parts) == 0 {
			ret nil
		}

		let mut params: []&ast::Param = nil
		if method && len(parts) > 0 {
			mut param := self.buildSelfParam(parts[0])
			if param != nil && param.IsSelf() {
				params = append(params, param)
				parts = parts[1:]
			}
		}

		for (_, mut part) in parts {
			if len(part) == 0 {
				continue
			}
			mut param := self.buildParam(part)
			if param != nil {
				params = append(params, param)
			}
		}

		self.checkParams(params)
		ret params
	}

	fn buildMultiRetType(mut &self, mut &t: &ast::RetType, mut &tokens: []&token::Token, mut &i: int): (ok: bool) {
		i++
		if i >= len(tokens) {
			i--
			t.Kind, ok = unsafe { self.buildType(tokens, &i, false) }
			ret
		}

		i-- // For point to parentheses - ( -
		mut rangeTokens := range(i, token::LParent, token::RParent, tokens)

		mut parts, errs := parts(rangeTokens, token::Comma, true)
		self.errors = append(self.errors, errs...)
		if len(parts) == 0 {
			ret
		}

		mut types := make([]&ast::Type, 0, len(parts))
		t.Idents = make([]&token::Token, 0, len(parts))
		for (_, mut part) in parts {
			if len(part) == 0 {
				continue
			}
			mut token := part[0]
			mut offset := 0

			// Check type annotation.
			if len(part) > 1 {
				token = part[1]
				if token.Id == token::Colon {
					offset = 2
					if len(part) < 3 {
						self.pushErr(token, log::MissingType)
						continue
					}
				}
			}

			token = part[0]
			if offset != 2 {
				mut newToken := new(token::Token, *token)
				newToken.Kind = jule::Anon
				t.Idents = append(t.Idents, newToken)
			} else {
				t.Idents = append(t.Idents, token)
			}

			mut tk, _ := unsafe { self.buildType(part, &offset, true) }
			if offset < len(part) {
				self.pushErr(part[offset], log::InvalidSyntax)
			}
			types = append(types, tk)
		}

		if len(types) > 1 {
			t.Kind = &ast::Type{
				Token: tokens[0],
				Kind: &ast::TupleType{
					Types: types,
				},
			}
		} else {
			t.Kind = types[0]
		}

		ok = true
		ret
	}

	// Builds function return type from tokens.
	fn buildRetType(mut &self, mut &tokens: []&token::Token, mut &i: int): (t: &ast::RetType, ok: bool) {
		t = new(ast::RetType)
		if i >= len(tokens) {
			ret
		}

		mut token := tokens[i]
		match token.Id {
		| token::LBrace:
			ret
		| token::Eq:
			ret
		| token::Colon:
			if i+1 >= len(tokens) {
				self.pushErr(token, log::MissingType)
				ret
			}

			i++
			token = tokens[i]
			match token.Id {
			| token::LParent:
				ok = self.buildMultiRetType(t, tokens, i)
				ret
			| token::LBrace:
				self.pushErr(token, log::MissingType)
				ret
			}
			t.Kind, ok = unsafe { self.buildType(tokens, &i, true) }
			// If result type analysis failed, set i to -1 for error mark.
			if !ok {
				i = -1
			}
			ret
		}
		i++
		self.pushErr(token, log::InvalidSyntax)
		ret
	}

	// Build function prototype.
	// Body is not necessary for successful parsing.
	// Just declaration.
	fn buildFuncPrototype(mut &self, mut &tokens: []&token::Token, mut &i: int, method: bool): &ast::Func {
		mut f := &ast::Func{
			Token: tokens[i],
		}

		// Detect static keyword.
		if f.Token.Id == token::Static {
			f.Statically = true
			i++
			if i >= len(tokens) {
				self.pushErr(f.Token, log::InvalidSyntax)
				ret nil
			}
			f.Token = tokens[i]
		}

		// Detect unsafe keyword.
		if f.Token.Id == token::Unsafe {
			f.Unsafety = true
			i++
			if i >= len(tokens) {
				self.pushErr(f.Token, log::InvalidSyntax)
				ret nil
			}
			f.Token = tokens[i]
		}

		// Skips fn token.
		i++
		if i >= len(tokens) {
			self.pushErr(f.Token, log::InvalidSyntax)
			ret nil
		}

		tok := tokens[i]
		if self.isIdent(tok) {
			i++
			if i >= len(tokens) {
				self.pushErr(f.Token, log::InvalidSyntax)
				ret nil
			}
			f.Ident = tok.Kind
		} else {
			f.Ident = jule::Anon
		}

		errorToken := tokens[i]
		mut genericsTokens := range(i, token::LBracket, token::RBracket, tokens)
		if genericsTokens != nil {
			f.Generics = self.buildGenerics(genericsTokens, errorToken)
		}

		if tokens[i].Id != token::LParent {
			self.pushErr(tokens[i], log::MissingFuncParentheses)
			ret nil
		}

		mut paramsToks := range(i, token::LParent, token::RParent, tokens)
		if len(paramsToks) > 0 {
			f.Params = self.buildParams(paramsToks, method)
		}

		if i < len(tokens) {
			token := tokens[i]
			if token.Id == token::Excl {
				f.Exceptional = true
				i++
			}
		}

		f.Public = mod::IsPub(f.Ident)
		f.Result, _ = self.buildRetType(tokens, i)
		ret f
	}

	// Parses function define.
	// Prototype and body.
	fn buildFunc(mut &self, mut &tokens: []&token::Token, method: bool, prototype: bool): &ast::Func {
		mut i := 0
		mut f := self.buildFuncPrototype(tokens, i, method)
		// If i == -1, there is critical error for analysis.
		// Return nil immediately.
		if i == -1 {
			ret nil
		}
		if prototype {
			if i < len(tokens) {
				self.pushErr(tokens[i], log::InvalidSyntax)
			}
			ret f
		} else if f == nil {
			ret f
		}

		if i >= len(tokens) {
			self.stop()
			self.pushErr(f.Token, log::BodyNotExist)
			self.pushSuggestion(log::ExpectedBody)
			ret nil
		}
		mut blockTokens := range(i, token::LBrace, token::RBrace, tokens)
		if blockTokens != nil {
			f.Scope = self.buildScope(blockTokens, tokens[i-1])
			f.Scope.Unsafety = f.Unsafety
			if i < len(tokens) {
				self.pushErr(tokens[i], log::InvalidSyntax)
			}
		} else {
			self.stop()
			self.pushErr(tokens[i], log::BodyNotExist)
			self.pushSuggestion(log::ExpectedBody)
			ret nil
		}
		ret f
	}

	fn buildBindUseDecl(mut self, mut &decl: &ast::Use, mut &tokens: []&token::Token) {
		if len(tokens) > 1 {
			self.pushErr(tokens[1], log::InvalidSyntax)
		}
		mut token := tokens[0]
		if token.Id != token::Lit || !token::IsStr(token.Kind) || token::IsRawStr(token.Kind) {
			self.pushErr(token, log::InvalidExpr)
			ret
		}
		decl.Binded = true
		decl.Path = token
	}

	fn parseUseDecl(mut self, mut &decl: &ast::Use, mut tokens: []&token::Token) {
		if decl.Binded {
			self.buildBindUseDecl(decl, tokens)
			ret
		}

		mut token := tokens[0]
		if token.Id != token::Name && token.Id != token::Lit &&
			!token::IsStr(token.Kind) || token::IsRawStr(token.Kind) {
			self.pushErr(token, log::InvalidSyntax)
			ret
		}

		if token.Id == token::Name { // custom alias exist
			decl.Alias = token
			tokens = tokens[1:]
			if len(tokens) == 0 {
				self.pushErr(token, log::InvalidSyntax)
				ret
			}
			token = tokens[0]
			if token.Id != token::Lit || !token::IsStr(token.Kind) {
				self.pushErr(token, log::InvalidSyntax)
				ret
			}
		}

		if len(tokens) > 1 {
			self.pushErr(tokens[1], log::InvalidSyntax)
			ret
		}

		decl.Path = token
	}

	fn buildUseDecl(mut self, mut tokens: []&token::Token, binded: bool): &ast::Use {
		mut decl := &ast::Use{
			Token: tokens[0], // See developer reference (8).
			Binded: binded,
		}
		if len(tokens) < 2 {
			self.pushErr(decl.Token, log::MissingUsePath)
			ret nil
		}
		tokens = tokens[1:] // Skip "use" keyword.
		self.parseUseDecl(decl, tokens)
		ret decl
	}

	fn buildTypeEnumItemKind(mut &self, mut &i: int, mut &tokens: []&token::Token): &ast::Type {
		mut braceN := 0
		exprStart := i
		for i < len(tokens); i++ {
			t := tokens[i]
			match t.Id {
			| token::LBrace
			| token::LBracket
			| token::LParent:
				braceN++
				continue
			| token::RBrace
			| token::RBracket
			| token::RParent:
				braceN--
			}
			if braceN > 0 {
				continue
			}
			if t.Id == token::Comma || i+1 >= len(tokens) {
				let mut kindTokens: []&token::Token = nil
				if t.Id == token::Comma {
					kindTokens = tokens[exprStart:i]
				} else {
					kindTokens = tokens[exprStart:]
				}
				mut j := 0
				mut kind, _ := unsafe { self.buildType(kindTokens, &j, true) }
				if j < len(kindTokens) {
					self.pushErr(kindTokens[j], log::InvalidSyntax)
				}
				ret kind
			}
		}
		ret nil
	}

	fn buildTypeEnumItems(mut &self, mut &tokens: []&token::Token): []&ast::TypeEnumItem {
		mut items := make([]&ast::TypeEnumItem, 0, 1)
		mut i := 0
		for i < len(tokens); i++ {
			mut t := tokens[i]
			mut item := new(ast::TypeEnumItem)
			item.Token = t
			// For more describing error messages, handle ordinary enum cases.
			// User may attempt to use named fields like ordinary enums for type enums.
			if item.Token.Id == token::Name && len(tokens)-i > 2 {
				t = tokens[i+1]
				if t.Id == token::Colon {
					self.pushErr(t, log::InvalidEnumKindForNamedFields)
					ret nil
				}
			}
			item.Kind = self.buildTypeEnumItemKind(i, tokens)
			items = append(items, item)
		}
		ret items
	}

	fn buildTypeEnum(mut &self, mut &tokens: []&token::Token): &ast::TypeEnum {
		mut i := 1
		mut e := &ast::TypeEnum{
			// Skip "enum" tokens.
			Token: tokens[i],
		}
		if e.Token.Id != token::Name {
			self.pushErr(e.Token, log::InvalidSyntax)
			self.pushSuggestion(log::ExpectedIdentifier)
		}
		e.Ident = e.Token.Kind
		i += 3 // Skip "identifier: type" tokens.
		mut itemTokens := range(i, token::LBrace, token::RBrace, tokens)
		if itemTokens == nil {
			self.stop()
			self.pushErr(e.Token, log::BodyNotExist)
			self.pushSuggestion(log::ExpectedBody)
			ret e
		} else if i < len(tokens) {
			self.pushErr(tokens[i], log::InvalidSyntax)
		}
		e.Public = mod::IsPub(e.Ident)
		e.End = tokens[i-1]
		e.Items = self.buildTypeEnumItems(itemTokens)
		ret e
	}

	fn buildEnumItemExpr(mut &self, mut &i: int, mut &tokens: []&token::Token): &ast::Expr {
		mut braceN := 0
		exprStart := i
		for i < len(tokens); i++ {
			t := tokens[i]
			match t.Id {
			| token::LBrace
			| token::LBracket
			| token::LParent:
				braceN++
				continue
			| token::RBrace
			| token::RBracket
			| token::RParent:
				braceN--
			}
			if braceN > 0 {
				continue
			}
			if t.Id == token::Comma || i+1 >= len(tokens) {
				let mut exprTokens: []&token::Token = nil
				if t.Id == token::Comma {
					exprTokens = tokens[exprStart:i]
				} else {
					exprTokens = tokens[exprStart:]
				}
				ret self.buildExpr(exprTokens)
			}
		}
		ret nil
	}

	fn buildEnumItems(mut &self, mut &tokens: []&token::Token): []&ast::EnumItem {
		mut items := make([]&ast::EnumItem, 0, 1)
		mut i := 0
		for i < len(tokens); i++ {
			mut t := tokens[i]
			mut item := new(ast::EnumItem)
			item.Token = t
			if item.Token.Id != token::Name {
				self.pushErr(item.Token, log::InvalidSyntax)
				self.pushSuggestion(log::ExpectedIdentifier)
			}
			item.Ident = item.Token.Kind
			if i+1 >= len(tokens) || tokens[i+1].Id == token::Comma {
				if i+1 < len(tokens) {
					i++
				}
				items = append(items, item)
				continue
			}
			i++
			t = tokens[i]
			i++
			if t.Id != token::Colon {
				self.pushErr(t, log::InvalidSyntax)
				self.pushSuggestion(log::ExpectedColonForAssign)
				continue
			}
			if i >= len(tokens) || tokens[i].Id == token::Comma {
				self.pushErr(t, log::MissingExpr)
				continue
			}
			item.Expr = self.buildEnumItemExpr(i, tokens)
			items = append(items, item)
		}
		ret items
	}

	fn buildEnum(mut &self, mut &tokens: []&token::Token): &ast::Enum {
		if len(tokens) < 3 {
			self.pushErr(tokens[0], log::InvalidSyntax)
			ret nil
		}
		mut e := &ast::Enum{
			Token: tokens[1],
		}
		if e.Token.Id != token::Name {
			self.pushErr(e.Token, log::InvalidSyntax)
			self.pushSuggestion(log::ExpectedIdentifier)
		}
		e.Ident = e.Token.Kind
		mut i := 2
		if tokens[i].Id == token::Colon {
			i++
			if i >= len(tokens) {
				self.pushErr(tokens[i-1], log::InvalidSyntax)
				ret e
			}
			e.Kind, _ = unsafe { self.buildType(tokens, &i, true) }
			if i >= len(tokens) {
				self.stop()
				self.pushErr(e.Token, log::BodyNotExist)
				self.pushSuggestion(log::ExpectedBody)
				ret e
			}
		} else {
			e.Kind = nil
		}
		mut itemTokens := range(i, token::LBrace, token::RBrace, tokens)
		if itemTokens == nil {
			self.stop()
			self.pushErr(e.Token, log::BodyNotExist)
			self.pushSuggestion(log::ExpectedBody)
			ret e
		} else if i < len(tokens) {
			self.pushErr(tokens[i], log::InvalidSyntax)
		}
		e.Public = mod::IsPub(e.Ident)
		e.End = tokens[i-1]
		e.Items = self.buildEnumItems(itemTokens)
		ret e
	}

	fn buildNodeEnum(mut &self, mut &tokens: []&token::Token): ast::NodeData {
		if len(tokens) > 3 && tokens[2].Id == token::Colon {
			if tokens[3].Id == token::Type {
				ret self.buildTypeEnum(tokens)
			}
		}
		ret self.buildEnum(tokens)
	}

	fn buildField(mut &self, mut tokens: []&token::Token): &ast::Field {
		mut f := new(ast::Field)

		f.Mutable = tokens[0].Id == token::Mut
		if f.Mutable {
			if len(tokens) == 1 {
				self.pushErr(tokens[0], log::InvalidSyntax)
				ret nil
			}
			tokens = tokens[1:]
		}

		f.Token = tokens[0]
		if f.Token.Id != token::Name {
			self.pushErr(f.Token, log::InvalidSyntax)
			self.pushSuggestion(log::ExpectedIdentifier)
			ret nil
		}
		f.Ident = f.Token.Kind

		if len(tokens) == 1 {
			self.pushErr(tokens[0], log::MissingType)
			ret nil
		} else if len(tokens) < 3 || tokens[1].Id != token::Colon {
			self.pushErr(tokens[1], log::MissingType)
			ret nil
		}

		tokens = tokens[2:] // Remove identifier and colon tokens.
		mut i := 0
		f.Kind, _ = unsafe { self.buildType(tokens, &i, true) }
		if i < len(tokens) {
			mut token := tokens[i]
			if token.Id == token::Lit {
				f.Tag = token
				i++
				if i < len(tokens) {
					self.pushErr(tokens[i], log::InvalidSyntax)
				}
			} else {
				self.pushErr(tokens[i], log::InvalidSyntax)
			}
		}
		f.Public = mod::IsPub(f.Ident)
		ret f
	}

	fn buildStructDeclFields(mut &self, mut tokens: []&token::Token): []&ast::Field {
		let mut fields: []&ast::Field = nil
		mut stmts := splitStmts(tokens)
		for (_, mut stmt) in stmts {
			tokens = stmt.tokens
			mut f := self.buildField(tokens)
			fields = append(fields, f)
		}
		ret fields
	}

	fn buildStructDecl(mut &self, mut &tokens: []&token::Token): &ast::Struct {
		if len(tokens) < 3 {
			self.pushErr(tokens[0], log::InvalidSyntax)
			ret nil
		}

		mut i := 1
		mut s := &ast::Struct{
			Token: tokens[i],
		}
		if !self.isIdent(s.Token) {
			self.pushErr(s.Token, log::InvalidSyntax)
			self.pushSuggestion(log::ExpectedIdentifier)
		}
		i++
		if i >= len(tokens) {
			self.pushErr(tokens[i], log::InvalidSyntax)
			ret s
		}
		s.Ident = s.Token.Kind

		errorToken := tokens[i]
		mut genericsTokens := range(i, token::LBracket, token::RBracket, tokens)
		if genericsTokens != nil {
			s.Generics = self.buildGenerics(genericsTokens, errorToken)
		}
		if i >= len(tokens) {
			self.pushErr(tokens[i-1], log::BodyNotExist)
			self.pushSuggestion(log::ExpectedBody)
			ret s
		}

		mut bodyTokens := range(i, token::LBrace, token::RBrace, tokens)
		if bodyTokens == nil {
			self.stop()
			self.pushErr(s.Token, log::BodyNotExist)
			self.pushSuggestion(log::ExpectedBody)
			ret s
		}
		if i < len(tokens) {
			self.pushErr(tokens[i], log::InvalidSyntax)
		}
		s.Public = mod::IsPub(s.Ident)
		s.Fields = self.buildStructDeclFields(bodyTokens)
		s.End = tokens[i-1]
		ret s
	}

	fn checkMethodReceiver(mut self, &f: &ast::Func) {
		// Static methods cannot have receiver.
		if f.Statically {
			if len(f.Params) > 0 && f.Params[0].IsSelf() {
				self.pushErr(f.Token, log::StaticFuncHasReceiver)
			}
			ret
		}
		if len(f.Params) == 0 {
			self.pushErr(f.Token, log::MissingReceiver)
			ret
		}
		param := f.Params[0]
		if !param.IsSelf() {
			self.pushErr(f.Token, log::MissingReceiver)
			ret
		}
	}

	fn buildTraitBody(mut &self, mut &t: &ast::Trait, mut tokens: []&token::Token) {
		mut stmts := splitStmts(tokens)
		for (_, mut stmt) in stmts {
			tokens = stmt.tokens
			if len(tokens) == 0 {
				continue
			}
			match tokens[0].Id {
			| token::Fn:
				mut f := self.buildFunc(tokens, true, true)
				if f == nil {
					break
				}
				self.checkMethodReceiver(f)
				if len(f.Generics) > 0 {
					self.pushErr(f.Token, log::TraitMethodHasGenerics)
				}
				t.Methods = append(t.Methods, f)
			|:
				mut i := 0
				mut ti, ok := unsafe { self.buildType(tokens, &i, true) }
				if !ok {
					break
				}
				if i < len(tokens) {
					self.pushErr(tokens[i], log::InvalidSyntax)
				}
				t.Inherits = append(t.Inherits, ti)
			}
		}
	}

	fn buildTraitDecl(mut &self, mut &tokens: []&token::Token): &ast::Trait {
		if len(tokens) < 3 {
			self.pushErr(tokens[0], log::InvalidSyntax)
			ret nil
		}
		mut t := &ast::Trait{
			Token: tokens[1],
		}
		if t.Token.Id != token::Name {
			self.pushErr(t.Token, log::InvalidSyntax)
			self.pushSuggestion(log::ExpectedIdentifier)
		}
		t.Ident = t.Token.Kind
		mut i := 2
		mut bodyTokens := range(i, token::LBrace, token::RBrace, tokens)
		if bodyTokens == nil {
			self.stop()
			self.pushErr(t.Token, log::BodyNotExist)
			self.pushSuggestion(log::ExpectedBody)
			ret nil
		}
		if i < len(tokens) {
			self.pushErr(tokens[i], log::InvalidSyntax)
		}
		t.Public = mod::IsPub(t.Ident)
		self.buildTraitBody(t, bodyTokens)
		t.End = tokens[i-1]
		ret t
	}

	fn buildBindFunc(mut &self, mut tokens: []&token::Token): &ast::Func {
		tokens = tokens[1:] // Remove "cpp" keyword.
		mut f := self.buildFunc(tokens, false, true)
		if f != nil {
			f.Public = false
			f.Binded = true
		}
		ret f
	}

	fn buildBindVar(mut &self, mut tokens: []&token::Token): &ast::Var {
		tokens = tokens[1:] // Remove "cpp" keyword.
		mut v := self.buildVar(tokens)
		if v != nil {
			v.Public = false
			v.Binded = true
			if v.Expr != nil {
				self.pushErr(v.Token, log::BindedVarHasExpr)
			}
		}
		ret v
	}

	fn buildBindStruct(mut &self, mut tokens: []&token::Token): &ast::Struct {
		tokens = tokens[1:] // Remove "cpp" keyword.
		mut s := self.buildStructDecl(tokens)
		if s != nil {
			s.Public = false
			for (_, mut f) in s.Fields {
				// Binded structure's fields are always public by default.
				f.Public = true
			}
			s.Binded = true
		}
		ret s
	}

	fn buildBindTypeAlias(mut &self, mut tokens: []&token::Token): &ast::TypeAlias {
		tokens = tokens[1:] // Remove "cpp" keyword.
		mut t := self.buildTypeAliasDecl(tokens)
		if t != nil {
			t.Public = false
			t.Binded = true
		}
		ret t
	}

	fn buildBindUse(mut &self, mut tokens: []&token::Token): &ast::Use {
		if len(tokens) == 1 {
			self.pushErr(tokens[0], log::InvalidSyntax)
			ret nil
		}
		tokens = tokens[1:] // Remove the bind keyword.

		const Binded = true
		ret self.buildUseDecl(tokens, Binded)
	}

	fn buildBind(mut &self, mut &tokens: []&token::Token): (data: ast::NodeData) {
		mut token := tokens[0]
		if len(tokens) == 1 {
			self.pushErr(token, log::InvalidSyntax)
			ret nil
		}

		// Save mode to restore and set additional required modes.
		mode := self.mode
		// Bind defines are may defined by a Jule keyword. It should be valid.
		// Since they accessed and defined via keyword, it should be safe and clear.
		self.mode |= allowKeywordIdentifiers

		token = tokens[1]
		match token.Id {
		| token::Fn
		| token::Unsafe:
			data = self.buildBindFunc(tokens)
		| token::Const
		| token::Let:
			data = self.buildBindVar(tokens)
		| token::Struct:
			data = self.buildBindStruct(tokens)
		| token::Type:
			data = self.buildBindTypeAlias(tokens)
		|:
			self.pushErr(token, log::InvalidSyntax)
		}
		self.mode = mode // Restore the parser mode.
		ret
	}

	fn getMethod(mut &self, mut &tokens: []&token::Token): &ast::Func {
		mut i := 0
		mut token := tokens[i]
		if token.Id == token::Static {
			if i+1 >= len(tokens) {
				self.pushErr(token, log::InvalidSyntax)
				ret nil
			}
			i++
			token = tokens[i]
		}

		if token.Id == token::Unsafe {
			if i+1 >= len(tokens) {
				self.pushErr(token, log::InvalidSyntax)
				ret nil
			}
			i++
			token = tokens[i]
		}

		if token.Id != token::Fn {
			self.pushErr(token, log::InvalidSyntax)
			ret nil
		}

		ret self.buildFunc(tokens, true, false)
	}

	fn parseImplBody(mut &self, mut &ipl: &ast::Impl, mut &tokens: []&token::Token) {
		mut stmts := splitStmts(tokens)
		for (_, mut stmt) in stmts {
			tokens = stmt.tokens
			mut token := tokens[0]
			match token.Id {
			| token::Hash:
				self.pushDirective(self.buildDirective(tokens))
				continue
			}

			match token.Id {
			| token::Static
			| token::Fn
			| token::Unsafe:
				mut f := self.getMethod(tokens)
				if f != nil {
					self.checkMethodReceiver(f)
					self.applyFuncMeta(f)
					ipl.Methods = append(ipl.Methods, f)
				}
			|:
				self.pushErr(token, log::InvalidSyntax)
				continue
			}
		}
	}

	fn buildImpl(mut &self, mut tokens: []&token::Token): &ast::Impl {
		mut token := tokens[0]
		if len(tokens) < 2 {
			self.pushErr(token, log::InvalidSyntax)
			ret nil
		}

		mut i := 1

		mut base, mut ok := unsafe { self.buildType(tokens, &i, true) }
		if !ok {
			ret nil
		}
		if i >= len(tokens) {
			self.pushErr(token, log::InvalidSyntax)
			ret nil
		}

		mut ipl := &ast::Impl{
			Base: base,
		}

		token = tokens[i]
		if token.Id != token::For {
			if token.Id == token::LBrace {
				// This implementation is single.
				// Just implements to destination.
				// Therefore, swap Base and Dest tokens.
				ipl.Base, ipl.Dest = ipl.Dest, ipl.Base
				goto body
			}
			self.stop()
			self.pushErr(token, log::BodyNotExist)
			self.pushSuggestion(log::ExpectedBody)
			ret nil
		}
		i++
		if i >= len(tokens) {
			self.stop()
			self.pushErr(token, log::BodyNotExist)
			self.pushSuggestion(log::ExpectedBody)
			ret nil
		}

		ipl.Dest, ok = unsafe { self.buildType(tokens, &i, true) }
		if !ok {
			ret nil
		}
		if i >= len(tokens) {
			self.stop()
			self.pushErr(token, log::BodyNotExist)
			self.pushSuggestion(log::ExpectedBody)
			ret nil
		}

	body:
		mut bodyTokens := range(i, token::LBrace, token::RBrace, tokens)
		if bodyTokens == nil {
			self.stop()
			self.pushErr(token, log::BodyNotExist)
			self.pushSuggestion(log::ExpectedBody)
			ret nil
		}
		if i < len(tokens) {
			self.pushErr(tokens[i], log::InvalidSyntax)
		}
		ipl.End = tokens[i-1]
		self.parseImplBody(ipl, bodyTokens)
		ret ipl
	}

	fn buildNodeData(mut &self, mut &tokens: []&token::Token): ast::NodeData {
		mut token := tokens[0]
		match token.Id {
		| token::Fn
		| token::Unsafe:
			mut f := self.buildFunc(tokens, false, false)
			if f != nil {
				f.Global = true
			}
			ret f
		| token::Let
		| token::Const
		| token::Mut
		| token::Static:
			ret self.buildVar(tokens)
		| token::Type:
			ret self.buildTypeAliasDecl(tokens)
		| token::Enum:
			ret self.buildNodeEnum(tokens)
		| token::Struct:
			ret self.buildStructDecl(tokens)
		| token::Trait:
			ret self.buildTraitDecl(tokens)
		| token::Impl:
			ret self.buildImpl(tokens)
		| token::Cpp:
			ret self.buildBind(tokens)
		|:
			self.pushErr(token, log::InvalidSyntax)
			ret nil
		}
	}

	fn applyFuncMeta(mut self, mut &f: &ast::Func) {
		f.Directives = self.directives
		self.directives = nil
	}

	fn applyMeta(mut self, mut &node: ast::Node) {
		match type node.Data {
		| &ast::Var:
			mut v := node.Data.(&ast::Var)
			if v == nil {
				ret
			}
			v.Directives = self.directives
			self.directives = nil
		| &ast::Func:
			mut f := node.Data.(&ast::Func)
			if f == nil {
				ret
			}
			self.applyFuncMeta(f)
		| &ast::Struct:
			mut sd := node.Data.(&ast::Struct)
			if sd == nil {
				ret
			}
			sd.Directives = self.directives
			self.directives = nil
		|:
			// no-op for other types
		}
	}

	fn pushUseDecl(mut &self, mut &decl: &ast::Use) {
		self.ast.UseDecls = append(self.ast.UseDecls, decl)
		if len(self.ast.Nodes) > 0 {
			self.pushErr(decl.Token, log::UseDeclAtBody)
			self.pushSuggestion(log::MoveUseDeclToTopOfFile)
		}
	}

	fn pushMetaNodes(mut &self, mut &tokens: []&token::Token): bool {
		match tokens[0].Id {
		| token::Use:
			const Binded = false
			mut decl := self.buildUseDecl(tokens, Binded)
			self.pushUseDecl(decl)
			ret true
		| token::Cpp:
			if len(tokens) > 1 && tokens[1].Id == token::Use {
				mut decl := self.buildBindUse(tokens)
				self.pushUseDecl(decl)
				ret true
			}
		| token::Hash:
			self.pushDirective(self.buildDirective(tokens))
			ret true
		}
		ret false
	}

	fn parseNode(mut &self, mut &st: []&token::Token): ast::Node {
		mut node := ast::Node{
			Token: st[0],
		}

		if self.pushMetaNodes(st) {
			ret node
		}

		mut data := self.buildNodeData(st)
		if data == nil {
			ret node
		}

		node.Data = data

		self.applyMeta(node)
		if len(self.directives) != 0 {
			self.pushErr(self.directives[0].Tag, log::UnusedDirective)
		}
		self.directives = nil
		ret node
	}

	fn appendNode(mut &self, mut &st: []&token::Token) {
		if len(st) == 0 {
			ret
		}
		mut node := self.parseNode(st)
		if node.Data != nil && !self.stopped() {
			self.ast.Nodes = append(self.ast.Nodes, node)
		}
	}

	fn removeRange(self, mut i: int, id: int, &tokens: []&token::Token, mut &ranges: []int) {
		close := getCloseOfBrace(id)
		for i >= 0; i-- {
			tok := tokens[ranges[i]]
			if tok.Id != close {
				continue
			}
			ranges = append(ranges[:i], ranges[i+1:]...)
			break
		}
	}

	fn pushWrongOrderCloseErr(mut self, &t: &token::Token, &tokens: []&token::Token, &ranges: []int) {
		match tokens[ranges[len(ranges)-1]].Id {
		| token::LParent:
			self.pushErr(t, log::ExpectedParentClose)
		| token::LBrace:
			self.pushErr(t, log::ExpectedBraceClose)
		| token::LBracket:
			self.pushErr(t, log::ExpectedBracketClose)
		}
	}

	fn pushRangeClose(mut self, t: &token::Token, left: int, &tokens: []&token::Token, mut &ranges: []int) {
		n := len(ranges)
		if n == 0 {
			match t.Id {
			| token::RBracket:
				self.pushErr(t, log::ExtraClosedBracket)
			| token::RBrace:
				self.pushErr(t, log::ExtraClosedBrace)
			| token::RParent:
				self.pushErr(t, log::ExtraClosedParent)
			}
			ret
		} else if tokens[ranges[n-1]].Id != left {
			self.pushWrongOrderCloseErr(t, tokens, ranges)
		}
		self.removeRange(n-1, t.Id, tokens, ranges)
	}

	fn checkRanges(mut self, &tokens: []&token::Token) {
		let mut ranges: []int = nil

		for i, token in tokens {
			match token.Id {
			| token::LParent
			| token::LBrace
			| token::LBracket:
				ranges = append(ranges, i)
			| token::RParent:
				self.pushRangeClose(token, token::LParent, tokens, ranges)
			| token::RBrace:
				self.pushRangeClose(token, token::LBrace, tokens, ranges)
			| token::RBracket:
				self.pushRangeClose(token, token::LBracket, tokens, ranges)
			}
		}

		for _, i in ranges {
			token := tokens[i]
			match token.Id {
			| token::LParent:
				self.pushErr(token, log::WaitCloseParent)
			| token::LBrace:
				self.pushErr(token, log::WaitCloseBrace)
			| token::LBracket:
				self.pushErr(token, log::WaitCloseBracket)
			}
		}
	}

	fn parse(mut &self, mut &f: &token::FileSet) {
		self.ast = &ast::AST{
			File: f,
		}
		self.ep = &exprBuilder{
			p: self,
		}

		self.checkRanges(f.Tokens)
		if len(self.errors) > 0 {
			ret
		}

		mut stmts := splitStmts(f.Tokens)

		// Get top directives.
		mut i := 0
		for i < len(stmts); i++ {
			mut stmt := stmts[i]
			if len(stmt.tokens) < 2 {
				break
			}
			if stmt.tokens[0].Id != token::Hash {
				break
			}
			if !directive::IsTop(stmt.tokens[1].Kind) {
				break
			}
			self.ast.TopDirectives = append(self.ast.TopDirectives, self.buildDirective(stmt.tokens))
		}

		// Remove all errors.
		self.errors = nil

		for i < len(stmts) && !self.stopped(); i++ {
			mut stmt := stmts[i]
			self.appendNode(stmt.tokens)
		}

		if len(self.directives) != 0 {
			self.pushErr(self.directives[0].Tag, log::UnusedDirective)
		}
	}
}
// Copyright 2023 The Jule Project Contributors. All rights reserved.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/conv"
use "std/internal/jule/mod"
use "std/jule"
use "std/jule/ast"
use "std/jule/build"
use "std/jule/directive"
use "std/jule/log"
use "std/jule/token"
use "std/os/filepath"
use "std/strings"

fn makeErr(row: int, col: int, f: &token::FileSet, fmt: str, args: ...any): log::Log {
	ret log::Log{
		Kind: log::Error,
		Row: row,
		Column: col,
		Path: f.Path,
		Text: log::Logf(fmt, args...),
	}
}

// Returns between of open and close ranges.
// Starts selection at i.
// Increases i for each selected token.
// i points to close range token after selection.
//
// Special cases are:
//	range(i, open, close, tokens) = nil if i > len(tokens)
//	range(i, open, close, tokens) = nil if tokens[i].ID != open
fn range(mut &i: *int, open: int, close: int, mut tokens: []&token::Token): []&token::Token {
	if *i >= len(tokens) {
		ret nil
	}
	tok := tokens[*i]
	if tok.ID != open {
		ret nil
	}
	*i++
	mut rangeN := 1
	start := *i
	for rangeN != 0 && *i < len(tokens); *i++ {
		token := tokens[*i]
		match token.ID {
		| open:
			rangeN++
		| close:
			rangeN--
		}
	}
	ret tokens[start : *i-1]
}

// Returns last range from tokens.
// Returns tokens without range tokens and range tokens.
// Range tokens includes left and right range tokens.
//
// Special cases are;
//	rangeLast(tokens) = tokens, nil if len(tokens) == 0
//	rangeLast(tokens) = tokens, nil if tokens is not has range at last
fn rangeLast(mut tokens: []&token::Token): (rest: []&token::Token, cut: []&token::Token) {
	if len(tokens) == 0 {
		ret tokens, nil
	}
	first := tokens[len(tokens)-1].ID
	if first != token::RBRACE &&
		first != token::LBRACK &&
		first != token::RPAREN {
		ret tokens, nil
	}
	mut braceN := 0
	mut i := len(tokens) - 1
	for i >= 0; i-- {
		token := tokens[i]
		match token.ID {
		| token::RBRACE
		| token::RBRACK
		| token::RPAREN:
			braceN++
			continue
		| token::LBRACE
		| token::LBRACK
		| token::LPAREN:
			braceN--
		}
		if braceN == 0 {
			ret tokens[:i], tokens[i:]
		}
	}
	ret tokens, nil
}

// Returns parts separated by given token identifier.
// It's skips parentheses ranges.
// Logs missing_expr if exprMust == true and not exist any expression for part.
//
// Special case is;
//	parts(tokens) = nil if len(tokens) == 0
fn parts(mut tokens: []&token::Token, id: int, exprMust: bool): (parts: [][]&token::Token, errors: []log::Log) {
	if len(tokens) == 0 {
		ret nil, nil
	}
	mut rangeN := 0
	mut last := 0
	for i, token in tokens {
		match token.ID {
		| token::LBRACE | token::LBRACK | token::LPAREN:
			rangeN++
		| token::RBRACE | token::RBRACK | token::RPAREN:
			rangeN--
		| id:
			if rangeN > 0 {
				continue
			}
			if exprMust && i-last <= 0 {
				err := makeErr(token.Row, token.Column, token.File, "missing expression")
				errors = append(errors, err)
			}
			parts = append(parts, tokens[last:i])
			last = i + 1
		}
	}
	if last < len(tokens) {
		parts = append(parts, tokens[last:])
	}
	ret
}

fn isTupleExpr(mut tokens: []&token::Token): bool {
	if len(tokens) == 0 {
		ret false
	}
	mut rangeN := 0
	for _, token in tokens {
		match token.ID {
		| token::LBRACE | token::LBRACK | token::LPAREN:
			rangeN++
		| token::RBRACE | token::RBRACK | token::RPAREN:
			rangeN--
		| token::COMMA:
			if rangeN > 0 {
				continue
			}
			ret true
		}
	}
	ret false
}

fn getCloseOfBrace(left: int): int {
	match left {
	| token::RPAREN:
		ret token::LPAREN
	| token::RBRACE:
		ret token::LBRACE
	| token::RBRACK:
		ret token::LBRACK
	|:
		ret left
	}
}

fn compilerErr(token: &token::Token, fmt: str, args: ...any): log::Log {
	ret log::Log{
		Kind: log::Error,
		Row: token.Row,
		Column: token.Column,
		Path: token.File.Path,
		Text: log::Logf(fmt, args...),
		Line: token.File.GetRow(token.Row),
	}
}

unsafe fn pushSuggestion(mut log: *log::Log, fmt: str, args: ...any) {
	log.Suggestion = log::Logf(fmt, args...)
}

// Parser modes.
const (
	allowKeywordIdentifiers = 1 << iota // supported by: functions, structs, and type aliases
)

struct parser {
	mode:       int
	ast:        &ast::AST
	directives: []&ast::Directive
	errors:     []log::Log
}

impl parser {
	fn stop(mut *self) { self.ast = nil }
	fn stopped(*self): bool { ret self.ast == nil }

	// Appends error by specified token, key and args.
	fn pushErr(mut *self, token: &token::Token, fmt: str, args: ...any) {
		self.errors = append(self.errors, compilerErr(token, fmt, args...))
	}

	// Push suggestion to last log.
	fn pushSuggestion(mut *self, fmt: str, args: ...any) {
		unsafe { pushSuggestion(&self.errors[len(self.errors)-1], fmt, args...) }
	}

	// Reports whether tok is identifier.
	// Must be used by definitions that must support the AllowKeywordIdentifiers mode.
	fn isIdent(mut *self, tok: &token::Token): bool {
		ret tok.ID == token::NAME ||
			self.mode&allowKeywordIdentifiers == allowKeywordIdentifiers && token::IsKeyword(tok.Kind)
	}

	fn getExprBuilder(mut &self): exprBuilder {
		ret exprBuilder.new(self)
	}

	fn buildExpr(mut &self, mut tokens: []&token::Token): &ast::Expr {
		ret self.getExprBuilder().parseFromTokens(tokens)
	}

	fn buildDirective(mut *self, mut tokens: []&token::Token): &ast::Directive {
		if len(tokens) == 1 {
			self.pushErr(tokens[0], "invalid syntax")
			ret nil
		}
		if tokens[1].Column != tokens[0].Column+1 {
			self.pushErr(tokens[0], "invalid syntax")
			ret nil
		}
		ret &ast::Directive{
			Tag: tokens[1],
			Args: tokens[2:], // Start 2 to skip '#', and tag tokens.
		}
	}

	fn pushDirective(mut *self, mut d: &ast::Directive) {
		if d == nil {
			ret
		}
		// Don't append if already added this directive.
		for _, pd in self.directives {
			if d.Tag.Kind == pd.Tag.Kind {
				self.pushErr(d.Tag, "directive @ is already used", conv::Quote(d.Tag.Kind))
				ret
			}
		}
		self.directives = append(self.directives, d)
	}

	fn buildScope(mut &self, mut tokens: []&token::Token, mut end: &token::Token): &ast::ScopeTree {
		mut s := newScope()
		s.End = end
		mut sp := scopeParser{
			p: self,
		}
		sp.build(tokens, s)
		ret s
	}

	// Builds AST model of data-type.
	fn buildType(mut &self, mut tokens: []&token::Token, mut &i: *int, err: bool): (typ: &ast::Expr, ok: bool) {
		mut eb := self.getExprBuilder()
		eb.setForNewTokens(tokens[*i:])
		if err {
			typ = eb.parseType()
		} else {
			typ = eb.tryIdentOrType()
		}
		*i += eb.i
		ok = typ != nil
		ret
	}

	fn buildTypeAliasDecl(mut &self, mut tokens: []&token::Token): &ast::TypeAlias {
		mut i := 1 // Skip "type" keyword.
		if i >= len(tokens) {
			self.pushErr(tokens[i-1], "invalid syntax")
			ret nil
		}
		mut tad := &ast::TypeAlias{
			Token: tokens[1],
			Name: tokens[1].Kind,
		}
		mut token := tokens[i]
		if !self.isIdent(token) {
			self.pushErr(token, "invalid syntax")
			self.pushSuggestion("give an identifier because identifier expected")
		}
		i++
		if i >= len(tokens) {
			self.pushErr(tokens[i-1], "invalid syntax")
			ret tad
		}
		token = tokens[i]

		mut genericsTokens := range(&i, token::LBRACK, token::RBRACK, tokens)
		if genericsTokens != nil {
			tad.Generics = self.buildGenerics(genericsTokens, token)
		}
		if i >= len(tokens) {
			self.pushErr(tokens[i-1], "invalid syntax")
			ret tad
		}
		token = tokens[i]

		match token.ID {
		| token::COLON:
			tad.Strict = true
			break
		| token::ASSIGN:
			break
		|:
			self.pushErr(tokens[i-1], "invalid syntax")
			self.pushSuggestion("expected : or =")
			ret tad
		}
		i++
		if i >= len(tokens) {
			self.pushErr(tokens[i-1], "missing type")
			ret tad
		}
		mut t, ok := self.buildType(tokens, &i, true)
		tad.Type = t
		if ok && i < len(tokens) {
			self.pushErr(tokens[i], "invalid syntax")
		}
		tad.Public = mod::IsPub(tad.Name)
		ret tad
	}

	fn buildConstVarGroup(mut &self, mut tokens: []&token::Token): &ast::Var {
		mut i := 1 // Point to open parentheses.
		mut rangeTokens := range(&i, token::LPAREN, token::RPAREN, tokens)
		if i < len(tokens) {
			self.pushErr(tokens[i], "invalid syntax")
		}
		mut stmts := splitStmts(rangeTokens)
		if len(stmts) == 0 {
			self.pushErr(tokens[0], "variable group cannot be empty")
			ret nil
		}
		mut group := make([]&ast::Var, 0, len(stmts))
		for (_, mut stmt) in stmts {
			mut v := &ast::Var{
				Const: true,
				Token: tokens[0],
			}
			self.buildVarCommon(v, stmt.tokens)
			group = append(group, v)
		}
		// Setup group metadata.
		for (j, mut v) in group {
			v.GroupIndex = j
			v.Group = group
		}
		ret group[0]
	}

	fn buildVarTypeAndExpr(mut &self, mut v: &ast::Var, mut tokens: []&token::Token) {
		mut i := 0
		mut tok := tokens[i]
		if tok.ID == token::COLON {
			i++ // Skip type annotation operator (:)
			if i >= len(tokens) || tokens[i].ID == token::ASSIGN {
				self.pushErr(tok, "missing type")
				ret
			}
			mut t, ok := self.buildType(tokens, &i, true)
			if ok {
				v.Type = t
				if i >= len(tokens) {
					ret
				}
				tok = tokens[i]
			}
		}

		if tok.ID != token::ASSIGN {
			self.pushErr(tok, "invalid syntax")
			ret
		}
		v.Op = tok

		mut exprTokens := tokens[i+1:]
		if len(exprTokens) == 0 {
			self.pushErr(tok, "missing expression")
			ret
		}
		v.X = self.buildExpr(exprTokens)
	}

	fn buildVarCommon(mut &self, mut v: &ast::Var, mut tokens: []&token::Token) {
		v.Token = tokens[0]
		if !self.isIdent(v.Token) {
			self.pushErr(v.Token, "invalid syntax")
			self.pushSuggestion("give an identifier because identifier expected")
			ret
		}
		v.Name = v.Token.Kind
		v.Public = mod::IsPub(v.Name)
		v.Type = nil // For auto-type.
		if len(tokens) > 1 {
			tokens = tokens[1:] // Remove identifier.
			self.buildVarTypeAndExpr(v, tokens)
		}
	}

	fn buildVarBegin(mut *self, mut v: &ast::Var, mut &tokens: *[]&token::Token) {
		tok := (*tokens)[0]
		match tok.ID {
		| token::LET:
			// Initialize 1 for skip the let keyword
			if len(*tokens) == 1 {
				*tokens = nil
				self.pushErr(tok, "invalid syntax")
				ret
			}
			*tokens = (*tokens)[1:]
			if (*tokens)[0].ID == token::MUT {
				v.Mutable = true
				// Skip the mut keyword
				*tokens = (*tokens)[1:]
			}
		| token::CONST:
			v.Const = true
			*tokens = (*tokens)[1:]
		|:
			*tokens = nil
			self.pushErr(tok, "invalid syntax")
		}
	}

	fn buildVar(mut &self, mut tokens: []&token::Token): &ast::Var {
		// Catch constant groups
		if len(tokens) >= 2 && tokens[0].ID == token::CONST && tokens[1].ID == token::LPAREN {
			ret self.buildConstVarGroup(tokens)
		}
		mut v := &ast::Var{
			Token: tokens[0],
		}
		self.buildVarBegin(v, &tokens)
		if len(tokens) == 0 {
			if tokens != nil {
				// Log error if tokens != nil, if tokens is nil, an error already logged.
				// Avoid duplicated errors.
				self.pushErr(v.Token, "invalid syntax")
			}
			ret nil
		}
		if tokens[0].ID == token::AND {
			v.Reference = true
			if len(tokens) == 1 {
				ret nil
			}
			tokens = tokens[1:]
		}
		self.buildVarCommon(v, tokens)
		if v.Type == nil && v.X == nil {
			self.pushErr(v.Token, "invalid syntax")
			self.pushSuggestion("expected type declaration or expression for variable")
			ret nil
		}
		ret v
	}

	fn buildGeneric(mut &self, mut tokens: []&token::Token): &ast::Generic {
		mut g := &ast::Generic{
			Token: tokens[0],
		}
		if g.Token.ID != token::NAME {
			self.pushErr(g.Token, "invalid syntax")
			self.pushSuggestion("give an identifier because identifier expected")
		}
		g.Name = g.Token.Kind
		if len(tokens) > 1 {
			if tokens[1].ID != token::COLON {
				self.pushErr(tokens[1], "invalid syntax")
				ret nil
			}
			if len(tokens) == 2 {
				self.pushErr(tokens[1], "missing expression")
				ret nil
			}
			mut constraintTokens := tokens[2:]
			mut parts, errors := parts(constraintTokens, token::OR, true)
			if len(errors) > 0 {
				self.errors = append(self.errors, errors...)
				ret nil
			}
			g.Constraint = &ast::Constraint{Mask: make([]ast::ConstraintMask, 0, len(parts))}
			for (_, mut part) in parts {
				let mut mask: ast::ConstraintMask
				mut i := 0
				if part[0].ID == token::TILDE {
					mask.Deep = true
					i++
					if i >= len(part) {
						self.pushErr(part[0], "operator ~ expects type")
						continue
					}
				}
				mask.Type, _ = self.buildType(part, &i, true)
				g.Constraint.Mask = append(g.Constraint.Mask, mask)
				if i < len(part) {
					self.pushErr(part[i], "invalid syntax")
				}
			}
		}
		ret g
	}

	fn buildGenerics(mut &self, mut tokens: []&token::Token, errorToken: &token::Token): []&ast::Generic {
		if len(tokens) == 0 {
			self.pushErr(errorToken, "missing expression")
			ret nil
		}

		mut parts, errors := parts(tokens, token::COMMA, true)
		if len(errors) > 0 {
			self.errors = append(self.errors, errors...)
			ret nil
		}

		mut generics := make([]&ast::Generic, 0, len(parts))
		for (_, mut part) in parts {
			generics = append(generics, self.buildGeneric(part))
		}

		ret generics
	}

	fn buildSelfParam(mut *self, mut tokens: []&token::Token): &ast::Param {
		if len(tokens) == 0 {
			ret nil
		}

		mut param := new(ast::Param)

		// Detects mut keyword.
		if tokens[0].ID == token::MUT {
			param.Mutable = true
			if len(tokens) == 1 {
				self.pushErr(tokens[0], "invalid syntax")
				ret nil
			}
			tokens = tokens[1:]
		}

		mut name := strings::Builder{}
		name.Grow(5) // enough for the maximum length

		match tokens[0].ID {
		| token::AND:
			name.WriteStr("&")!
		| token::MUL:
			name.WriteStr("*")!
		| token::SELF:
			param.Token = tokens[0] // avoid nil error because of nil token
			self.pushErr(tokens[0], "expected * or & before self receiver")
			ret param
		|:
			ret nil
		}
		if len(tokens) == 1 {
			self.pushErr(tokens[0], "invalid syntax")
			ret nil
		}
		if tokens[1].ID != token::SELF {
			ret nil
		}
		name.WriteStr("self")!
		param.Token = tokens[1]
		if len(tokens) != 2 {
			self.pushErr(tokens[1], "invalid syntax")
		}

		param.Name = name.Str()
		ret param
	}

	fn paramTypeBegin(mut *self, mut param: &ast::Param, mut &i: *int, tokens: []&token::Token) {
		for *i < len(tokens); *i++ {
			token := tokens[*i]
			if token.ID != token::ELLIPSIS {
				ret
			}

			if param.Variadic {
				self.pushErr(token, "parameter is already variadic")
				continue
			}
			param.Variadic = true
		}
	}

	fn buildParamType(mut &self, mut param: &ast::Param, mut tokens: []&token::Token) {
		mut i := 0
		self.paramTypeBegin(param, &i, tokens)
		if i >= len(tokens) {
			ret
		}

		param.Type, _ = self.buildType(tokens, &i, true)
		if i < len(tokens) {
			self.pushErr(tokens[i], "invalid syntax")
		}
	}

	fn buildParamBody(mut &self, mut param: &ast::Param, mut tokens: []&token::Token) {
		mut tok := tokens[0]
		if len(tokens) == 1 {
			// Just identifier token.
			param.Name = tok.Kind
			ret
		} else if len(tokens) < 3 {
			self.pushErr(tok, "missing type")
			ret
		}
		if tokens[1].ID != token::COLON {
			param.Name = jule::Anon
			self.buildParamType(param, tokens)
			ret
		}
		param.Name = tok.Kind
		tokens = tokens[2:] // Skip colon
		self.buildParamType(param, tokens)
	}

	fn buildParam(mut &self, mut tokens: []&token::Token): &ast::Param {
		mut param := &ast::Param{
			Token: tokens[0],
		}

		// Detects mut keyword.
		if param.Token.ID == token::MUT {
			param.Mutable = true
			if len(tokens) == 1 {
				self.pushErr(tokens[0], "invalid syntax")
				ret nil
			}
			tokens = tokens[1:]
			param.Token = tokens[0]
		}

		// Catch reference parameters.
		if len(tokens) >= 3 {
			if param.Token.ID == token::AND {
				if len(tokens) == 1 {
					self.pushErr(tokens[0], "invalid syntax")
					ret nil
				}

				if tokens[1].ID == token::NAME && tokens[2].ID == token::COLON {
					param.Reference = true
					tokens = tokens[1:]
					param.Token = tokens[0]
				}
			}
		}

		if param.Token.ID != token::NAME {
			// Just data type
			param.Name = jule::Anon
			self.buildParamType(param, tokens)
		} else {
			self.buildParamBody(param, tokens)
		}

		ret param
	}

	fn checkParams(mut *self, mut params: []&ast::Param) {
		for (_, mut param) in params {
			if param.IsSelf() || param.Type != nil {
				continue
			}
			if param.Token == nil {
				self.pushErr(param.Token, "missing type")
			} else {
				param.Type = &ast::Expr{
					Token: param.Token,
					End: param.Token,
					Data: &ast::NameExpr{
						Token: param.Token,
						Name: param.Token.Kind,
					},
				}
				param.Name = jule::Anon
			}
		}
	}

	fn buildParams(mut &self, mut tokens: []&token::Token, method: bool): []&ast::Param {
		mut parts, errs := parts(tokens, token::COMMA, true)
		self.errors = append(self.errors, errs...)
		if len(parts) == 0 {
			ret nil
		}

		let mut params: []&ast::Param = nil
		if method && len(parts) > 0 {
			mut param := self.buildSelfParam(parts[0])
			if param != nil {
				params = append(params, param)
				parts = parts[1:]
			}
		}

		for (_, mut part) in parts {
			if len(part) == 0 {
				continue
			}
			mut param := self.buildParam(part)
			if param != nil {
				params = append(params, param)
			}
		}

		self.checkParams(params)
		ret params
	}

	fn buildMultiRetType(mut &self, mut t: &ast::RetType, mut tokens: []&token::Token, mut &i: *int): (ok: bool) {
		*i++
		if *i >= len(tokens) {
			*i--
			t.Type, ok = self.buildType(tokens, i, false)
			ret
		}

		*i-- // For point to parentheses - ( -
		mut rangeTokens := range(i, token::LPAREN, token::RPAREN, tokens)

		mut parts, errs := parts(rangeTokens, token::COMMA, true)
		self.errors = append(self.errors, errs...)
		if len(parts) == 0 {
			ret
		}

		mut types := make([]&ast::Expr, 0, len(parts))
		t.Names = make([]&token::Token, 0, len(parts))
		for (_, mut part) in parts {
			if len(part) == 0 {
				continue
			}
			mut token := part[0]
			mut offset := 0

			// Check type annotation.
			if len(part) > 1 {
				token = part[1]
				if token.ID == token::COLON {
					offset = 2
					if len(part) < 3 {
						self.pushErr(token, "missing type")
						continue
					}
				}
			}

			token = part[0]
			if offset != 2 {
				mut newToken := new(token::Token, *token)
				newToken.Kind = jule::Anon
				t.Names = append(t.Names, newToken)
			} else {
				t.Names = append(t.Names, token)
			}

			mut tk, _ := self.buildType(part, &offset, true)
			if offset < len(part) {
				self.pushErr(part[offset], "invalid syntax")
			}
			types = append(types, tk)
		}

		if len(types) > 1 {
			t.Type = &ast::Expr{
				Token: tokens[0],
				End: types[len(types)-1].End,
				Data: &ast::TupleExpr{
					X: types,
				},
			}
		} else {
			t.Type = types[0]
		}

		ok = true
		ret
	}

	// Builds function return type from tokens.
	// If expression mode enabled, it will not complain about trailing invalid tokens.
	fn buildRetType(mut &self, mut tokens: []&token::Token, mut expr: bool, mut &i: *int): (t: &ast::RetType, ok: bool) {
		t = new(ast::RetType)
		if *i >= len(tokens) {
			// EOF, void return type.
			ok = true
			ret
		}

		mut token := tokens[*i]
		match token.ID {
		| token::LBRACE:
			// Body started, void return type.
			ok = true
			ret
		| token::ASSIGN:
			// Assignment started, void return type.
			ok = true
			ret
		| token::COLON:
			if *i+1 >= len(tokens) {
				self.pushErr(token, "missing type")
				ret
			}

			*i++
			token = tokens[*i]
			match token.ID {
			| token::LPAREN:
				ok = self.buildMultiRetType(t, tokens, i)
				ret
			| token::LBRACE:
				self.pushErr(token, "missing type")
				ret
			}
			t.Type, ok = self.buildType(tokens, i, true)
			ret
		}
		if !expr {
			*i++
			self.pushErr(token, "invalid syntax")
		}
		ret
	}

	// Build function prototype.
	// Body is not necessary for successful parsing, just declaration.
	// If expression mode enabled, it will not complain about trailing invalid tokens.
	fn buildFuncPrototype(mut &self, mut tokens: []&token::Token, mut &i: *int, expr: bool, method: bool): &ast::Func {
		mut f := &ast::Func{
			Token: tokens[*i],
		}

		// Detect unsafe keyword.
		if f.Token.ID == token::UNSAFE {
			f.Unsafe = true
			*i++
			if *i >= len(tokens) {
				self.pushErr(f.Token, "invalid syntax")
				ret nil
			}
			f.Token = tokens[*i]
		}

		// Skips fn token.
		*i++
		if *i >= len(tokens) {
			self.pushErr(f.Token, "invalid syntax")
			ret nil
		}

		tok := tokens[*i]
		if self.isIdent(tok) {
			*i++
			if *i >= len(tokens) {
				self.pushErr(f.Token, "invalid syntax")
				ret nil
			}
			f.Name = tok.Kind
		} else {
			f.Name = jule::Anon
		}

		errorToken := tokens[*i]
		mut genericsTokens := range(i, token::LBRACK, token::RBRACK, tokens)
		if genericsTokens != nil {
			f.Generics = self.buildGenerics(genericsTokens, errorToken)
		}

		if tokens[*i].ID != token::LPAREN {
			self.pushErr(tokens[*i], "missing function parentheses")
			ret nil
		}

		mut paramsToks := range(i, token::LPAREN, token::RPAREN, tokens)
		if len(paramsToks) > 0 {
			f.Params = self.buildParams(paramsToks, method)
		}

		if *i < len(tokens) {
			token := tokens[*i]
			if token.ID == token::NOT {
				f.Exceptional = true
				*i++
			}
		}

		f.Public = mod::IsPub(f.Name)
		f.Result, ok := self.buildRetType(tokens, expr, i)
		if !ok {
			ret nil
		}
		ret f
	}

	// Parses function define.
	// Prototype and body.
	// If prototype is true, it only parses declaration, body and following tokens considired illegal.
	// It advances i by token, it will be point to the last handled legal token.
	fn buildFunc(mut &self, mut &i: *int, mut tokens: []&token::Token, method: bool, prototype: bool): &ast::Func {
		const ExprMode = false
		mut f := self.buildFuncPrototype(tokens, i, ExprMode, method)
		if f == nil {
			ret f
		}
		if prototype {
			if *i < len(tokens) {
				self.pushErr(tokens[*i], "invalid syntax")
			}
			ret f
		}

		if *i >= len(tokens) {
			self.stop()
			self.pushErr(f.Token, "missing function body")
			ret nil
		}
		mut blockTokens := range(i, token::LBRACE, token::RBRACE, tokens)
		if blockTokens != nil {
			f.Scope = self.buildScope(blockTokens, tokens[*i-1])
			f.Scope.Unsafe = f.Unsafe
			if *i < len(tokens) {
				self.pushErr(tokens[*i], "invalid syntax")
			}
		} else {
			self.stop()
			self.pushErr(tokens[*i], "missing function body")
			ret nil
		}
		ret f
	}

	fn buildExternUseDecl(mut *self, mut decl: &ast::Use, mut tokens: []&token::Token) {
		if len(tokens) > 1 {
			self.pushErr(tokens[1], "invalid syntax")
		}
		mut token := tokens[0]
		if token.ID != token::STR || token.Kind[0] != '"' {
			self.pushErr(token, "invalid expression")
			self.pushSuggestion(`expected string literal, like "string"`)
			ret
		}
		decl.Extern = true
		decl.Path = token
	}

	fn parseUseDecl(mut *self, mut decl: &ast::Use, mut tokens: []&token::Token) {
		if decl.Extern {
			self.buildExternUseDecl(decl, tokens)
			ret
		}

		mut token := tokens[0]
		if token.ID != token::NAME && token.ID != token::STR && token.Kind[0] != '"' {
			self.pushErr(token, "invalid syntax")
			ret
		}

		if token.ID == token::NAME { // custom alias exist
			decl.Alias = token
			tokens = tokens[1:]
			if len(tokens) == 0 {
				self.pushErr(token, "invalid syntax")
				ret
			}
			token = tokens[0]
			if token.ID != token::STR {
				self.pushErr(token, "invalid syntax")
				ret
			}
		}

		if len(tokens) > 1 {
			self.pushErr(tokens[1], "invalid syntax")
			ret
		}

		decl.Path = token
	}

	fn buildUseDecl(mut *self, mut tokens: []&token::Token, _extern: bool): &ast::Use {
		mut decl := &ast::Use{
			Token: tokens[0], // See developer reference (8).
			Extern: _extern,
		}
		if len(tokens) < 2 {
			self.pushErr(decl.Token, "path is missing of use declaration")
			ret nil
		}
		tokens = tokens[1:] // Skip "use" keyword.
		self.parseUseDecl(decl, tokens)
		ret decl
	}

	fn buildTypeEnumItemKind(mut &self, mut &i: *int, mut tokens: []&token::Token): &ast::Expr {
		mut braceN := 0
		exprStart := *i
		for *i < len(tokens); *i++ {
			t := tokens[*i]
			match t.ID {
			| token::LBRACE
			| token::LBRACK
			| token::LPAREN:
				braceN++
				continue
			| token::RBRACE
			| token::RBRACK
			| token::RPAREN:
				braceN--
			}
			if braceN > 0 {
				continue
			}
			if t.ID == token::COMMA || *i+1 >= len(tokens) {
				let mut kindTokens: []&token::Token = nil
				if t.ID == token::COMMA {
					kindTokens = tokens[exprStart:*i]
				} else {
					kindTokens = tokens[exprStart:]
				}
				mut j := 0
				mut kind, _ := self.buildType(kindTokens, &j, true)
				if j < len(kindTokens) {
					self.pushErr(kindTokens[j], "invalid syntax")
				}
				ret kind
			}
		}
		ret nil
	}

	fn buildTypeEnumItems(mut &self, mut tokens: []&token::Token): []&ast::TypeEnumItem {
		mut items := make([]&ast::TypeEnumItem, 0, 1)
		mut i := 0
		for i < len(tokens); i++ {
			mut t := tokens[i]
			mut item := new(ast::TypeEnumItem)
			item.Token = t
			// For more describing error messages, handle ordinary enum cases.
			// User may attempt to use named fields like ordinary enums for type enums.
			if item.Token.ID == token::NAME && len(tokens)-i > 2 {
				t = tokens[i+1]
				if t.ID == token::COLON {
					self.pushErr(t, "type-enums does not supports named fields")

					ret nil
				}
			}
			item.Type = self.buildTypeEnumItemKind(&i, tokens)
			items = append(items, item)
		}
		ret items
	}

	fn buildTypeEnum(mut &self, mut tokens: []&token::Token): &ast::TypeEnum {
		mut i := 1
		mut e := &ast::TypeEnum{
			// Skip "enum" tokens.
			Token: tokens[i],
		}
		if e.Token.ID != token::NAME {
			self.pushErr(e.Token, "invalid syntax")
			self.pushSuggestion("give an identifier because identifier expected")
		}
		e.Name = e.Token.Kind
		i += 3 // Skip "identifier: type" tokens.
		mut itemTokens := range(&i, token::LBRACE, token::RBRACE, tokens)
		if itemTokens == nil {
			self.stop()
			self.pushErr(e.Token, "missing type-enum body")
			ret e
		} else if i < len(tokens) {
			self.pushErr(tokens[i], "invalid syntax")
		}
		e.Public = mod::IsPub(e.Name)
		e.End = tokens[i-1]
		e.Items = self.buildTypeEnumItems(itemTokens)
		ret e
	}

	fn buildEnumItemExpr(mut &self, mut &i: *int, mut tokens: []&token::Token): &ast::Expr {
		mut braceN := 0
		exprStart := *i
		for *i < len(tokens); *i++ {
			t := tokens[*i]
			match t.ID {
			| token::LBRACE
			| token::LBRACK
			| token::LPAREN:
				braceN++
				continue
			| token::RBRACE
			| token::RBRACK
			| token::RPAREN:
				braceN--
			}
			if braceN > 0 {
				continue
			}
			if t.ID == token::COMMA || *i+1 >= len(tokens) {
				let mut exprTokens: []&token::Token = nil
				if t.ID == token::COMMA {
					exprTokens = tokens[exprStart:*i]
				} else {
					exprTokens = tokens[exprStart:]
				}
				ret self.buildExpr(exprTokens)
			}
		}
		ret nil
	}

	fn buildEnumItems(mut &self, mut tokens: []&token::Token): []&ast::EnumItem {
		mut items := make([]&ast::EnumItem, 0, 1)
		mut i := 0
		for i < len(tokens); i++ {
			mut t := tokens[i]
			mut item := new(ast::EnumItem)
			item.Token = t
			if item.Token.ID != token::NAME {
				self.pushErr(item.Token, "invalid syntax")
				self.pushSuggestion("give an identifier because identifier expected")
			}
			item.Name = item.Token.Kind
			if i+1 >= len(tokens) || tokens[i+1].ID == token::COMMA {
				if i+1 < len(tokens) {
					i++
				}
				items = append(items, item)
				continue
			}
			i++
			t = tokens[i]
			i++
			if t.ID != token::COLON {
				self.pushErr(t, "invalid syntax")
				self.pushSuggestion("expected : to assign expression")
				continue
			}
			if i >= len(tokens) || tokens[i].ID == token::COMMA {
				self.pushErr(t, "missing expression")
				continue
			}
			item.X = self.buildEnumItemExpr(&i, tokens)
			items = append(items, item)
		}
		ret items
	}

	fn buildEnum(mut &self, mut tokens: []&token::Token): &ast::Enum {
		if len(tokens) < 3 {
			self.pushErr(tokens[0], "invalid syntax")
			ret nil
		}
		mut e := &ast::Enum{
			Token: tokens[1],
		}
		if e.Token.ID != token::NAME {
			self.pushErr(e.Token, "invalid syntax")
			self.pushSuggestion("give an identifier because identifier expected")
		}
		e.Name = e.Token.Kind
		mut i := 2
		if tokens[i].ID == token::COLON {
			i++
			if i >= len(tokens) {
				self.pushErr(tokens[i-1], "invalid syntax")
				ret e
			}
			e.Type, _ = self.buildType(tokens, &i, true)
			if i >= len(tokens) {
				self.stop()
				self.pushErr(e.Token, "missing enum body")
				ret e
			}
		} else {
			e.Type = nil
		}
		mut itemTokens := range(&i, token::LBRACE, token::RBRACE, tokens)
		if itemTokens == nil {
			self.stop()
			self.pushErr(e.Token, "missing enum body")
			ret e
		} else if i < len(tokens) {
			self.pushErr(tokens[i], "invalid syntax")
		}
		e.Public = mod::IsPub(e.Name)
		e.End = tokens[i-1]
		e.Items = self.buildEnumItems(itemTokens)
		ret e
	}

	fn buildNodeEnum(mut &self, mut tokens: []&token::Token): ast::NodeData {
		if len(tokens) > 3 && tokens[2].ID == token::COLON {
			if tokens[3].ID == token::TYPE {
				ret self.buildTypeEnum(tokens)
			}
		}
		ret self.buildEnum(tokens)
	}

	fn buildField(mut &self, mut tokens: []&token::Token): &ast::Field {
		mut f := new(ast::Field)

		f.Mutable = tokens[0].ID == token::MUT
		if f.Mutable {
			if len(tokens) == 1 {
				self.pushErr(tokens[0], "invalid syntax")
				ret nil
			}
			tokens = tokens[1:]
		}

		f.Token = tokens[0]
		if f.Token.ID != token::NAME {
			self.pushErr(f.Token, "invalid syntax")
			self.pushSuggestion("give an identifier because identifier expected")
			ret nil
		}
		f.Name = f.Token.Kind

		if len(tokens) == 1 {
			self.pushErr(tokens[0], "missing type")
			ret nil
		} else if len(tokens) < 3 || tokens[1].ID != token::COLON {
			self.pushErr(tokens[1], "missing type")
			ret nil
		}

		tokens = tokens[2:] // Remove identifier and colon tokens.
		mut i := 0
		f.Type, _ = self.buildType(tokens, &i, true)
		if i < len(tokens) {
			mut token := tokens[i]
			if token.ID == token::STR {
				f.Tag = token
				i++
				if i < len(tokens) {
					self.pushErr(tokens[i], "invalid syntax")
				}
			} else {
				self.pushErr(tokens[i], "invalid syntax")
			}
		}
		f.Public = mod::IsPub(f.Name)
		ret f
	}

	fn buildStructDeclFields(mut &self, mut tokens: []&token::Token): []&ast::Field {
		let mut fields: []&ast::Field = nil
		mut stmts := splitStmts(tokens)
		for (_, mut stmt) in stmts {
			tokens = stmt.tokens
			mut f := self.buildField(tokens)
			fields = append(fields, f)
		}
		ret fields
	}

	fn buildStructDecl(mut &self, mut tokens: []&token::Token): &ast::Struct {
		if len(tokens) < 3 {
			self.pushErr(tokens[0], "invalid syntax")
			ret nil
		}

		mut i := 1
		mut s := &ast::Struct{
			Token: tokens[i],
		}
		if !self.isIdent(s.Token) {
			self.pushErr(s.Token, "invalid syntax")
			self.pushSuggestion("give an identifier because identifier expected")
		}
		i++
		if i >= len(tokens) {
			self.pushErr(tokens[i], "invalid syntax")
			ret s
		}
		s.Name = s.Token.Kind

		errorToken := tokens[i]
		mut genericsTokens := range(&i, token::LBRACK, token::RBRACK, tokens)
		if genericsTokens != nil {
			s.Generics = self.buildGenerics(genericsTokens, errorToken)
		}
		if i >= len(tokens) {
			self.pushErr(tokens[i-1], "missing struct body")
			ret s
		}

		mut bodyTokens := range(&i, token::LBRACE, token::RBRACE, tokens)
		if bodyTokens == nil {
			self.stop()
			self.pushErr(s.Token, "missing struct body")
			ret s
		}
		if i < len(tokens) {
			self.pushErr(tokens[i], "invalid syntax")
		}
		s.Public = mod::IsPub(s.Name)
		s.Fields = self.buildStructDeclFields(bodyTokens)
		s.End = tokens[i-1]
		ret s
	}

	fn checkMethodReceiver(mut *self, mut f: &ast::Func, mustRecv: bool) {
		if len(f.Params) == 0 {
			f.Static = true
			if mustRecv {
				self.pushErr(f.Token, "missing receiver parameter")
			}
			ret
		}
		param := f.Params[0]
		if !param.IsSelf() {
			f.Static = true
			if mustRecv {
				self.pushErr(f.Token, "missing receiver parameter")
			}
		}
	}

	fn buildTraitBody(mut &self, mut t: &ast::Trait, mut tokens: []&token::Token) {
		mut stmts := splitStmts(tokens)
		for (_, mut stmt) in stmts {
			tokens = stmt.tokens
			if len(tokens) == 0 {
				continue
			}
			match tokens[0].ID {
			| token::FN:
				mut i := 0
				mut f := self.buildFunc(&i, tokens, true, true)
				if f == nil {
					break
				}
				self.checkMethodReceiver(f, true)
				if len(f.Generics) > 0 {
					self.pushErr(f.Token, "trait methods cannot have generic types")
				}
				t.Methods = append(t.Methods, f)
			|:
				mut i := 0
				mut ti, ok := self.buildType(tokens, &i, true)
				if !ok {
					break
				}
				if i < len(tokens) {
					self.pushErr(tokens[i], "invalid syntax")
				}
				t.Inherits = append(t.Inherits, ti)
			}
		}
	}

	fn buildTraitDecl(mut &self, mut tokens: []&token::Token): &ast::Trait {
		if len(tokens) < 3 {
			self.pushErr(tokens[0], "invalid syntax")
			ret nil
		}
		mut t := &ast::Trait{
			Token: tokens[1],
		}
		if t.Token.ID != token::NAME {
			self.pushErr(t.Token, "invalid syntax")
			self.pushSuggestion("give an identifier because identifier expected")
		}
		t.Name = t.Token.Kind
		mut i := 2
		mut bodyTokens := range(&i, token::LBRACE, token::RBRACE, tokens)
		if bodyTokens == nil {
			self.stop()
			self.pushErr(t.Token, "missing trait body")
			ret nil
		}
		if i < len(tokens) {
			self.pushErr(tokens[i], "invalid syntax")
		}
		t.Public = mod::IsPub(t.Name)
		self.buildTraitBody(t, bodyTokens)
		t.End = tokens[i-1]
		ret t
	}

	fn buildExternFunc(mut &self, mut tokens: []&token::Token): &ast::Func {
		mut i := 1 // Skip "cpp" keyword.
		mut f := self.buildFunc(&i, tokens, false, true)
		if f != nil {
			f.Public = false
			f.Extern = true
		}
		ret f
	}

	fn buildExternVar(mut &self, mut tokens: []&token::Token): &ast::Var {
		tokens = tokens[1:] // Remove "cpp" keyword.
		mut v := self.buildVar(tokens)
		if v != nil {
			v.Public = false
			v.Extern = true
			v.Static = true
			if v.Const {
				self.pushErr(v.Token, "external variables cannot be constant")
			}
			if v.X != nil {
				self.pushErr(v.Token, "external variables cannot have expressions")
			}
		}
		ret v
	}

	fn buildExternStruct(mut &self, mut tokens: []&token::Token): &ast::Struct {
		tokens = tokens[1:] // Remove "cpp" keyword.
		mut s := self.buildStructDecl(tokens)
		if s != nil {
			s.Public = false
			for (_, mut f) in s.Fields {
				// External structure's fields are always public by default.
				f.Public = true
			}
			s.Extern = true
		}
		ret s
	}

	fn buildExternTypeAlias(mut &self, mut tokens: []&token::Token): &ast::TypeAlias {
		tokens = tokens[1:] // Remove "cpp" keyword.
		mut t := self.buildTypeAliasDecl(tokens)
		if t != nil {
			t.Public = false
			t.Extern = true
		}
		ret t
	}

	fn buildExternUse(mut &self, mut tokens: []&token::Token): &ast::Use {
		if len(tokens) == 1 {
			self.pushErr(tokens[0], "invalid syntax")
			ret nil
		}
		tokens = tokens[1:] // Remove the extern keyword.

		const Extern = true
		ret self.buildUseDecl(tokens, Extern)
	}

	fn buildExtern(mut &self, mut tokens: []&token::Token): (data: ast::NodeData) {
		mut token := tokens[0]
		if len(tokens) == 1 {
			self.pushErr(token, "invalid syntax")
			ret nil
		}

		// Save mode to restore and set additional required modes.
		mode := self.mode
		// Extern defines are may defined by a Jule keyword. It should be valid.
		// Since they accessed and defined via keyword, it should be safe and clear.
		self.mode |= allowKeywordIdentifiers

		token = tokens[1]
		match token.ID {
		| token::FN
		| token::UNSAFE:
			data = self.buildExternFunc(tokens)
		| token::CONST
		| token::LET:
			data = self.buildExternVar(tokens)
		| token::STRUCT:
			data = self.buildExternStruct(tokens)
		| token::TYPE:
			data = self.buildExternTypeAlias(tokens)
		|:
			self.pushErr(token, "invalid syntax")
		}
		self.mode = mode // Restore the parser mode.
		ret
	}

	fn getMethod(mut &self, mut tokens: []&token::Token): &ast::Func {
		mut i := 0
		mut token := tokens[i]
		if token.ID == token::UNSAFE {
			if i+1 >= len(tokens) {
				self.pushErr(token, "invalid syntax")
				ret nil
			}
			i++
			token = tokens[i]
		}

		if token.ID != token::FN {
			self.pushErr(token, "invalid syntax")
			ret nil
		}

		i = 0
		ret self.buildFunc(&i, tokens, true, false)
	}

	fn parseImplBody(mut &self, mut ipl: &ast::Impl, mut tokens: []&token::Token) {
		mut stmts := splitStmts(tokens)
		for (_, mut stmt) in stmts {
			tokens = stmt.tokens
			mut token := tokens[0]
			match token.ID {
			| token::HASH:
				self.pushDirective(self.buildDirective(tokens))
				continue
			}

			match token.ID {
			| token::FN
			| token::UNSAFE:
				mut f := self.getMethod(tokens)
				if f != nil {
					self.checkMethodReceiver(f, false)
					self.applyFuncMeta(f)
					ipl.Methods = append(ipl.Methods, f)
				}
			|:
				self.pushErr(token, "invalid syntax")
				continue
			}
		}
	}

	fn buildImpl(mut &self, mut tokens: []&token::Token): &ast::Impl {
		mut token := tokens[0]
		if len(tokens) < 2 {
			self.pushErr(token, "invalid syntax")
			ret nil
		}

		mut i := 1

		mut base, mut ok := self.buildType(tokens, &i, true)
		if !ok {
			ret nil
		}
		if i >= len(tokens) {
			self.pushErr(token, "invalid syntax")
			ret nil
		}

		mut ipl := &ast::Impl{
			Base: base,
		}

		token = tokens[i]
		if token.ID != token::FOR {
			if token.ID == token::LBRACE {
				// This implementation is single.
				// Just implements to destination.
				// Therefore, swap Base and Dest tokens.
				ipl.Base, ipl.Dest = ipl.Dest, ipl.Base
				goto body
			}
			self.stop()
			self.pushErr(token, "missing impl body")
			ret nil
		}
		i++
		if i >= len(tokens) {
			self.stop()
			self.pushErr(token, "missing impl body")
			ret nil
		}

		ipl.Dest, ok = self.buildType(tokens, &i, true)
		if !ok {
			ret nil
		}
		if i >= len(tokens) {
			self.stop()
			self.pushErr(token, "missing impl body")
			ret nil
		}

	body:
		mut bodyTokens := range(&i, token::LBRACE, token::RBRACE, tokens)
		if bodyTokens == nil {
			self.stop()
			self.pushErr(token, "missing impl body")
			ret nil
		}
		if i < len(tokens) {
			self.pushErr(tokens[i], "invalid syntax")
		}
		ipl.End = tokens[i-1]
		self.parseImplBody(ipl, bodyTokens)
		ret ipl
	}

	fn buildNodeData(mut &self, mut tokens: []&token::Token): ast::NodeData {
		mut token := tokens[0]
		match token.ID {
		| token::FN
		| token::UNSAFE:
			mut i := 0
			mut f := self.buildFunc(&i, tokens, false, false)
			if f != nil {
				f.Global = true
			}
			ret f
		| token::LET
		| token::CONST
		| token::MUT:
			mut v := self.buildVar(tokens)
			if v != nil && !v.Const {
				v.Static = true
			}
			ret v
		| token::TYPE:
			ret self.buildTypeAliasDecl(tokens)
		| token::ENUM:
			ret self.buildNodeEnum(tokens)
		| token::STRUCT:
			ret self.buildStructDecl(tokens)
		| token::TRAIT:
			ret self.buildTraitDecl(tokens)
		| token::IMPL:
			ret self.buildImpl(tokens)
		| token::EXTERN:
			ret self.buildExtern(tokens)
		|:
			self.pushErr(token, "invalid syntax")
			ret nil
		}
	}

	fn applyFuncMeta(mut *self, mut f: &ast::Func) {
		f.Directives = self.directives
		self.directives = nil
	}

	fn applyMeta(mut *self, mut node: ast::Node) {
		match type node.Data {
		| &ast::Var:
			mut v := node.Data.(&ast::Var)
			if v == nil {
				ret
			}
			v.Directives = self.directives
			self.directives = nil
		| &ast::Func:
			mut f := node.Data.(&ast::Func)
			if f == nil {
				ret
			}
			self.applyFuncMeta(f)
		| &ast::Struct:
			mut sd := node.Data.(&ast::Struct)
			if sd == nil {
				ret
			}
			sd.Directives = self.directives
			self.directives = nil
		|:
			// no-op for other types
		}
	}

	fn pushUseDecl(mut &self, mut decl: &ast::Use) {
		self.ast.UseDecls = append(self.ast.UseDecls, decl)
		if len(self.ast.Nodes) > 0 {
			self.pushErr(decl.Token, "use declarations must appear before other declarations")
		}
	}

	fn pushMetaNodes(mut &self, mut tokens: []&token::Token): bool {
		match tokens[0].ID {
		| token::USE:
			const Extern = false
			mut decl := self.buildUseDecl(tokens, Extern)
			self.pushUseDecl(decl)
			ret true
		| token::EXTERN:
			if len(tokens) > 1 && tokens[1].ID == token::USE {
				mut decl := self.buildExternUse(tokens)
				self.pushUseDecl(decl)
				ret true
			}
		| token::HASH:
			self.pushDirective(self.buildDirective(tokens))
			ret true
		}
		ret false
	}

	fn parseNode(mut &self, mut st: []&token::Token): ast::Node {
		mut node := ast::Node{
			Token: st[0],
		}

		if self.pushMetaNodes(st) {
			ret node
		}

		mut data := self.buildNodeData(st)
		if data == nil {
			ret node
		}

		node.Data = data

		self.applyMeta(node)
		if len(self.directives) != 0 {
			self.pushErr(self.directives[0].Tag, "unused directive")
		}
		self.directives = nil
		ret node
	}

	fn appendNode(mut &self, mut st: []&token::Token) {
		if len(st) == 0 {
			ret
		}
		mut node := self.parseNode(st)
		if node.Data != nil && !self.stopped() {
			self.ast.Nodes = append(self.ast.Nodes, node)
		}
	}

	fn removeRange(*self, mut i: int, id: int, tokens: []&token::Token, mut &ranges: *[]int) {
		close := getCloseOfBrace(id)
		for i >= 0; i-- {
			tok := tokens[(*ranges)[i]]
			if tok.ID != close {
				continue
			}
			*ranges = append((*ranges)[:i], (*ranges)[i+1:]...)
			break
		}
	}

	fn pushWrongOrderCloseErr(mut *self, t: &token::Token, tokens: []&token::Token, &ranges: *[]int) {
		match tokens[(*ranges)[len(*ranges)-1]].ID {
		| token::LPAREN:
			self.pushErr(t, "expected parentheses close )")
		| token::LBRACE:
			self.pushErr(t, "expected brace close }")
		| token::LBRACK:
			self.pushErr(t, "expected bracket close ]")
		}
	}

	fn pushRangeClose(mut *self, t: &token::Token, left: int, tokens: []&token::Token, mut &ranges: *[]int) {
		n := len(*ranges)
		if n == 0 {
			match t.ID {
			| token::RBRACK:
				self.pushErr(t, "extra closed bracket ]")
			| token::RBRACE:
				self.pushErr(t, "extra closed brace }")
			| token::RPAREN:
				self.pushErr(t, "extra closed parentheses )")
			}
			ret
		} else if tokens[(*ranges)[n-1]].ID != left {
			self.pushWrongOrderCloseErr(t, tokens, ranges)
		}
		self.removeRange(n-1, t.ID, tokens, ranges)
	}

	fn checkRanges(mut *self, tokens: []&token::Token) {
		let mut ranges: []int = nil

		for i, token in tokens {
			match token.ID {
			| token::LPAREN
			| token::LBRACE
			| token::LBRACK:
				ranges = append(ranges, i)
			| token::RPAREN:
				self.pushRangeClose(token, token::LPAREN, tokens, &ranges)
			| token::RBRACE:
				self.pushRangeClose(token, token::LBRACE, tokens, &ranges)
			| token::RBRACK:
				self.pushRangeClose(token, token::LBRACK, tokens, &ranges)
			}
		}

		for _, i in ranges {
			token := tokens[i]
			match token.ID {
			| token::LPAREN:
				self.pushErr(token, "parentheses open but not closed, expected )")
			| token::LBRACE:
				self.pushErr(token, "brace open but not closed, expected }")
			| token::LBRACK:
				self.pushErr(token, "bracket open but not closed, expected ]")
			}
		}
	}

	fn parse(mut &self, mut f: &token::FileSet) {
		self.ast = &ast::AST{
			File: f,
		}

		self.checkRanges(f.Tokens)
		if len(self.errors) > 0 {
			ret
		}

		mut stmts := splitStmts(f.Tokens)

		// Get top directives.
		mut i := 0
		for i < len(stmts); i++ {
			mut stmt := stmts[i]
			if len(stmt.tokens) < 2 {
				break
			}
			if stmt.tokens[0].ID != token::HASH {
				break
			}
			if !directive::IsTop(stmt.tokens[1].Kind) {
				break
			}
			self.ast.TopDirectives = append(self.ast.TopDirectives, self.buildDirective(stmt.tokens))
		}

		// Remove all errors.
		self.errors = nil

		for i < len(stmts) && !self.stopped(); i++ {
			mut stmt := stmts[i]
			self.appendNode(stmt.tokens)
		}

		if len(self.directives) != 0 {
			self.pushErr(self.directives[0].Tag, "unused directive")
		}
	}
}
// Copyright 2023-2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/fs"
use "std/fs/path"
use "std/jule/ast"
use "std/jule/build"
use "std/jule/internal/mod"
use "std/jule/lex"
use "std/jule/parser"
use "std/jule/sema"
use "std/process"
use "std/strings"

// Read buffer by file path.
fn readBuff(path: str): []byte {
	ret fs::File.Read(path) else {
		outln("error: file cannot read")
		const ErrorExitCode = 1
		process::Exit(ErrorExitCode)
		ret nil // Avoid error
	}
}

// Make compiler error, just text.
// Not includes row, column, and etc. informations.
fn flatCompilerErr(text: str): build::Log {
	ret build::Log{
		Kind: build::LogKind.Error,
		Text: text,
	}
}

// Default importer for the reference Jule compiler.
struct Importer {
	mods: []str
	mod:  str
	pkgs: []&sema::ImportInfo
	vars: []str
}

impl Importer {
	// Returns new importer instance by compile information.
	static fn New(info: CompileInfo): &Importer {
		mut imp := &Importer{
			mods: [build::PathStdlib],
		}
		initVars(imp.vars, info)
		ret imp
	}

	// Returns all imported packages.
	// The return value is mutable reference to internal buffer.
	// You should be care about using that copy.
	fn AllPackages(mut self): []&sema::ImportInfo {
		ret self.pkgs
	}
}

impl sema::Importer for Importer {
	fn SetModPath(mut self, path: str) {
		self.mod = path
	}

	fn GetModPath(self): str {
		ret self.mod
	}

	fn ModById(self, id: int): str {
		ret self.mods[id]
	}

	fn GetImport(mut self, path: str): &sema::ImportInfo {
		for (_, mut p) in self.pkgs {
			// avoid case sensivity for fair comparison
			if strings::EqualFold(p.Path, path) {
				ret p
			}
		}
		ret nil
	}

	fn ImportPackage(mut self, path: str, updateMod: bool): ([]&ast::AST, []build::Log) {
		mut dirents := fs::Directory.Read(path) else {
			ret nil, [flatCompilerErr("cannot read package directory: " + path)]
		}

		if updateMod {
			newMod := mod::FindModuleFileDeep(path)
			if newMod != self.mod {
				self.mod = newMod
				mut errs := mod::CheckModuleFile(self.mod)
				if len(errs) != 0 {
					ret nil, errs
				}
			}
		}

		mut asts := make([]&ast::AST, 0, len(dirents))
		for _, dirent in dirents {
			// Skip directories, and non-jule files.
			if dirent.Stat.IsDir() || !strings::HasSuffix(dirent.Name, build::Ext) {
				continue
			}

			_path := path::Join(path, dirent.Name)
			mut file := lex::NewFileSet(_path)
			file.Fill(readBuff(file.Path))
			mut errors := lex::Lex(file, lex::LexMode.Standard)
			if len(errors) > 0 {
				ret nil, errors
			}

			mut finfo := parser::ParseFile(file)
			if len(finfo.Errors) > 0 {
				ret nil, finfo.Errors
			}

			// Skip this source file if file annotation is failed.
			if !isPassFileAnnotation(dirent.Name) {
				continue
			}

			r, mut logs := self.isPassBuildDirectives(finfo.Ast)
			if len(logs) > 0 {
				ret nil, logs
			}

			// Skip file if can't pass build directives.
			if !r {
				continue
			}

			asts = append(asts, finfo.Ast)
		}

		ret asts, nil
	}

	fn Imported(mut self, mut imp: &sema::ImportInfo) {
		// Already imported?
		for _, p in self.pkgs {
			// avoid case sensivity for fair comparison
			if p.Binded == imp.Binded && strings::EqualFold(p.Path, imp.Path) {
				ret
			}
		}

		if len(self.mod) != 0 {
			for i, mod in self.mods {
				if self.mod == mod {
					imp.ModId = i
					goto setted
				}
			}
			imp.ModId = len(self.mods)
			self.mods = append(self.mods, self.mod)
		setted:
		}

		self.pkgs = append(self.pkgs, imp)
	}
}

impl Importer {
	// Reports whether file passes build directives.
	fn isPassBuildDirectives(mut self, mut &file: &ast::AST): (bool, []build::Log) {
		for (_, mut td) in file.TopDirectives {
			if td.Tag.Kind != build::Directive.Build {
				continue
			}
			mut de := directiveEval{
				d: td,
				vars: self.vars,
			}
			result := de.eval()
			if len(de.logs) > 0 {
				ret false, de.logs
			}
			if !result {
				ret false, nil
			}
		}
		ret true, nil
	}
}
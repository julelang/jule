// Copyright 2025 The Jule Project Contributors. All rights reserved.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/io"
use "std/strings"
use "std/testing"

#test
async fn testOneByteReader_nonEmptyReader(t: &testing::T) {
	const msg = "Hello, World!"
	mut buf := strings::Reader.New(msg)

	mut obr := OneByteReader(buf.Async())
	let mut b: []byte
	mut n := obr.Read(b).await else {
		t.Errorf("unexpected error: {}", error)
		ret
	}
	if n != 0 {
		t.Errorf("Empty buffer read returned n={}", n)
	}

	b = make([]byte, 3)
	// Read from obr until EOF.
	mut got := new(strings::Builder)
	mut i := 0
	for ; i++ {
		n = obr.Read(b).await else {
			t.Errorf("unexpected error: {}", error)
			ret
		}
		if n == io::EOF {
			break
		}
		g, w := n, 1
		if g != w {
			t.Errorf("Iteration #{} read {} bytes, want {}", i, g, w)
		}
		got.Write(b[:n])!
	}
	g, w := got.Str(), "Hello, World!"
	if g != w {
		t.Errorf("Read mismatch\n\tGot:  {\n\tWant: {}", g, w)
	}
}

#test
async fn testOneByteReader_emptyReader(t: &testing::T) {
	mut r := strings::Reader.New("")

	mut obr := OneByteReader(r.Async())
	let mut b: []byte
	mut n := obr.Read(b).await else {
		t.Errorf("unexpected error: {}", error)
		ret
	}
	if n != 0 {
		t.Errorf("Empty buffer read returned n={}", n)
	}

	b = make([]byte, 5)
	n = obr.Read(b).await else {
		t.Errorf("unexpected error: {}", error)
		ret
	}
	if n != io::EOF {
		t.Errorf("expected EOF, got: {}", n)
	}
}

#test
async fn testHalfReader_nonEmptyReader(t: &testing::T) {
	const msg = "Hello, World!"
	mut buf := strings::Reader.New(msg)

	mut obr := HalfReader(buf.Async())
	let mut b: []byte
	mut n := obr.Read(b).await else {
		t.Errorf("unexpected error: {}", error)
		ret
	}
	if n != 0 {
		t.Errorf("Empty buffer read returned n={}", n)
	}

	b = make([]byte, 2)
	// Read from obr until EOF.
	mut got := new(strings::Builder)
	mut i := 0
	for ; i++ {
		n = obr.Read(b).await else {
			t.Errorf("unexpected error: {}", error)
			ret
		}
		if n == io::EOF {
			break
		}
		g, w := n, 1
		if g != w {
			t.Errorf("Iteration #{} read {} bytes, want {}", i, g, w)
		}
		got.Write(b[:n])!
	}
	g, w := got.Str(), "Hello, World!"
	if g != w {
		t.Errorf("Read mismatch\n\tGot:  {\n\tWant: {}", g, w)
	}
}

#test
async fn testHalfReader_emptyReader(t: &testing::T) {
	mut r := strings::Reader.New("")

	mut obr := HalfReader(r.Async())
	let mut b: []byte
	mut n := obr.Read(b).await else {
		t.Errorf("unexpected error: {}", error)
		ret
	}
	if n != io::EOF {
		t.Errorf("Empty buffer read returned n={}", n)
	}

	b = make([]byte, 5)
	n = obr.Read(b).await else {
		t.Errorf("unexpected error: {}", error)
		ret
	}
	if n != io::EOF {
		t.Errorf("expected EOF, got: {}", n)
	}
}

#test
async fn testDataErrReader_nonEmptyReader(t: &testing::T) {
	const msg = "Hello, World!"
	mut buf := strings::Reader.New(msg)

	mut der := DataErrReader(buf.Async())

	mut b := make([]byte, 3)
	mut got := new(strings::Builder)
	for {
		n := der.Read(b).await else {
			t.Errorf("unexpected error: {}", error)
			ret
		}
		if n == io::EOF {
			break
		}
		got.Write(b[:n])!
	}
	g, w := got.Str(), "Hello, World!"
	if g != w {
		t.Errorf("Read mismatch\n\tGot:  {\n\tWant: {}", g, w)
	}
}

#test
async fn testDataErrReader_emptyReader(t: &testing::T) {
	mut r := strings::Reader.New("")

	mut der := DataErrReader(r.Async())
	let mut b: []byte
	mut n := der.Read(b).await else {
		t.Errorf("unexpected error: {}", error)
		ret
	}
	if n != io::EOF {
		t.Errorf("Empty buffer read returned n={}", n)
	}

	b = make([]byte, 5)
	n = der.Read(b).await else {
		t.Errorf("unexpected error: {}", error)
		ret
	}
	if n != io::EOF {
		t.Errorf("expected EOF, got: {}", n)
	}
}
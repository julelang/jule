// Copyright 2025 The Jule Authors. All rights reserved.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/io"
use "std/testing"

struct testbuffer {
	buf: []byte
	r:   int
}

impl io::Writer for testbuffer {
	fn Write(mut *self, data: []byte)!: int {
		self.buf = append(self.buf, data...)
		ret len(data)
	}
}

impl io::Reader for testbuffer {
	fn Read(mut *self, mut data: []byte)!: int {
		if len(data) == 0 {
			ret 0
		}
		n := copy(data, self.buf[self.r:])
		if n == 0 {
			ret io::EOF
		}
		self.r += n
		ret n
	}
}

impl testbuffer {
	fn Str(*self): str {
		ret str(self.buf)
	}
}

#test
fn testCopyN(t: &testing::T) {
	mut rb := new(testbuffer)
	mut wb := new(testbuffer)
	io::WriteStr(rb, "hello, world.")!
	io::CopyN(wb, rb, 5)!
	if wb.Str() != "hello" {
		t.Errorf("CopyN did not work properly")
	}
}

#test
fn testCopy(t: &testing::T) {
	mut rb := new(testbuffer)
	mut wb := new(testbuffer)
	rb.buf = append(rb.buf, "hello, world."...)
	io::Copy(wb, rb)!
	if str(wb.buf) != "hello, world." {
		t.Errorf("Copy did not work properly")
	}
}

#test
fn testCopyBuffer(t: &testing::T) {
	mut rb := new(testbuffer)
	mut wb := new(testbuffer)
	rb.buf = append(rb.buf, "hello, world."...)
	io::CopyBuffer(wb, rb, make([]byte, 1))! // Tiny buffer to keep it honest.
	if str(wb.buf) != "hello, world." {
		t.Errorf("CopyBuffer did not work properly")
	}
}

#test
fn testCopyBufferNil(t: &testing::T) {
	mut rb := new(testbuffer)
	mut wb := new(testbuffer)
	rb.buf = append(rb.buf, "hello, world."...)
	io::CopyBuffer(wb, rb, nil)! // Should allocate a buffer.
	if str(wb.buf) != "hello, world." {
		t.Errorf("CopyBuffer did not work properly")
	}
}

#test
fn testReadAtLeast(t: &testing::T) {
	mut rb := new(testbuffer)
	rb.Write([]byte("0123"))!
	mut buf := make([]byte, 2)
	mut n := io::ReadAtLeast(rb, buf, 2) else {
		t.Errorf("{}", error)
		use 0
	}
	if n != 2 {
		t.Errorf("expected to have read 2 bytes, got {}", n)
	}
	let mut err: any
	n = io::ReadAtLeast(rb, buf, 4) else {
		err = error
		use 0
	}
	if err != io::ErrShortBuffer {
		t.Errorf("expected ErrShortBuffer got {}", err)
	}
	if n != 0 {
		t.Errorf("expected to have read 0 bytes, got {}", n)
	}
	n = io::ReadAtLeast(rb, buf, 1) else {
		t.Errorf("{}", error)
		use 0
	}
	if n != 2 {
		t.Errorf("expected to have read 2 bytes, got {}", n)
	}
	n = io::ReadAtLeast(rb, buf, 2) else {
		t.Errorf("{}", error)
		use 0
	}
	if n != io::EOF {
		t.Errorf("expected EOF, got {}", n)
	}
	rb.Write([]byte("4"))!
	err = nil
	n = io::ReadAtLeast(rb, buf, 2) else {
		err = error
		use 0
	}
	mut want := io::ErrUnexpectedEOF
	if err != want {
		t.Errorf("expected {}, got {}", want, err)
	}
}
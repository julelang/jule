// Copyright 2025 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

// The Jule code is a modified version of the original Go code from
// https://github.com/golang/go/blob/go1.24.3/src/math/rand/v2/pcg.go and came with this notice.
//
// ====================================================
// Copyright (c) 2009 The Go Authors. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//    * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//    * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//    * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// ====================================================

use "std/math/bits"

// https://numpy.org/devdocs/reference/random/upgrading-pcg64.html
// https://github.com/imneme/pcg-cpp/commit/871d0494ee9c9a7b7c43f753e3d8ca47c26f8005

// A PCG is a PCG generator with 128 bits of internal state.
// A zero PCG is equivalent to NewPCG(0, 0).
struct PCG {
	mut hi: u64
	mut lo: u64
}

// Returns a new PCG seeded with the given values.
fn NewPCG(seed1: u64, seed2: u64): &PCG {
	ret &PCG{seed1, seed2}
}

impl PCG {
	// Resets the PCG to behave the same way as NewPCG(seed1, seed2).
	fn Seed(*self, seed1: u64, seed2: u64) {
		self.hi = seed1
		self.lo = seed2
	}

	fn next(*self): (hi: u64, lo: u64) {
		// https://github.com/imneme/pcg-cpp/blob/428802d1a5/include/pcg_random.hpp#L161
		//
		// Numpy's PCG multiplies by the 64-bit value cheapMul
		// instead of the 128-bit value used here and in the official PCG code.
		// This does not seem worthwhile, at least for Go: not having any high
		// bits in the multiplier reduces the effect of low bits on the highest bits,
		// and it only saves 1 multiply out of 3.
		// (On 32-bit systems, it saves 1 out of 6, since Mul64 is doing 4.)
		const (
			mulHi = 2549297995355413924
			mulLo = 4865540595714422341
			incHi = 6364136223846793005
			incLo = 1442695040888963407
		)

		// state = state * mul + inc
		hi, lo = bits::Mul64(self.lo, mulLo)
		hi += self.hi*mulLo + self.lo*mulHi
		lo, c := bits::Add64(lo, incLo, 0)
		hi, _ = bits::Add64(hi, incHi, c)
		self.lo = lo
		self.hi = hi
		ret hi, lo
	}
}

impl Source for PCG {
	// Return a uniformly-distributed random u64 value.
	fn U64(*self): u64 {
		mut hi, lo := self.next()

		// XSL-RR would be
		//	hi, lo := p.next()
		//	return bits.RotateLeft64(lo^hi, -int(hi>>58))
		// but Numpy uses DXSM and O'Neill suggests doing the same.
		// See https://github.com/golang/go/issues/21835#issuecomment-739065688
		// and following comments.

		// DXSM "double xorshift multiply"
		// https://github.com/imneme/pcg-cpp/blob/428802d1a5/include/pcg_random.hpp#L1015

		// https://github.com/imneme/pcg-cpp/blob/428802d1a5/include/pcg_random.hpp#L176
		const cheapMul = 0xda942042e4dd58b5
		hi ^= hi >> 32
		hi *= cheapMul
		hi ^= hi >> 48
		hi *= (lo | 1)
		ret hi
	}
}
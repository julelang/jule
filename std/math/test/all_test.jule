// Copyright 2025 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/math"
use "std/mem"
use "std/testing"

static vf = [
	4.9790119248836735e+00,
	7.7388724745781045e+00,
	-2.7688005719200159e-01,
	-5.0106036182710749e+00,
	9.6362937071984173e+00,
	2.9263772392439646e+00,
	5.2290834314593066e+00,
	2.7279399104360102e+00,
	1.8253080916808550e+00,
	-8.6859247685756013e+00,
]

// The expected results below were computed by the high precision calculators
// at https://keisan.casio.com/.  More exact input values (array vf[], above)
// were obtained by printing them with "%.26f".  The answers were calculated
// to 26 digits (by using the "Digit number" drop-down control of each
// calculator).
static acos = [
	1.0496193546107222142571536e+00,
	6.8584012813664425171660692e-01,
	1.5984878714577160325521819e+00,
	2.0956199361475859327461799e+00,
	2.7053008467824138592616927e-01,
	1.2738121680361776018155625e+00,
	1.0205369421140629186287407e+00,
	1.2945003481781246062157835e+00,
	1.3872364345374451433846657e+00,
	2.6231510803970463967294145e+00,
]
static acosh = [
	2.4743347004159012494457618e+00,
	2.8576385344292769649802701e+00,
	7.2796961502981066190593175e-01,
	2.4796794418831451156471977e+00,
	3.0552020742306061857212962e+00,
	2.044238592688586588942468e+00,
	2.5158701513104513595766636e+00,
	1.99050839282411638174299e+00,
	1.6988625798424034227205445e+00,
	2.9611454842470387925531875e+00,
]
static asin = [
	5.2117697218417440497416805e-01,
	8.8495619865825236751471477e-01,
	-02.769154466281941332086016e-02,
	-5.2482360935268931351485822e-01,
	1.3002662421166552333051524e+00,
	2.9698415875871901741575922e-01,
	5.5025938468083370060258102e-01,
	2.7629597861677201301553823e-01,
	1.83559892257451475846656e-01,
	-1.0523547536021497774980928e+00,
]
static asinh = [
	2.3083139124923523427628243e+00,
	2.743551594301593620039021e+00,
	-2.7345908534880091229413487e-01,
	-2.3145157644718338650499085e+00,
	2.9613652154015058521951083e+00,
	1.7949041616585821933067568e+00,
	2.3564032905983506405561554e+00,
	1.7287118790768438878045346e+00,
	1.3626658083714826013073193e+00,
	-2.8581483626513914445234004e+00,
]
static atan = [
	1.372590262129621651920085e+00,
	1.442290609645298083020664e+00,
	-2.7011324359471758245192595e-01,
	-1.3738077684543379452781531e+00,
	1.4673921193587666049154681e+00,
	1.2415173565870168649117764e+00,
	1.3818396865615168979966498e+00,
	1.2194305844639670701091426e+00,
	1.0696031952318783760193244e+00,
	-1.4561721938838084990898679e+00,
]
static atanh = [
	5.4651163712251938116878204e-01,
	1.0299474112843111224914709e+00,
	-2.7695084420740135145234906e-02,
	-5.5072096119207195480202529e-01,
	1.9943940993171843235906642e+00,
	3.01448604578089708203017e-01,
	5.8033427206942188834370595e-01,
	2.7987997499441511013958297e-01,
	1.8459947964298794318714228e-01,
	-1.3273186910532645867272502e+00,
]
static atan2 = [
	1.1088291730037004444527075e+00,
	9.1218183188715804018797795e-01,
	1.5984772603216203736068915e+00,
	2.0352918654092086637227327e+00,
	8.0391819139044720267356014e-01,
	1.2861075249894661588866752e+00,
	1.0889904479131695712182587e+00,
	1.3044821793397925293797357e+00,
	1.3902530903455392306872261e+00,
	2.2859857424479142655411058e+00,
]
static cbrt = [
	1.7075799841925094446722675e+00,
	1.9779982212970353936691498e+00,
	-6.5177429017779910853339447e-01,
	-1.7111838886544019873338113e+00,
	2.1279920909827937423960472e+00,
	1.4303536770460741452312367e+00,
	1.7357021059106154902341052e+00,
	1.3972633462554328350552916e+00,
	1.2221149580905388454977636e+00,
	-2.0556003730500069110343596e+00,
]
static ceil = [
	5.0000000000000000e+00,
	8.0000000000000000e+00,
	math::Copysign(0, -1),
	-5.0000000000000000e+00,
	1.0000000000000000e+01,
	3.0000000000000000e+00,
	6.0000000000000000e+00,
	3.0000000000000000e+00,
	2.0000000000000000e+00,
	-8.0000000000000000e+00,
]
static copysign = [
	-4.9790119248836735e+00,
	-7.7388724745781045e+00,
	-2.7688005719200159e-01,
	-5.0106036182710749e+00,
	-9.6362937071984173e+00,
	-2.9263772392439646e+00,
	-5.2290834314593066e+00,
	-2.7279399104360102e+00,
	-1.8253080916808550e+00,
	-8.6859247685756013e+00,
]
static cos = [
	2.634752140995199110787593e-01,
	1.148551260848219865642039e-01,
	9.6191297325640768154550453e-01,
	2.938141150061714816890637e-01,
	-9.777138189897924126294461e-01,
	-9.7693041344303219127199518e-01,
	4.940088096948647263961162e-01,
	-9.1565869021018925545016502e-01,
	-2.517729313893103197176091e-01,
	-7.39241351595676573201918e-01,
]

// Results for 100000 * Pi + vf[i]
static cosLarge = [
	0.263475214062405,
	0.11485512611336555,
	0.9619129732505776,
	0.29381411505119975,
	-0.9777138190002365,
	-0.9769304134327169,
	0.4940088096808886,
	-0.9156586901941208,
	-0.25177293138045437,
	-0.7392413516109304,
]

static cosh = [
	7.2668796942212842775517446e+01,
	1.1479413465659254502011135e+03,
	1.0385767908766418550935495e+00,
	7.5000957789658051428857788e+01,
	7.655246669605357888468613e+03,
	9.3567491758321272072888257e+00,
	9.331351599270605471131735e+01,
	7.6833430994624643209296404e+00,
	3.1829371625150718153881164e+00,
	2.9595059261916188501640911e+03,
]
static erf = [
	5.1865354817738701906913566e-01,
	7.2623875834137295116929844e-01,
	-3.123458688281309990629839e-02,
	-5.2143121110253302920437013e-01,
	8.2704742671312902508629582e-01,
	3.2101767558376376743993945e-01,
	5.403990312223245516066252e-01,
	3.0034702916738588551174831e-01,
	2.0369924417882241241559589e-01,
	-7.8069386968009226729944677e-01,
]
static erfc = [
	4.8134645182261298093086434e-01,
	2.7376124165862704883070156e-01,
	1.0312345868828130999062984e+00,
	1.5214312111025330292043701e+00,
	1.7295257328687097491370418e-01,
	6.7898232441623623256006055e-01,
	4.596009687776754483933748e-01,
	6.9965297083261411448825169e-01,
	7.9630075582117758758440411e-01,
	1.7806938696800922672994468e+00,
]
static erfinv = [
	4.746037673358033586786350696e-01,
	8.559054432692110956388764172e-01,
	-2.45427830571707336251331946e-02,
	-4.78116683518973366268905506e-01,
	1.479804430319470983648120853e+00,
	2.654485787128896161882650211e-01,
	5.027444534221520197823192493e-01,
	2.466703532707627818954585670e-01,
	1.632011465103005426240343116e-01,
	-1.06672334642196900710000389e+00,
]
static exp = [
	1.4533071302642137507696589e+02,
	2.2958822575694449002537581e+03,
	7.5814542574851666582042306e-01,
	6.6668778421791005061482264e-03,
	1.5310493273896033740861206e+04,
	1.8659907517999328638667732e+01,
	1.8662167355098714543942057e+02,
	1.5301332413189378961665788e+01,
	6.2047063430646876349125085e+00,
	1.6894712385826521111610438e-04,
]
static expm1 = [
	5.105047796122957327384770212e-02,
	8.046199708567344080562675439e-02,
	-2.764970978891639815187418703e-03,
	-4.8871434888875355394330300273e-02,
	1.0115864277221467777117227494e-01,
	2.969616407795910726014621657e-02,
	5.368214487944892300914037972e-02,
	2.765488851131274068067445335e-02,
	1.842068661871398836913874273e-02,
	-8.3193870863553801814961137573e-02,
]
static expm1Large = [
	4.2031418113550844e+21,
	4.0690789717473863e+33,
	-0.9372627915981363e+00,
	-1.0,
	7.077694784145933e+41,
	5.117936223839153e+12,
	5.124137759001189e+22,
	7.03546003972584e+11,
	8.456921800389698e+07,
	-1.0,
]
static exp2 = [
	3.1537839463286288034313104e+01,
	2.1361549283756232296144849e+02,
	8.2537402562185562902577219e-01,
	3.1021158628740294833424229e-02,
	7.9581744110252191462569661e+02,
	7.6019905892596359262696423e+00,
	3.7506882048388096973183084e+01,
	6.6250893439173561733216375e+00,
	3.5438267900243941544605339e+00,
	2.4281533133513300984289196e-03,
]
static fabs = [
	4.9790119248836735e+00,
	7.7388724745781045e+00,
	2.7688005719200159e-01,
	5.0106036182710749e+00,
	9.6362937071984173e+00,
	2.9263772392439646e+00,
	5.2290834314593066e+00,
	2.7279399104360102e+00,
	1.8253080916808550e+00,
	8.6859247685756013e+00,
]
static fdim = [
	4.9790119248836735e+00,
	7.7388724745781045e+00,
	0.0000000000000000e+00,
	0.0000000000000000e+00,
	9.6362937071984173e+00,
	2.9263772392439646e+00,
	5.2290834314593066e+00,
	2.7279399104360102e+00,
	1.8253080916808550e+00,
	0.0000000000000000e+00,
]
static floor = [
	4.0000000000000000e+00,
	7.0000000000000000e+00,
	-1.0000000000000000e+00,
	-6.0000000000000000e+00,
	9.0000000000000000e+00,
	2.0000000000000000e+00,
	5.0000000000000000e+00,
	2.0000000000000000e+00,
	1.0000000000000000e+00,
	-9.0000000000000000e+00,
]
static fmod = [
	4.197615023265299782906368e-02,
	2.261127525421895434476482e+00,
	3.231794108794261433104108e-02,
	4.989396381728925078391512e+00,
	3.637062928015826201999516e-01,
	1.220868282268106064236690e+00,
	4.770916568540693347699744e+00,
	1.816180268691969246219742e+00,
	8.734595415957246977711748e-01,
	1.314075231424398637614104e+00,
]

struct fi {
	f: f64
	i: int
}

static frexp: []fi = [
	{6.2237649061045918750e-01, 3},
	{9.6735905932226306250e-01, 3},
	{-5.5376011438400318000e-01, -1},
	{-6.2632545228388436250e-01, 3},
	{6.02268356699901081250e-01, 4},
	{7.3159430981099115000e-01, 2},
	{6.5363542893241332500e-01, 3},
	{6.8198497760900255000e-01, 2},
	{9.1265404584042750000e-01, 1},
	{-5.4287029803597508250e-01, 4},
]
static gamma = [
	2.3254348370739963835386613898e+01,
	2.991153837155317076427529816e+03,
	-4.561154336726758060575129109e+00,
	7.719403468842639065959210984e-01,
	1.6111876618855418534325755566e+05,
	1.8706575145216421164173224946e+00,
	3.4082787447257502836734201635e+01,
	1.579733951448952054898583387e+00,
	9.3834586598354592860187267089e-01,
	-2.093995902923148389186189429e-05,
]
static j0 = [
	-1.8444682230601672018219338e-01,
	2.27353668906331975435892e-01,
	9.809259936157051116270273e-01,
	-1.741170131426226587841181e-01,
	-2.1389448451144143352039069e-01,
	-2.340905848928038763337414e-01,
	-1.0029099691890912094586326e-01,
	-1.5466726714884328135358907e-01,
	3.252650187653420388714693e-01,
	-8.72218484409407250005360235e-03,
]
static j1 = [
	-3.251526395295203422162967e-01,
	1.893581711430515718062564e-01,
	-1.3711761352467242914491514e-01,
	3.287486536269617297529617e-01,
	1.3133899188830978473849215e-01,
	3.660243417832986825301766e-01,
	-3.4436769271848174665420672e-01,
	4.329481396640773768835036e-01,
	5.8181350531954794639333955e-01,
	-2.7030574577733036112996607e-01,
]
static j2 = [
	5.3837518920137802565192769e-02,
	-1.7841678003393207281244667e-01,
	9.521746934916464142495821e-03,
	4.28958355470987397983072e-02,
	2.4115371837854494725492872e-01,
	4.842458532394520316844449e-01,
	-3.142145220618633390125946e-02,
	4.720849184745124761189957e-01,
	3.122312022520957042957497e-01,
	7.096213118930231185707277e-02,
]
static jM3 = [
	-3.684042080996403091021151e-01,
	2.8157665936340887268092661e-01,
	4.401005480841948348343589e-04,
	3.629926999056814081597135e-01,
	3.123672198825455192489266e-02,
	-2.958805510589623607540455e-01,
	-3.2033177696533233403289416e-01,
	-2.592737332129663376736604e-01,
	-1.0241334641061485092351251e-01,
	-2.3762660886100206491674503e-01,
]
static lgamma: []fi = [
	{3.146492141244545774319734e+00, 1},
	{8.003414490659126375852113e+00, 1},
	{1.517575735509779707488106e+00, -1},
	{-2.588480028182145853558748e-01, 1},
	{1.1989897050205555002007985e+01, 1},
	{6.262899811091257519386906e-01, 1},
	{3.5287924899091566764846037e+00, 1},
	{4.5725644770161182299423372e-01, 1},
	{-6.363667087767961257654854e-02, 1},
	{-1.077385130910300066425564e+01, -1},
]
static log = [
	1.605231462693062999102599e+00,
	2.0462560018708770653153909e+00,
	-1.2841708730962657801275038e+00,
	1.6115563905281545116286206e+00,
	2.2655365644872016636317461e+00,
	1.0737652208918379856272735e+00,
	1.6542360106073546632707956e+00,
	1.0035467127723465801264487e+00,
	6.0174879014578057187016475e-01,
	2.161703872847352815363655e+00,
]
static logb = [
	2.0000000000000000e+00,
	2.0000000000000000e+00,
	-2.0000000000000000e+00,
	2.0000000000000000e+00,
	3.0000000000000000e+00,
	1.0000000000000000e+00,
	2.0000000000000000e+00,
	1.0000000000000000e+00,
	0.0000000000000000e+00,
	3.0000000000000000e+00,
]
static log10 = [
	6.9714316642508290997617083e-01,
	8.886776901739320576279124e-01,
	-5.5770832400658929815908236e-01,
	6.998900476822994346229723e-01,
	9.8391002850684232013281033e-01,
	4.6633031029295153334285302e-01,
	7.1842557117242328821552533e-01,
	4.3583479968917773161304553e-01,
	2.6133617905227038228626834e-01,
	9.3881606348649405716214241e-01,
]
static log1p = [
	4.8590257759797794104158205e-02,
	7.4540265965225865330849141e-02,
	-2.7726407903942672823234024e-03,
	-5.1404917651627649094953380e-02,
	9.1998280672258624681335010e-02,
	2.8843762576593352865894824e-02,
	5.0969534581863707268992645e-02,
	2.6913947602193238458458594e-02,
	1.8088493239630770262045333e-02,
	-9.0865245631588989681559268e-02,
]
static log2 = [
	2.3158594707062190618898251e+00,
	2.9521233862883917703341018e+00,
	-1.8526669502700329984917062e+00,
	2.3249844127278861543568029e+00,
	3.268478366538305087466309e+00,
	1.5491157592596970278166492e+00,
	2.3865580889631732407886495e+00,
	1.447811865817085365540347e+00,
	8.6813999540425116282815557e-01,
	3.118679457227342224364709e+00,
]
static modf: [][2]f64 = [
	[4.0000000000000000e+00, 9.7901192488367350108546816e-01],
	[7.0000000000000000e+00, 7.3887247457810456552351752e-01],
	[math::Copysign(0, -1), -2.7688005719200159404635997e-01],
	[-5.0000000000000000e+00, -1.060361827107492160848778e-02],
	[9.0000000000000000e+00, 6.3629370719841737980004837e-01],
	[2.0000000000000000e+00, 9.2637723924396464525443662e-01],
	[5.0000000000000000e+00, 2.2908343145930665230025625e-01],
	[2.0000000000000000e+00, 7.2793991043601025126008608e-01],
	[1.0000000000000000e+00, 8.2530809168085506044576505e-01],
	[-8.0000000000000000e+00, -6.8592476857560136238589621e-01],
]
static nextafter32: []f32 = [
	4.979012489318848e+00,
	7.738873004913330e+00,
	-2.768800258636475e-01,
	-5.010602951049805e+00,
	9.636294364929199e+00,
	2.926377534866333e+00,
	5.229084014892578e+00,
	2.727940082550049e+00,
	1.825308203697205e+00,
	-8.685923576354980e+00,
]
static nextafter64 = [
	4.97901192488367438926388786e+00,
	7.73887247457810545370193722e+00,
	-2.7688005719200153853520874e-01,
	-5.01060361827107403343006808e+00,
	9.63629370719841915615688777e+00,
	2.92637723924396508934364647e+00,
	5.22908343145930754047867595e+00,
	2.72793991043601069534929593e+00,
	1.82530809168085528249036997e+00,
	-8.68592476857559958602905681e+00,
]
static pow = [
	9.5282232631648411840742957e+04,
	5.4811599352999901232411871e+07,
	5.2859121715894396531132279e-01,
	9.7587991957286474464259698e-06,
	4.328064329346044846740467e+09,
	8.4406761805034547437659092e+02,
	1.6946633276191194947742146e+05,
	5.3449040147551939075312879e+02,
	6.688182138451414936380374e+01,
	2.0609869004248742886827439e-09,
]
static remainder = [
	4.197615023265299782906368e-02,
	2.261127525421895434476482e+00,
	3.231794108794261433104108e-02,
	-2.120723654214984321697556e-02,
	3.637062928015826201999516e-01,
	1.220868282268106064236690e+00,
	-4.581668629186133046005125e-01,
	-9.117596417440410050403443e-01,
	8.734595415957246977711748e-01,
	1.314075231424398637614104e+00,
]
static round: []f64 = [
	5,
	8,
	math::Copysign(0, -1),
	-5,
	10,
	3,
	5,
	3,
	2,
	-9,
]
static signbit = [
	false,
	false,
	true,
	true,
	false,
	false,
	false,
	false,
	false,
	true,
]
static sin = [
	-9.6466616586009283766724726e-01,
	9.9338225271646545763467022e-01,
	-2.7335587039794393342449301e-01,
	9.5586257685042792878173752e-01,
	-2.099421066779969164496634e-01,
	2.135578780799860532750616e-01,
	-8.694568971167362743327708e-01,
	4.019566681155577786649878e-01,
	9.6778633541687993721617774e-01,
	-6.734405869050344734943028e-01,
]

// Results for 100000 * Pi + vf[i]
static sinLarge = [
	-0.9646661658702298,
	0.9933822527131653,
	-0.2733558704184597,
	0.9558625768365872,
	-0.20994210662935844,
	0.2135578781271738,
	-0.8694568971246772,
	0.4019566681521616,
	0.9677863354191839,
	-0.6734405868882902,
]
static sinh = [
	7.2661916084208532301448439e+01,
	1.1479409110035194500526446e+03,
	-2.8043136512812518927312641e-01,
	-7.499429091181587232835164e+01,
	7.6552466042906758523925934e+03,
	9.3031583421672014313789064e+00,
	9.330815755828109072810322e+01,
	7.6179893137269146407361477e+00,
	3.021769180549615819524392e+00,
	-2.95950575724449499189888e+03,
]
static sqrt = [
	2.2313699659365484748756904e+00,
	2.7818829009464263511285458e+00,
	5.2619393496314796848143251e-01,
	2.2384377628763938724244104e+00,
	3.1042380236055381099288487e+00,
	1.7106657298385224403917771e+00,
	2.286718922705479046148059e+00,
	1.6516476350711159636222979e+00,
	1.3510396336454586262419247e+00,
	2.9471892997524949215723329e+00,
]
static tan = [
	-3.661316565040227801781974e+00,
	8.64900232648597589369854e+00,
	-2.8417941955033612725238097e-01,
	3.253290185974728640827156e+00,
	2.147275640380293804770778e-01,
	-2.18600910711067004921551e-01,
	-1.760002817872367935518928e+00,
	-4.389808914752818126249079e-01,
	-3.843885560201130679995041e+00,
	9.10988793377685105753416e-01,
]

// Results for 100000 * Pi + vf[i]
static tanLarge = [
	-3.6613165655944604,
	8.649002324307808,
	-0.28417941957338666,
	3.2532901854290404,
	0.2147275639859885,
	-0.21860091076167726,
	-1.7600028179382352,
	-0.43898089152296066,
	-3.8438855603454876,
	0.9109887933362367,
]
static tanh = [
	9.9990531206936338549262119e-01,
	9.9999962057085294197613294e-01,
	-2.7001505097318677233756845e-01,
	-9.9991110943061718603541401e-01,
	9.9999999146798465745022007e-01,
	9.9427249436125236705001048e-01,
	9.9994257600983138572705076e-01,
	9.9149409509772875982054701e-01,
	9.4936501296239685514466577e-01,
	-9.9999994291374030946055701e-01,
]
static trunc = [
	4.0000000000000000e+00,
	7.0000000000000000e+00,
	math::Copysign(0, -1),
	-5.0000000000000000e+00,
	9.0000000000000000e+00,
	2.0000000000000000e+00,
	5.0000000000000000e+00,
	2.0000000000000000e+00,
	1.0000000000000000e+00,
	-8.0000000000000000e+00,
]
static y0 = [
	-3.053399153780788357534855e-01,
	1.7437227649515231515503649e-01,
	-8.6221781263678836910392572e-01,
	-3.100664880987498407872839e-01,
	1.422200649300982280645377e-01,
	4.000004067997901144239363e-01,
	-3.3340749753099352392332536e-01,
	4.5399790746668954555205502e-01,
	4.8290004112497761007536522e-01,
	2.7036697826604756229601611e-01,
]
static y1 = [
	0.15494213737457922210218611,
	-0.2165955142081145245075746,
	-2.4644949631241895201032829,
	0.1442740489541836405154505,
	0.2215379960518984777080163,
	0.3038800915160754150565448,
	0.0691107642452362383808547,
	0.2380116417809914424860165,
	-0.20849492979459761009678934,
	0.0242503179793232308250804,
]
static y2 = [
	0.3675780219390303613394936,
	-0.23034826393250119879267257,
	-16.939677983817727205631397,
	0.367653980523052152867791,
	-0.0962401471767804440353136,
	-0.1923169356184851105200523,
	0.35984072054267882391843766,
	-0.2794987252299739821654982,
	-0.7113490692587462579757954,
	-0.2647831587821263302087457,
]
static yM3 = [
	-0.14035984421094849100895341,
	-0.097535139617792072703973,
	242.25775994555580176377379,
	-0.1492267014802818619511046,
	0.26148702629155918694500469,
	0.56675383593895176530394248,
	-0.206150264009006981070575,
	0.64784284687568332737963658,
	1.3503631555901938037008443,
	0.1461869756579956803341844,
]

// arguments and expected results for special cases
static vfacosSC = [
	-math::Pi,
	1,
	math::Pi,
	math::NaN(),
]
static acosSC = [
	math::NaN(),
	0,
	math::NaN(),
	math::NaN(),
]

static vfacoshSC = [
	math::Inf(-1),
	0.5,
	1,
	math::Inf(1),
	math::NaN(),
]
static acoshSC = [
	math::NaN(),
	math::NaN(),
	0,
	math::Inf(1),
	math::NaN(),
]

static vfasinSC = [
	-math::Pi,
	math::Copysign(0, -1),
	0,
	math::Pi,
	math::NaN(),
]
static asinSC = [
	math::NaN(),
	math::Copysign(0, -1),
	0,
	math::NaN(),
	math::NaN(),
]

static vfasinhSC = [
	math::Inf(-1),
	math::Copysign(0, -1),
	0,
	math::Inf(1),
	math::NaN(),
]
static asinhSC = [
	math::Inf(-1),
	math::Copysign(0, -1),
	0,
	math::Inf(1),
	math::NaN(),
]

static vfatanSC = [
	math::Inf(-1),
	math::Copysign(0, -1),
	0,
	math::Inf(1),
	math::NaN(),
]
static atanSC = [
	-math::Pi / 2,
	math::Copysign(0, -1),
	0,
	math::Pi / 2,
	math::NaN(),
]

static vfatanhSC = [
	math::Inf(-1),
	-math::Pi,
	-1,
	math::Copysign(0, -1),
	0,
	1,
	math::Pi,
	math::Inf(1),
	math::NaN(),
]
static atanhSC = [
	math::NaN(),
	math::NaN(),
	math::Inf(-1),
	math::Copysign(0, -1),
	0,
	math::Inf(1),
	math::NaN(),
	math::NaN(),
	math::NaN(),
]
static vfatan2SC: [][2]f64 = [
	[math::Inf(-1), math::Inf(-1)],
	[math::Inf(-1), -math::Pi],
	[math::Inf(-1), 0],
	[math::Inf(-1), +math::Pi],
	[math::Inf(-1), math::Inf(1)],
	[math::Inf(-1), math::NaN()],
	[-math::Pi, math::Inf(-1)],
	[-math::Pi, 0],
	[-math::Pi, math::Inf(1)],
	[-math::Pi, math::NaN()],
	[math::Copysign(0, -1), math::Inf(-1)],
	[math::Copysign(0, -1), -math::Pi],
	[math::Copysign(0, -1), math::Copysign(0, -1)],
	[math::Copysign(0, -1), 0],
	[math::Copysign(0, -1), +math::Pi],
	[math::Copysign(0, -1), math::Inf(1)],
	[math::Copysign(0, -1), math::NaN()],
	[0, math::Inf(-1)],
	[0, -math::Pi],
	[0, math::Copysign(0, -1)],
	[0, 0],
	[0, +math::Pi],
	[0, math::Inf(1)],
	[0, math::NaN()],
	[+math::Pi, math::Inf(-1)],
	[+math::Pi, 0],
	[+math::Pi, math::Inf(1)],
	[1.0, math::Inf(1)],
	[-1.0, math::Inf(1)],
	[+math::Pi, math::NaN()],
	[math::Inf(1), math::Inf(-1)],
	[math::Inf(1), -math::Pi],
	[math::Inf(1), 0],
	[math::Inf(1), +math::Pi],
	[math::Inf(1), math::Inf(1)],
	[math::Inf(1), math::NaN()],
	[math::NaN(), math::NaN()],
]
static atan2SC = [
	-3 * math::Pi / 4,     // atan2(-Inf, -Inf)
	-math::Pi / 2,         // atan2(-Inf, -Pi)
	-math::Pi / 2,         // atan2(-Inf, +0)
	-math::Pi / 2,         // atan2(-Inf, +Pi)
	-math::Pi / 4,         // atan2(-Inf, +Inf)
	math::NaN(),           // atan2(-Inf, NaN)
	-math::Pi,             // atan2(-Pi, -Inf)
	-math::Pi / 2,         // atan2(-Pi, +0)
	math::Copysign(0, -1), // atan2(-Pi, Inf)
	math::NaN(),           // atan2(-Pi, NaN)
	-math::Pi,             // atan2(-0, -Inf)
	-math::Pi,             // atan2(-0, -Pi)
	-math::Pi,             // atan2(-0, -0)
	math::Copysign(0, -1), // atan2(-0, +0)
	math::Copysign(0, -1), // atan2(-0, +Pi)
	math::Copysign(0, -1), // atan2(-0, +Inf)
	math::NaN(),           // atan2(-0, NaN)
	math::Pi,              // atan2(+0, -Inf)
	math::Pi,              // atan2(+0, -Pi)
	math::Pi,              // atan2(+0, -0)
	0,                     // atan2(+0, +0)
	0,                     // atan2(+0, +Pi)
	0,                     // atan2(+0, +Inf)
	math::NaN(),           // atan2(+0, NaN)
	math::Pi,              // atan2(+Pi, -Inf)
	math::Pi / 2,          // atan2(+Pi, +0)
	0,                     // atan2(+Pi, +Inf)
	0,                     // atan2(+1, +Inf)
	math::Copysign(0, -1), // atan2(-1, +Inf)
	math::NaN(),           // atan2(+Pi, NaN)
	3 * math::Pi / 4,      // atan2(+Inf, -Inf)
	math::Pi / 2,          // atan2(+Inf, -Pi)
	math::Pi / 2,          // atan2(+Inf, +0)
	math::Pi / 2,          // atan2(+Inf, +Pi)
	math::Pi / 4,          // atan2(+Inf, +Inf)
	math::NaN(),           // atan2(+Inf, NaN)
	math::NaN(),           // atan2(NaN, NaN)
]

static vfcbrtSC = [
	math::Inf(-1),
	math::Copysign(0, -1),
	0,
	math::Inf(1),
	math::NaN(),
]
static cbrtSC = [
	math::Inf(-1),
	math::Copysign(0, -1),
	0,
	math::Inf(1),
	math::NaN(),
]

static vfceilSC = [
	math::Inf(-1),
	math::Copysign(0, -1),
	0,
	math::Inf(1),
	math::NaN(),
	4.503599627370495e+15,   /* 1<<52 - 1 */
	4.5035996273704955e+15,  /* 1<<52 - 0.5 */  // largest fractional f64
	4.503599627370496e+15,   /* 1 << 52 */
	-4.503599627370496e+15,  /* -1 << 52 */
	-4.5035996273704955e+15, /* -1<<52 + 0.5 */ // smallest fractional f64
	-4.503599627370495e+15,  /* -1<<52 + 1 */
	9.007199254740992e+15,   /* 1 << 53 */
	-9.007199254740992e+15,  /* -1 << 53 */
]

static mut ceilBaseSC = [
	math::Inf(-1),
	math::Copysign(0, -1),
	0,
	math::Inf(1),
	math::NaN(),
]

static ceilSC = append(ceilBaseSC,
	4.503599627370495e+15,
	4.503599627370496e+15,
	4.503599627370496e+15,
	-4.503599627370496e+15,
	-4.503599627370495e+15,
	-4.503599627370495e+15,
	9.007199254740992e+15,
	-9.007199254740992e+15)

static floorSC = append(ceilBaseSC,
	4.503599627370495e+15,
	4.503599627370495e+15,
	4.503599627370496e+15,
	-4.503599627370496e+15,
	-4.503599627370496e+15,
	-4.503599627370495e+15,
	9.007199254740992e+15,
	-9.007199254740992e+15)

static truncSC = append(ceilBaseSC,
	4.503599627370495e+15,
	4.503599627370495e+15,
	4.503599627370496e+15,
	-4.503599627370496e+15,
	-4.503599627370495e+15,
	-4.503599627370495e+15,
	9.007199254740992e+15,
	-9.007199254740992e+15)

static vfcopysignSC = [
	math::Inf(-1),
	math::Inf(1),
	math::NaN(),
]
static copysignSC = [
	math::Inf(-1),
	math::Inf(-1),
	math::NaN(),
]

static vfcosSC = [
	math::Inf(-1),
	math::Inf(1),
	math::NaN(),
]
static cosSC = [
	math::NaN(),
	math::NaN(),
	math::NaN(),
]

static vfcoshSC = [
	math::Inf(-1),
	math::Copysign(0, -1),
	0,
	math::Inf(1),
	math::NaN(),
]
static coshSC = [
	math::Inf(1),
	1,
	1,
	math::Inf(1),
	math::NaN(),
]

static vferfSC = [
	math::Inf(-1),
	math::Copysign(0, -1),
	0,
	math::Inf(1),
	math::NaN(),
	-1000,
	1000,
]
static erfSC: []f64 = [
	-1,
	math::Copysign(0, -1),
	0,
	1,
	math::NaN(),
	-1,
	1,
]

static vferfcSC = [
	math::Inf(-1),
	math::Inf(1),
	math::NaN(),
	-1000,
	1000,
]
static erfcSC: []f64 = [
	2,
	0,
	math::NaN(),
	2,
	0,
]

static vferfinvSC: []f64 = [
	1,
	-1,
	0,
	math::Inf(-1),
	math::Inf(1),
	math::NaN(),
]
static erfinvSC = [
	math::Inf(+1),
	math::Inf(-1),
	0,
	math::NaN(),
	math::NaN(),
	math::NaN(),
]

static vferfcinvSC: []f64 = [
	0,
	2,
	1,
	math::Inf(1),
	math::Inf(-1),
	math::NaN(),
]
static erfcinvSC = [
	math::Inf(+1),
	math::Inf(-1),
	0,
	math::NaN(),
	math::NaN(),
	math::NaN(),
]

static vfexpSC = [
	math::Inf(-1),
	-2000,
	2000,
	math::Inf(1),
	math::NaN(),
	// smallest f64 that overflows Exp(x)
	7.097827128933841e+02,
	// Issue 18912
	1.48852223e+09,
	1.4885222e+09,
	1,
	// near zero
	3.725290298461915e-09,
	// denormal
	-740,
]
static expSC: []f64 = [
	0,
	0,
	math::Inf(1),
	math::Inf(1),
	math::NaN(),
	math::Inf(1),
	math::Inf(1),
	math::Inf(1),
	2.718281828459045,
	1.0000000037252903,
	4.2e-322,
]

static vfexp2SC = [
	math::Inf(-1),
	-2000,
	2000,
	math::Inf(1),
	math::NaN(),
	// smallest f64 that overflows Exp2(x)
	1024,
	// near underflow
	-1.07399999999999e+03,
	// near zero
	3.725290298461915e-09,
]
static exp2SC: []f64 = [
	0,
	0,
	math::Inf(1),
	math::Inf(1),
	math::NaN(),
	math::Inf(1),
	5e-324,
	1.0000000025821745,
]

static vfexpm1SC = [
	math::Inf(-1),
	-710,
	math::Copysign(0, -1),
	0,
	710,
	math::Inf(1),
	math::NaN(),
]
static expm1SC: []f64 = [
	-1,
	-1,
	math::Copysign(0, -1),
	0,
	math::Inf(1),
	math::Inf(1),
	math::NaN(),
]

static vffabsSC = [
	math::Inf(-1),
	math::Copysign(0, -1),
	0,
	math::Inf(1),
	math::NaN(),
]
static fabsSC = [
	math::Inf(1),
	0,
	0,
	math::Inf(1),
	math::NaN(),
]

static vffdimSC: [][2]f64 = [
	[math::Inf(-1), math::Inf(-1)],
	[math::Inf(-1), math::Inf(1)],
	[math::Inf(-1), math::NaN()],
	[math::Copysign(0, -1), math::Copysign(0, -1)],
	[math::Copysign(0, -1), 0],
	[0, math::Copysign(0, -1)],
	[0, 0],
	[math::Inf(1), math::Inf(-1)],
	[math::Inf(1), math::Inf(1)],
	[math::Inf(1), math::NaN()],
	[math::NaN(), math::Inf(-1)],
	[math::NaN(), math::Copysign(0, -1)],
	[math::NaN(), 0],
	[math::NaN(), math::Inf(1)],
	[math::NaN(), math::NaN()],
]
static nan = math::F64frombits(0xFFF8000000000000) // SSE2 DIVSD 0/0
static vffdim2SC: [][2]f64 = [
	[math::Inf(-1), math::Inf(-1)],
	[math::Inf(-1), math::Inf(1)],
	[math::Inf(-1), nan],
	[math::Copysign(0, -1), math::Copysign(0, -1)],
	[math::Copysign(0, -1), 0],
	[0, math::Copysign(0, -1)],
	[0, 0],
	[math::Inf(1), math::Inf(-1)],
	[math::Inf(1), math::Inf(1)],
	[math::Inf(1), nan],
	[nan, math::Inf(-1)],
	[nan, math::Copysign(0, -1)],
	[nan, 0],
	[nan, math::Inf(1)],
	[nan, nan],
]
static fdimSC = [
	math::NaN(),
	0,
	math::NaN(),
	0,
	0,
	0,
	0,
	math::Inf(1),
	math::NaN(),
	math::NaN(),
	math::NaN(),
	math::NaN(),
	math::NaN(),
	math::NaN(),
	math::NaN(),
]
static fmaxSC = [
	math::Inf(-1),
	math::Inf(1),
	math::NaN(),
	math::Copysign(0, -1),
	0,
	0,
	0,
	math::Inf(1),
	math::Inf(1),
	math::Inf(1),
	math::NaN(),
	math::NaN(),
	math::NaN(),
	math::Inf(1),
	math::NaN(),
]
static fminSC = [
	math::Inf(-1),
	math::Inf(-1),
	math::Inf(-1),
	math::Copysign(0, -1),
	math::Copysign(0, -1),
	math::Copysign(0, -1),
	0,
	math::Inf(-1),
	math::Inf(1),
	math::NaN(),
	math::Inf(-1),
	math::NaN(),
	math::NaN(),
	math::NaN(),
	math::NaN(),
]

static vffmodSC: [][2]f64 = [
	[math::Inf(-1), math::Inf(-1)],
	[math::Inf(-1), -math::Pi],
	[math::Inf(-1), 0],
	[math::Inf(-1), math::Pi],
	[math::Inf(-1), math::Inf(1)],
	[math::Inf(-1), math::NaN()],
	[-math::Pi, math::Inf(-1)],
	[-math::Pi, 0],
	[-math::Pi, math::Inf(1)],
	[-math::Pi, math::NaN()],
	[math::Copysign(0, -1), math::Inf(-1)],
	[math::Copysign(0, -1), 0],
	[math::Copysign(0, -1), math::Inf(1)],
	[math::Copysign(0, -1), math::NaN()],
	[0, math::Inf(-1)],
	[0, 0],
	[0, math::Inf(1)],
	[0, math::NaN()],
	[math::Pi, math::Inf(-1)],
	[math::Pi, 0],
	[math::Pi, math::Inf(1)],
	[math::Pi, math::NaN()],
	[math::Inf(1), math::Inf(-1)],
	[math::Inf(1), -math::Pi],
	[math::Inf(1), 0],
	[math::Inf(1), math::Pi],
	[math::Inf(1), math::Inf(1)],
	[math::Inf(1), math::NaN()],
	[math::NaN(), math::Inf(-1)],
	[math::NaN(), -math::Pi],
	[math::NaN(), 0],
	[math::NaN(), math::Pi],
	[math::NaN(), math::Inf(1)],
	[math::NaN(), math::NaN()],
]
static fmodSC = [
	math::NaN(),           // fmod(-Inf, -Inf)
	math::NaN(),           // fmod(-Inf, -Pi)
	math::NaN(),           // fmod(-Inf, 0)
	math::NaN(),           // fmod(-Inf, Pi)
	math::NaN(),           // fmod(-Inf, +Inf)
	math::NaN(),           // fmod(-Inf, NaN)
	-math::Pi,             // fmod(-Pi, -Inf)
	math::NaN(),           // fmod(-Pi, 0)
	-math::Pi,             // fmod(-Pi, +Inf)
	math::NaN(),           // fmod(-Pi, NaN)
	math::Copysign(0, -1), // fmod(-0, -Inf)
	math::NaN(),           // fmod(-0, 0)
	math::Copysign(0, -1), // fmod(-0, Inf)
	math::NaN(),           // fmod(-0, NaN)
	0,                     // fmod(0, -Inf)
	math::NaN(),           // fmod(0, 0)
	0,                     // fmod(0, +Inf)
	math::NaN(),           // fmod(0, NaN)
	math::Pi,              // fmod(Pi, -Inf)
	math::NaN(),           // fmod(Pi, 0)
	math::Pi,              // fmod(Pi, +Inf)
	math::NaN(),           // fmod(Pi, NaN)
	math::NaN(),           // fmod(+Inf, -Inf)
	math::NaN(),           // fmod(+Inf, -Pi)
	math::NaN(),           // fmod(+Inf, 0)
	math::NaN(),           // fmod(+Inf, Pi)
	math::NaN(),           // fmod(+Inf, +Inf)
	math::NaN(),           // fmod(+Inf, NaN)
	math::NaN(),           // fmod(NaN, -Inf)
	math::NaN(),           // fmod(NaN, -Pi)
	math::NaN(),           // fmod(NaN, 0)
	math::NaN(),           // fmod(NaN, Pi)
	math::NaN(),           // fmod(NaN, +Inf)
	math::NaN(),           // fmod(NaN, NaN)
]

static vffrexpSC = [
	math::Inf(-1),
	math::Copysign(0, -1),
	0,
	math::Inf(1),
	math::NaN(),
]
static frexpSC: []fi = [
	{math::Inf(-1), 0},
	{math::Copysign(0, -1), 0},
	{0, 0},
	{math::Inf(1), 0},
	{math::NaN(), 0},
]

static vfgamma: [][2]f64 = [
	[math::Inf(1), math::Inf(1)],
	[math::Inf(-1), math::NaN()],
	[0, math::Inf(1)],
	[math::Copysign(0, -1), math::Inf(-1)],
	[math::NaN(), math::NaN()],
	[-1, math::NaN()],
	[-2, math::NaN()],
	[-3, math::NaN()],
	[-1e16, math::NaN()],
	[-1e300, math::NaN()],
	[1.7e308, math::Inf(1)],

	// Test inputs inspired by Python test suite.
	// Outputs computed at high precision by PARI/GP.
	// If recomputing table entries, be careful to use
	// high-precision (%.1000g) formatting of the f64 inputs.
	// For example, -2.0000000000000004 is the f64 with exact value
	// -2.00000000000000044408920985626161695, and
	// gamma(-2.0000000000000004) = -1249999999999999.5386078562728167651513, while
	// gamma(-2.00000000000000044408920985626161695) = -1125899906826907.2044875028130093136826.
	// Thus the table lists -1.1258999068426235e+15 as the answer.
	[0.5, 1.772453850905516],
	[1.5, 0.886226925452758],
	[2.5, 1.329340388179137],
	[3.5, 3.3233509704478426],
	[-0.5, -3.544907701811032],
	[-1.5, 2.363271801207355],
	[-2.5, -0.9453087204829419],
	[-3.5, 0.2700882058522691],
	[0.1, 9.51350769866873],
	[0.01, 99.4325851191506],
	[1e-08, 9.999999942278434e+07],
	[1e-16, 1e+16],
	[0.001, 999.4237724845955],
	[1e-16, 1e+16],
	[1e-308, 1e+308],
	[5.6e-309, 1.7857142857142864e+308],
	[5.5e-309, math::Inf(1)],
	[1e-309, math::Inf(1)],
	[1e-323, math::Inf(1)],
	[5e-324, math::Inf(1)],
	[-0.1, -10.686287021193193],
	[-0.01, -100.58719796441078],
	[-1e-08, -1.0000000057721567e+08],
	[-1e-16, -1e+16],
	[-0.001, -1000.5782056293586],
	[-1e-16, -1e+16],
	[-1e-308, -1e+308],
	[-5.6e-309, -1.7857142857142864e+308],
	[-5.5e-309, math::Inf(-1)],
	[-1e-309, math::Inf(-1)],
	[-1e-323, math::Inf(-1)],
	[-5e-324, math::Inf(-1)],
	[-0.9999999999999999, -9.007199254740992e+15],
	[-1.0000000000000002, 4.5035996273704955e+15],
	[-1.9999999999999998, 2.2517998136852485e+15],
	[-2.0000000000000004, -1.1258999068426235e+15],
	[-100.00000000000001, -7.540083334883109e-145],
	[-99.99999999999999, 7.540083334884096e-145],
	[17, 2.0922789888e+13],
	[171, 7.257415615307999e+306],
	[171.6, 1.5858969096672565e+308],
	[171.624, 1.7942117599248104e+308],
	[171.625, math::Inf(1)],
	[172, math::Inf(1)],
	[2000, math::Inf(1)],
	[-100.5, -3.3536908198076787e-159],
	[-160.5, -5.255546447007829e-286],
	[-170.5, -3.3127395215386074e-308],
	[-171.5, 1.9316265431712e-310],
	[-176.5, -1.196e-321],
	[-177.5, 5e-324],
	[-178.5, math::Copysign(0, -1)],
	[-179.5, 0],
	[-201.0001, 0],
	[-202.9999, math::Copysign(0, -1)],
	[-1000.5, math::Copysign(0, -1)],
	[-1.0000000003e+09, math::Copysign(0, -1)],
	[-4.5035996273704955e+15, 0],
	[-63.349078729022985, 4.177797167776188e-88],
	[-127.45117632943295, 1.183111089623681e-214],
]

static vfhypotSC: [][2]f64 = [
	[math::Inf(-1), math::Inf(-1)],
	[math::Inf(-1), 0],
	[math::Inf(-1), math::Inf(1)],
	[math::Inf(-1), math::NaN()],
	[math::Copysign(0, -1), math::Copysign(0, -1)],
	[math::Copysign(0, -1), 0],
	[0, math::Copysign(0, -1)],
	[0, 0],                                         // +0, +0
	[0, math::Inf(-1)],
	[0, math::Inf(1)],
	[0, math::NaN()],
	[math::Inf(1), math::Inf(-1)],
	[math::Inf(1), 0],
	[math::Inf(1), math::Inf(1)],
	[math::Inf(1), math::NaN()],
	[math::NaN(), math::Inf(-1)],
	[math::NaN(), 0],
	[math::NaN(), math::Inf(1)],
	[math::NaN(), math::NaN()],
]
static hypotSC = [
	math::Inf(1),
	math::Inf(1),
	math::Inf(1),
	math::Inf(1),
	0,
	0,
	0,
	0,
	math::Inf(1),
	math::Inf(1),
	math::NaN(),
	math::Inf(1),
	math::Inf(1),
	math::Inf(1),
	math::Inf(1),
	math::Inf(1),
	math::NaN(),
	math::Inf(1),
	math::NaN(),
]

static ilogbSC: []int = [
	i32.Max,
	i32.Min,
	i32.Max,
	i32.Max,
]

static vfj0SC = [
	math::Inf(-1),
	0,
	math::Inf(1),
	math::NaN(),
]
static j0SC: []f64 = [
	0,
	1,
	0,
	math::NaN(),
]
static j1SC: []f64 = [
	0,
	0,
	0,
	math::NaN(),
]
static j2SC: []f64 = [
	0,
	0,
	0,
	math::NaN(),
]
static jM3SC: []f64 = [
	0,
	0,
	0,
	math::NaN(),
]

static vfldexpSC: []fi = [
	{0, 0},
	{0, -1075},
	{0, 1024},
	{math::Copysign(0, -1), 0},
	{math::Copysign(0, -1), -1075},
	{math::Copysign(0, -1), 1024},
	{math::Inf(1), 0},
	{math::Inf(1), -1024},
	{math::Inf(-1), 0},
	{math::Inf(-1), -1024},
	{math::NaN(), -1024},
	{10, int(1) << (u64(mem::SizeOf(0)-1) * 8)},
	{10, -(int(1) << (u64(mem::SizeOf(0)-1) * 8))},
]
static ldexpSC: []f64 = [
	0,
	0,
	0,
	math::Copysign(0, -1),
	math::Copysign(0, -1),
	math::Copysign(0, -1),
	math::Inf(1),
	math::Inf(1),
	math::Inf(-1),
	math::Inf(-1),
	math::NaN(),
	math::Inf(1),
	0,
]

static vflgammaSC = [
	math::Inf(-1),
	-3,
	0,
	1,
	2,
	math::Inf(1),
	math::NaN(),
]
static lgammaSC: []fi = [
	{math::Inf(-1), 1},
	{math::Inf(1), 1},
	{math::Inf(1), 1},
	{0, 1},
	{0, 1},
	{math::Inf(1), 1},
	{math::NaN(), 1},
]

static vflogSC = [
	math::Inf(-1),
	-math::Pi,
	math::Copysign(0, -1),
	0,
	1,
	math::Inf(1),
	math::NaN(),
]
static logSC = [
	math::NaN(),
	math::NaN(),
	math::Inf(-1),
	math::Inf(-1),
	0,
	math::Inf(1),
	math::NaN(),
]

static vflogbSC = [
	math::Inf(-1),
	0,
	math::Inf(1),
	math::NaN(),
]
static logbSC = [
	math::Inf(1),
	math::Inf(-1),
	math::Inf(1),
	math::NaN(),
]

static vflog1pSC = [
	math::Inf(-1),
	-math::Pi,
	-1,
	math::Copysign(0, -1),
	0,
	math::Inf(1),
	math::NaN(),
	4503599627370496.5,    // Issue #29488
]
static log1pSC = [
	math::NaN(),
	math::NaN(),
	math::Inf(-1),
	math::Copysign(0, -1),
	0,
	math::Inf(1),
	math::NaN(),
	36.04365338911715,     // Issue #29488
]

static vfmodfSC = [
	math::Inf(-1),
	math::Copysign(0, -1),
	math::Inf(1),
	math::NaN(),
]
static modfSC: [][2]f64 = [
	[math::Inf(-1), math::NaN()],                   // [2]f64{math::Copysign(0, -1), math::Inf(-1)},
	[math::Copysign(0, -1), math::Copysign(0, -1)],
	[math::Inf(1), math::NaN()],                    // [2]f64{0, math::Inf(1)},
	[math::NaN(), math::NaN()],
]

static vfnextafter32SC: [][2]f32 = [
	[0, 0],
	[0, f32(math::Copysign(0, -1))],
	[0, -1],
	[0, f32(math::NaN())],
	[f32(math::Copysign(0, -1)), 1],
	[f32(math::Copysign(0, -1)), 0],
	[f32(math::Copysign(0, -1)), f32(math::Copysign(0, -1))],
	[f32(math::Copysign(0, -1)), -1],
	[f32(math::NaN()), 0],
	[f32(math::NaN()), f32(math::NaN())],
]
static nextafter32SC: []f32 = [
	0,
	0,
	-1.401298464e-45,           // Float32frombits(0x80000001)
	f32(math::NaN()),
	1.401298464e-45,            // Float32frombits(0x00000001)
	f32(math::Copysign(0, -1)),
	f32(math::Copysign(0, -1)),
	-1.401298464e-45,           // Float32frombits(0x80000001)
	f32(math::NaN()),
	f32(math::NaN()),
]

static vfnextafter64SC: [][2]f64 = [
	[0, 0],
	[0, math::Copysign(0, -1)],
	[0, -1],
	[0, math::NaN()],
	[math::Copysign(0, -1), 1],
	[math::Copysign(0, -1), 0],
	[math::Copysign(0, -1), math::Copysign(0, -1)],
	[math::Copysign(0, -1), -1],
	[math::NaN(), 0],
	[math::NaN(), math::NaN()],
]
static nextafter64SC: []f64 = [
	0,
	0,
	-4.9406564584124654418e-324, // F64grombits(0x8000000000000001)
	math::NaN(),
	4.9406564584124654418e-324,  // F64frombits(0x0000000000000001)
	math::Copysign(0, -1),
	math::Copysign(0, -1),
	-4.9406564584124654418e-324, // F64frombits(0x8000000000000001)
	math::NaN(),
	math::NaN(),
]

static vfpowSC: [][2]f64 = [
	[math::Inf(-1), -math::Pi],
	[math::Inf(-1), -3],
	[math::Inf(-1), math::Copysign(0, -1)],
	[math::Inf(-1), 0],
	[math::Inf(-1), 1],
	[math::Inf(-1), 3],
	[math::Inf(-1), math::Pi],
	[math::Inf(-1), 0.5],
	[math::Inf(-1), math::NaN()],
	[-math::Pi, math::Inf(-1)],
	[-math::Pi, -math::Pi],
	[-math::Pi, math::Copysign(0, -1)],
	[-math::Pi, 0],
	[-math::Pi, 1],
	[-math::Pi, math::Pi],
	[-math::Pi, math::Inf(1)],
	[-math::Pi, math::NaN()],
	[-1, math::Inf(-1)],
	[-1, math::Inf(1)],
	[-1, math::NaN()],
	[-0.5, math::Inf(-1)],
	[-0.5, math::Inf(1)],
	[math::Copysign(0, -1), math::Inf(-1)],
	[math::Copysign(0, -1), -math::Pi],
	[math::Copysign(0, -1), -0.5],
	[math::Copysign(0, -1), -3],
	[math::Copysign(0, -1), 3],
	[math::Copysign(0, -1), math::Pi],
	[math::Copysign(0, -1), 0.5],
	[math::Copysign(0, -1), math::Inf(1)],
	[0, math::Inf(-1)],
	[0, -math::Pi],
	[0, -3],
	[0, math::Copysign(0, -1)],
	[0, 0],
	[0, 3],
	[0, math::Pi],
	[0, math::Inf(1)],
	[0, math::NaN()],
	[0.5, math::Inf(-1)],
	[0.5, math::Inf(1)],
	[1, math::Inf(-1)],
	[1, math::Inf(1)],
	[1, math::NaN()],
	[math::Pi, math::Inf(-1)],
	[math::Pi, math::Copysign(0, -1)],
	[math::Pi, 0],
	[math::Pi, 1],
	[math::Pi, math::Inf(1)],
	[math::Pi, math::NaN()],
	[math::Inf(1), -math::Pi],
	[math::Inf(1), math::Copysign(0, -1)],
	[math::Inf(1), 0],
	[math::Inf(1), 1],
	[math::Inf(1), math::Pi],
	[math::Inf(1), math::NaN()],
	[math::NaN(), -math::Pi],
	[math::NaN(), math::Copysign(0, -1)],
	[math::NaN(), 0],
	[math::NaN(), 1],
	[math::NaN(), math::Pi],
	[math::NaN(), math::NaN()],

	// Issue #7394 overflow checks
	[2, 4.294967296e+09],
	[2, -4.294967296e+09],
	[-2, 4.294967297e+09],
	[0.5, 3.5184372088832e+13],
	[0.5, -3.5184372088832e+13],
	[math::Nextafter(1, 2), 9.223372036854776e+18],
	[math::Nextafter(1, -2), 9.223372036854776e+18],
	[math::Nextafter(-1, 2), 9.223372036854776e+18],
	[math::Nextafter(-1, -2), 9.223372036854776e+18],

	// Issue #57465
	[math::Copysign(0, -1), 1e19],
	[math::Copysign(0, -1), -1e19],
	[math::Copysign(0, -1), 9.007199254740991e+15],
	[math::Copysign(0, -1), -9.007199254740991e+15],
]
static powSC: []f64 = [
	0,                     // pow(-Inf, -Pi)
	math::Copysign(0, -1), // pow(-Inf, -3)
	1,                     // pow(-Inf, -0)
	1,                     // pow(-Inf, +0)
	math::Inf(-1),         // pow(-Inf, 1)
	math::Inf(-1),         // pow(-Inf, 3)
	math::Inf(1),          // pow(-Inf, Pi)
	math::Inf(1),          // pow(-Inf, 0.5)
	math::NaN(),           // pow(-Inf, NaN)
	0,                     // pow(-Pi, -Inf)
	math::NaN(),           // pow(-Pi, -Pi)
	1,                     // pow(-Pi, -0)
	1,                     // pow(-Pi, +0)
	-math::Pi,             // pow(-Pi, 1)
	math::NaN(),           // pow(-Pi, Pi)
	math::Inf(1),          // pow(-Pi, +Inf)
	math::NaN(),           // pow(-Pi, NaN)
	1,                     // pow(-1, -Inf) IEEE 754-2008
	1,                     // pow(-1, +Inf) IEEE 754-2008
	math::NaN(),           // pow(-1, NaN)
	math::Inf(1),          // pow(-1/2, -Inf)
	0,                     // pow(-1/2, +Inf)
	math::Inf(1),          // pow(-0, -Inf)
	math::Inf(1),          // pow(-0, -Pi)
	math::Inf(1),          // pow(-0, -0.5)
	math::Inf(-1),         // pow(-0, -3) IEEE 754-2008
	math::Copysign(0, -1), // pow(-0, 3) IEEE 754-2008
	0,                     // pow(-0, +Pi)
	0,                     // pow(-0, 0.5)
	0,                     // pow(-0, +Inf)
	math::Inf(1),          // pow(+0, -Inf)
	math::Inf(1),          // pow(+0, -Pi)
	math::Inf(1),          // pow(+0, -3)
	1,                     // pow(+0, -0)
	1,                     // pow(+0, +0)
	0,                     // pow(+0, 3)
	0,                     // pow(+0, +Pi)
	0,                     // pow(+0, +Inf)
	math::NaN(),           // pow(+0, NaN)
	math::Inf(1),          // pow(1/2, -Inf)
	0,                     // pow(1/2, +Inf)
	1,                     // pow(1, -Inf) IEEE 754-2008
	1,                     // pow(1, +Inf) IEEE 754-2008
	1,                     // pow(1, NaN) IEEE 754-2008
	0,                     // pow(+Pi, -Inf)
	1,                     // pow(+Pi, -0)
	1,                     // pow(+Pi, +0)
	math::Pi,              // pow(+Pi, 1)
	math::Inf(1),          // pow(+Pi, +Inf)
	math::NaN(),           // pow(+Pi, NaN)
	0,                     // pow(+Inf, -Pi)
	1,                     // pow(+Inf, -0)
	1,                     // pow(+Inf, +0)
	math::Inf(1),          // pow(+Inf, 1)
	math::Inf(1),          // pow(+Inf, Pi)
	math::NaN(),           // pow(+Inf, NaN)
	math::NaN(),           // pow(NaN, -Pi)
	1,                     // pow(NaN, -0)
	1,                     // pow(NaN, +0)
	math::NaN(),           // pow(NaN, 1)
	math::NaN(),           // pow(NaN, +Pi)
	math::NaN(),           // pow(NaN, NaN)

	// Issue #7394 overflow checks
	math::Inf(1),          // pow(2, f64(1 << 32))
	0,                     // pow(2, -f64(1 << 32))
	math::Inf(-1),         // pow(-2, f64(1<<32 + 1))
	0,                     // pow(1/2, f64(1 << 45))
	math::Inf(1),          // pow(1/2, -f64(1 << 45))
	math::Inf(1),          // pow(Nextafter(1, 2), f64(1 << 63))
	0,                     // pow(Nextafter(1, -2), f64(1 << 63))
	0,                     // pow(Nextafter(-1, 2), f64(1 << 63))
	math::Inf(1),          // pow(Nextafter(-1, -2), f64(1 << 63))

	// Issue #57465
	0,                     // pow(-0, 1e19)
	math::Inf(1),          // pow(-0, -1e19)
	math::Copysign(0, -1), // pow(-0, 1<<53 -1)
	math::Inf(-1),         // pow(-0, -(1<<53 -1))
]

static vfpow10SC: []int = [
	i32.Min,
	-324,
	-323,
	-50,
	-22,
	-1,
	0,
	1,
	22,
	50,
	100,
	200,
	308,
	309,
	i32.Max,
]

static pow10SC: []f64 = [
	0,            // pow10(MinInt32)
	0,            // pow10(-324)
	1.0e-323,     // pow10(-323)
	1.0e-50,      // pow10(-50)
	1.0e-22,      // pow10(-22)
	1.0e-1,       // pow10(-1)
	1.0e0,        // pow10(0)
	1.0e1,        // pow10(1)
	1.0e22,       // pow10(22)
	1.0e50,       // pow10(50)
	1.0e100,      // pow10(100)
	1.0e200,      // pow10(200)
	1.0e308,      // pow10(308)
	math::Inf(1), // pow10(309)
	math::Inf(1), // pow10(MaxInt32)
]

static vfroundSC: [][2]f64 = [
	[0, 0],
	[1.390671161567e-309, 0],               // denormal
	[0.49999999999999994, 0],               // 0.5-epsilon
	[0.5, 1],
	[0.5000000000000001, 1],                // 0.5+epsilon
	[-1.5, -2],
	[-2.5, -3],
	[math::NaN(), math::NaN()],
	[math::Inf(1), math::Inf(1)],
	[2251799813685249.5, 2251799813685250], // 1 bit fraction
	[2251799813685250.5, 2251799813685251],
	[4503599627370495.5, 4503599627370496], // 1 bit fraction, rounding to 0 bit fraction
	[4503599627370497, 4503599627370497],   // large integer
]
static vfroundEvenSC: [][2]f64 = [
	[0, 0],
	[1.390671161567e-309, 0],               // denormal
	[0.49999999999999994, 0],               // 0.5-epsilon
	[0.5, 0],
	[0.5000000000000001, 1],                // 0.5+epsilon
	[-1.5, -2],
	[-2.5, -2],
	[math::NaN(), math::NaN()],
	[math::Inf(1), math::Inf(1)],
	[2251799813685249.5, 2251799813685250], // 1 bit fraction
	[2251799813685250.5, 2251799813685250],
	[4503599627370495.5, 4503599627370496], // 1 bit fraction, rounding to 0 bit fraction
	[4503599627370497, 4503599627370497],   // large integer
]

static vfsignbitSC = [
	math::Inf(-1),
	math::Copysign(0, -1),
	0,
	math::Inf(1),
	math::NaN(),
]
static signbitSC = [
	true,
	true,
	false,
	false,
	false,
]

static vfsinSC = [
	math::Inf(-1),
	math::Copysign(0, -1),
	0,
	math::Inf(1),
	math::NaN(),
]
static sinSC = [
	math::NaN(),
	math::Copysign(0, -1),
	0,
	math::NaN(),
	math::NaN(),
]

static vfsinhSC = [
	math::Inf(-1),
	math::Copysign(0, -1),
	0,
	math::Inf(1),
	math::NaN(),
]
static sinhSC = [
	math::Inf(-1),
	math::Copysign(0, -1),
	0,
	math::Inf(1),
	math::NaN(),
]

static vfsqrtSC = [
	math::Inf(-1),
	-math::Pi,
	math::Copysign(0, -1),
	0,
	math::Inf(1),
	math::NaN(),
	math::F64frombits(2),  // subnormal; see https://golang.org/issue/13013
]
static sqrtSC = [
	math::NaN(),
	math::NaN(),
	math::Copysign(0, -1),
	0,
	math::Inf(1),
	math::NaN(),
	3.1434555694052576e-162,
]

static vftanhSC = [
	math::Inf(-1),
	math::Copysign(0, -1),
	0,
	math::Inf(1),
	math::NaN(),
]
static tanhSC: []f64 = [
	-1,
	math::Copysign(0, -1),
	0,
	1,
	math::NaN(),
]

static vfy0SC = [
	math::Inf(-1),
	0,
	math::Inf(1),
	math::NaN(),
	-1,
]
static y0SC = [
	math::NaN(),
	math::Inf(-1),
	0,
	math::NaN(),
	math::NaN(),
]
static y1SC = [
	math::NaN(),
	math::Inf(-1),
	0,
	math::NaN(),
	math::NaN(),
]
static y2SC = [
	math::NaN(),
	math::Inf(-1),
	0,
	math::NaN(),
	math::NaN(),
]
static yM3SC = [
	math::NaN(),
	math::Inf(1),
	0,
	math::NaN(),
	math::NaN(),
]

// arguments and expected results for boundary cases
const SmallestNormalF64 = 2.2250738585072014e-308 // 2**-1022
const LargestSubnormalF64 = SmallestNormalF64 - f64.SmallestNonZero

static vffrexpBC = [
	SmallestNormalF64,
	LargestSubnormalF64,
	f64.SmallestNonZero,
	f64.Max,
	-SmallestNormalF64,
	-LargestSubnormalF64,
	-f64.SmallestNonZero,
	-f64.Max,
]
static frexpBC: []fi = [
	{0.5, -1021},
	{0.99999999999999978, -1022},
	{0.5, -1073},
	{0.99999999999999989, 1024},
	{-0.5, -1021},
	{-0.99999999999999978, -1022},
	{-0.5, -1073},
	{-0.99999999999999989, 1024},
]

static vfldexpBC: []fi = [
	{SmallestNormalF64, -52},
	{LargestSubnormalF64, -51},
	{f64.SmallestNonZero, 1074},
	{f64.Max, -(1023 + 1074)},
	{1, -1075},
	{-1, -1075},
	{1, 1024},
	{-1, 1024},
	{1.0000000000000002, -1075},
	{1, -1075},
]
static ldexpBC = [
	f64.SmallestNonZero,
	1e-323,                // 2**-1073
	1,
	1e-323,                // 2**-1073
	0,
	math::Copysign(0, -1),
	math::Inf(1),
	math::Inf(-1),
	f64.SmallestNonZero,
	0,
]

static logbBC: []f64 = [
	-1022,
	-1023,
	-1074,
	1023,
	-1022,
	-1023,
	-1074,
	1023,
]

struct fmaTest {
	x:    f64
	y:    f64
	z:    f64
	want: f64
}

// Test cases were generated with Berkeley TestFloat-3e/testfloat_gen.
// http://www.jhauser.us/arithmetic/TestFloat.html.
// The default rounding mode is selected (nearest/even), and exception flags are ignored.
static fmaC: []fmaTest = [
	// Large exponent spread
	{-3.999999999999087, -1.1123914289620494e-16, -7.999877929687506, -7.999877929687505},
	{-262112.0000004768, -0.06251525855623184, 1.1102230248837136e-16, 16385.99945072085},
	{-6.462348523533467e-27, -2.3763644720331857e-211, 4.000000000931324, 4.000000000931324},

	// Effective addition
	{-2.0000000037252907, 6.7904383376e-313, -3.3951933161e-313, -1.697607001654e-312},
	{-0.12499999999999999, 512.007568359375, -1.4193627164960366e-16, -64.00094604492188},
	{-2.7550648847397148e-39, -3.4028301595800694e+38, 0.9960937495343386, 1.9335955376735676},
	{5.723369164769208e+24, 3.8149300927159385e-06, 1.84489958778182e+19, 4.028324913621874e+19},
	{-0.4843749999990904, -3.6893487872543293e+19, 9.223653786709391e+18, 2.7093936974938993e+19},
	{-3.8146972665201165e-06, 4.2949672959999385e+09, -2.2204460489938386e-16, -16384.000003844263},
	{6.98156394130982e-309, -1.1072962560000002e+09, -4.4414561548793455e-308, -7.73065965765153e-300},

	// Effective subtraction
	{5e-324, 4.5, -2e-323, 0},
	{5e-324, 7, -3.5e-323, 0},
	{5e-324, 0.5000000000000001, -5e-324, math::Copysign(0, -1)},
	{-2.1240680525e-314, -1.233647078189316e+308, -0.25781249999954525, -0.25780987964919844},
	{8.579992955364441e-308, 0.6037391876780558, -4.4501307410480706e-308, 7.29947236107098e-309},
	{-4.450143471986689e-308, -0.9960937499927239, -4.450419332475649e-308, -1.7659233458788e-310},
	{1.4932076393918112, -2.2248022430460833e-308, 4.449875571054211e-308, 1.127783865601762e-308},

	// Overflow
	{-2.288020632214759e+38, -8.98846570988901e+307, 1.7696041796300924e+308, math::Inf(0)},
	{1.4888652783208255e+308, -9.007199254742012e+15, -6.807282911929205e+38, math::Inf(-1)},
	{9.142703268902826e+192, -1.3504889569802838e+296, -1.9082200803806996e-89, math::Inf(-1)},

	// Finite x and y, but non-finite z.
	{31.99218749627471, -1.7976930544991702e+308, math::Inf(0), math::Inf(0)},
	{-1.7976931281784667e+308, -2.0009765625002265, math::Inf(-1), math::Inf(-1)},

	// Special
	{0, 0, 0, 0},
	{math::Copysign(0, -1), 0, 0, 0},
	{0, 0, math::Copysign(0, -1), 0},
	{math::Copysign(0, -1), 0, math::Copysign(0, -1), math::Copysign(0, -1)},
	{-1.1754226043408471e-38, math::NaN(), math::Inf(0), math::NaN()},
	{0, 0, 2.22507385643494e-308, 2.22507385643494e-308},
	{-8.65697792e+09, math::NaN(), -7.516192799999999e+09, math::NaN()},
	{-0.00012207403779029757, 3.221225471996093e+09, math::NaN(), math::NaN()},
	{math::Inf(-1), 0.1252441407414153, -1.387184532981584e-76, math::Inf(-1)},
	{math::Inf(0), 1.525878907671432e-05, -9.214364835452549e+18, math::Inf(0)},

	// Random
	{0.1777916152213626, -32.000015266239636, -2.2204459148334633e-16, -5.689334401293007},
	{-2.0816681711722314e-16, -0.4997558592585846, -0.9465627129124969, -0.9465627129124968},
	{-1.9999997615814211, 1.8518819259933516e+19, 16.874999999999996, -3.703763410463646e+19},
	{-0.12499994039717421, 32767.99999976135, -2.0752587082923246e+19, -2.075258708292325e+19},
	{7.705600568510257e-34, -1.801432979000528e+16, -0.17224197722973714, -0.17224197722973716},
	{3.8988133103758913e-308, -0.9848632812499999, 3.893879244098556e-308, 5.40811742605814e-310},
	{-0.012651981190687427, 6.911985574912436e+38, 6.669240527007144e+18, -8.745031148409496e+36},
	{4.612811918325842e+18, 1.4901161193847641e-08, 2.6077032311277997e-08, 6.873625395187494e+10},
	{-9.094947033611148e-13, 4.450691014249257e-308, 2.086006742350485e-308, 2.086006742346437e-308},
	{-7.751454006381804e-05, 5.588653777189071e-308, -2.2207280111272877e-308, -2.2211612130544025e-308},

	// Issue #61130
	{-1, 1, 1, 0},
	{1, 1, -1, 0},
]

static sqrt32: []f32 = [
	0,
	f32(math::Copysign(0, -1)),
	f32(math::NaN()),
	f32(math::Inf(1)),
	f32(math::Inf(-1)),
	1,
	2,
	-2,
	4.9790119248836735e+00,
	7.7388724745781045e+00,
	-2.7688005719200159e-01,
	-5.0106036182710749e+00,
]

fn tolerance(a: f64, b: f64, mut e: f64): bool {
	// Multiplying by e here can underflow denormal values to zero.
	// Check a==b so that at least if a and b are small and identical
	// we say they match.
	if a == b {
		ret true
	}
	mut d := a - b
	if d < 0 {
		d = -d
	}

	// note: b is correct (expected) value, a is actual value.
	// make error tolerance a fraction of b, not a.
	if b != 0 {
		e = e * b
		if e < 0 {
			e = -e
		}
	}
	ret d < e
}
fn close(a: f64, b: f64): bool { ret tolerance(a, b, 1e-14) }
fn veryclose(a: f64, b: f64): bool { ret tolerance(a, b, 4e-16) }
fn soclose(a: f64, b: f64, e: f64): bool { ret tolerance(a, b, e) }
fn alike(a: f64, b: f64): bool {
	match {
	| math::IsNaN(a) && math::IsNaN(b):
		ret true
	| a == b:
		ret math::Signbit(a) == math::Signbit(b)
	}
	ret false
}

#test
fn testNaN(t: &testing::T) {
	nan := math::NaN()
	if nan == nan {
		t.Errorf("NaN() returns {}, expected NaN", nan)
	}
	nan32 := f32(nan)
	if nan32 == nan32 {
		t.Errorf("f32(NaN()) is {}, expected NaN", nan)
	}
}

#test
fn testAcos(t: &testing::T) {
	mut i := 0
	for i < len(vf); i++ {
		a := vf[i] / 10
		f := math::Acos(a)
		if !close(acos[i], f) {
			t.Errorf("Acos({}) = {}, want {}", a, f, acos[i])
		}
	}
	i = 0
	for i < len(vfacosSC); i++ {
		f := math::Acos(vfacosSC[i])
		if !alike(acosSC[i], f) {
			t.Errorf("Acos({}) = {}, want {}", vfacosSC[i], f, acosSC[i])
		}
	}
}

#test
fn testAcosh(t: &testing::T) {
	mut i := 0
	for i < len(vf); i++ {
		a := 1 + math::Abs(vf[i])
		f := math::Acosh(a)
		if !veryclose(acosh[i], f) {
			t.Errorf("Acosh({}) = {}, want {}", a, f, acosh[i])
		}
	}
	i = 0
	for i < len(vfacoshSC); i++ {
		f := math::Acosh(vfacoshSC[i])
		if !alike(acoshSC[i], f) {
			t.Errorf("Acosh({}) = {}, want {}", vfacoshSC[i], f, acoshSC[i])
		}
	}
}

#test
fn testAsin(t: &testing::T) {
	mut i := 0
	for i < len(vf); i++ {
		a := vf[i] / 10
		f := math::Asin(a)
		if !veryclose(asin[i], f) {
			t.Errorf("Asin({}) = {}, want {}", a, f, asin[i])
		}
	}
	i = 0
	for i < len(vfasinSC); i++ {
		f := math::Asin(vfasinSC[i])
		if !alike(asinSC[i], f) {
			t.Errorf("Asin({}) = {}, want {}", vfasinSC[i], f, asinSC[i])
		}
	}
}

#test
fn testAsinh(t: &testing::T) {
	mut i := 0
	for i < len(vf); i++ {
		f := math::Asinh(vf[i])
		if !veryclose(asinh[i], f) {
			t.Errorf("Asinh({}) = {}, want {}", vf[i], f, asinh[i])
		}
	}
	i = 0
	for i < len(vfasinhSC); i++ {
		f := math::Asinh(vfasinhSC[i])
		if !alike(asinhSC[i], f) {
			t.Errorf("Asinh({}) = {}, want {}", vfasinhSC[i], f, asinhSC[i])
		}
	}
}

#test
fn testAtan(t: &testing::T) {
	mut i := 0
	for i < len(vf); i++ {
		f := math::Atan(vf[i])
		if !veryclose(atan[i], f) {
			t.Errorf("Atan({}) = {}, want {}", vf[i], f, atan[i])
		}
	}
	i = 0
	for i < len(vfatanSC); i++ {
		f := math::Atan(vfatanSC[i])
		if !alike(atanSC[i], f) {
			t.Errorf("Atan({}) = {}, want {}", vfatanSC[i], f, atanSC[i])
		}
	}
}

#test
fn testAtan2(t: &testing::T) {
	mut i := 0
	for i < len(vf); i++ {
		f := math::Atan2(10, vf[i])
		if !veryclose(atan2[i], f) {
			t.Errorf("Atan2(10, {}) = {}, want {}", vf[i], f, atan2[i])
		}
	}
	i = 0
	for i < len(vfatan2SC); i++ {
		f := math::Atan2(vfatan2SC[i][0], vfatan2SC[i][1])
		if !alike(atan2SC[i], f) {
			t.Errorf("Atan2({}, {}) = {}, want {}", vfatan2SC[i][0], vfatan2SC[i][1], f, atan2SC[i])
		}
	}
}

#test
fn testCbrt(t: &testing::T) {
	mut i := 0
	for i < len(vf); i++ {
		f := math::Cbrt(vf[i])
		if !veryclose(cbrt[i], f) {
			t.Errorf("Cbrt({}) = {}, want {}", vf[i], f, cbrt[i])
		}
	}
	i = 0
	for i < len(vfcbrtSC); i++ {
		f := math::Cbrt(vfcbrtSC[i])
		if !alike(cbrtSC[i], f) {
			t.Errorf("Cbrt({}) = {}, want {}", vfcbrtSC[i], f, cbrtSC[i])
		}
	}
}

#test
fn testCeil(t: &testing::T) {
	mut i := 0
	for i < len(vf); i++ {
		f := math::Ceil(vf[i])
		if !alike(ceil[i], f) {
			t.Errorf("Ceil({}) = {}, want {}", vf[i], f, ceil[i])
		}
	}
	i = 0
	for i < len(vfceilSC); i++ {
		f := math::Ceil(vfceilSC[i])
		if !alike(ceilSC[i], f) {
			t.Errorf("Ceil({}) = {}, want {}", vfceilSC[i], f, ceilSC[i])
		}
	}
}

#test
fn testCopysign(t: &testing::T) {
	mut i := 0
	for i < len(vf); i++ {
		f := math::Copysign(vf[i], -1)
		if copysign[i] != f {
			t.Errorf("Copysign({}, -1) = {}, want {}", vf[i], f, copysign[i])
		}
	}
	i = 0
	for i < len(vf); i++ {
		f := math::Copysign(vf[i], 1)
		if -copysign[i] != f {
			t.Errorf("Copysign({}, 1) = {}, want {}", vf[i], f, -copysign[i])
		}
	}
	i = 0
	for i < len(vfcopysignSC); i++ {
		f := math::Copysign(vfcopysignSC[i], -1)
		if !alike(copysignSC[i], f) {
			t.Errorf("Copysign({}, -1) = {}, want {}", vfcopysignSC[i], f, copysignSC[i])
		}
	}
}

#test
fn testCos(t: &testing::T) {
	mut i := 0
	for i < len(vf); i++ {
		f := math::Cos(vf[i])
		if !veryclose(cos[i], f) {
			t.Errorf("Cos({}) = {}, want {}", vf[i], f, cos[i])
		}
	}
	i = 0
	for i < len(vfcosSC); i++ {
		f := math::Cos(vfcosSC[i])
		if !alike(cosSC[i], f) {
			t.Errorf("Cos({}) = {}, want {}", vfcosSC[i], f, cosSC[i])
		}
	}
}

#test
fn testCosh(t: &testing::T) {
	mut i := 0
	for i < len(vf); i++ {
		f := math::Cosh(vf[i])
		if !close(cosh[i], f) {
			t.Errorf("Cosh({}) = {}, want {}", vf[i], f, cosh[i])
		}
	}
	i = 0
	for i < len(vfcoshSC); i++ {
		f := math::Cosh(vfcoshSC[i])
		if !alike(coshSC[i], f) {
			t.Errorf("Cosh({}) = {}, want {}", vfcoshSC[i], f, coshSC[i])
		}
	}
}

#test
fn testErf(t: &testing::T) {
	mut i := 0
	for i < len(vf); i++ {
		a := vf[i] / 10
		f := math::Erf(a)
		if !veryclose(erf[i], f) {
			t.Errorf("Erf({}) = {}, want {}", a, f, erf[i])
		}
	}
	i = 0
	for i < len(vferfSC); i++ {
		f := math::Erf(vferfSC[i])
		if !alike(erfSC[i], f) {
			t.Errorf("Erf({}) = {}, want {}", vferfSC[i], f, erfSC[i])
		}
	}
}

#test
fn testErfc(t: &testing::T) {
	mut i := 0
	for i < len(vf); i++ {
		a := vf[i] / 10
		f := math::Erfc(a)
		if !veryclose(erfc[i], f) {
			t.Errorf("Erfc({}) = {}, want {}", a, f, erfc[i])
		}
	}
	i = 0
	for i < len(vferfcSC); i++ {
		f := math::Erfc(vferfcSC[i])
		if !alike(erfcSC[i], f) {
			t.Errorf("Erfc({}) = {}, want {}", vferfcSC[i], f, erfcSC[i])
		}
	}
}

#test
fn testErfinv(t: &testing::T) {
	mut i := 0
	for i < len(vf); i++ {
		a := vf[i] / 10
		f := math::Erfinv(a)
		if !veryclose(erfinv[i], f) {
			t.Errorf("Erfinv({}) = {}, want {}", a, f, erfinv[i])
		}
	}
	i = 0
	for i < len(vferfinvSC); i++ {
		f := math::Erfinv(vferfinvSC[i])
		if !alike(erfinvSC[i], f) {
			t.Errorf("Erfinv({}) = {}, want {}", vferfinvSC[i], f, erfinvSC[i])
		}
	}
	mut x := -0.9
	for x <= 0.90; x += 1e-2 {
		f := math::Erf(math::Erfinv(x))
		if !close(x, f) {
			t.Errorf("Erf(Erfinv({})) = {}, want {}", x, f, x)
		}
	}
	x = -0.9
	for x <= 0.90; x += 1e-2 {
		f := math::Erfinv(math::Erf(x))
		if !close(x, f) {
			t.Errorf("Erfinv(Erf({})) = {}, want {}", x, f, x)
		}
	}
}

#test
fn testErfcinv(t: &testing::T) {
	mut i := 0
	for i < len(vf); i++ {
		a := 1.0 - (vf[i] / 10)
		f := math::Erfcinv(a)
		if !veryclose(erfinv[i], f) {
			t.Errorf("Erfcinv({}) = {}, want {}", a, f, erfinv[i])
		}
	}
	i = 0
	for i < len(vferfcinvSC); i++ {
		f := math::Erfcinv(vferfcinvSC[i])
		if !alike(erfcinvSC[i], f) {
			t.Errorf("Erfcinv({}) = {}, want {}", vferfcinvSC[i], f, erfcinvSC[i])
		}
	}
	mut x := 0.1
	for x <= 1.9; x += 1e-2 {
		f := math::Erfc(math::Erfcinv(x))
		if !close(x, f) {
			t.Errorf("Erfc(Erfcinv({})) = {}, want {}", x, f, x)
		}
	}
	x = 0.1
	for x <= 1.9; x += 1e-2 {
		f := math::Erfcinv(math::Erfc(x))
		if !close(x, f) {
			t.Errorf("Erfcinv(Erfc({})) = {}, want {}", x, f, x)
		}
	}
}

#test
fn testExp(t: &testing::T) {
	_testExp(t, math::Exp, "Exp")
}

fn _testExp(t: &testing::T, Exp: fn(f64): f64, name: str) {
	mut i := 0
	for i < len(vf); i++ {
		f := Exp(vf[i])
		if !veryclose(exp[i], f) {
			t.Errorf("{}({}) = {}, want {}", name, vf[i], f, exp[i])
		}
	}
	i = 0
	for i < len(vfexpSC); i++ {
		f := Exp(vfexpSC[i])
		if !alike(expSC[i], f) {
			t.Errorf("{}({}) = {}, want {}", name, vfexpSC[i], f, expSC[i])
		}
	}
}

#test
fn testExpm1(t: &testing::T) {
	mut i := 0
	for i < len(vf); i++ {
		a := vf[i] / 100
		f := math::Expm1(a)
		if !veryclose(expm1[i], f) {
			t.Errorf("Expm1({}) = {}, want {}", a, f, expm1[i])
		}
	}
	i = 0
	for i < len(vf); i++ {
		a := vf[i] * 10
		f := math::Expm1(a)
		if !close(expm1Large[i], f) {
			t.Errorf("Expm1({}) = {}, want {}", a, f, expm1Large[i])
		}
	}
	i = 0
	for i < len(vfexpm1SC); i++ {
		f := math::Expm1(vfexpm1SC[i])
		if !alike(expm1SC[i], f) {
			t.Errorf("Expm1({}) = {}, want {}", vfexpm1SC[i], f, expm1SC[i])
		}
	}
}

#test
fn testExp2(t: &testing::T) {
	_testExp2(t, math::Exp2, "Exp2")
}

fn _testExp2(t: &testing::T, Exp2: fn(f64): f64, name: str) {
	mut i := 0
	for i < len(vf); i++ {
		f := Exp2(vf[i])
		if !close(exp2[i], f) {
			t.Errorf("{}({}) = {}, want {}", name, vf[i], f, exp2[i])
		}
	}
	i = 0
	for i < len(vfexp2SC); i++ {
		f := Exp2(vfexp2SC[i])
		if !alike(exp2SC[i], f) {
			t.Errorf("{}({}) = {}, want {}", name, vfexp2SC[i], f, exp2SC[i])
		}
	}
	mut n := -1074
	for n < 1024; n++ {
		f := Exp2(f64(n))
		vf := math::Ldexp(1, n)
		if f != vf {
			t.Errorf("{}({}) = {}, want {}", name, n, f, vf)
		}
	}
}

#test
fn testAbs(t: &testing::T) {
	mut i := 0
	for i < len(vf); i++ {
		f := math::Abs(vf[i])
		if fabs[i] != f {
			t.Errorf("Abs({}) = {}, want {}", vf[i], f, fabs[i])
		}
	}
	i = 0
	for i < len(vffabsSC); i++ {
		f := math::Abs(vffabsSC[i])
		if !alike(fabsSC[i], f) {
			t.Errorf("Abs({}) = {}, want {}", vffabsSC[i], f, fabsSC[i])
		}
	}
}

#test
fn testDim(t: &testing::T) {
	mut i := 0
	for i < len(vf); i++ {
		f := math::Dim(vf[i], 0)
		if fdim[i] != f {
			t.Errorf("Dim({}, {}) = {}, want {}", vf[i], 0.0, f, fdim[i])
		}
	}
	i = 0
	for i < len(vffdimSC); i++ {
		f := math::Dim(vffdimSC[i][0], vffdimSC[i][1])
		if !alike(fdimSC[i], f) {
			t.Errorf("Dim({}, {}) = {}, want {}", vffdimSC[i][0], vffdimSC[i][1], f, fdimSC[i])
		}
	}
	i = 0
	for i < len(vffdim2SC); i++ {
		f := math::Dim(vffdim2SC[i][0], vffdim2SC[i][1])
		if !alike(fdimSC[i], f) {
			t.Errorf("Dim({}, {}) = {}, want {}", vffdim2SC[i][0], vffdim2SC[i][1], f, fdimSC[i])
		}
	}
}

#test
fn testFloor(t: &testing::T) {
	mut i := 0
	for i < len(vf); i++ {
		f := math::Floor(vf[i])
		if !alike(floor[i], f) {
			t.Errorf("Floor({}) = {}, want {}", vf[i], f, floor[i])
		}
	}
	i = 0
	for i < len(vfceilSC); i++ {
		f := math::Floor(vfceilSC[i])
		if !alike(floorSC[i], f) {
			t.Errorf("Floor({}) = {}, want {}", vfceilSC[i], f, floorSC[i])
		}
	}
}

#test
fn testMax(t: &testing::T) {
	mut i := 0
	for i < len(vf); i++ {
		f := math::Max(vf[i], ceil[i])
		if ceil[i] != f {
			t.Errorf("Max({}, {}) = {}, want {}", vf[i], ceil[i], f, ceil[i])
		}
	}
	i = 0
	for i < len(vffdimSC); i++ {
		f := math::Max(vffdimSC[i][0], vffdimSC[i][1])
		if !alike(fmaxSC[i], f) {
			t.Errorf("Max({}, {}) = {}, want {}", vffdimSC[i][0], vffdimSC[i][1], f, fmaxSC[i])
		}
	}
	i = 0
	for i < len(vffdim2SC); i++ {
		f := math::Max(vffdim2SC[i][0], vffdim2SC[i][1])
		if !alike(fmaxSC[i], f) {
			t.Errorf("Max({}, {}) = {}, want {}", vffdim2SC[i][0], vffdim2SC[i][1], f, fmaxSC[i])
		}
	}
}

#test
fn testMin(t: &testing::T) {
	mut i := 0
	for i < len(vf); i++ {
		f := math::Min(vf[i], floor[i])
		if floor[i] != f {
			t.Errorf("Min({}, {}) = {}, want {}", vf[i], floor[i], f, floor[i])
		}
	}
	i = 0
	for i < len(vffdimSC); i++ {
		f := math::Min(vffdimSC[i][0], vffdimSC[i][1])
		if !alike(fminSC[i], f) {
			t.Errorf("Min({}, {}) = {}, want {}", vffdimSC[i][0], vffdimSC[i][1], f, fminSC[i])
		}
	}
	i = 0
	for i < len(vffdim2SC); i++ {
		f := math::Min(vffdim2SC[i][0], vffdim2SC[i][1])
		if !alike(fminSC[i], f) {
			t.Errorf("Min({}, {}) = {}, want {}", vffdim2SC[i][0], vffdim2SC[i][1], f, fminSC[i])
		}
	}
}

#test
fn testMod(t: &testing::T) {
	mut i := 0
	for i < len(vf); i++ {
		f := math::Mod(10, vf[i])
		if fmod[i] != f {
			t.Errorf("Mod(10, {}) = {}, want {}", vf[i], f, fmod[i])
		}
	}
	i = 0
	for i < len(vffmodSC); i++ {
		f := math::Mod(vffmodSC[i][0], vffmodSC[i][1])
		if !alike(fmodSC[i], f) {
			t.Errorf("Mod({}, {}) = {}, want {}", vffmodSC[i][0], vffmodSC[i][1], f, fmodSC[i])
		}
	}
	// verify precision of result for extreme inputs
	f := math::Mod(5.9790119248836734e+200, 1.1258465975523544)
	if 0.6447968302508578 != f {
		t.Errorf("Remainder(5.9790119248836734e+200, 1.1258465975523544) = {}, want 0.6447968302508578", f)
	}
}

#test
fn testFrexp(t: &testing::T) {
	mut i := 0
	for i < len(vf); i++ {
		f, j := math::Frexp(vf[i])
		if !veryclose(frexp[i].f, f) || frexp[i].i != j {
			t.Errorf("Frexp({}) = {}, {}, want {}, {}", vf[i], f, j, frexp[i].f, frexp[i].i)
		}
	}
	i = 0
	for i < len(vffrexpSC); i++ {
		f, j := math::Frexp(vffrexpSC[i])
		if !alike(frexpSC[i].f, f) || frexpSC[i].i != j {
			t.Errorf("Frexp({}) = {}, {}, want {}, {}", vffrexpSC[i], f, j, frexpSC[i].f, frexpSC[i].i)
		}
	}
	i = 0
	for i < len(vffrexpBC); i++ {
		f, j := math::Frexp(vffrexpBC[i])
		if !alike(frexpBC[i].f, f) || frexpBC[i].i != j {
			t.Errorf("3Frexp({}) = {}, {}, want {}, {}", vffrexpBC[i], f, j, frexpBC[i].f, frexpBC[i].i)
		}
	}
}

#test
fn testGamma(t: &testing::T) {
	mut i := 0
	for i < len(vf); i++ {
		f := math::Gamma(vf[i])
		if !close(gamma[i], f) {
			t.Errorf("Gamma({}) = {}, want {}", vf[i], f, gamma[i])
		}
	}
	for _, g in vfgamma {
		f := math::Gamma(g[0])
		let mut ok: bool
		if math::IsNaN(g[1]) || math::IsInf(g[1], 0) || g[1] == 0 || f == 0 {
			ok = alike(g[1], f)
		} else if g[0] > -50 && g[0] <= 171 {
			ok = veryclose(g[1], f)
		} else {
			ok = close(g[1], f)
		}
		if !ok {
			t.Errorf("Gamma({}) = {}, want {}", g[0], f, g[1])
		}
	}
}

#test
fn testHypot(t: &testing::T) {
	mut i := 0
	for i < len(vf); i++ {
		a := math::Abs(1e200 * tanh[i] * math::Sqrt(2))
		f := math::Hypot(1e200*tanh[i], 1e200*tanh[i])
		if !veryclose(a, f) {
			t.Errorf("Hypot({}, {}) = {}, want {}", 1e200*tanh[i], 1e200*tanh[i], f, a)
		}
	}
	i = 0
	for i < len(vfhypotSC); i++ {
		f := math::Hypot(vfhypotSC[i][0], vfhypotSC[i][1])
		if !alike(hypotSC[i], f) {
			t.Errorf("Hypot({}, {}) = {}, want {}", vfhypotSC[i][0], vfhypotSC[i][1], f, hypotSC[i])
		}
	}
}

#test
fn testIlogb(t: &testing::T) {
	mut i := 0
	for i < len(vf); i++ {
		a := frexp[i].i - 1 // adjust because fr in the interval [, 1)
		e := math::Ilogb(vf[i])
		if a != e {
			t.Errorf("Ilogb({}) = {}, want {}", vf[i], e, a)
		}
	}
	i = 0
	for i < len(vflogbSC); i++ {
		e := math::Ilogb(vflogbSC[i])
		if ilogbSC[i] != e {
			t.Errorf("Ilogb({}) = {}, want {}", vflogbSC[i], e, ilogbSC[i])
		}
	}
	i = 0
	for i < len(vffrexpBC); i++ {
		e := math::Ilogb(vffrexpBC[i])
		if int(logbBC[i]) != e {
			t.Errorf("Ilogb({}) = {}, want {}", vffrexpBC[i], e, int(logbBC[i]))
		}
	}
}

#test
fn testJ0(t: &testing::T) {
	mut i := 0
	for i < len(vf); i++ {
		f := math::J0(vf[i])
		if !soclose(j0[i], f, 4e-14) {
			t.Errorf("J0({}) = {}, want {}", vf[i], f, j0[i])
		}
	}
	i = 0
	for i < len(vfj0SC); i++ {
		f := math::J0(vfj0SC[i])
		if !alike(j0SC[i], f) {
			t.Errorf("J0({}) = {}, want {}", vfj0SC[i], f, j0SC[i])
		}
	}
}

#test
fn testJ1(t: &testing::T) {
	mut i := 0
	for i < len(vf); i++ {
		f := math::J1(vf[i])
		if !close(j1[i], f) {
			t.Errorf("J1({}) = {}, want {}", vf[i], f, j1[i])
		}
	}
	i = 0
	for i < len(vfj0SC); i++ {
		f := math::J1(vfj0SC[i])
		if !alike(j1SC[i], f) {
			t.Errorf("J1({}) = {}, want {}", vfj0SC[i], f, j1SC[i])
		}
	}
}

#test
fn testJn(t: &testing::T) {
	mut i := 0
	for i < len(vf); i++ {
		mut f := math::Jn(2, vf[i])
		if !close(j2[i], f) {
			t.Errorf("Jn(2, {}) = {}, want {}", vf[i], f, j2[i])
		}
		f = math::Jn(-3, vf[i])
		if !close(jM3[i], f) {
			t.Errorf("Jn(-3, {}) = {}, want {}", vf[i], f, jM3[i])
		}
	}
	i = 0
	for i < len(vfj0SC); i++ {
		mut f := math::Jn(2, vfj0SC[i])
		if !alike(j2SC[i], f) {
			t.Errorf("Jn(2, {}) = {}, want {}", vfj0SC[i], f, j2SC[i])
		}
		f = math::Jn(-3, vfj0SC[i])
		if !alike(jM3SC[i], f) {
			t.Errorf("Jn(-3, {}) = {}, want {}", vfj0SC[i], f, jM3SC[i])
		}
	}
}

#test
fn testLdexp(t: &testing::T) {
	mut i := 0
	for i < len(vf); i++ {
		f := math::Ldexp(frexp[i].f, frexp[i].i)
		if !veryclose(vf[i], f) {
			t.Errorf("Ldexp({}, {}) = {}, want {}", frexp[i].f, frexp[i].i, f, vf[i])
		}
	}
	i = 0
	for i < len(vffrexpSC); i++ {
		f := math::Ldexp(frexpSC[i].f, frexpSC[i].i)
		if !alike(vffrexpSC[i], f) {
			t.Errorf("Ldexp({}, {}) = {}, want {}", frexpSC[i].f, frexpSC[i].i, f, vffrexpSC[i])
		}
	}
	i = 0
	for i < len(vfldexpSC); i++ {
		f := math::Ldexp(vfldexpSC[i].f, vfldexpSC[i].i)
		if !alike(ldexpSC[i], f) {
			t.Errorf("Ldexp({}, {}) = {}, want {}", vfldexpSC[i].f, vfldexpSC[i].i, f, ldexpSC[i])
		}
	}
	i = 0
	for i < len(vffrexpBC); i++ {
		f := math::Ldexp(frexpBC[i].f, frexpBC[i].i)
		if !alike(vffrexpBC[i], f) {
			t.Errorf("Ldexp({}, {}) = {}, want {}", frexpBC[i].f, frexpBC[i].i, f, vffrexpBC[i])
		}
	}
	i = 0
	for i < len(vfldexpBC); i++ {
		f := math::Ldexp(vfldexpBC[i].f, vfldexpBC[i].i)
		if !alike(ldexpBC[i], f) {
			t.Errorf("Ldexp({}, {}) = {}, want {}", vfldexpBC[i].f, vfldexpBC[i].i, f, ldexpBC[i])
		}
	}
}

#test
fn testLgamma(t: &testing::T) {
	mut i := 0
	for i < len(vf); i++ {
		f, s := math::Lgamma(vf[i])
		if !close(lgamma[i].f, f) || lgamma[i].i != s {
			t.Errorf("Lgamma({}) = {}, {}, want {}, {}", vf[i], f, s, lgamma[i].f, lgamma[i].i)
		}
	}
	i = 0
	for i < len(vflgammaSC); i++ {
		f, s := math::Lgamma(vflgammaSC[i])
		if !alike(lgammaSC[i].f, f) || lgammaSC[i].i != s {
			t.Errorf("Lgamma({}) = {}, {}, want {}, {}", vflgammaSC[i], f, s, lgammaSC[i].f, lgammaSC[i].i)
		}
	}
}

#test
fn testLog(t: &testing::T) {
	mut i := 0
	for i < len(vf); i++ {
		a := math::Abs(vf[i])
		f := math::Log(a)
		if log[i] != f {
			t.Errorf("Log({}) = {}, want {}", a, f, log[i])
		}
	}
	{
		f := math::Log(10)
		if f != math::Ln10 {
			t.Errorf("Log({}) = {}, want {}", 10.0, f, math::Ln10)
		}
	}
	i = 0
	for i < len(vflogSC); i++ {
		f := math::Log(vflogSC[i])
		if !alike(logSC[i], f) {
			t.Errorf("Log({}) = {}, want {}", vflogSC[i], f, logSC[i])
		}
	}
}

#test
fn testLogb(t: &testing::T) {
	mut i := 0
	for i < len(vf); i++ {
		f := math::Logb(vf[i])
		if logb[i] != f {
			t.Errorf("Logb({}) = {}, want {}", vf[i], f, logb[i])
		}
	}
	i = 0
	for i < len(vflogbSC); i++ {
		f := math::Logb(vflogbSC[i])
		if !alike(logbSC[i], f) {
			t.Errorf("Logb({}) = {}, want {}", vflogbSC[i], f, logbSC[i])
		}
	}
	i = 0
	for i < len(vffrexpBC); i++ {
		f := math::Logb(vffrexpBC[i])
		if !alike(logbBC[i], f) {
			t.Errorf("Logb({}) = {}, want {}", vffrexpBC[i], f, logbBC[i])
		}
	}
}

#test
fn testLog10(t: &testing::T) {
	mut i := 0
	for i < len(vf); i++ {
		a := math::Abs(vf[i])
		f := math::Log10(a)
		if !veryclose(log10[i], f) {
			t.Errorf("Log10({}) = {}, want {}", a, f, log10[i])
		}
	}
	{
		f := math::Log10(math::E)
		if f != math::Log10E {
			t.Errorf("Log10({}) = {}, want {}", math::E, f, math::Log10E)
		}
	}
	i = 0
	for i < len(vflogSC); i++ {
		f := math::Log10(vflogSC[i])
		if !alike(logSC[i], f) {
			t.Errorf("Log10({}) = {}, want {}", vflogSC[i], f, logSC[i])
		}
	}
}

#test
fn testLog1p(t: &testing::T) {
	mut i := 0
	for i < len(vf); i++ {
		a := vf[i] / 100
		f := math::Log1p(a)
		if !veryclose(log1p[i], f) {
			t.Errorf("Log1p({}) = {}, want {}", a, f, log1p[i])
		}
	}
	a := 9.0
	{
		f := math::Log1p(a)
		if f != math::Ln10 {
			t.Errorf("Log1p({}) = {}, want {}", a, f, math::Ln10)
		}
	}
	i = 0
	for i < len(vflogSC); i++ {
		f := math::Log1p(vflog1pSC[i])
		if !alike(log1pSC[i], f) {
			t.Errorf("Log1p({}) = {}, want {}", vflog1pSC[i], f, log1pSC[i])
		}
	}
}

#test
fn testLog2(t: &testing::T) {
	mut i := 0
	for i < len(vf); i++ {
		a := math::Abs(vf[i])
		f := math::Log2(a)
		if !veryclose(log2[i], f) {
			t.Errorf("Log2({}) = {}, want {}", a, f, log2[i])
		}
	}
	{
		f := math::Log2(math::E)
		if f != math::Log2E {
			t.Errorf("Log2({}) = {}, want {}", math::E, f, math::Log2E)
		}
	}
	i = 0
	for i < len(vflogSC); i++ {
		f := math::Log2(vflogSC[i])
		if !alike(logSC[i], f) {
			t.Errorf("Log2({}) = {}, want {}", vflogSC[i], f, logSC[i])
		}
	}
	i = -1074
	for i <= 1023; i++ {
		f := math::Ldexp(1, i)
		l := math::Log2(f)
		if l != f64(i) {
			t.Errorf("Log2(2**{}) = {}, want {}", i, l, i)
		}
	}
}

#test
fn testModf(t: &testing::T) {
	mut i := 0
	for i < len(vf); i++ {
		f, g := math::Modf(vf[i])
		if !veryclose(modf[i][0], f) || !veryclose(modf[i][1], g) {
			t.Errorf("Modf({}) = {}, {}, want {}, {}", vf[i], f, g, modf[i][0], modf[i][1])
		}
	}
	i = 0
	for i < len(vfmodfSC); i++ {
		f, g := math::Modf(vfmodfSC[i])
		if !alike(modfSC[i][0], f) || !alike(modfSC[i][1], g) {
			t.Errorf("Modf({}) = {}, {}, want {}, {}", vfmodfSC[i], f, g, modfSC[i][0], modfSC[i][1])
		}
	}
}

#test
fn testNextafter32(t: &testing::T) {
	mut i := 0
	for i < len(vf); i++ {
		vfi := f32(vf[i])
		f := math::Nextafter32(vfi, 10)
		if nextafter32[i] != f {
			t.Errorf("Nextafter32({}, {}) = {} want {}", vfi, 10.0, f, nextafter32[i])
		}
	}
	i = 0
	for i < len(vfnextafter32SC); i++ {
		f := math::Nextafter32(vfnextafter32SC[i][0], vfnextafter32SC[i][1])
		if !alike(f64(nextafter32SC[i]), f64(f)) {
			t.Errorf("Nextafter32({}, {}) = {} want {}", vfnextafter32SC[i][0], vfnextafter32SC[i][1], f, nextafter32SC[i])
		}
	}
}

#test
fn testNextafter64(t: &testing::T) {
	mut i := 0
	for i < len(vf); i++ {
		f := math::Nextafter(vf[i], 10)
		if nextafter64[i] != f {
			t.Errorf("Nextafter64({}, {}) = {} want {}", vf[i], 10.0, f, nextafter64[i])
		}
	}
	i = 0
	for i < len(vfnextafter64SC); i++ {
		f := math::Nextafter(vfnextafter64SC[i][0], vfnextafter64SC[i][1])
		if !alike(nextafter64SC[i], f) {
			t.Errorf("Nextafter64({}, {}) = {} want {}", vfnextafter64SC[i][0], vfnextafter64SC[i][1], f, nextafter64SC[i])
		}
	}
}

#test
fn testPow(t: &testing::T) {
	mut i := 0
	for i < len(vf); i++ {
		f := math::Pow(10, vf[i])
		if !close(pow[i], f) {
			t.Errorf("Pow(10, {}) = {}, want {}", vf[i], f, pow[i])
		}
	}
	i = 0
	for i < len(vfpowSC); i++ {
		f := math::Pow(vfpowSC[i][0], vfpowSC[i][1])
		if !alike(powSC[i], f) {
			t.Errorf("Pow({}, {}) = {}, want {}", vfpowSC[i][0], vfpowSC[i][1], f, powSC[i])
		}
	}
}

#test
fn testPow10(t: &testing::T) {
	mut i := 0
	for i < len(vfpow10SC); i++ {
		f := math::Pow10(vfpow10SC[i])
		if !alike(pow10SC[i], f) {
			t.Errorf("Pow10({}) = {}, want {}", vfpow10SC[i], f, pow10SC[i])
		}
	}
}

#test
fn testRemainder(t: &testing::T) {
	mut i := 0
	for i < len(vf); i++ {
		f := math::Remainder(10, vf[i])
		if remainder[i] != f {
			t.Errorf("Remainder(10, {}) = {}, want {}", vf[i], f, remainder[i])
		}
	}
	i = 0
	for i < len(vffmodSC); i++ {
		f := math::Remainder(vffmodSC[i][0], vffmodSC[i][1])
		if !alike(fmodSC[i], f) {
			t.Errorf("Remainder({}, {}) = {}, want {}", vffmodSC[i][0], vffmodSC[i][1], f, fmodSC[i])
		}
	}
	{
		// verify precision of result for extreme inputs
		f := math::Remainder(5.9790119248836734e+200, 1.1258465975523544)
		if -0.4810497673014966 != f {
			t.Errorf("Remainder(5.9790119248836734e+200, 1.1258465975523544) = {}, want -0.4810497673014966", f)
		}
	}
	// verify that sign is correct when r == 0.
	test := fn(x: f64, y: f64) {
		r := math::Remainder(x, y)
		if r == 0 && math::Signbit(r) != math::Signbit(x) {
			t.Errorf("Remainder(x={}, y={}) = {}, sign of (zero) result should agree with sign of x", x, y, r)
		}
	}
	mut x := 0.0
	for x <= 3.0; x += 1 {
		mut y := 1.0
		for y <= 3.0; y += 1 {
			test(x, y)
			test(x, -y)
			test(-x, y)
			test(-x, -y)
		}
	}
}

#test
fn testRound(t: &testing::T) {
	mut i := 0
	for i < len(vf); i++ {
		f := math::Round(vf[i])
		if !alike(round[i], f) {
			t.Errorf("Round({}) = {}, want {}", vf[i], f, round[i])
		}
	}
	i = 0
	for i < len(vfroundSC); i++ {
		f := math::Round(vfroundSC[i][0])
		if !alike(vfroundSC[i][1], f) {
			t.Errorf("Round({}) = {}, want {}", vfroundSC[i][0], f, vfroundSC[i][1])
		}
	}
}

#test
fn testSignbit(t: &testing::T) {
	mut i := 0
	for i < len(vf); i++ {
		f := math::Signbit(vf[i])
		if signbit[i] != f {
			t.Errorf("Signbit({}) = %t, want %t", vf[i], f, signbit[i])
		}
	}
	i = 0
	for i < len(vfsignbitSC); i++ {
		f := math::Signbit(vfsignbitSC[i])
		if signbitSC[i] != f {
			t.Errorf("Signbit({}) = %t, want %t", vfsignbitSC[i], f, signbitSC[i])
		}
	}
}

#test
fn testSin(t: &testing::T) {
	mut i := 0
	for i < len(vf); i++ {
		f := math::Sin(vf[i])
		if !veryclose(sin[i], f) {
			t.Errorf("Sin({}) = {}, want {}", vf[i], f, sin[i])
		}
	}
	i = 0
	for i < len(vfsinSC); i++ {
		f := math::Sin(vfsinSC[i])
		if !alike(sinSC[i], f) {
			t.Errorf("Sin({}) = {}, want {}", vfsinSC[i], f, sinSC[i])
		}
	}
}

#test
fn testSincos(t: &testing::T) {
	mut i := 0
	for i < len(vf); i++ {
		s, c := math::Sincos(vf[i])
		if !veryclose(sin[i], s) || !veryclose(cos[i], c) {
			t.Errorf("Sincos({}) = {}, {} want {}, {}", vf[i], s, c, sin[i], cos[i])
		}
	}
}

#test
fn testSinh(t: &testing::T) {
	mut i := 0
	for i < len(vf); i++ {
		f := math::Sinh(vf[i])
		if !close(sinh[i], f) {
			t.Errorf("Sinh({}) = {}, want {}", vf[i], f, sinh[i])
		}
	}
	i = 0
	for i < len(vfsinhSC); i++ {
		f := math::Sinh(vfsinhSC[i])
		if !alike(sinhSC[i], f) {
			t.Errorf("Sinh({}) = {}, want {}", vfsinhSC[i], f, sinhSC[i])
		}
	}
}

#test
fn testSqrt(t: &testing::T) {
	mut i := 0
	for i < len(vf); i++ {
		a := math::Abs(vf[i])
		f := math::Sqrt(a)
		if sqrt[i] != f {
			t.Errorf("Sqrt({}) = {}, want {}", a, f, sqrt[i])
		}
	}
	i = 0
	for i < len(vfsqrtSC); i++ {
		f := math::Sqrt(vfsqrtSC[i])
		if !alike(sqrtSC[i], f) {
			t.Errorf("Sqrt({}) = {}, want {}", vfsqrtSC[i], f, sqrtSC[i])
		}
	}
}

#test
fn testTan(t: &testing::T) {
	mut i := 0
	for i < len(vf); i++ {
		f := math::Tan(vf[i])
		if !veryclose(tan[i], f) {
			t.Errorf("Tan({}) = {}, want {}", vf[i], f, tan[i])
		}
	}
	// same special cases as Sin
	i = 0
	for i < len(vfsinSC); i++ {
		f := math::Tan(vfsinSC[i])
		if !alike(sinSC[i], f) {
			t.Errorf("Tan({}) = {}, want {}", vfsinSC[i], f, sinSC[i])
		}
	}
}

#test
fn testTanh(t: &testing::T) {
	mut i := 0
	for i < len(vf); i++ {
		f := math::Tanh(vf[i])
		if !veryclose(tanh[i], f) {
			t.Errorf("Tanh({}) = {}, want {}", vf[i], f, tanh[i])
		}
	}
	i = 0
	for i < len(vftanhSC); i++ {
		f := math::Tanh(vftanhSC[i])
		if !alike(tanhSC[i], f) {
			t.Errorf("Tanh({}) = {}, want {}", vftanhSC[i], f, tanhSC[i])
		}
	}
}

#test
fn testTrunc(t: &testing::T) {
	mut i := 0
	for i < len(vf); i++ {
		f := math::Trunc(vf[i])
		if !alike(trunc[i], f) {
			t.Errorf("Trunc({}) = {}, want {}", vf[i], f, trunc[i])
		}
	}
	for i < len(vfceilSC); i++ {
		f := math::Trunc(vfceilSC[i])
		if !alike(truncSC[i], f) {
			t.Errorf("Trunc({}) = {}, want {}", vfceilSC[i], f, truncSC[i])
		}
	}
}

#test
fn testY0(t: &testing::T) {
	mut i := 0
	for i < len(vf); i++ {
		a := math::Abs(vf[i])
		f := math::Y0(a)
		if !close(y0[i], f) {
			t.Errorf("Y0({}) = {}, want {}", a, f, y0[i])
		}
	}
	i = 0
	for i < len(vfy0SC); i++ {
		f := math::Y0(vfy0SC[i])
		if !alike(y0SC[i], f) {
			t.Errorf("Y0({}) = {}, want {}", vfy0SC[i], f, y0SC[i])
		}
	}
}

#test
fn testY1(t: &testing::T) {
	mut i := 0
	for i < len(vf); i++ {
		a := math::Abs(vf[i])
		f := math::Y1(a)
		if !soclose(y1[i], f, 2e-14) {
			t.Errorf("Y1({}) = {}, want {}", a, f, y1[i])
		}
	}
	i = 0
	for i < len(vfy0SC); i++ {
		f := math::Y1(vfy0SC[i])
		if !alike(y1SC[i], f) {
			t.Errorf("Y1({}) = {}, want {}", vfy0SC[i], f, y1SC[i])
		}
	}
}

#test
fn testYn(t: &testing::T) {
	mut i := 0
	for i < len(vf); i++ {
		a := math::Abs(vf[i])
		mut f := math::Yn(2, a)
		if !close(y2[i], f) {
			t.Errorf("Yn(2, {}) = {}, want {}", a, f, y2[i])
		}
		f = math::Yn(-3, a)
		if !close(yM3[i], f) {
			t.Errorf("Yn(-3, {}) = {}, want {}", a, f, yM3[i])
		}
	}
	i = 0
	for i < len(vfy0SC); i++ {
		mut f := math::Yn(2, vfy0SC[i])
		if !alike(y2SC[i], f) {
			t.Errorf("Yn(2, {}) = {}, want {}", vfy0SC[i], f, y2SC[i])
		}
		f = math::Yn(-3, vfy0SC[i])
		if !alike(yM3SC[i], f) {
			t.Errorf("Yn(-3, {}) = {}, want {}", vfy0SC[i], f, yM3SC[i])
		}
	}
	f := math::Yn(0, 0)
	if !alike(math::Inf(-1), f) {
		t.Errorf("Yn(0, 0) = {}, want {}", f, math::Inf(-1))
	}
}

#test
fn testFMA(t: &testing::T) {
	for _, c in fmaC {
		got := math::FMA(c.x, c.y, c.z)
		if !alike(got, c.want) {
			t.Errorf("FMA({},{},{}) == {}; want {}", c.x, c.y, c.z, got, c.want)
		}
	}
}

// Check that math functions of high angle values
// return accurate results. [Since (vf[i] + large) - large != vf[i],
// testing for Trig(vf[i] + large) == Trig(vf[i]), where large is
// a multiple of 2*Pi, is misleading.]
#test
fn testLargeCos(t: &testing::T) {
	large := f64(100000 * math::Pi)
	mut i := 0
	for i < len(vf); i++ {
		f1 := cosLarge[i]
		f2 := math::Cos(vf[i] + large)
		if !close(f1, f2) {
			t.Errorf("Cos({}) = {}, want {}", vf[i]+large, f2, f1)
		}
	}
}

#test
fn testLargeSin(t: &testing::T) {
	large := f64(100000 * math::Pi)
	mut i := 0
	for i < len(vf); i++ {
		f1 := sinLarge[i]
		f2 := math::Sin(vf[i] + large)
		if !close(f1, f2) {
			t.Errorf("Sin({}) = {}, want {}", vf[i]+large, f2, f1)
		}
	}
}

#test
fn testLargeSincos(t: &testing::T) {
	large := f64(100000 * math::Pi)
	mut i := 0
	for i < len(vf); i++ {
		f1, g1 := sinLarge[i], cosLarge[i]
		f2, g2 := math::Sincos(vf[i] + large)
		if !close(f1, f2) || !close(g1, g2) {
			t.Errorf("Sincos({}) = {}, {}, want {}, {}", vf[i]+large, f2, g2, f1, g1)
		}
	}
}

#test
fn testLargeTan(t: &testing::T) {
	large := f64(100000 * math::Pi)
	mut i := 0
	for i < len(vf); i++ {
		f1 := tanLarge[i]
		f2 := math::Tan(vf[i] + large)
		if !close(f1, f2) {
			t.Errorf("Tan({}) = {}, want {}", vf[i]+large, f2, f1)
		}
	}
}

// Check that trigReduce matches the standard reduction results for input values
// below reduceThreshold.
fn testTrigReduce(t: &testing::T) {
	mut inputs := make([]f64, len(vf))
	// all of the standard inputs
	copy(inputs, vf)
	// all of the large inputs
	large := f64(100000 * math::Pi)
	for _, v in vf {
		inputs = append(inputs, v+large)
	}
	// Also test some special inputs, Pi and right below the reduceThreshold
	inputs = append(inputs, math::Pi, math::Nextafter(math::ReduceThreshold, 0))
	for _, x in inputs {
		// reduce the value to compare
		j, z := math::TrigReduce(x)
		xred := f64(j)*(math::Pi/4) + z

		mut f, mut fred := math::Sin(x), math::Sin(xred)
		if !close(f, fred) {
			t.Errorf("Sin(trigReduce({})) != Sin({}), got {}, want {}", x, x, fred, f)
		}
		f, fred = math::Cos(x), math::Cos(xred)
		if !close(f, fred) {
			t.Errorf("Cos(trigReduce({})) != Cos({}), got {}, want {}", x, x, fred, f)
		}
		f, fred := math::Tan(x), math::Tan(xred)
		if !close(f, fred) {
			t.Errorf(" Tan(trigReduce({})) != Tan({}), got {}, want {}", x, x, fred, f)
		}
		f, g := math::Sincos(x)
		fred, gred := math::Sincos(xred)
		if !close(f, fred) || !close(g, gred) {
			t.Errorf(" Sincos(trigReduce({})) != Sincos({}), got {}, {}, want {}, {}", x, x, fred, gred, f, g)
		}
	}
}
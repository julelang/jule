// Copyright 2022-2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

/*
  Floating-point arctangent.
*/

// The Jule code is a modified version of the original Go code from
// https://github.com/golang/go/blob/go1.19/src/math/atan.go and came with this notice.
//
// ====================================================
// Copyright (c) 2009 The Go Authors. All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
// 
//    * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//    * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//    * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// ====================================================

// The original C code, the long comment, and the constants below were
// from http://netlib.sandia.gov/cephes/cmath/atan.c, available from
// http://www.netlib.org/cephes/cmath.tgz.
// The Jule code is a version of the original C.
//
// atan.c
// Inverse circular tangent (arctangent)
//
// SYNOPSIS:
// double x, y, atan();
// y = atan( x );
//
// DESCRIPTION:
// Returns radian angle between -pi/2 and +pi/2 whose tangent is x.
//
// Range reduction is from three intervals into the interval from zero to 0.66.
// The approximant uses a rational function of degree 4/5 of the form
// x + x**3 P(x)/Q(x).
//
// ACCURACY:
//                      Relative error:
// arithmetic   domain    # trials  peak     rms
//    DEC       -10, 10   50000     2.4e-17  8.3e-18
//    IEEE      -10, 10   10^6      1.8e-16  5.0e-17
//
// Cephes Math Library Release 2.8:  June, 2000
// Copyright 1984, 1987, 1989, 1992, 2000 by Stephen L. Moshier
//
// The readme file at http://netlib.sandia.gov/cephes/ says:
//    Some software in this archive may be from the book _Methods and
// Programs for Mathematical Functions_ (Prentice-Hall or Simon & Schuster
// International, 1989) or from the Cephes Mathematical Library, a
// commercial product. In either event, it is copyrighted by the author.
// What you see here may be used freely but it comes with no support or
// guarantee.
//
//   The two known misprints in the book are repaired here in the
// source listings for the gamma function and the incomplete beta
// integral.
//
//   Stephen L. Moshier
//   moshier@na-net.ornl.gov

// Evaluates a series valid in the range [0, 0.66].
fn xatan(x: f64): f64 {
	const P0 = -8.750608600031904122785e-01
	const P1 = -1.615753718733365076637e+01
	const P2 = -7.500855792314704667340e+01
	const P3 = -1.228866684490136173410e+02
	const P4 = -6.485021904942025371773e+01
	const Q0 = +2.485846490142306297962e+01
	const Q1 = +1.650270098316988542046e+02
	const Q2 = +4.328810604912902668951e+02
	const Q3 = +4.853903996359136964868e+02
	const Q4 = +1.945506571482613964425e+02

	mut z := x * x
	z = z * ((((P0 * z + P1) * z + P2) * z + P3) * z + P4) / (((((z + Q0) * z + Q1) * z + Q2) * z + Q3) * z + Q4)
	z = x * z + x
	ret z
}

// Reduces its argument (known to be positive)
// to the range [0, 0.66] and calls xatan.
fn satan(x: f64): f64 {
	const morebits = 6.123233995736765886130e-17 // pi/2 = PIO2 + Morebits
	const tan3pio8 = 2.41421356237309504880      // tan(3*pi/8)

	if x <= 0.66 {
		ret xatan(x)
	}
	if x > tan3pio8 {
		ret Pi / 2 - xatan(1 / x) + morebits
	}
	ret Pi / 4 + xatan((x - 1) / (x + 1)) + 0.5 * morebits
}

// Returns the arctangent, in radians, of x.
//
// Special cases are:
//  Atan(±0) = ±0
//  Atan(±Inf) = ±Pi/2
fn Atan(x: f64): f64 {
	if x == 0 {
		ret x
	}
	if x > 0 {
		ret satan(x)
	}
	ret -satan(-x)
}
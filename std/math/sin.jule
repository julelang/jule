// Copyright 2022-2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

/*
  Floating-point sine and cosine.
*/

// The Jule code is a modified version of the original Go code from
// https://github.com/golang/go/blob/go1.19/src/math/sin.go and came with this notice.
//
// ====================================================
// Copyright (c) 2009 The Go Authors. All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
// 
//    * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//    * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//    * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// ====================================================

// The original C code, the long comment, and the constants
// below were from http://netlib.sandia.gov/cephes/cmath/sin.c,
// available from http://www.netlib.org/cephes/cmath.tgz.
// The Jule code is a simplified version of the original C.
//
//      sin.c
//
//      Circular sine
//
// SYNOPSIS:
//
// double x, y, sin();
// y = sin( x );
//
// DESCRIPTION:
//
// Range reduction is into intervals of pi/4.  The reduction error is nearly
// eliminated by contriving an extended precision modular arithmetic.
//
// Two polynomial approximating functions are employed.
// Between 0 and pi/4 the sine is approximated by
//      x  +  x**3 P(x**2).
// Between pi/4 and pi/2 the cosine is represented as
//      1  -  x**2 Q(x**2).
//
// ACCURACY:
//
//                      Relative error:
// arithmetic   domain      # trials      peak         rms
//    DEC       0, 10       150000       3.0e-17     7.8e-18
//    IEEE -1.07e9,+1.07e9  130000       2.1e-16     5.4e-17
//
// Partial loss of accuracy begins to occur at x = 2**30 = 1.074e9.  The loss
// is not gradual, but jumps suddenly to about 1 part in 10e7.  Results may
// be meaningless for x > 2**49 = 5.6e14.
//
//      cos.c
//
//      Circular cosine
//
// SYNOPSIS:
//
// double x, y, cos();
// y = cos( x );
//
// DESCRIPTION:
//
// Range reduction is into intervals of pi/4.  The reduction error is nearly
// eliminated by contriving an extended precision modular arithmetic.
//
// Two polynomial approximating functions are employed.
// Between 0 and pi/4 the cosine is approximated by
//      1  -  x**2 Q(x**2).
// Between pi/4 and pi/2 the sine is represented as
//      x  +  x**3 P(x**2).
//
// ACCURACY:
//
//                      Relative error:
// arithmetic   domain      # trials      peak         rms
//    IEEE -1.07e9,+1.07e9  130000       2.1e-16     5.4e-17
//    DEC        0,+1.07e9   17000       3.0e-17     7.2e-18
//
// Cephes Math Library Release 2.8:  June, 2000
// Copyright 1984, 1987, 1989, 1992, 2000 by Stephen L. Moshier
//
// The readme file at http://netlib.sandia.gov/cephes/ says:
//    Some software in this archive may be from the book _Methods and
// Programs for Mathematical Functions_ (Prentice-Hall or Simon & Schuster
// International, 1989) or from the Cephes Mathematical Library, a
// commercial product. In either event, it is copyrighted by the author.
// What you see here may be used freely but it comes with no support or
// guarantee.
//
//   The two known misprints in the book are repaired here in the
// source listings for the gamma function and the incomplete beta
// integral.
//
//   Stephen L. Moshier
//   moshier@na-net.ornl.gov

// sin coefficients
static _SIN: [...]f64 = [
    1.58962301576546568060e-10, // 0x3de5d8fd1fd19ccd
    -2.50507477628578072866e-8, // 0xbe5ae5e5a9291f5d
    2.75573136213857245213e-6,  // 0x3ec71de3567d48a1
    -1.98412698295895385996e-4, // 0xbf2a01a019bfdf03
    8.33333333332211858878e-3,  // 0x3f8111111110f7d0
    -1.66666666666666307295e-1, // 0xbfc5555555555548
]

// cos coefficients
static _COS: [...]f64 = [
    -1.13585365213876817300e-11, // 0xbda8fa49a0861a9b
    2.08757008419747316778e-9,   // 0x3e21ee9d7b4e3f05
    -2.75573141792967388112e-7,  // 0xbe927e4f7eac4bc6
    2.48015872888517045348e-5,   // 0x3efa01a019c844f5
    -1.38888888888730564116e-3,  // 0xbf56c16c16c14f91
    4.16666666666665929218e-2,   // 0x3fa555555555554b
]

// Returns the cosine of the radian argument x.
//
// Special cases are:
//  Cos(±Inf) = NaN
//  Cos(NaN) = NaN
pub fn Cos(mut x: f64): f64 {
    const PI4A = 7.85398125648498535156e-1  // 0x3fe921fb40000000, PI/4 split into three parts
    const PI4B = 3.77489470793079817668e-8  // 0x3e64442d00000000,
    const PI4C = 2.69515142907905952645e-15 // 0x3ce8469898cc5170,
    // special cases
    if IsNaN(x) || IsInf(x, 0) {
        ret NaN()
    }

    // make argument positive
    let mut sign = false
    x = Abs(x)

    let mut j: u64 = 0
    let mut y: f64 = 0
    let mut z: f64 = 0
    if x >= reduceThreshold {
        j, z = trigReduce(x)
    } else {
        j = u64(x * (4 / Pi)) // integer part of x/(PI/4), as integer for tests on the phase angle
        y = f64(j) // integer part of x/(PI/4), as float

        // map zeros to origin
        if j&1 == 1 {
            j++
            y++
        }
        j &= 7 // octant modulo 2Pi radians (360 degrees)
        z = ((x - y * PI4A) - y * PI4B) - y * PI4C // Extended precision modular arithmetic
    }

    if j > 3 {
        j -= 4
        sign = !sign
    }
    if j > 1 {
        sign = !sign
    }

    let zz = z * z
    if j == 1 || j == 2 {
        y = z + z * zz * ((((((_SIN[0] * zz) + _SIN[1]) * zz + _SIN[2]) * zz + _SIN[3]) * zz + _SIN[4]) * zz + _SIN[5])
    } else {
        y = 1.0 - 0.5 * zz + zz * zz * ((((((_COS[0] * zz) + _COS[1]) * zz + _COS[2]) * zz + _COS[3]) * zz + _COS[4]) * zz + _COS[5])
    }
    if sign {
        y = -y
    }
    ret y
}

// Returns the sine of the radian argument x.
//
// Special cases are:
//  Sin(±0) = ±0
//  Sin(±Inf) = NaN
//  Sin(NaN) = NaN
pub fn Sin(mut x: f64): f64 {
    const PI4A = 7.85398125648498535156e-1  // 0x3fe921fb40000000, PI/4 split into three parts
    const PI4B = 3.77489470793079817668e-8  // 0x3e64442d00000000,
    const PI4C = 2.69515142907905952645e-15 // 0x3ce8469898cc5170,
    // special cases
    match {
    | x == 0 | IsNaN(x):
        ret x // ret ±0 || NaN()
    | IsInf(x, 0):
        ret NaN()
    }

    // make argument positive but save the sign
    let mut sign = false
    if x < 0 {
        x = -x
        sign = true
    }

    let mut j: u64 = 0
    let mut y: f64 = 0
    let mut z: f64 = 0
    if x >= reduceThreshold {
        j, z = trigReduce(x)
    } else {
        j = u64(x * (4 / Pi)) // integer part of x/(PI/4), as integer for tests on the phase angle
        y = f64(j) // integer part of x/(PI/4), as float

        // map zeros to origin
        if j&1 == 1 {
            j++
            y++
        }
        j &= 7 // octant modulo 2Pi radians (360 degrees)
        z = ((x - y * PI4A) - y * PI4B) - y * PI4C // Extended precision modular arithmetic
    }
    // reflect in x axis
    if j > 3 {
        sign = !sign
        j -= 4
    }
    let zz = z * z
    if j == 1 || j == 2 {
        y = 1.0 - 0.5 * zz + zz * zz * ((((((_COS[0] * zz) + _COS[1]) * zz + _COS[2]) * zz + _COS[3]) * zz + _COS[4]) * zz + _COS[5])
    } else {
        y = z + z * zz * ((((((_SIN[0] * zz) + _SIN[1]) * zz + _SIN[2]) * zz + _SIN[3]) * zz + _SIN[4]) * zz + _SIN[5])
    }
    if sign {
        y = -y
    }
    ret y
}
// Copyright 2023-2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/math"

// Complex number.
struct Cmplx {
	real: f64
	imag: f64
}

impl Cmplx {
	// Returns new complex number.
	static fn New(real: f64, imag: f64): Cmplx {
		ret Cmplx{
			real: real,
			imag: imag,
		}
	}

	// Returns NaN complex number.
	static fn NaN(): Cmplx {
		ret Cmplx{
			real: math::NaN(),
			imag: math::NaN(),
		}
	}

	// Returns Inf complex number.
	// Uses positive infinity if sign >= 0, negative infinity if !sign < 0.
	static fn Inf(sign: int): Cmplx {
		ret Cmplx{
			real: math::Inf(sign),
			imag: math::Inf(sign),
		}
	}

	// Returns zero complex number.
	static fn Zero(): Cmplx {
		ret Cmplx.New(0, 0)
	}

	// Returns real part of complex number.
	fn Real(self): f64 {
		ret self.real
	}

	// Returns imaginary part of complex number.
	fn Imag(self): f64 {
		ret self.imag
	}

	// Returns conjugate of complex number.
	fn Conj(self): Cmplx {
		ret Cmplx.New(self.Real(), -self.Imag())
	}

	// Returns addition of complex numbers.
	fn Add(self, c: Cmplx): Cmplx {
		mut r := self
		r.add(c)
		ret r
	}

	// Adds complex numbers and sets result to self.
	fn add(mut self, c: Cmplx) {
		self.real += c.Real()
		self.imag += c.Imag()
	}

	// Returns subtraction of complex numbers.
	fn Sub(self, c: Cmplx): Cmplx {
		mut r := self
		r.sub(c)
		ret r
	}

	// Subtracts complex numbers and sets result to self.
	fn sub(mut self, c: Cmplx) {
		self.real -= c.Real()
		self.imag -= c.Imag()
	}

	// Returns multiplication of complex numbers.
	fn Mul(self, c: Cmplx): Cmplx {
		mut r := self
		r.mul(c)
		ret r
	}

	// Multiplies complex numbers and sets result to self.
	fn mul(mut self, c: Cmplx) {
		real := self.Real()*c.Real() + self.Imag()*c.Imag()*-1
		imag := self.Real()*c.Imag() + self.Imag()*c.Real()
		self.real = real
		self.imag = imag
	}

	// Returns division of complex numbers.
	// Returns NaN complex number if denominator is zero.
	fn Div(self, c: Cmplx): Cmplx {
		mut r := self
		r.div(c)
		ret r
	}

	// Divides complex numbers and sets result to self.
	fn div(mut self, m: Cmplx) {
		// Algorithm for robust complex division as described in
		// Robert L. Smith: Algorithm 116: Complex division. Commun. ACM 5(8): 435 (1962).
		mut r, mut i := 0.0, 0.0

		if math::Abs(m.Real()) >= math::Abs(m.Imag()) {
			if m.Real() == 0 {
				r = math::NaN()
				i = math::NaN()
			} else {
				ratio := m.Imag() / m.Real()
				denom := m.Real() + ratio*m.Imag()
				if denom == 0 {
					r = math::NaN()
					i = math::NaN()
				} else {
					r = (self.Real() + self.Imag()*ratio) / denom
					i = (self.Imag() - self.Real()*ratio) / denom
				}
			}
		} else {
			if m.Imag() == 0 {
				r = math::NaN()
				i = math::NaN()
			} else {
				ratio := m.Real() / m.Imag()
				denom := m.Imag() + ratio*m.Real()
				if denom == 0 {
					r = math::NaN()
					i = math::NaN()
				} else {
					r = (self.Real()*ratio + self.Imag()) / denom
					i = (self.Imag()*ratio - self.Real()) / denom
				}
			}
		}

		if math::IsNaN(r) && math::IsNaN(i) {
			// Correct final result to infinities and zeros if applicable.
			// Matches C99: ISO/IEC 9899:1999 - G.5.1  Multiplicative operators.

			mut a, mut b := self.Real(), self.Imag()
			mut c, mut d := m.Real(), m.Imag()

			static inf = math::F64FromBits(0x7FF0000000000000)

			match {
			| m.IsZero() && (!math::IsNaN(a) || !math::IsNaN(b)):
				r = math::Copysign(inf, c) * a
				i = math::Copysign(inf, c) * b
			| (isInf(a) || isInf(b)) && isFinite(c) && isFinite(d):
				a = inf2one(a)
				b = inf2one(b)
				r = inf * (a*c + b*d)
				i = inf * (b*c - a*d)
			| (isInf(c) || isInf(d)) && isFinite(a) && isFinite(b):
				c = inf2one(c)
				d = inf2one(d)
				r = 0 * (a*c + b*d)
				i = 0 * (b*c - a*d)
			}
		}

		self.real, self.imag = r, i
	}

	// Unary minus operator.
	fn Neg(self): Cmplx {
		ret Cmplx.New(-self.Real(), -self.Imag())
	}

	// Reports whether either real or imag is an infinity.
	fn IsInf(self): bool {
		ret math::IsInf(self.Real(), 0) || math::IsInf(self.Imag(), 0)
	}

	// Reports whether either real or imag is NaN and neither is an infinity.
	fn IsNaN(self): bool {
		match {
		| math::IsInf(self.Real(), 0) | math::IsInf(self.Imag(), 0):
			ret false
		| math::IsNaN(self.Real()) | math::IsNaN(self.Imag()):
			ret true
		|:
			ret false
		}
	}

	// Reports whether real and imag is zero.
	fn IsZero(self): bool {
		ret self.Real() == 0 && self.Imag() == 0
	}
}

// Reports whether f is neither NaN nor an infinity.
fn isFinite(f: f64): bool {
	ret !math::IsNaN(f - f)
}

// Reports whether f is an infinity.
fn isInf(f: f64): bool {
	ret !math::IsNaN(f) && !isFinite(f)
}

// Returns a signed 1 if f is an infinity and a signed 0 otherwise.
// The sign of the result is the sign of f.
fn inf2one(f: f64): f64 {
	mut g := 0.0
	if math::IsInf(f, 0) {
		g = 1.0
	}
	ret math::Copysign(g, f)
}
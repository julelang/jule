// Copyright 2024 The Jule Project Contributors. All rights reserved.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/unsafe"

let mut intZero = Int{}
let mut intOne = Int{abs: wordOne}

// An Int represents a signed multi-precision integer.
// The zero value for an Int represents the value 0.
//
// The Int type is optimized for high-performance and efficiency.
// Implementation focuses to reduce allocations as much as possible and
// suitable for stack-based use cases by default.
// Int instances use internal mutable slice to store data.
// Computations may use available capacity of the underlying slice
// to avoid making new allocation. So shared data needs extra attention.
// Any mutable operation may be reflected to shared common data.
// If you need to share same Int instance, using smart pointers is a best naive way.
// If you need to have guaranteed independent copy, use Set on a zero instance.
//
// Note that methods may leak the Int's value through timing side-channels.
// Because of this and because of the scope and complexity of the
// implementation, Int is not well-suited to implement cryptographic operations.
// The standard library avoids exposing non-trivial Int methods to
// attacker-controlled inputs and the determination of whether a bug in
// the big package is considered a security vulnerability might depend on the
// impact on the standard library.
struct Int {
	// Mutability is for just copy-by-reference uses cases,
	// any mutation on abs must be done in a mutable scope for the owner.
	mut abs: []Word
	neg:     bool
}

impl Int {
	fn New(x: i64): Int {
		let mut r: Int
		r.SetI64(x)
		ret r
	}

	// Returns the Jacobi symbol (x/y), either +1, -1, or 0.
	// The y argument must be an odd integer.
	fn Jacobi(&x: *Int, &y: *Int): int {
		if !y.Odd() {
			panic("math/big: invalid 2nd argument to Int.Jacobi: need odd integer but got " + y.Str())
		}

		// We use the formulation described in chapter 2, section 2.4,
		// "The Yacas Book of Algorithms":
		// http://yacas.sourceforge.net/Algo.book.pdf

		mut a := Int{}
		mut b := Int{}
		mut c := Int{}
		a.Set(x)
		b.Set(y)
		mut j := 1

		if b.neg {
			if a.neg {
				j = -1
			}
			b.neg = false
		}

		for {
			if b.Cmp(&intOne) == 0 {
				ret j
			}
			if len(a.abs) == 0 {
				ret 0
			}
			a.Mod(&a, &b)
			if len(a.abs) == 0 {
				ret 0
			}
			// a > 0

			// handle factors of 2 in 'a'
			s := trailingZeroBitsW(a.abs)
			if s&1 != 0 {
				bmod8 := b.abs[0] & 7
				if bmod8 == 3 || bmod8 == 5 {
					j = -j
				}
			}
			c.Rsh(&a, s) // a = 2^s*c

			// swap numerator and denominator
			if b.abs[0]&3 == 3 && c.abs[0]&3 == 3 {
				j = -j
			}
			a.Set(&b)
			b.Set(&c)
		}
	}

	// Sets self to the product of all integers in the range [a, b] inclusively.
	// If a > b (empty range), the result is 1.
	fn MulRange(mut *self, mut a: i64, mut b: i64) {
		match {
		| a > b:
			self.SetU64(0) // empty range
			ret
		| a <= 0 && b >= 0:
			self.SetU64(0) // range includes 0
			ret
		}
		// a <= b && (b < 0 || a > 0)

		mut neg := false
		if a < 0 {
			neg = (b-a)&1 == 0
			a, b = -b, -a
		}

		mulRangeW(&self.abs, u64(a), u64(b))
		self.neg = neg
	}

	// Sets self to the binomial coefficient C(n, k).
	fn Binomial(mut *self, n: i64, mut k: i64) {
		if k > n {
			self.SetU64(0)
			ret
		}
		// reduce the number of multiplications by reducing k
		if k > n-k {
			k = n - k // C(n, k) == C(n, n-k)
		}
		// C(n, k) == n * (n-1) * ... * (n-k+1) / k * (k-1) * ... * 1
		//         == n * (n-1) * ... * (n-k+1) / 1 * (1+1) * ... * k
		//
		// Using the multiplicative formula produces smaller values
		// at each step, requiring fewer allocations and computations:
		//
		//	mut z := 1
		//	mut i := 0
		//	for i < k; i++ {
		//		z *= n-i
		//		z /= i+1
		//	}
		//
		// finally to avoid computing i+1 twice per loop:
		//
		//	mut z := 1
		//	mut i := 0
		//	for i < k {
		//		z *= n-i
		//		i++
		//		z /= i
		//	}
		let mut N: Int
		let mut K: Int
		let mut i: Int
		let mut t: Int
		N.SetI64(n)
		K.SetI64(k)
		i.SetU64(0)
		self.SetU64(1)
		for i.Cmp(&K) < 0 {
			t.Sub(&N, &i)
			self.Mul(self, &t)
			i.Add(&i, &intOne)
			self.Quo(self, &i)
		}
	}

	// Sets self = x + y
	fn Add(mut *self, &x: *Int, &y: *Int) {
		mut neg := x.neg
		if x.neg == y.neg {
			// x + y == x + y
			// (-x) + (-y) == -(x + y)
			addW(&self.abs, x.abs, y.abs)
		} else {
			// x + (-y) == x - y == -(y - x)
			// (-x) + y == y - x == -(x - y)
			if cmpW(x.abs, y.abs) >= 0 {
				subW(&self.abs, x.abs, y.abs)
			} else {
				neg = !neg
				subW(&self.abs, y.abs, x.abs)
			}
		}
		self.neg = len(self.abs) > 0 && neg // 0 has no sign
	}

	// Sets self = x + y
	fn Sub(mut *self, &x: *Int, &y: *Int) {
		mut neg := x.neg
		if x.neg != y.neg {
			// x - (-y) == x + y
			// (-x) - y == -(x + y)
			addW(&self.abs, x.abs, y.abs)
		} else {
			// x - y == x - y == -(y - x)
			// (-x) - (-y) == y - x == -(x - y)
			if cmpW(x.abs, y.abs) >= 0 {
				subW(&self.abs, x.abs, y.abs)
			} else {
				neg = !neg
				subW(&self.abs, y.abs, x.abs)
			}
		}
		self.neg = len(self.abs) > 0 && neg // 0 has no sign
	}

	// Sets self = x * y.
	fn Mul(mut *self, &x: *Int, &y: *Int) {
		// x * y == x * y
		// x * (-y) == -(x * y)
		// (-x) * y == -(x * y)
		// (-x) * (-y) == x * y
		if x == y {
			sqrW(&self.abs, x.abs)
			self.neg = false
			ret
		}
		mulW(&self.abs, x.abs, y.abs)
		self.neg = len(self.abs) > 0 && x.neg != y.neg // 0 has no sign
	}

	// Sets self to square root |√x|.
	// Panics if number is negative.
	fn Sqrt(mut *self, &x: *Int) {
		if self.neg {
			panic("math/big: Int.Sqrt: square root of negative number")
		}
		self.neg = false
		sqrtW(&self.abs, x.abs)
	}

	// Sets self to the quotient x/y and r to the remainder x%y.
	// If y == 0, a division-by-zero run-time panic occurs.
	//
	// Implements T-division and modulus (like Jule):
	//
	//	q = x/y      with the result truncated to zero
	//	r = x - y*q
	//
	// (See Daan Leijen, “Division and Modulus for Computer Scientists”.)
	// See [DivMod] for Euclidean division and modulus (unlike Jule).
	fn QuoRem(mut *self, &x: *Int, &y: *Int, mut &r: *Int) {
		divW(&self.abs, &r.abs, x.abs, y.abs)
		self.neg, r.neg = len(self.abs) > 0 && x.neg != y.neg, len(r.abs) > 0 && x.neg // 0 has no sign
	}

	// Sets self to the quotient x/y for y != 0.
	// If y == 0, a division-by-zero run-time panic occurs.
	// Implements truncated division (like Jule); see [Int.QuoRem] for more details.
	fn Quo(mut *self, &x: *Int, &y: *Int) {
		mut r := []Word(nil)
		divW(&self.abs, &r, x.abs, y.abs)
		self.neg = len(self.abs) > 0 && x.neg != y.neg // 0 has no sign
	}

	// Sets self to the quotient x/y for y != 0.
	// If y == 0, a division-by-zero runtime panic occurs.
	// Implements Euclidean division; see [Int.DivMod] for more details.
	fn Div(mut *self, &x: *Int, &y: *Int) {
		mut r := Int{}
		self.QuoRem(x, y, &r)
		if r.neg {
			if y.neg {
				self.Add(self, &intOne)
			} else {
				self.Sub(self, &intOne)
			}
		}
	}

	// Sets self to the modulus x%y for y != 0.
	// If y == 0, a division-by-zero run-time panic occurs.
	// Implements Euclidean modulus (unlike Jule); see [Int.DivMod] for more details.
	fn Mod(mut *self, &x: *Int, &y: *Int) {
		if self == y || aliasW(self.abs, y.abs) {
			mut y0 := *y
			y0.abs = cloneW(y.abs)
			self.Mod(x, &y0)
			ret
		}
		mut q := Int{}
		q.QuoRem(x, y, self)
		if self.neg {
			if y.neg {
				self.Sub(self, y)
			} else {
				self.Add(self, y)
			}
		}
	}

	// Sets self to the quotient x div y and m to the modulus x mod y
	// and returns the pair (q, m) for y != 0.
	// If y == 0, a division-by-zero run-time panic occurs.
	//
	// Implements Euclidean division and modulus (unlike Jule):
	//
	//	q = x div y  such that
	//	m = x - y*q  with 0 <= m < |y|
	//
	// (See Raymond T. Boute, “The Euclidean definition of the functions
	// div and mod”. ACM Transactions on Programming Languages and
	// Systems (TOPLAS), 14(2):127-144, New York, NY, USA, 4/1992.
	// ACM press.)
	// See [Int.QuoRem] for T-division and modulus (like Jule).
	fn DivMod(mut *self, mut &x: *Int, mut &y: *Int): (q: Int, m: Int) {
		if self == y || aliasW(self.abs, y.abs) {
			mut y0 := *y
			y0.abs = cloneW(y.abs)
			ret self.DivMod(x, &y0)
		}
		self.QuoRem(x, y, &m)
		if m.neg {
			if y.neg {
				q.Add(&q, &intOne)
				m.Sub(&m, y)
			} else {
				q.Sub(&q, &intOne)
				m.Add(&m, y)
			}
		}
		ret
	}

	// Sets self = x << y
	fn Lsh(mut *self, &x: *Int, y: uint) {
		lshW(&self.abs, x.abs, y)
		self.neg = x.neg
	}

	// Sets self = x >> y
	fn Rsh(mut *self, &x: *Int, y: uint) {
		if x.neg {
			// (-x) >> s == ^(x-1) >> s == ^((x-1) >> s) == -(((x-1) >> s) + 1)
			subW(&self.abs, x.abs, wordOne) // no underflow because |x| > 0
			rshW(&self.abs, self.abs, y)
			addW(&self.abs, self.abs, wordOne)
			self.neg = true // cannot be zero if x is negative
			ret
		}
		rshW(&self.abs, x.abs, y)
		self.neg = false
	}

	// Sets self = x | y
	fn Or(mut *self, &x: *Int, &y: *Int) {
		if x.neg == y.neg {
			if x.neg {
				// (-x) | (-y) == ^(x-1) | ^(y-1) == ^((x-1) & (y-1)) == -(((x-1) & (y-1)) + 1)
				mut x1 := []Word(nil)
				subW(&x1, x.abs, wordOne)
				mut y1 := []Word(nil)
				subW(&y1, y.abs, wordOne)
				addW(&self.abs, andW(x1, y1), wordOne)
				self.neg = true // self cannot be zero if x and y are negative
				ret
			}

			// x | y == x | y
			self.abs = orW(x.abs, y.abs)
			self.neg = false
			ret
		}

		// x.neg != y.neg
		if x.neg {
			unsafe {
				*(&x), *(&y) = *(&y), *(&x) // | is symmetric
			}
		}

		// x | (-y) == x | ^(y-1) == ^((y-1) &^ x) == -(^((y-1) &^ x) + 1)
		mut y1 := []Word(nil)
		subW(&y1, y.abs, wordOne)
		addW(&self.abs, andNotW(y1, x.abs), wordOne)
		self.neg = true // self cannot be zero if one of x or y is negative
	}

	// Sets self = x & y
	fn And(mut *self, &x: *Int, &y: *Int) {
		if x.neg == y.neg {
			if x.neg {
				// (-x) & (-y) == ^(x-1) & ^(y-1) == ^((x-1) | (y-1)) == -(((x-1) | (y-1)) + 1)
				mut x1 := []Word(nil)
				subW(&x1, x.abs, wordOne)
				mut y1 := []Word(nil)
				subW(&y1, y.abs, wordOne)
				addW(&self.abs, orW(x1, y1), wordOne)
				self.neg = true // self cannot be zero if x and y are negative
				ret
			}

			// x & y == x & y
			self.abs = andW(x.abs, y.abs)
			self.neg = false
			ret
		}

		// x.neg != y.neg
		if x.neg {
			unsafe {
				*(&x), *(&y) = *(&y), *(&x) // & is symmetric
			}
		}

		// x & (-y) == x & ^(y-1) == x &^ (y-1)
		mut y1 := []Word(nil)
		subW(&y1, y.abs, wordOne)
		self.abs = andNotW(x.abs, y1)
		self.neg = false
	}

	// Sets self = x ^ y
	fn Xor(mut *self, &x: *Int, &y: *Int) {
		if x.neg == y.neg {
			if x.neg {
				// (-x) ^ (-y) == ^(x-1) ^ ^(y-1) == (x-1) ^ (y-1)
				mut x1 := []Word(nil)
				subW(&x1, x.abs, wordOne)
				mut y1 := []Word(nil)
				subW(&y1, y.abs, wordOne)
				self.abs = xorW(x1, y1)
				self.neg = false
				ret
			}

			// x ^ y == x ^ y
			self.abs = xorW(x.abs, y.abs)
			self.neg = false
			ret
		}

		// x.neg != y.neg
		if x.neg {
			unsafe {
				*(&x), *(&y) = *(&y), *(&x) // ^ is symmetric
			}
		}

		// x ^ (-y) == x ^ ^(y-1) == ^(x ^ (y-1)) == -((x ^ (y-1)) + 1)
		mut y1 := []Word(nil)
		subW(&y1, y.abs, wordOne)
		addW(&self.abs, xorW(self.abs, y1), wordOne)
		self.neg = true // self cannot be zero if only one of x or y is negative
	}

	// Sets self to copy of x.
	fn Set(mut *self, &x: *Int) {
		if self != x {
			self.abs = makeW(self.abs, len(x.abs))
			copy(self.abs, x.abs)
			self.neg = x.neg
		}
	}

	fn exp(mut *self, &x: *Int, &y: *Int, &m: *Int, slow: bool) {
		// See Knuth, volume 2, section 4.6.3.
		mut xWords := x.abs
		if y.neg {
			if m == nil || len(m.abs) == 0 {
				setWU64(&self.abs, 1)
				self.neg = false
				ret
			}
			// for y < 0: x**y mod m == (x**(-1))**|y| mod m
			let mut inverse: Int
			inverse.ModInverse(x, m)
			if inverse.Cmp(&intZero) == 0 {
				setWU64(&self.abs, 0)
				self.neg = false
				ret
			}
			xWords = inverse.abs
		}
		yWords := y.abs
		mut mWords := []Word(nil)
		let mut tm: Int // Temporary m, used in need.
		if m != nil {
			if self == m || aliasW(self.abs, m.abs) {
				tm.Set(m)
				unsafe { *(&m) = &tm }
			}
			mWords = m.abs // m.abs may be nil for m == 0
		}
		expWW(&self.abs, xWords, yWords, mWords, slow)
		self.neg = len(self.abs) > 0 && x.neg && len(yWords) > 0 && yWords[0]&1 == 1 // 0 has no sign
		if self.neg && len(mWords) > 0 {
			// make modulus result positive
			subW(&self.abs, mWords, self.abs) // self == x**y mod |m| && 0 <= self < |m|
			self.neg = false
		}
	}

	// Sets self = x**y mod |m| (i.e. the sign of m is ignored).
	// If m == nil or m == 0, self = x**y unless y <= 0 then self = 1. If m != 0, y < 0,
	// and x and m are not relatively prime, self is zero.
	//
	// Modular exponentiation of inputs of a particular size is not a
	// cryptographically constant-time operation.
	fn Exp(mut *self, &x: *Int, &y: *Int, &m: *Int) {
		self.exp(x, y, m, false)
	}

	// Sets self to the greatest common divisor of a and b,
	// which both must be != 0.
	// If x or y are not nil, their values are set such that self = a*x + b*y.
	// See Knuth, The Art of Computer Programming, Vol. 2, Section 4.5.2, Algorithm L.
	// This implementation uses the improved condition by Collins requiring only one
	// quotient and avoiding the possibility of single Word overflow.
	// See Jebelean, "Improving the multiprecision Euclidean algorithm",
	// Design and Implementation of Symbolic Computation Systems, pp 45-58.
	// The cosequences are updated according to Algorithm 10.45 from
	// Cohen et al. "Handbook of Elliptic and Hyperelliptic Curve Cryptography" pp 192.
	fn lehmerGCD(mut *self, mut &x: *Int, mut &y: *Int, &a: *Int, &b: *Int) {
		mut A := Int{}
		mut B := Int{}
		mut Ua := Int{}
		mut Ub := Int{}

		A.Abs(a)
		B.Abs(b)

		extended := x != nil || y != nil

		if extended {
			// Ua (Ub) tracks how many times input a has been accumulated into A (B).
			setWU64(&Ua.abs, 1)
		}

		// temp variables for multiprecision update
		mut q := Int{}
		mut r := Int{}
		mut s := Int{}
		mut t := Int{}

		// ensure A >= B
		if cmpW(A.abs, B.abs) < 0 {
			A, B = B, A
			Ub, Ua = Ua, Ub
		}

		// loop invariant A >= B
		for len(B.abs) > 1 {
			// Attempt to calculate in single-precision using leading words of A and B.
			u0, u1, v0, v1, even := lehmerSimulate(A, B)
			// multiprecision Step
			if v0 != 0 {
				// Simulate the effect of the single-precision steps using the cosequences.
				// A = u0*A + v0*B
				// B = u1*A + v1*B
				lehmerUpdate(&A, &B, &q, &r, &s, &t, u0, u1, v0, v1, even)
				if extended {
					// Ua = u0*Ua + v0*Ub
					// Ub = u1*Ua + v1*Ub
					lehmerUpdate(&Ua, &Ub, &q, &r, &s, &t, u0, u1, v0, v1, even)
				}
			} else {
				// Single-digit calculations failed to simulate any quotients.
				// Do a standard Euclidean step.
				euclidUpdate(&A, &B, &Ua, &Ub, &q, &r, &s, &t, extended)
			}
		}

		if len(B.abs) > 0 {
			// extended Euclidean algorithm base case if B is a single Word
			if len(A.abs) > 1 {
				// A is longer than a single Word, so one update is needed.
				euclidUpdate(&A, &B, &Ua, &Ub, &q, &r, &s, &t, extended)
			}
			if len(B.abs) > 0 {
				// A and B are both a single Word.
				mut aWord, mut bWord := A.abs[0], B.abs[0]
				if extended {
					mut ua := Word(0)
					mut ub := Word(0)
					mut va := Word(0)
					mut vb := Word(0)
					ua, ub = 1, 0
					va, vb = 0, 1
					mut even := true
					for bWord != 0 {
						q2, r2 := aWord/bWord, aWord%bWord
						aWord, bWord = bWord, r2
						ua, ub = ub, ua+q2*ub
						va, vb = vb, va+q2*vb
						even = !even
					}

					setWV(&t.abs, ua)
					setWV(&s.abs, va)
					t.neg = !even
					s.neg = even

					t.Mul(&Ua, &t)
					s.Mul(&Ub, &s)

					Ua.Add(&t, &s)
				} else {
					for bWord != 0 {
						aWord, bWord = bWord, aWord%bWord
					}
				}
				A.abs[0] = aWord
			}
		}

		negA := a.neg
		if y != nil {
			// avoid aliasing b needed in the division below
			if aliasW(y.abs, b.abs) {
				B.Set(b)
			} else {
				B = *b
			}
			// y = (self - a*x)/b
			y.Mul(a, &Ua) // y can safely alias a
			if negA {
				y.neg = !y.neg
			}
			y.Sub(&A, y)
			y.Div(y, &B)
		}
		if x != nil {
			*x = Ua
			if negA {
				x.neg = !x.neg
			}
		}

		*self = A
	}

	// Sets self to the greatest common divisor of a and b.
	// If x or y are not nil, GCD sets their value such that self = a*x + b*y.
	//
	// a and b may be positive, zero or negative. (Before Go 1.14 both had
	// to be > 0.) Regardless of the signs of a and b, self is always >= 0.
	//
	// If a == b == 0, GCD sets self = x = y = 0.
	//
	// If a == 0 and b != 0, GCD sets self = |b|, x = 0, y = sign(b) * 1.
	//
	// If a != 0 and b == 0, GCD sets self = |a|, x = sign(a) * 1, y = 0.
	fn GCD(mut *self, mut &x: *Int, mut &y: *Int, &a: *Int, &b: *Int) {
		if len(a.abs) == 0 || len(b.abs) == 0 {
			lenA, lenB, negA, negB := len(a.abs), len(b.abs), a.neg, b.neg
			if lenA == 0 {
				self.Set(b)
			} else {
				self.Set(a)
			}
			self.neg = false
			if x != nil {
				if lenA == 0 {
					setWU64(&x.abs, 0)
					x.neg = false
				} else {
					setWU64(&x.abs, 1)
					x.neg = negA
				}
			}
			if y != nil {
				if lenB == 0 {
					setWU64(&y.abs, 0)
					y.neg = false
				} else {
					setWU64(&y.abs, 1)
					y.neg = negB
				}
			}
			ret
		}

		self.lehmerGCD(x, y, a, b)
	}

	// Sets self to the multiplicative inverse of g in the ring ℤ/nℤ.
	// If g and n are not relatively prime, g has no multiplicative
	// inverse in the ring ℤ/nℤ. In this case, self is zero.
	// If n == 0, a division-by-zero run-time panic occurs.
	fn ModInverse(mut *self, &g: *Int, &n: *Int) {
		// GCD expects parameters a and b to be > 0.
		if n.neg {
			let mut n0: Int
			n0.Neg(n)
			self.ModInverse(g, &n0)
			ret
		}
		if g.neg {
			let mut g0: Int
			g0.Mod(g, n)
			self.ModInverse(&g0, n)
			ret
		}
		let mut d: Int
		let mut x: Int
		d.GCD(&x, nil, g, n)

		// if and only if d==1, g and n are relatively prime
		if d.Cmp(&intOne) != 0 {
			setWU64(&self.abs, 0)
			self.neg = false
			ret
		}

		// x and y are such that g*x + n*y = 1, therefore x is the inverse element,
		// but it may be negative, so convert to the range 0 <= self < |n|
		if x.neg {
			self.Add(&x, n)
		} else {
			self.Set(&x)
		}
	}

	// Reports whether self is probably prime,
	// applying the Miller-Rabin test with n pseudorandomly chosen bases
	// as well as a Baillie-PSW test.
	//
	// If self is prime, returns true.
	// If self is chosen randomly and not prime, probably returns false.
	// The probability of returning true for a randomly chosen non-prime is at most ¼ⁿ.
	//
	// It is 100% accurate for inputs less than 2⁶⁴.
	// See Menezes et al., Handbook of Applied Cryptography, 1997, pp. 145-149,
	// and FIPS 186-4 Appendix F for further discussion of the error probabilities.
	//
	// It is not suitable for judging primes that an adversary may
	// have crafted to fool the test.
	fn ProbablyPrime(*self, n: int): bool {
		// Note regarding the doc comment above:
		// It would be more precise to say that the Baillie-PSW test uses the
		// extra strong Lucas test as its Lucas test, but since no one knows
		// how to tell any of the Lucas tests apart inside a Baillie-PSW test
		// (they all work equally well empirically), that detail need not be
		// documented or implicitly guaranteed.
		// The comment does avoid saying "the" Baillie-PSW test
		// because of this general ambiguity.

		if n < 0 {
			panic("math/rand: Int.ProbablyPrime: negative n given")
		}
		if self.neg || len(self.abs) == 0 {
			ret false
		}

		// records the primes < 64.
		const primeBitMask: u64 = 1<<2 | 1<<3 | 1<<5 | 1<<7 |
			1<<11 | 1<<13 | 1<<17 | 1<<19 | 1<<23 | 1<<29 | 1<<31 |
			1<<37 | 1<<41 | 1<<43 | 1<<47 | 1<<53 | 1<<59 | 1<<61

		w := self.abs[0]
		if len(self.abs) == 1 && w < 64 {
			ret primeBitMask&(1<<w) != 0
		}

		if w&1 == 0 {
			ret false // number is even
		}

		const primesA = 3 * 5 * 7 * 11 * 13 * 17 * 19 * 23 * 37
		const primesB = 29 * 31 * 41 * 43 * 47 * 53

		mut rA := u32(0)
		mut rB := u32(0)
		const match _W {
		| 32:
			rA = u32(modW(self.abs, primesA))
			rB = u32(modW(self.abs, primesB))
		| 64:
			r := modW(self.abs, (primesA*primesB)&_M)
			rA = u32(r % primesA)
			rB = u32(r % primesB)
		|:
			panic("math/big: invalid word size")
		}

		if rA%3 == 0 || rA%5 == 0 || rA%7 == 0 || rA%11 == 0 || rA%13 == 0 || rA%17 == 0 || rA%19 == 0 || rA%23 == 0 || rA%37 == 0 ||
			rB%29 == 0 || rB%31 == 0 || rB%41 == 0 || rB%43 == 0 || rB%47 == 0 || rB%53 == 0 {
			ret false
		}

		ret probablyPrimeMillerRabinW(self.abs, n+1, true) && probablyPrimeLucasW(self.abs)
	}

	// Returns the number of consecutive least significant zero bits of |self|.
	fn TrailingZeroBits(*self): uint {
		ret trailingZeroBitsW(self.abs)
	}

	// Returns the length of the absolute value of int in bits. The bit length of 0 is 0.
	fn BitLen(*self): int {
		// This function is may used in cryptographic operations. It must not leak
		// anything but the Int's sign and bit size through side-channels. Any
		// changes must be reviewed by a security expert.
		ret bitLenW(self.abs)
	}

	// Returns the value of the i'th bit of integer. That is, it
	// returns (x>>i)&1. The bit index i must be >= 0.
	fn Bit(*self, i: int): uint {
		if i < 0 {
			panic("math/big: Int.Bit: negative bit index")
		}
		if i == 0 {
			// optimization for common case: odd/even test of x
			if len(self.abs) > 0 {
				ret uint(self.abs[0] & 1) // bit 0 is same for -x
			}
			ret 0
		}
		if self.neg {
			mut abs := cloneW(self.abs)
			subW(&abs, abs, wordOne)
			ret bitW(abs, uint(i)) ^ 1
		}
		ret bitW(self.abs, uint(i))
	}

	// Sets self to |x| (the absolute value of x).
	fn Abs(mut *self, &x: *Int) {
		self.Set(x)
		self.neg = false
	}

	// Sets self = ^x
	fn Not(mut *self, &x: *Int) {
		if self.neg {
			// ^(-x) == ^(^(x-1)) == x-1
			subW(&self.abs, x.abs, wordOne)
			self.neg = false
			ret
		}
		// ^x == -x-1 == -(x+1)
		addW(&self.abs, x.abs, wordOne)
		self.neg = true // self cannot be zero if x is positive
		ret
	}

	// Sets self to -x.
	fn Neg(mut *self, &x: *Int) {
		self.Set(x)
		self.neg = len(self.abs) > 0 && !self.neg // 0 has no sign
	}

	// Reports whether x(self) is odd.
	fn Odd(*self): bool {
		ret len(self.abs) == 0 || self.abs[0]&1 == 1
	}

	// Reports whether x(self) is even.
	fn Even(*self): bool {
		ret len(self.abs) > 0 && self.abs[0]&1 == 0
	}

	// Returns, x = self:
	//	Sign() = -1 if x < 0
	//	Sign() = 0 if x == 0
	//	Sign() = +1 if x > 0
	fn Sign(*self): int {
		// This function is may used in cryptographic operations. It must not leak
		// anything but the Int's sign and bit size through side-channels. Any
		// changes must be reviewed by a security expert.
		if len(self.abs) == 0 {
			ret 0
		}
		if self.neg {
			ret -1
		}
		ret +1
	}

	// Compares integers.
	//	Returns +1 if self > y
	//	Returns 0 if self == y
	//	Returns -1 if self < y
	fn Cmp(*self, &y: *Int): (r: int) {
		// self cmp y == self cmp y
		// self cmp (-y) == self
		// (-self) cmp y == y
		// (-self) cmp (-y) == -(self cmp y)
		match {
		| self.neg == y.neg:
			r = cmpW(self.abs, y.abs)
			if self.neg {
				r = -r
			}
		| self.neg:
			r = -1
		|:
			r = +1
		}
		ret
	}

	// Compares absolute value.
	//	Returns +1 if |self| > |y|
	//	Returns 0 if |self| == |y|
	//	Returns -1 if |self| < |y|
	fn CmpAbs(*self, &y: *Int): int { ret cmpW(self.abs, y.abs) }

	// Sets self to x.
	fn SetU64(mut *self, x: u64) {
		setWU64(&self.abs, x)
		self.neg = false
	}

	// Sets self to x.
	fn SetI64(mut *self, x: i64) {
		self.neg = x < 0
		if self.neg {
			setWU64(&self.abs, u64(-x))
		} else {
			setWU64(&self.abs, u64(x))
		}
	}

	// Sets self to the value of s, interpreted in the given base,
	// and returns a boolean indicating success. The entire string
	// (not just a prefix) must be valid for success. If SetStr fails,
	// the value of self is undefined.
	//
	// The base argument must be 0 or a value between 2 and [MaxBase].
	// For base 0, the number prefix determines the actual base: A prefix of
	// “0b” or “0B” selects base 2, “0”, “0o” or “0O” selects base 8,
	// and “0x” or “0X” selects base 16. Otherwise, the selected base is 10
	// and no prefix is accepted.
	//
	// For bases <= 36, lower and upper case letters are considered the same:
	// The letters 'a' to 'z' and 'A' to 'Z' represent digit values 10 to 35.
	// For bases > 36, the upper case letters 'A' to 'Z' represent the digit
	// values 36 to 61.
	//
	// For base 0, an underscore character “_” may appear between a base
	// prefix and an adjacent digit, and between successive digits; such
	// underscores do not change the value of the number.
	// Incorrect placement of underscores is reported as an error if there
	// are no other errors. If base != 0, underscores are not recognized
	// and act like any other character that is not a valid digit.
	fn SetStr(mut *self, mut s: str, base: int): (ok: bool) {
		// determine sign
		mut neg := false
		if len(s) > 0 {
			match s[0] {
			| '-':
				neg = true
				fall
			| '+':
				s = s[1:] // remove sign
			}
		}

		// parse abs
		mut r := strScan.new(s)
		(self.abs), _, _, ok := scanW(self.abs[:0], &r, base, false)
		self.neg = len(self.abs) > 0 && neg // 0 has no sign
		if !ok {
			ret false
		}
		// entire content must have been consumed
		if len(r.s) != r.i {
			ret false
		}
		ret true
	}

	// Returns the i64 representation of x(self).
	// If x cannot be represented in an i64, the result is undefined.
	fn I64(*self): i64 {
		mut v := i64(low64W(self.abs))
		if self.neg {
			v = -v
		}
		ret v
	}

	// Returns the u64 representation of x(self).
	// If x cannot be represented in a u64, the result is undefined.
	fn U64(*self): u64 {
		ret low64W(self.abs)
	}

	// Reports whether x(self) can be represented as an i64.
	fn IsI64(*self): bool {
		if len(self.abs) <= 64/_W {
			w := i64(low64W(self.abs))
			ret w >= 0 || self.neg && w == -w
		}
		ret false
	}

	// Reports whether x(self) can be represented as a u64.
	fn IsU64(*self): bool {
		ret !self.neg && len(self.abs) <= 64/_W
	}

	// Returns string representation of x(self) in decimal format.
	fn Str(*self): str {
		ret self.Format(10)
	}

	// Returns the string representation of x(self) in the given base.
	// Base must be between 2 and 62, inclusive. The result uses the
	// lower-case letters 'a' to 'z' for digit values 10 to 35, and
	// the upper-case letters 'A' to 'Z' for digit values 36 to 61.
	// No prefix (such as "0x") is added to the string.
	fn Format(*self, b: int): str {
		ret unsafe::StrFromBytes(itoaW(self.abs, self.neg, b))
	}

	// Returns the f64 value nearest x(self),
	// and an indication of any rounding that occurred.
	fn F64(*self): (f64, Accuracy) {
		n := bitLenW(self.abs) // NB: still uses slow crypto impl!
		if n == 0 {
			ret 0.0, Exact
		}

		// Fast path: no more than 53 significant bits.
		if n <= 53 || n < 64 && n-int(trailingZeroBitsW(self.abs)) <= 53 {
			mut f := f64(low64W(self.abs))
			if self.neg {
				f = -f
			}
			ret f, Exact
		}
		mut f := float{}
		f.SetInt(self)
		ret f.F64()
	}
}

// Attempts to simulate several Euclidean update steps
// using the leading digits of A and B. It returns u0, u1, v0, v1
// such that A and B can be updated as:
//
//	A = u0*A + v0*B
//	B = u1*A + v1*B
//
// Requirements: A >= B and len(B.abs) >= 2
// Since we are calculating with full words to avoid overflow,
// we use 'even' to track the sign of the cosequences.
// For even iterations: u0, v1 >= 0 && u1, v0 <= 0
// For odd  iterations: u0, v1 <= 0 && u1, v0 >= 0
fn lehmerSimulate(A: Int, B: Int): (u0: Word, u1: Word, v0: Word, v1: Word, even: bool) {
	// initialize the digits
	mut a1 := Word(0)
	mut a2 := Word(0)
	mut u2 := Word(0)
	mut v2 := Word(0)

	m := len(B.abs) // m >= 2
	n := len(A.abs) // n >= m >= 2

	// extract the top Word of bits from A and B
	h := nlz(A.abs[n-1])
	a1 = A.abs[n-1]<<h | A.abs[n-2]>>(_W-h)
	// B may have implicit zero words in the high bits if the lengths differ
	match {
	| n == m:
		a2 = B.abs[n-1]<<h | B.abs[n-2]>>(_W-h)
	| n == m+1:
		a2 = B.abs[n-2] >> (_W - h)
	|:
		a2 = 0
	}

	// Since we are calculating with full words to avoid overflow,
	// we use 'even' to track the sign of the cosequences.
	// For even iterations: u0, v1 >= 0 && u1, v0 <= 0
	// For odd  iterations: u0, v1 <= 0 && u1, v0 >= 0
	// The first iteration starts with k=1 (odd).
	even = false
	// variables to track the cosequences
	u0, u1, u2 = 0, 1, 0
	v0, v1, v2 = 0, 0, 1

	// Calculate the quotient and cosequences using Collins' stopping condition.
	// Note that overflow of a Word is not possible when computing the remainder
	// sequence and cosequences since the cosequence size is bounded by the input size.
	// See section 4.2 of Jebelean for details.
	for a2 >= v2 && a1-a2 >= v1+v2 {
		q, r := a1/a2, a1%a2
		a1, a2 = a2, r
		u0, u1, u2 = u1, u2, u1+q*u2
		v0, v1, v2 = v1, v2, v1+q*v2
		even = !even
	}
	ret
}

// Updates the inputs A and B such that:
//
//	A = u0*A + v0*B
//	B = u1*A + v1*B
//
// where the signs of u0, u1, v0, v1 are given by even
// For even == true: u0, v1 >= 0 && u1, v0 <= 0
// For even == false: u0, v1 <= 0 && u1, v0 >= 0
// q, r, s, t are temporary variables to avoid allocations in the multiplication.
fn lehmerUpdate(mut &A: *Int, mut &B: *Int, mut &q: *Int, mut &r: *Int, mut &s: *Int, mut &t: *Int,
	u0: Word, u1: Word, v0: Word, v1: Word, even: bool) {
	setWV(&t.abs, u0)
	setWV(&s.abs, v0)
	t.neg = !even
	s.neg = even

	t.Mul(A, t)
	s.Mul(B, s)

	setWV(&r.abs, u1)
	setWV(&q.abs, v1)
	r.neg = even
	q.neg = !even

	r.Mul(A, r)
	q.Mul(B, q)

	A.Add(t, s)
	B.Add(r, q)
}

// Performs a single step of the Euclidean GCD algorithm
// if extended is true, it also updates the cosequence Ua, Ub.
fn euclidUpdate(mut &A: *Int, mut &B: *Int, mut &Ua: *Int, mut &Ub: *Int, mut &q: *Int,
	mut &r: *Int, mut &s: *Int, mut &t: *Int, extended: bool) {
	q.QuoRem(A, B, r)

	*A, *B, *r = *B, *r, *A

	if extended {
		// Ua, Ub = Ub, Ua - q*Ub
		t.Set(Ub)
		s.Mul(Ub, q)
		Ub.Sub(Ua, s)
		Ua.Set(t)
	}
}
// Copyright 2025 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/bytes"
use "std/conv"
use "std/unsafe"

impl float {
	// Converts the floating-point number x(self) to a string according
	// to the given format and precision prec. The format is one of:
	//
	//	'e'	-d.dddde±dd, decimal exponent, at least two (possibly 0) exponent digits
	//	'E'	-d.ddddE±dd, decimal exponent, at least two (possibly 0) exponent digits
	//	'f'	-ddddd.dddd, no exponent
	//	'g'	like 'e' for large exponents, like 'f' otherwise
	//	'G'	like 'E' for large exponents, like 'f' otherwise
	//	'x'	-0xd.dddddp±dd, hexadecimal mantissa, decimal power of two exponent
	//	'p'	-0x.dddp±dd, hexadecimal mantissa, decimal power of two exponent (non-standard)
	//	'b'	-ddddddp±dd, decimal mantissa, decimal power of two exponent (non-standard)
	//
	// For the power-of-two exponent formats, the mantissa is printed in normalized form:
	//
	//	'x'	hexadecimal mantissa in [1, 2), or 0
	//	'p'	hexadecimal mantissa in [½, 1), or 0
	//	'b'	decimal integer mantissa using x.Prec() bits, or 0
	//
	// Note that the 'x' form is the one used by most other languages and libraries.
	//
	// If format is a different character, Text returns a "%" followed by the
	// unrecognized format character.
	//
	// The precision prec controls the number of digits (excluding the exponent)
	// printed by the 'e', 'E', 'f', 'g', 'G', and 'x' formats.
	// For 'e', 'E', 'f', and 'x', it is the number of digits after the decimal point.
	// For 'g' and 'G' it is the total number of digits. A negative precision selects
	// the smallest number of decimal digits necessary to identify the value x uniquely
	// using x.Prec() mantissa bits.
	// The prec value is ignored for the 'b' and 'p' formats.
	fn Format(*self, format: byte, prec: int): str {
		mut cap := 10 // TODO: determine a good/better value here
		if prec > 0 {
			cap += prec
		}
		ret unsafe::StrFromBytes(self.Append(make([]byte, 0, cap), format, prec))
	}

	// Appends to buf the string form of the floating-point number x(self),
	// as generated by x.Format, and returns the extended buffer.
	fn Append(*self, mut buf: []byte, fmt: byte, mut prec: int): []byte {
		// sign
		if self.neg {
			buf = append(buf, '-')
		}

		// Inf
		if self.form == inf {
			if !self.neg {
				buf = append(buf, '+')
			}
			ret append(buf, "Inf"...)
		}

		// pick off easy formats
		match fmt {
		| 'b':
			ret self.fmtB(buf)
		| 'p':
			ret self.fmtP(buf)
		| 'x':
			ret self.fmtX(buf, prec)
		}

		// Algorithm:
		//   1) convert Float to multiprecision decimal
		//   2) round to desired precision
		//   3) read digits out and format

		// 1) convert Float to multiprecision decimal
		let mut d: decimal // == 0.0
		if self.form == finite {
			// self != 0
			d.init(self.mant, int(self.exp)-bitLenW(self.mant))
		}

		// 2) round to desired precision
		mut shortest := false
		if prec < 0 {
			shortest = true
			roundShortest(&d, self)
			// Precision for shortest representation mode.
			match fmt {
			| 'e' | 'E':
				prec = len(d.mant) - 1
			| 'f':
				prec = max(len(d.mant)-d.exp, 0)
			| 'g' | 'G':
				prec = len(d.mant)
			}
		} else {
			// round appropriately
			match fmt {
			| 'e' | 'E':
				// one digit before and number of digits after decimal point
				d.round(1 + prec)
			| 'f':
				// number of digits before and after decimal point
				d.round(d.exp + prec)
			| 'g' | 'G':
				if prec == 0 {
					prec = 1
				}
				d.round(prec)
			}
		}

		// 3) read digits out and format
		match fmt {
		| 'e' | 'E':
			ret fmtE(buf, fmt, prec, d)
		| 'f':
			ret fmtF(buf, prec, d)
		| 'g' | 'G':
			// trim trailing fractional zeros in %e format
			mut eprec := prec
			if eprec > len(d.mant) && len(d.mant) >= d.exp {
				eprec = len(d.mant)
			}
			// %e is used if the exponent from the conversion
			// is less than -4 or greater than or equal to the precision.
			// If precision was the shortest possible, use eprec = 6 for
			// this decision.
			if shortest {
				eprec = 6
			}
			exp := d.exp - 1
			if exp < -4 || exp >= eprec {
				if prec > len(d.mant) {
					prec = len(d.mant)
				}
				ret fmtE(buf, fmt+'e'-'g', prec-1, d)
			}
			if prec > d.exp {
				prec = len(d.mant)
			}
			ret fmtF(buf, max(prec-d.exp, 0), d)
		}

		// unknown format
		if self.neg {
			buf = buf[:len(buf)-1] // sign was added prematurely - remove it again
		}
		ret append(buf, '%', fmt)
	}

	// Appends the string of x(self) in the format mantissa "p" exponent
	// with a decimal mantissa and a binary exponent, or "0" if x is zero,
	// and returns the extended buffer.
	// The mantissa is normalized such that is uses x.Prec() bits in binary
	// representation.
	// The sign of x is ignored, and x must not be an Inf.
	// (The caller handles Inf before invoking fmtB.)
	fn fmtB(*self, mut buf: []byte): []byte {
		if self.form == zero {
			ret append(buf, '0')
		}

		if debugFloat && self.form != finite {
			panic("non-finite float")
		}
		// x != 0

		// adjust mantissa to use exactly x.prec bits
		mut m := unsafe { *(&self.mant) } // Do not mutate.
		w := u32(len(self.mant)) * _W
		match {
		| w < self.prec:
			mut r := []Word(nil)
			lshW(&r, m, uint(self.prec-w))
			m = r
		| w > self.prec:
			mut r := []Word(nil)
			rshW(&r, m, uint(w-self.prec))
			m = r
		}

		buf = append(buf, utoaW(m, 10)...)
		buf = append(buf, 'p')
		e := i64(self.exp) - i64(self.prec)
		if e >= 0 {
			buf = append(buf, '+')
		}
		ret conv::AppendInt(buf, e, 10)
	}

	// fmtX appends the string of x in the format "0x1." mantissa "p" exponent
	// with a hexadecimal mantissa and a binary exponent, or "0x0p0" if x is zero,
	// and returns the extended buffer.
	// A non-zero mantissa is normalized such that 1.0 <= mantissa < 2.0.
	// The sign of x is ignored, and x must not be an Inf.
	// (The caller handles Inf before invoking fmtX.)
	fn fmtX(*self, mut buf: []byte, prec: int): []byte {
		if self.form == zero {
			buf = append(buf, "0x0"...)
			if prec > 0 {
				buf = append(buf, '.')
				mut i := 0
				for i < prec; i++ {
					buf = append(buf, '0')
				}
			}
			buf = append(buf, "p+00"...)
			ret buf
		}

		if debugFloat && self.form != finite {
			panic("non-finite float")
		}

		// round mantissa to n bits
		let mut n: uint
		if prec < 0 {
			n = 1 + (self.MinPrec()-1+3)/4*4 // round MinPrec up to 1 mod 4
		} else {
			n = 1 + 4*uint(prec)
		}
		// n%4 == 1
		let mut x: float
		x.SetPrec(n)
		x.SetMode(self.mode)
		x.Set(*self)

		// adjust mantissa to use exactly n bits
		mut m := unsafe { *(&self.mant) } // Do not mutate.
		w := uint(len(self.mant)) * _W
		match {
		| w < n:
			mut r := []Word(nil)
			lshW(&r, m, n-w)
			m = r
		| w > n:
			mut r := []Word(nil)
			rshW(&r, m, w-n)
			m = r
		}
		mut exp64 := i64(self.exp) - 1 // avoid wrap-around

		hm := utoaW(m, 16)
		if debugFloat && hm[0] != '1' {
			panic("incorrect mantissa: " + str(hm))
		}
		buf = append(buf, "0x1"...)
		if len(hm) > 1 {
			buf = append(buf, '.')
			buf = append(buf, hm[1:]...)
		}

		buf = append(buf, 'p')
		if exp64 >= 0 {
			buf = append(buf, '+')
		} else {
			exp64 = -exp64
			buf = append(buf, '-')
		}
		// Force at least two exponent digits, to match fmt.
		if exp64 < 10 {
			buf = append(buf, '0')
		}
		ret conv::AppendInt(buf, exp64, 10)
	}

	// Appends the string of x(self) in the format "0x." mantissa "p" exponent
	// with a hexadecimal mantissa and a binary exponent, or "0" if x is zero,
	// and returns the extended buffer.
	// The mantissa is normalized such that 0.5 <= 0.mantissa < 1.0.
	// The sign of x is ignored, and x must not be an Inf.
	// (The caller handles Inf before invoking fmtP.)
	fn fmtP(*self, mut buf: []byte): []byte {
		if self.form == zero {
			ret append(buf, '0')
		}

		if debugFloat && self.form != finite {
			panic("non-finite float")
		}
		// self != 0

		// remove trailing 0 words early
		// (no need to convert to hex 0's and trim later)
		mut m := unsafe { *(&self.mant) } // Do not mutate.
		mut i := 0
		for i < len(m) && m[i] == 0 {
			i++
		}
		m = m[i:]

		buf = append(buf, "0x."...)
		buf = append(buf, bytes::TrimRight(utoaW(m, 16), "0")...)
		buf = append(buf, 'p')
		if self.exp >= 0 {
			buf = append(buf, '+')
		}
		ret conv::AppendInt(buf, i64(self.exp), 10)
	}
}

// %e: d.ddddde±dd
fn fmtE(mut buf: []byte, fmt: byte, prec: int, d: decimal): []byte {
	// first digit
	mut ch := byte('0')
	if len(d.mant) > 0 {
		ch = d.mant[0]
	}
	buf = append(buf, ch)

	// .moredigits
	if prec > 0 {
		buf = append(buf, '.')
		mut i := 1
		m := min(len(d.mant), prec+1)
		if i < m {
			buf = append(buf, d.mant[i:m]...)
			i = m
		}
		for i <= prec; i++ {
			buf = append(buf, '0')
		}
	}

	// e±
	buf = append(buf, fmt)
	let mut exp: i64
	if len(d.mant) > 0 {
		exp = i64(d.exp) - 1 // -1 because first digit was printed before '.'
	}
	if exp < 0 {
		ch = '-'
		exp = -exp
	} else {
		ch = '+'
	}
	buf = append(buf, ch)

	// dd...d
	if exp < 10 {
		buf = append(buf, '0') // at least 2 exponent digits
	}
	ret conv::AppendInt(buf, exp, 10)
}

// %f: ddddddd.ddddd
fn fmtF(mut buf: []byte, prec: int, d: decimal): []byte {
	// integer, padded with zeros as needed
	if d.exp > 0 {
		mut m := min(len(d.mant), d.exp)
		buf = append(buf, d.mant[:m]...)
		for m < d.exp; m++ {
			buf = append(buf, '0')
		}
	} else {
		buf = append(buf, '0')
	}

	// fraction
	if prec > 0 {
		buf = append(buf, '.')
		mut i := 0
		for i < prec; i++ {
			buf = append(buf, d.at(d.exp+i))
		}
	}

	ret buf
}

fn roundShortest(mut &d: *decimal, &x: *float) {
	// if the mantissa is zero, the number is zero - stop now
	if len(d.mant) == 0 {
		ret
	}

	// Approach: All numbers in the interval [x - 1/2ulp, x + 1/2ulp]
	// (possibly exclusive) round to x for the given precision of x.
	// Compute the lower and upper bound in decimal form and find the
	// shortest decimal number d such that lower <= d <= upper.

	// TODO: conv/ftoa describes a shortcut in some cases.
	// See if we can use it (in adjusted form) here as well.

	// 1) Compute normalized mantissa mant and exponent exp for x such
	// that the lsb of mant corresponds to 1/2 ulp for the precision of
	// x (i.e., for mant we want x.prec + 1 bits).
	mut mant := []Word(nil)
	setWW(&mant, x.mant)
	mut exp := int(x.exp) - bitLenW(mant)
	s := bitLenW(mant) - int(x.prec+1)
	match {
	| s < 0:
		lshW(&mant, mant, uint(-s))
	| s > 0:
		rshW(&mant, mant, uint(+s))
	}
	exp += s
	// x = mant * 2**exp with lsb(mant) == 1/2 ulp of x.prec

	// 2) Compute lower bound by subtracting 1/2 ulp.
	let mut lower: decimal
	let mut tmp: []Word
	subW(&tmp, mant, wordOne)
	lower.init(tmp, exp)

	// 3) Compute upper bound by adding 1/2 ulp.
	let mut upper: decimal
	addW(&tmp, mant, wordOne)
	upper.init(tmp, exp)

	// The upper and lower bounds are possible outputs only if
	// the original mantissa is even, so that ToNearestEven rounding
	// would round to the original mantissa and not the neighbors.
	inclusive := mant[0]&2 == 0 // test bit 1 since original mantissa was shifted by 1

	// Now we can figure out the minimum number of digits required.
	// Walk along until d has distinguished itself from upper and lower.
	for i, m in d.mant {
		l := lower.at(i)
		u := upper.at(i)

		// Okay to round down (truncate) if lower has a different digit
		// or if lower is inclusive and is exactly the result of rounding
		// down (i.e., and we have reached the final digit of lower).
		okdown := l != m || inclusive && i+1 == len(lower.mant)

		// Okay to round up if upper has a different digit and either upper
		// is inclusive or upper is bigger than the result of rounding up.
		okup := m != u && (inclusive || m+1 < u || i+1 < len(upper.mant))

		// If it's okay to do either, then round to the nearest one.
		// If it's okay to do only one, do it.
		match {
		| okdown && okup:
			d.round(i + 1)
			ret
		| okdown:
			d.roundDown(i + 1)
			ret
		| okup:
			d.roundUp(i + 1)
			ret
		}
	}
}
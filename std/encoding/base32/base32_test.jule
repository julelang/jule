// Copyright 2024 The Jule Project Contributors. All rights reserved.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/strings"
use "std/testing"

let encodeDecodeMap = [
	// RFC 4648 examples.
	[[]byte(""), []byte("")],
	[[]byte("f"), []byte("MY======")],
	[[]byte("fo"), []byte("MZXQ====")],
	[[]byte("foo"), []byte("MZXW6===")],
	[[]byte("foob"), []byte("MZXW6YQ=")],
	[[]byte("fooba"), []byte("MZXW6YTB")],
	[[]byte("foobar"), []byte("MZXW6YTBOI======")],

	// Wikipedia examples, converted to base32.
	[[]byte("sure."), []byte("ON2XEZJO")],
	[[]byte("sure"), []byte("ON2XEZI=")],
	[[]byte("sur"), []byte("ON2XE===")],
	[[]byte("su"), []byte("ON2Q====")],
	[[]byte("leasure."), []byte("NRSWC43VOJSS4===")],
	[[]byte("easure."), []byte("MVQXG5LSMUXA====")],
	[[]byte("asure."), []byte("MFZXK4TFFY======")],
]

#test
fn testEncode(t: &testing::T) {
	for _, case in encodeDecodeMap {
		mut r := make([]byte, StdEncoding.EncodedLen(len(case[0])))
		StdEncoding.Encode(r, case[0])
		d := case[1]
		if len(r) != len(d) {
			t.Fail()
			continue
		}
		for i in r {
			if r[i] != d[i] {
				t.Fail()
				break
			}
		}
	}
}

#test
fn testAppendEncode(t: &testing::T) {
	for _, case in encodeDecodeMap {
		r := StdEncoding.AppendEncode(nil, case[0])
		d := case[1]
		if len(r) != len(d) {
			t.Fail()
			continue
		}
		for i in r {
			if r[i] != d[i] {
				t.Fail()
				break
			}
		}
	}
}

#test
async fn testEncoder(t: &testing::T) {
	for _, case in encodeDecodeMap {
		mut sb := new(strings::Builder)
		mut enc := NewEncoder(StdEncoding, sb.Async())
		enc.Write([]byte(case[0])).await!
		enc.Close().await!
		r := sb.Str()
		d := case[1]
		if len(r) != len(d) {
			t.Fail()
			continue
		}
		for i in r {
			if r[i] != d[i] {
				println(r)
				println(str(d))
				t.Fail()
				break
			}
		}
	}
}

#test
fn testEncodeToStr(t: &testing::T) {
	for _, case in encodeDecodeMap {
		r := StdEncoding.EncodeToStr(case[0])
		d := case[1]
		if len(r) != len(d) {
			t.Fail()
			continue
		}
		for i in r {
			if r[i] != d[i] {
				t.Fail()
				break
			}
		}
	}
}

#test
fn testDecode(t: &testing::T) {
	for _, case in encodeDecodeMap {
		mut r := make([]byte, StdEncoding.DecodedLen(len(case[1])))
		n := StdEncoding.Decode(r, case[1])!
		r = r[:n]
		d := case[0]
		if len(r) != len(d) {
			t.Fail()
			continue
		}
		for i in r {
			if r[i] != d[i] {
				t.Fail()
				break
			}
		}
	}
}

#test
fn testAppendDecode(t: &testing::T) {
	for _, case in encodeDecodeMap {
		r := StdEncoding.AppendDecode(nil, case[1])!
		d := case[0]
		if len(r) != len(d) {
			t.Fail()
			continue
		}
		for i in r {
			if r[i] != d[i] {
				t.Fail()
				break
			}
		}
	}
}

#test
fn testDecodeStr(t: &testing::T) {
	for _, case in encodeDecodeMap {
		r := StdEncoding.DecodeStr(str(case[1]))!
		d := case[0]
		if len(r) != len(d) {
			t.Fail()
			continue
		}
		for i in r {
			if r[i] != d[i] {
				t.Fail()
				break
			}
		}
	}
}

#test
async fn testDecoder(t: &testing::T) {
	for _, case in encodeDecodeMap {
		mut r := make([]byte, StdEncoding.DecodedLen(len(case[1])))
		mut dec := NewDecoder(StdEncoding, strings::Reader.New(str(case[1])).Async())
		n := dec.Read(r).await!
		r = r[:n]
		d := case[0]
		if len(r) != len(d) {
			t.Fail()
			continue
		}
		for i in r {
			if r[i] != d[i] {
				t.Fail()
				break
			}
		}
	}
}

fn removePad(b: []byte, padByte: byte): []byte {
	mut bm := unsafe { *(&b) }
	mut i := len(b) - 1
	for i >= 0 && b[i] == padByte; i-- {
	}
	ret bm[:i+1]
}

#test
fn testEncodeNoPad(t: &testing::T) {
	stdNoPaddingEncode := Encoding.New("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", NoPadding)
	for _, case in encodeDecodeMap {
		mut r := make([]byte, stdNoPaddingEncode.EncodedLen(len(case[0])))
		stdNoPaddingEncode.Encode(r, case[0])
		d := removePad(case[1], '=')
		if len(r) != len(d) {
			t.Fail()
			continue
		}
		for i in r {
			if r[i] != d[i] {
				t.Fail()
				break
			}
		}
	}
}

#test
fn testDecodeNoPad(t: &testing::T) {
	stdNoPaddingEncode := Encoding.New("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", NoPadding)
	for _, case in encodeDecodeMap {
		case1 := removePad(case[1], '=')
		mut r := make([]byte, stdNoPaddingEncode.DecodedLen(len(case1)))
		n := stdNoPaddingEncode.Decode(r, case1)!
		r = r[:n]
		d := removePad(case[0], '=')
		if len(r) != len(d) {
			t.Fail()
			continue
		}
		for i in r {
			if r[i] != d[i] {
				t.Fail()
				break
			}
		}
	}
}
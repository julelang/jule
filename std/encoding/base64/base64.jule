// Copyright 2023-2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

// Table for standard base64 encoding, as defined in RFC 4648.
static t64e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"

// Decoding table for t64e.
static t64d: [...]i32 = [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 62, 63, 62, 62, 63, 52, 53, 54, 55,
    56, 57, 58, 59, 60, 61, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6,
    7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 0,
    0, 0, 0, 63, 0, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
    41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51,
]

// Standard byte for padding.
const paddingByte = '='

// Returns length of encoded bytes of b.
fn EncodeLen(b: []byte, pad: bool): int {
    if !pad {
        ret len(b) / 3 << 2 + (len(b) % 3 * 8 + 5) / 6
    }
    ret (len(b) + 2) / 3 << 2
}

fn decodeLen(&b: []byte): (n: int, l: int, pad1: bool, pad2: bool) {
    if len(b) == 0 {
        ret
    }
    let p = &b[0]
    pad1 = len(b) > 0 && (len(b)%4 != 0 || unsafe { p[len(b)-1] } == paddingByte)
    l = (len(b) + 3) / 4
    if pad1 {
        l--
    }
    l = l << 2
    pad2 = pad1 && len(b) > l+2 && unsafe { p[l+2] } != paddingByte
    n = l >> 2 * 3
    if pad1 {
        n++
        if pad2 {
            n++
        }
    }
    ret
}

fn encode(&src: []byte, pad: bool): []byte {
    let n = EncodeLen(src, pad)
    if n <= len(src) {
        ret nil
    }
    let mut dest = make([]byte, n)
    let mut j = &dest[0]
    let mut i = &src[0]
    let end = i + len(src)
    let table = &t64e[0]
    for i+3 <= end; i += 3 {
        unsafe {
            *j = table[i[0]>>2]
            j++
            *j = table[((i[0]&0x03)<<4)|(i[1]>>4)]
            j++
            *j = table[((i[1]&0x0f)<<2)|(i[2]>>6)]
            j++
            *j = table[i[2]&0x3f]
            j++
        }
    }
    if i < end {
        unsafe {
            *j = table[i[0]>>2]
            j++
            if i+1 == end {
                *j = table[(i[0]&0x03)<<4]
                j++
                if pad {
                    *j = paddingByte
                    j++
                }
            } else {
                *j = table[((i[0]&0x03)<<4)|(i[1]>>4)]
                j++
                *j = table[(i[1]&0x0f)<<2]
                j++
            }
            if pad {
                *j = paddingByte
                j++
            }
        }
    }
    ret dest
}

// Encodes source bytes with standard base64 table.
// Returns encoded base64 bytes if success, nil slice if not.
// Adds padding if pad is true.
fn Encode(src: []byte, pad: bool): []byte {
    ret encode(src, pad)
}

// Encodes source bytes with url base64 table.
// It is typically used for URLs and file names.
// Returns encoded base64 bytes if success, nil slice if not.
fn EncodeUrl(src: []byte): []byte {
    const Padding = false
    let mut r = encode(src, Padding)
    for i, b in r {
        match b {
        | '+':
            r[i] = '-'
        | '/':
            r[i] = '_'
        }
    }
    ret r
}

fn decode(&src: []byte): []byte {
    let (n, l, pad1, pad2) = decodeLen(src)
    if n == 0 {
        ret nil
    }
    let mut dest = make([]byte, n)

    let mut d = &dest[0]
    let p = &src[0]

    // Use pointer for table to skip boundary-checking cost.
    let ip = &t64d[0]

    let mut i = 0
    for i < l; i += 4 {
        unsafe {
            let k = ip[p[i]] << 18 | ip[p[i+1]] << 12 | ip[p[i+2]] << 6 | ip[p[i+3]]
            *d = byte(k >> 16)
            d++
            *d = byte(k >> 8 & 0xFF)
            d++
            *d = byte(k & 0xFF)
            d++
        }
    }
    if pad1 {
        unsafe {
            let mut k = ip[p[l]] << 18 | ip[p[l+1]] << 12
            *d = byte(k >> 16)
            if pad2 {
                d++
                k |= ip[p[l+2]] << 6
                *d = byte(k >> 8 & 0xFF)
            }
        }
    }
    ret dest
}

// Decodes source bytes with standard base64 table.
// Returns decoded bytes if success, nil slice if not.
// Detects padding by default, no required padding specification.
fn Decode(src: []byte): []byte {
    ret decode(src)
}

// Decodes source bytes with url base64 table.
// It is typically used for URLs and file names.
// Returns decoded bytes if success, nil slice if not.
fn DecodeUrl(src: []byte): []byte {
    ret decode(src)
}
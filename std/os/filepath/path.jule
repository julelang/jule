// Copyright 2023-2025 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/internal/os/filepathlite"

// Operating system specific path separator.
const Separator = filepathlite::Separator

// Operating system specific path list separator.
const ListSeparator = filepathlite::ListSeparator

// Returns the shortest path name equivalent to path
// by purely lexical processing. It applies the following rules
// iteratively until no further processing can be done:
//
//  1. Replace multiple SEPARATOR elements with a single one.
//  2. Eliminate each . path name element (the current directory).
//  3. Eliminate each inner .. path name element (the parent directory)
//     along with the non-.. element that precedes it.
//  4. Eliminate .. elements that begin a rooted path:
//     that is, replace "/.." by "/" at the beginning of a path,
//     assuming SEPARATOR is '/'.
//
// The returned path ends in a slash only if it represents a root directory,
// such as "/" on Unix or `C:\` on Windows.
//
// Finally, any occurrences of slash are replaced by SEPARATOR.
//
// If the result of this process is an empty string, clean
// returns the string ".".
//
// On Windows, clean does not modify the volume name other than to replace
// occurrences of "/" with `\`.
// For example, clean("//host/share/../x") returns `\\host\share\x`.
//
// See also Rob Pike, “Lexical File Names in Plan 9 or Getting Dot-Dot Right”
// https://9p.io/sys/doc/lexnames.html
fn Clean(path: str): str {
	ret filepathlite::Clean(path)
}

// Returns the result of replacing each separator character
// in path with a slash ('/') character. Multiple separators are
// replaced by multiple slashes.
fn ToSlash(path: str): str {
	ret filepathlite::ToSlash(path)
}

// Returns the result of replacing each slash ('/') character
// in path with a separator character. Multiple slashes are replaced
// by multiple separators.
fn FromSlash(path: str): str {
	ret filepathlite::FromSlash(path)
}

// Joins any number of path elements into a single path,
// separating them with an OS specific SEPARATOR. Empty elements
// are ignored. The result is cleaned. However, if the argument
// list is empty or all its elements are empty, join returns
// an empty string.
// On Windows, the result will only be a UNC path if the first
// non-empty element is a UNC path.
fn Join(elem: ...str): str {
	ret filepathlite::Join(elem...)
}

// Returns the file name extension used by path.
// The extension is the suffix beginning at the final dot
// in the final element of path; it is empty if there is no dot.
fn Ext(path: str): str {
	ret filepathlite::Ext(path)
}

// Returns an absolute representation of path.
// If the path is not absolute it will be joined with the current
// working directory to turn it into an absolute path. The absolute
// path name for a given file is not guaranteed to be unique.
// abs calls clean on the result.
fn Abs(path: str)!: str {
	ret filepathlite::Abs(path) else { error(error) }
}

// Returns the last element of path.
// Trailing path separators are removed before extracting the last element.
// If the path is empty, base returns ".".
// If the path consists entirely of separators, base returns a single separator.
fn Base(mut path: str): str {
	ret filepathlite::Base(path)
}

// Returns all but the last element of path, typically the path's directory.
// After dropping the final element, dir calls clean on the path and trailing
// slashes are removed.
// If the path is empty, dir returns ".".
// If the path consists entirely of separators, dir returns a single separator.
// The returned path does not end in a separator unless it is the root directory.
fn Dir(path: str): str {
	ret filepathlite::Dir(path)
}

// Returns leading volume name.
// Given "C:\foo\bar" it returns "C:" on Windows.
// Given "\\host\share\foo" it returns "\\host\share".
// On other platforms it returns empty string.
fn VolumeName(path: str): str {
	ret filepathlite::VolumeName(path)
}

// Reports whether the path is absolute.
fn IsAbs(path: str): bool {
	ret filepathlite::IsAbs(path)
}

// Reports whether c is path separator.
fn IsPathSeparator(c: byte): bool {
	ret filepathlite::IsPathSeparator(c)
}
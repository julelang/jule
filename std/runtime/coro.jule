// Copyright 2025 The Jule Project Contributors. All rights reserved.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

// Jule coroutine handle type.
#typedef
extern struct __jule_cHandle {
	address: fn(): *unsafe
	resume:  fn()       // Resume execution.
	done:    fn(): bool // Reports whether the coroutine is done.
	destroy: fn()       // Destroys coroutine.
}

// Type alias for extern Jule coroutine handle.
type cHandle = extern.__jule_cHandle

const (
	// State flags of coroutines.
	coroRunning = 1 << iota
	coroSuspended
	coroClosed

	// State flags of coroutines for suspend reason.
	reasonNA          = 0
	reasonRecv        = 1 << iota // Channel-recv.
	reasonSend                    // Channel-send.
	reasonWaitGroup               // WaitGroup.
	reasonMutex                   // Mutex.
	reasonCond                    // Condition variable.
	reasonSelect                  // Header group specifier of select statement.
	reasonSelectEmpty             // Empty select statement state. Use like reasonSelect&reasonSelectEmpty.
	reasonSleep                   // Sleep.
	reasonBlocking                // Waits for a blocking task.
	reasonIOWait                  // Waits for a pollable I/O.

	reasonMask = reasonRecv | reasonSend | reasonWaitGroup | reasonMutex |
		reasonCond | reasonSelect | reasonSelectEmpty | reasonSleep |
		reasonBlocking | reasonIOWait
)

// A Jule coroutine.
//
// When represented on the C++ side,
// a C must be trivially destructible and copyable.
struct c {
	// Handle of the C.
	handle: cHandle

	// State and suspend reasons if it is suspended.
	// The reasons may be not zeroed after C closed or woken.
	state: u32

	// A flag invented to prevent short-lived race conditions.
	race: u32
}

// Creates new C with the handle.
// Ready for the resume call.
#disable nilptr boundary
fn newc(h: cHandle): c {
	let mut c: c
	c.state |= coroSuspended
	c.handle = h
	ret c
}

// Appends the main C of the program.
// Implicitly called by the compiler to add the main C.
#disable nilptr
fn spawnmainc(h: cHandle) {
	mut m := gett()
	m.pp.runnext.used = true
	m.pp.runnext.c = newc(h)
}

// A low level API function for Jule Cs.
// It doesn't provide much abstraction.
// It just creates a C using API.
// The handle h is the handle of the C.
#export "__jule_cospawn"
#disable nilptr
async fn cospawn(h: cHandle) {
	mut c := newc(h)
	mut m := gett()
	overflow := runqput(m.pp, &c, true)
	wakep()
	// If an overflow occurs in the global runnable queue, yield this C.
	// This allows the runtime to wait briefly before creating more
	// Cs and gives other Cs a chance to run.
	// It is also effective at reducing memory usage.
	if overflow {
		Yield().await
	}
}

// Resumes execution of cp.
#disable nilptr
fn resume(&cp: *c) {
	cp.handle.resume()
}

// Reports whether cp done.
#disable nilptr
fn done(&cp: *c): bool {
	ret cp.handle.done()
}

// Closes cp, releases memory.
#disable nilptr
fn close(&cp: *c) {
	cp.handle.destroy()
}

// A coroq C.
struct coroqc {
	// The C.
	c: c

	// Pointer to the previous corotuine.
	prev: &coroqc

	// Pointer to the next C.
	next: &coroqc
}

// A C doubly linked-list queue.
// Not safe for concurrent use.
struct coroq {
	head: &coroqc
	tail: &coroqc
	len:  int
}

impl coroq {
	// Appends cp to the queue.
	#disable nilptr
	fn push(mut *self, mut &cp: *c) {
		mut qc := new(coroqc)
		qc.c = *cp
		self.pushq(qc)
	}

	// Same as push, but takes a coroq.
	#disable nilptr
	fn pushq(mut *self, mut qc: &coroqc) {
		if self.tail == nil {
			self.head = qc
			self.tail = qc
		} else {
			qc.prev = self.tail
			self.tail.next = qc
			self.tail = qc
		}
		self.len++
	}

	// Removes c from the queue.
	#disable nilptr
	fn remove(mut *self, mut c: &coroqc) {
		if c.prev != nil {
			c.prev.next = c.next
		} else {
			self.head = c.next
		}
		if c.next != nil {
			c.next.prev = c.prev
		} else {
			self.tail = c.prev
		}
		c.prev = nil
		c.next = nil
		self.len--
	}
}
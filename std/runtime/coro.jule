// Copyright 2025 The Jule Project Contributors. All rights reserved.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

extern use "std/runtime/coroutine.hpp"

// Jule coroutine handle type.
#typedef
extern struct __jule_coroutineHandle {
	address: fn(): *unsafe
	resume:  fn()       // Resume execution.
	done:    fn(): bool // Reports whether the coroutine is done.
	destroy: fn()       // Destroys coroutine.
}

// Type alias for extern Jule coroutine.
type coroutineHandle = extern.__jule_coroutineHandle

// Coroutine handle pointer to capture park handles.
extern let mut __jule_parkhandle: *coroutineHandle

// Mutex address to release before yield for park.
extern let mut __jule_parkmu: uintptr

// Destroys all retired coroutine frames for the current worker thread.
extern fn __jule_retireDrain()

const (
	// State flags of coroutines.
	coroRunning = 1 << iota
	coroSuspended
	coroClosed
	coroMain // Coroutine is the main coroutine.

	// State flags of coroutines for suspend reason.
	reasonNA          = 0
	reasonRecv        = 1 << iota // Channel-recv.
	reasonSend                    // Channel-send.
	reasonWaitGroup               // WaitGroup.
	reasonMutex                   // Mutex.
	reasonCond                    // Condition variable.
	reasonSelect                  // Header group specifier of select statement.
	reasonSelectEmpty             // Empty select statement state. Use like reasonSelect&reasonSelectEmpty.

	reasonMask = reasonRecv | reasonSend | reasonWaitGroup | reasonMutex |
		reasonCond | reasonSelect | reasonSelectEmpty
)

// A Jule coroutine.
struct coro {
	// Handle of the coroutine.
	handle: coroutineHandle

	// Coroutine state and suspend reasons if it is suspended.
	// The reasons may be not zeroed after thread closed or woken.
	state: u32
}

// Creates new coroutine with the handle.
// Ready for the resume call.
#disable nilptr boundary
fn newcoro(h: coroutineHandle): &coro {
	mut c := new(coro)
	c.state |= coroSuspended
	c.handle = h
	ret c
}

// Appends the main coroutine of the program.
// Implicitly called by the compiler to add the main coroutine.
#disable nilptr
fn spawnmaincoro(h: coroutineHandle) {
	mut c := newcoro(h)
	c.state |= coroMain
	threadHead.proc.runnext = c
}

// A low level API function for Jule coroutines.
// It doesn't provide much abstraction.
// It just creates a coroutine using API.
// The coroutine handle h is the handle of the coroutine.
#export "__jule_cospawn"
fn cospawn(h: coroutineHandle) {
	mut c := newcoro(h)
	runqput(&c, true)
}

// Basic resume primitive for the coroutine c.
#disable nilptr
fn resume(mut c: &coro) {
	c.handle.resume()
}

// Reports whether the coroutine done.
fn done(c: &coro): bool {
	ret c.handle.done()
}

// Closes coroutine, releases memory.
fn close(mut c: &coro) {
	c.handle.destroy()
	c = nil
}

// Suspends the current coroutine and yields the CPU.
// If the mu is not zero, assumes it already locked and releases before yield.
// The coroutine can be made runnable again by calling [unpark].
//
// The coroutine rc is the resume coroutine.
// Compiler will write the handle to it, resume(rc) must be used to resume.
//
// This function will compile inlinely by the compiler.
// The function must implement additional behavior before the park.
// Compiler will park the coroutine at the placeholder comment.
#disable nilptr
async fn park(mut rc: &coro, mu: uintptr, mut reason: u32) {
	mut c := gett().coro
	c.state |= coroSuspended | reason
	setparkhandle(rc)
	setparkmutex(mu)
	// park(c)
}

// Unlocks mutex mu, if it is not zero.
// The mu must point to the `fmutex` memory layout.
#export "__jule_mutexUnlock"
fn mutexunlock(mu: uintptr) {
	if mu != 0 {
		// Assume fmutex and qmutex have the same memory layout and
		// implementation for unlock.
		unsafe { (*fmutex)(mu).unlock() }
	}
}

// Makes coroutine c runnable.
#disable nilptr
fn unpark(mut &c: *&coro) {
	(*c).state &= ^reasonMask
	runqput(c, true)
}

// Sets handle receiver for the park.
#disable nilptr
fn setparkhandle(mut c: &coro) {
	if c != nil {
		extern.__jule_parkhandle = &c.handle
	} else {
		extern.__jule_parkhandle = nil
	}
}

// Sets mutex for the park.
fn setparkmutex(mu: uintptr) {
	extern.__jule_parkmu = mu
}

// Destroys all retired coroutine frames for the current worker thread.
fn retiredrain() {
	extern.__jule_retireDrain()
}

// A coroq coroutine.
struct coroqc {
	// The coroutine.
	coro: &coro

	// Pointer to the previous corotuine.
	prev: &coroqc

	// Pointer to the next coroutine.
	next: &coroqc
}

// A coroutine doubly linked-list queue.
// Not safe for concurrent use.
struct coroq {
	len:  int
	head: &coroqc
	tail: &coroqc
}

impl coroq {
	// Appends coroutine c to the queue.
	#disable nilptr
	fn push(mut *self, mut c: &coro) {
		mut qc := new(coroqc)
		qc.coro = c
		self.pushq(qc)
	}

	// Appends coroutine c to front of the queue.
	#disable nilptr
	fn pushFront(mut *self, mut c: &coro) {
		mut qc := new(coroqc)
		qc.coro = c
		if self.tail == nil {
			self.head = qc
			self.tail = qc
		} else {
			qc.next = self.head
			self.head.prev = qc
			self.head = qc
		}
		self.len++
	}

	// Same as push, but takes a coroq.
	#disable nilptr
	fn pushq(mut *self, mut qc: &coroqc) {
		if self.tail == nil {
			self.head = qc
			self.tail = qc
		} else {
			qc.prev = self.tail
			self.tail.next = qc
			self.tail = qc
		}
		self.len++
	}

	// Removes coroutine c from the queue.
	#disable nilptr
	fn remove(mut *self, mut c: &coroqc) {
		if c.prev != nil {
			c.prev.next = c.next
		} else {
			self.head = c.next
		}
		if c.next != nil {
			c.next.prev = c.prev
		} else {
			self.tail = c.prev
		}
		c.prev = nil
		c.next = nil
		self.len--
	}
}
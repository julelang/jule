// Copyright 2024 The Jule Project Contributors. All rights reserved.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

// Implements pseudo-random number generator (PRNG) based on PCG.
// See https://www.pcg-random.org
// See O’neill, M. E. (2014). “PCG: A family of simple fast space-efficient
//     statistically good algorithms for random number generation.
//     ACM Transactions on Mathematical Software.”
struct randmach {
	mu: qmutex

	mut lo: u64
	mut hi: u64
}

impl randmach {
	// This function initializes the internal state array with seed.
	fn init(*self, seed1: u64, seed2: u64) {
		self.lo = seed1
		self.hi = seed2
	}

	fn next(*self): u64 {
		// The Jule code is a modified version of the original Go code from
		// https://github.com/golang/go/blob/a947912d8ad5398a78f14ceaa80369f60a3f85f8/src/math/rand/v2/pcg.go

		// https://github.com/imneme/pcg-cpp/blob/428802d1a5/include/pcg_random.hpp#L161
		//
		// Numpy's PCG multiplies by the 64-bit value cheapMul
		// instead of the 128-bit value used here and in the official PCG code.
		// This does not seem worthwhile, at least for Go: not having any high
		// bits in the multiplier reduces the effect of low bits on the highest bits,
		// and it only saves 1 multiply out of 3.
		// (On 32-bit systems, it saves 1 out of 6, since Mul64 is doing 4.)
		const (
			mulHi = 2549297995355413924
			mulLo = 4865540595714422341
			incHi = 6364136223846793005
			incLo = 1442695040888963407
		)

		self.mu.lock()

		// state = state * mul + inc
		mut hi, mut lo := mul64(self.lo, mulLo)
		hi = hi + self.hi*mulLo + self.lo*mulHi
		lo, c := add64(lo, incLo, 0)
		hi, _ = add64(hi, incHi, c)

		self.lo = lo
		self.hi = hi

		self.mu.unlock()

		// XSL-RR would be
		//	ret bits::RotateLeft64(lo^hi, -int(hi>>58))
		// but Numpy uses DXSM and O'Neill suggests doing the same.
		// See https://github.com/golang/go/issues/21835#issuecomment-739065688
		// and following comments.

		// DXSM "double xorshift multiply"
		// https://github.com/imneme/pcg-cpp/blob/428802d1a5/include/pcg_random.hpp#L1015

		// https://github.com/imneme/pcg-cpp/blob/428802d1a5/include/pcg_random.hpp#L176
		const cheapMul = 0xda942042e4dd58b5
		hi ^= hi >> 32
		hi *= cheapMul
		hi ^= hi >> 48
		hi *= (lo | 1)
		ret hi
	}

	// Same as next (stay sync), but not concurrency-safe.
	// See next for documentation.
	fn nextl(*self): u64 {
		const (
			mulHi = 2549297995355413924
			mulLo = 4865540595714422341
			incHi = 6364136223846793005
			incLo = 1442695040888963407
		)
		mut hi, mut lo := mul64(self.lo, mulLo)
		hi = hi + self.hi*mulLo + self.lo*mulHi
		lo, c := add64(lo, incLo, 0)
		hi, _ = add64(hi, incHi, c)
		self.lo = lo
		self.hi = hi
		const cheapMul = 0xda942042e4dd58b5
		hi ^= hi >> 32
		hi *= cheapMul
		hi ^= hi >> 48
		hi *= (lo | 1)
		ret hi
	}
}

// Runtime PRNG instance.
let __rand = randmach{}

// NOTE:
// Before initialization of runtime randmach instance, do not use it.
// If any initializer function uses random function directly or undirectly,
// be aware of that risk. Runtime randmach instance should be initialized before use.
fn randinit() {
	__rand.init(u64(nanotime()), u64(uintptr(&__rand)))
}

// Returns pseudo-random number from the global random state.
// It is safe for concurrent use by multiple coroutines.
fn randg(): u64 {
	ret __rand.next()
}

// Returns pseudo-random number from the thread local random state.
fn rand(): u64 {
	ret gett().rand.nextl()
}

// Like rand() % n but faster.
fn randn(n: u32): u32 {
	// See https://lemire.me/blog/2016/06/27/a-fast-alternative-to-the-modulo-reduction
	ret u32((u64(u32(rand())) * u64(n)) >> 32)
}

#disable nilptr
fn trandinit(mut t: &thread) {
	seed := randg()
	t.cheaprand = seed
	t.rand.init(seed, u64(nanotime()))
}

// A non-cryptographic-quality 32-bit random generator
// suitable for calling at very high frequency.
// it is "cheap" in the sense of both expense and quality.
#disable nilptr
fn cheaprand(): u32 {
	// Implement xorshift64+: 2 32-bit xorshift sequences added together.
	// Shift triplet [17,7,16] was calculated as indicated in Marsaglia's
	// Xorshift paper: https://www.jstatsoft.org/article/view/v008i14/xorshift.pdf
	m := gett()
	unsafe {
		mut t := (*[2]u32)(&m.cheaprand)
		mut s1, s0 := (*t)[0], (*t)[1]
		s1 ^= s1 << 17
		s1 = s1 ^ s0 ^ s1>>7 ^ s0>>16
		(*t)[0], (*t)[1] = s0, s1
		ret s0 + s1
	}
}

// A non-cryptographic-quality 63-bit random generator
// suitable for calling at very high frequency.
// it is "cheap" in the sense of both expense and quality.
fn cheaprand64(): i64 {
	ret i64(cheaprand())<<31 ^ i64(cheaprand())
}

// Like cheaprand() % n but faster.
fn cheaprandn(n: u32): u32 {
	// See https://lemire.me/blog/2016/06/27/a-fast-alternative-to-the-modulo-reduction/
	ret u32((u64(cheaprand()) * u64(n)) >> 32)
}
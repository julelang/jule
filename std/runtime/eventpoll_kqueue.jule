// Copyright 2025 The Jule Project Contributors. All rights reserved.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

#build darwin

use "std/internal/runtime"
use "std/internal/runtime/atomic"
use "std/sys"

extern use "<sys/event.h>"

extern let kqueue: *unsafe
extern let kevent: *unsafe

struct keventt {
	ident:  u64
	filter: i16
	flags:  u16
	fflags: u32
	data:   i64
	udata:  *unsafe
}

let mut kq: i32 = -1

fn eventpollinit() {
	kq = sys::Addrcall[i32](uintptr(extern.kqueue))
	if kq < 0 {
		panic("runtime: kqueue init failed")
	}
	// close-on-exec
	sys::Fcntl(int(kq), sys::F_SETFD, sys::FD_CLOEXEC) else {}
}

#disable nilptr boundary
fn eventpollopen(fd: u64, mut &pd: *polldesc)! {
	let mut ev: [2]keventt
	ev[0].ident = fd
	ev[0].filter = sys::EVFILT_READ
	ev[0].flags = sys::EV_ADD | sys::EV_CLEAR
	ev[0].fflags = 0
	ev[0].data = 0
	if runtime::PtrSize == 4 {
		// We only have a pointer-sized field to store into,
		// so on a 32-bit system we get no sequence protection.
		// TODO: If we notice any problems we could at least
		// steal the low-order 2 bits for a tiny sequence number.
		ev[0].udata = pd
	} else {
		tp := taggedPointerPack(pd, atomic::Load(&pd.fdseq, atomic::Acquire))
		ev[0].udata = unsafe { (*unsafe)(uintptr(tp)) }
	}
	ev[1] = ev[0]
	ev[1].filter = sys::EVFILT_WRITE
	r := sys::Addrcall[i32](uintptr(extern.kevent), kq, &ev[0], i32(2), (*unsafe)(nil), i32(0), (*unsafe)(nil))
	if r < 0 {
		error(sys::GetLastErrno())
	}
}

fn eventpollclose(fd: u64): sys::Errno {
	// Don't need to unregister because calling close()
	// on fd will remove any kevents that reference the descriptor.
	ret 0
}

// delay < 0: blocks indefinitely
// delay == 0: does not block, just polls
// delay > 0: block for up to that many nanoseconds
#disable nilptr boundary
fn eventpoll(delay: i64, mut &toRun: *[prunqsize]c): u32 {
	if kq == -1 {
		ret 0
	}
	let mut tsp: *sys::Timespec
	let mut ts: sys::Timespec
	if delay < 0 {
		tsp = nil
	} else if delay == 0 {
		tsp = &ts
	} else {
		setNsec(&ts, delay)
		if ts.Sec > 1e6 {
			// Darwin returns EINVAL if the sleep time is too long.
			ts.Sec = 1e6
		}
		tsp = &ts
	}
	let mut events: [64]keventt
retry:
	kn, e := kevent(kq, nil, 0, &events[0], i32(len(events)), tsp)
	n := int(kn)
	if n < 0 {
		// Ignore the ETIMEDOUT error for now, but try to dive deep and
		// figure out what really happened with n == ETIMEOUT,
		// see Go's iissue https://go.dev/issue/59679 for details.
		if e != sys::EINTR && e != sys::ETIMEDOUT {
			panic("runtime: eventpoll: kevent failed")
		}
		// If a timed sleep was interrupted, just return to
		// recalculate how long we should sleep now.
		if delay > 0 {
			ret 0
		}
		goto retry
	}
	mut i := 0
	mut b := u32(0)
	for i < n; i++ {
		&ev := &events[i]

		let mut mode: i32
		match ev.filter {
		| sys::EVFILT_READ:
			mode += 'r'

			// On some systems when the read end of a pipe
			// is closed the write end will not get a
			// EVFILT_WRITE event, but will get a
			// EVFILT_READ event with EV_EOF set.
			// Note that setting 'w' here just means that we
			// will wake up a coroutine waiting to write;
			// that coroutine will try the write again,
			// and the appropriate thing will happen based
			// on what that write returns (success, EPIPE, EAGAIN).
			if ev.flags&sys::EV_EOF != 0 {
				mode += 'w'
			}
		| sys::EVFILT_WRITE:
			mode += 'w'
		}
		if mode == 0 {
			continue
		}
		let mut &pd: *polldesc = nil
		let mut tag: uintptr
		if runtime::PtrSize == 4 {
			// No sequence protection on 32-bit systems.
			// See eventpollopen for details.
			unsafe { *(&pd) = &(*(*polldesc)(ev.udata)) }
			tag = 0
		} else {
			tp := taggedPointer(uintptr(ev.udata))
			unsafe { *(&pd) = &(*(*polldesc)(tp.pointer())) }
			tag = tp.tag()
			if atomic::Load(&pd.fdseq, atomic::Acquire) != tag {
				continue // stale
			}
		}
		pd.setEventErr(ev.flags == sys::EV_ERROR, tag)
		eventpollready(pd, mode, toRun, &b)
	}
	ret b
}

fn setNsec(mut &ts: *sys::Timespec, ns: i64) {
	ts.Sec = ns / 1e9
	ts.Nsec = ns % 1e9
}

fn kevent(kq: i32, &ev: *keventt, evn: i32, &ev2: *keventt, ev2n: i32, tm: *sys::Timespec): (n: i32, e: sys::Errno) {
	n = sys::Addrcall[i32](uintptr(extern.kevent), kq, ev, evn, ev2, ev2n, tm)
	if n < 0 {
		e = sys::GetLastErrno()
	}
	ret n, e
}
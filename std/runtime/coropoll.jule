// Copyright 2025 The Jule Project Contributors. All rights reserved.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

// Polls a coroutine.
#disable nilptr boundary
fn coropoll(): (polled: &coro) {
	gsched.enterspin()
	{
		mut t := gett()
		if t.proc.runnext != nil {
			polled = t.proc.runnext
			t.proc.runnext = nil
			goto ExitSpin
		}

		let mut ok: bool
		polled, ok = t.proc.runq.pop()
		if ok {
			goto ExitSpin
		}

		// Local queue is empty, pop from the global queue.
		gsched.runqmu.lock()
		if gsched.runq.head != nil {
			let mut batch: [coroprocRunQueueSize]&coro
			mut n := 0
			for n < coroprocRunQueueSize; n++ {
				if gsched.runq.head == nil {
					break
				}
				batch[n] = gsched.runq.head.coro
				gsched.runq.remove(gsched.runq.head)
			}
			gsched.runqmu.unlock()
			if n > 0 {
				polled = batch[0]
				mut i := 1
				for i < n; i++ {
					ok = t.proc.runq.push(batch[i])
					if !ok {
						panic("runtime: coroutine scheduler queue corruption")
					}
				}
				goto ExitSpin
			}
		} else {
			gsched.runqmu.unlock()
		}

		// Try to steal from a coroutine process.
		const StealTries = 4
		mut n := 0
		for n < StealTries; n++ {
			idx := absint(int(rand() % u64(len(gsched.procs))))
			mut proc := gsched.procs[idx]
			if proc == t.proc {
				continue
			}
			polled, ok = proc.runq.steal()
			if ok {
				goto ExitSpin
			}
		}

		mut delay := i64(-1)

		// Timer exist try eventpoll.
		mut now := nanotime()
		mut iodeadline := false // IO deadline found.
		if t.proc.timers.peek() != nil {
			// Check for already expired timers.
			n = 0
			for n < coroprocRunQueueSize; n++ {
				mut timer := t.proc.timers.peek()
				if timer == nil || timer.when > now {
					break
				}
				mut coro := t.proc.timers.pop().coro
				if coro != nil {
					if polled == nil {
						polled = coro
					} else {
						ok = t.proc.runq.push(coro)
						if !ok {
							panic("runtime: coroutine scheduler queue corruption")
						}
					}
				} else {
					iodeadline = true
				}
			}
			// If there is already a polled expired timer, do not eventpoll.
			// Return immediately.
			if polled != nil {
				goto ExitSpin
			}
			soonest := t.proc.timers.peek()
			if soonest != nil {
				delay = soonest.when - now
				if delay <= 0 {
					panic("runtime: inconsistent timer state")
				}
			}
		}
		// No timer found but IO deadline.
		// Check for waiting coroutines with deadline and make them runnable.
		if iodeadline && t.proc.pds.head != nil {
			mut q := t.proc.pds.head
			for {
				if n >= coroprocRunQueueSize || q == nil {
					break
				}
				q.mu.lock()
				if q.rdeadline <= now && q.rcoro != nil {
					ok = t.proc.runq.push(q.rcoro)
					if !ok {
						panic("runtime: coroutine scheduler queue corruption")
					}
					n++
				}
				if q.wdeadline <= now && q.wcoro != nil {
					ok = t.proc.runq.push(q.wcoro)
					if !ok {
						panic("runtime: coroutine scheduler queue corruption")
					}
					n++
				}
				if q.deadline <= now {
					if q.rcoro != nil {
						ok = t.proc.runq.push(q.rcoro)
						if !ok {
							panic("runtime: coroutine scheduler queue corruption")
						}
						n++
					}
					if q.wcoro != nil {
						ok = t.proc.runq.push(q.wcoro)
						if !ok {
							panic("runtime: coroutine scheduler queue corruption")
						}
						n++
					}
				}
				q.mu.unlock()
				q = q.next
			}
			polled, ok = t.proc.runq.pop()
			if !ok {
				panic("runtime: coroutine scheduler queue corruption")
			}
			goto ExitSpin
		}

		mut toRun := eventpoll(delay)
		// If we have toRun list, use these coroutines.
		// Some timer might be expired, they will be handled at next iteration.
		if toRun.len > 0 {
			// eventpoll always returns: len(toRun)<=cap(t.proc.runq)
			// So we can push all coroutine to the local queue of the process,
			// since it is empty and we are looking for coroutine from eventpoll.
			// Reserve the first coroutine for return and enqueue what remains.
			polled = toRun.head.coro
			toRun.remove(toRun.head)
			for toRun.head != nil {
				ok = t.proc.runq.push(toRun.head.coro)
				if !ok {
					panic("runtime: coroutine scheduler queue corruption")
				}
				toRun.remove(toRun.head)
			}
			goto ExitSpin
		}
	}
ExitSpin:
	gsched.exitspin()
	ret
}
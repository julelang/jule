// Copyright 2024 The Jule Project Contributors. All rights reserved.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/internal/cpu"
use "std/internal/runtime"
use "std/internal/runtime/atomic"

const semaRootSize = qmutexSize + runtime::SmartptrSize + 4 // +4 for u32

// Stores all space collections of sema.
struct semaRoot {
	lock:  qmutex
	treap: &parkerList // Root of balanced tree of unique waiters.
	nwait: u32         // Number of waiters. Read w/o the lock, should be atomic.
}

impl semaRoot {
	// Adds p to the blocked coroutines in semaRoot.
	#disable nilptr
	fn queue(mut *self, mut &sema: *u32, mut p: &parkerList, lifo: bool) {
		// The leaf may already used and some fields may be modified.
		// For example, a dequeued leaf may cannot acquaire sema and
		// enqueued again. So, data of old record may cause errors.
		// Reset them to default to avoid data misunderstanding.
		p.next = nil
		p.prev = nil
		p.ticket = 0
		p.stack = uintptr(sema)

		let mut last: &parkerList
		mut &pt := &self.treap
		mut t := *pt
		for t != nil; t = *pt {
			if t.stack == uintptr(sema) {
				// Already have sema in list.
				if lifo {
					// Substitute p in t's place in treap.
					*pt = p
					p.ticket = t.ticket
					p.parent = t.parent
					p.prev = t.prev
					p.next = t.next
					if p.prev != nil {
						p.prev.parent = p
					}
					if p.next != nil {
						p.next.parent = p
					}
					// Add t first in p's wait list.
					p.waitlink = t
					p.waittail = t.waittail
					if p.waittail == nil {
						p.waittail = t
					}
					t.parent = nil
					t.prev = nil
					t.next = nil
					t.waittail = nil
				} else {
					// Add p to end of t's wait list.
					if t.waittail == nil {
						t.waitlink = p
					} else {
						t.waittail.waitlink = p
					}
					t.waittail = p
					p.waitlink = nil
				}
				ret
			}
			last = t
			if uintptr(sema) < t.stack {
				unsafe { *(&pt) = &t.prev }
			} else {
				unsafe { *(&pt) = &t.next }
			}
		}

		// Add p as new leaf in tree of unique addrs.
		// The balanced tree is a treap using ticket as the random heap priority.
		// That is, it is a binary tree ordered according to the elem addresses,
		// but then among the space of possible binary trees respecting those
		// addresses, it is kept balanced on average by maintaining a heap ordering
		// on the ticket: p.ticket <= both p.prev.ticket and p.next.ticket.
		// https://en.wikipedia.org/wiki/Treap
		// https://faculty.washington.edu/aragon/pubs/rst89.pdf
		//
		// p.ticket may be compared with zero, therefore set lowest bit.
		// It will not affect treap's quality noticeably.
		//
		// Only the main and scheduler threads have a gett() result.
		// When this semaRoot used by other threads, such as blocking thread pool
		// worker threads, gett() may return nil. When this happened, use the
		// global random state, otherwise always prefer cheaprand.
		if gett() == nil {
			p.ticket = u32(randg()) | 1
		} else {
			p.ticket = cheaprand() | 1
		}
		p.parent = last
		*pt = p

		// Rotate up into tree according to ticket (priority).
		for p.parent != nil && p.parent.ticket > p.ticket {
			if p.parent.prev == p {
				self.rotateRight(p.parent)
			} else {
				if p.parent.next != p {
					panic("semaRoot queue")
				}
				self.rotateLeft(p.parent)
			}
		}
	}

	// Searches for and finds the first coroutine in semaRoot blocked on sema.
	#disable nilptr
	fn dequeue(mut *self, &sema: *u32): &parkerList {
		mut &ps := &self.treap
		mut p := *ps
		for p != nil; p = *ps {
			if p.stack == uintptr(sema) {
				goto Found
			}
			if uintptr(sema) < p.stack {
				unsafe { *(&ps) = &p.prev }
			} else {
				unsafe { *(&ps) = &p.next }
			}
		}
		ret nil

	Found:
		mut t := p.waitlink
		if t != nil {
			// Substitute t, also waiting on addr, for p in root tree of unique addrs.
			*ps = t
			t.ticket = p.ticket
			t.parent = p.parent
			t.prev = p.prev
			if t.prev != nil {
				t.prev.parent = t
			}
			t.next = p.next
			if t.next != nil {
				t.next.parent = t
			}
			if t.waitlink != nil {
				t.waittail = p.waittail
			} else {
				t.waittail = nil
			}
			p.waitlink = nil
			p.waittail = nil
		} else {
			// Rotate p down to be leaf of tree for removal, respecting priorities.
			for p.next != nil || p.prev != nil {
				if p.next == nil || p.prev != nil && p.prev.ticket < p.next.ticket {
					self.rotateRight(p)
				} else {
					self.rotateLeft(p)
				}
			}
			// Remove p, now a leaf.
			if p.parent != nil {
				if p.parent.prev == p {
					p.parent.prev = nil
				} else {
					p.parent.next = nil
				}
			} else {
				self.treap = nil
			}
		}
		p.parent = nil
		p.stack = 0
		p.next = nil
		p.prev = nil
		p.ticket = 0
		ret p
	}

	// Rotates the tree rooted at node x.
	// turning (x a (y b c)) into (y (x a b) c).
	#disable nilptr
	fn rotateLeft(mut *self, mut x: &parkerList) {
		// p -> (x a (y b c))
		mut p := x.parent
		mut y := x.next
		mut b := y.prev

		y.prev = x
		x.parent = y
		x.next = b
		if b != nil {
			b.parent = x
		}

		y.parent = p
		if p == nil {
			self.treap = y
		} else if p.prev == x {
			p.prev = y
		} else {
			if p.next != x {
				panic("semaRoot rotateLeft")
			}
			p.next = y
		}
	}

	// Rotates the tree rooted at node y.
	// turning (y (x a b) c) into (x a (y b c)).
	#disable nilptr
	fn rotateRight(mut *self, mut y: &parkerList) {
		// p -> (y (x a b) c)
		mut p := y.parent
		mut x := y.prev
		mut b := x.next

		x.next = y
		y.parent = x
		y.prev = b
		if b != nil {
			b.parent = y
		}

		x.parent = p
		if p == nil {
			self.treap = x
		} else if p.prev == y {
			p.prev = x
		} else {
			if p.next != y {
				panic("semaRoot rotateRight")
			}
			p.next = x
		}
	}
}

// Prime to not correlate with any user patterns.
const semTabSize = 251

struct semTable {
	root: semaRoot
	_:    [cpu::CacheLinePadSize - semaRootSize]byte
}

let mut semtable: [semTabSize]semTable = []

// Returns sema space collection for the sema from semtable.
#disable nilptr
fn semtable_rootFor(&sema: *u32): &semaRoot {
	ret unsafe { (&semaRoot)(&semtable[(uintptr(sema)>>3)%semTabSize].root) }
}

#disable nilptr
fn cansemacquire(mut &sema: *u32): bool {
	for {
		v := atomic::Load(sema, atomic::Acquire)
		if v == 0 {
			ret false
		}
		if atomic::CompareAndSwap(sema, v, v-1, atomic::AcqRel, atomic::Acquire) {
			ret true
		}
	}
}

// Waits until sema > 0 and then atomically decrements it.
// It is intended as a simple sleep primitive for use by the synchronization
// library and should not be used directly.
// If lifo is true, queue waiter at the head of wait queue.
// wg reports whether the semacqure called by a waitgroup.
#disable nilptr
async fn semacquire(mut &sema: *u32, lifo: bool, reason: u32) {
	// Easy case.
	if cansemacquire(sema) {
		ret
	}

	// Harder case:
	//	increment waiter count
	//	try cansemacquire one more time, return if succeeded
	//	enqueue itself as a waiter
	//	sleep
	//	(waiter descriptor is dequeued by signaler)
	mut root := semtable_rootFor(sema)
	mut p := new(parkerList)
	for {
		root.lock.lock()
		// Add ourselves to nwait to disable "easy case" in semrelease.
		atomic::Add(&root.nwait, 1, atomic::AcqRel)
		// Check cansemacquire to avoid missed wakeup.
		if cansemacquire(sema) {
			atomic::Add(&root.nwait, ^u32(0), atomic::AcqRel)
			root.lock.unlock()
			break
		}
		// Any semrelease after the cansemacquire knows we're waiting
		// (we set nwait above), so go to sleep.
		root.queue(sema, p, lifo)
		mut tc := gett().c
		p.cp = unsafe { (&c)(&tc) }
		park(&(*p.cp), uintptr(&root.lock), reason).await
		// Try to acquire semaphore before enqueue again.
		if p.ticket != 0 || cansemacquire(sema) {
			break
		}
	}
}

// Atomically increments sema and notifies a waiting C
// if one is blocked in semacquire.
// It is intended as a simple wakeup primitive for use by the synchronization
// library and should not be used directly.
// If handoff is true, tries to pass count directly to the first waiter.
#disable nilptr
fn semrelease(mut &sema: *u32, handoff: bool) {
	mut root := semtable_rootFor(sema)
	atomic::Add(sema, 1, atomic::AcqRel)

	// Easy case: no waiters?
	// This check must happen after the atomicAdd, to avoid a missed wakeup
	// (see loop in semacquire).
	if atomic::Load(&root.nwait, atomic::Acquire) == 0 {
		ret
	}

	// Harder case: search for a waiter and wake it.
	root.lock.lock()
	if atomic::Load(&root.nwait, atomic::Acquire) == 0 {
		// The count is already consumed by another coroutine,
		// so no need to wake up another coroutine.
		root.lock.unlock()
		ret
	}

	mut p := root.dequeue(sema)
	if p != nil {
		atomic::Add(&root.nwait, ^u32(0), atomic::AcqRel)
	}
	root.lock.unlock()
	// May be slow or even yield, so unlock first.
	if p != nil {
		if p.ticket != 0 {
			panic("runtime: invalid semaphore ticket")
		}
		if handoff && cansemacquire(sema) {
			p.ticket = 1
		}
		unpark(&(*p.cp))
	}
}

// Same as semacquire, but based-on thread parking instead of C parking.
#disable nilptr
fn tsemacquire(mut &sema: *u32, lifo: bool, reason: u32) {
	// Easy case.
	if cansemacquire(sema) {
		ret
	}

	// Harder case:
	//	increment waiter count
	//	try cansemacquire one more time, return if succeeded
	//	enqueue itself as a waiter
	//	sleep
	//	(waiter descriptor is dequeued by signaler)
	mut root := semtable_rootFor(sema)
	mut p := new(parkerList)
	p.parker = new(parker)
	p.parker.init()
	for {
		root.lock.lock()
		// Add ourselves to nwait to disable "easy case" in semrelease.
		atomic::Add(&root.nwait, 1, atomic::AcqRel)
		// Check cansemacquire to avoid missed wakeup.
		if cansemacquire(sema) {
			atomic::Add(&root.nwait, ^u32(0), atomic::AcqRel)
			root.lock.unlock()
			p.parker.release() // Release memory.
			break
		}
		// Any semrelease after the cansemacquire knows we're waiting
		// (we set nwait above), so go to sleep.
		root.queue(sema, p, lifo)
		root.lock.unlock()
		p.parker.park()
		// Try to acquire semaphore before enqueue again.
		if p.ticket != 0 || cansemacquire(sema) {
			p.parker.release() // Release memory.
			break
		}
	}
}

// Same as semrelease, but based-on thread parking instead of C parking.
#disable nilptr
fn tsemrelease(mut &sema: *u32, handoff: bool) {
	mut root := semtable_rootFor(sema)
	atomic::Add(sema, 1, atomic::AcqRel)

	// Easy case: no waiters?
	// This check must happen after the atomicAdd, to avoid a missed wakeup
	// (see loop in semacquire).
	if atomic::Load(&root.nwait, atomic::Acquire) == 0 {
		ret
	}

	// Harder case: search for a waiter and wake it.
	root.lock.lock()
	if atomic::Load(&root.nwait, atomic::Acquire) == 0 {
		// The count is already consumed by another thread,
		// so no need to wake up another thread.
		root.lock.unlock()
		ret
	}

	mut p := root.dequeue(sema)
	if p != nil {
		atomic::Add(&root.nwait, ^u32(0), atomic::AcqRel)
	}
	root.lock.unlock()
	// May be slow or even yield, so unlock first.
	if p != nil {
		if p.ticket != 0 {
			panic("runtime: invalid semaphore ticket")
		}
		if handoff && cansemacquire(sema) {
			p.ticket = 1
		}
		p.parker.unpark()
		// If handoff is true, immediately yield the CPU with no analysis.
		// This thread is not the expected owner of the next semacquire.
		// So this thread doesn't matter for now, yield the CPU to increase
		// the chances of semacquire of the dequeued thread.
		if handoff && p.ticket == 1 {
			osyield()
		}
	}
}

// Checks if a < b, considering a & b running counts that may overflow the
// 32-bit range, and that their "unwrapped" difference is always less than 2^31.
fn less(a: u32, b: u32): bool {
	ret i32(a-b) < 0
}

// Ticket-based notification list used to implement condition variable primitives.
// It can be used raw (without any wrapper), but designed for wrapped use cases.
struct notifyList {
	// Ticket number of the next waiter.
	// It is atomically incremented outside the lock.
	wait: u32

	// Ticket number of the next waiter to be notified. It can
	// be read outside the lock, but is only written to with lock held.
	//
	// Both wait & notify can wrap around, and such cases will be correctly
	// handled as long as their "unwrapped" difference is bounded by 2^31.
	// For this not to be the case, we'd need to have 2^31+ coroutines
	// blocked on the same condvar, which is currently not possible.
	notify: u32

	// List of parked waiters.
	head: &parkerList
	tail: &parkerList

	lock: mutex
}

// Adds new notify ticked to list l and returns the ticket number.
#disable nilptr
fn notifyListAdd(mut &l: *notifyList): u32 {
	ret atomic::Add(&l.wait, 1, atomic::AcqRel) - 1
}

// Waits for a notification. If one has been sent since
// notifyListAdd was called, it returns immediately. Otherwise, it blocks.
#disable nilptr
async fn notifyListWait(mut &l: *notifyList, t: u32) {
	// Return right away if this ticket has already been notified.
	l.lock.lock()
	if less(t, l.notify) {
		l.lock.unlock()
		ret
	}

	// Enqueue itself.
	mut p := new(parkerList)
	mut tc := gett().c
	p.cp = unsafe { (&c)(&tc) }
	p.ticket = t
	if l.tail == nil {
		l.head = p
	} else {
		l.tail.next = p
	}
	l.tail = p

	park(&(*p.cp), uintptr(&l.lock), reasonCond).await
}

// Notifies one entry in the list.
#disable nilptr
fn notifyListNotifyOne(mut &l: *notifyList) {
	// Fast-path: if there are no new waiters since the last notification
	// we don't need to acquire the lock at all.
	if atomic::Load(&l.wait, atomic::Acquire) == atomic::Load(&l.notify, atomic::Acquire) {
		ret
	}

	l.lock.lock()

	// Re-check under the lock if we need to do anything.
	t := l.notify
	if t == atomic::Load(&l.wait, atomic::Acquire) {
		l.lock.unlock()
		ret
	}

	// Update the next notify ticket number.
	atomic::Add(&l.notify, t+1, atomic::Release)

	// Try to find the p that needs to be notified.
	// If it hasn't made it to the list yet we won't find it,
	// but it won't park itself once it sees the new notify number.
	//
	// This scan looks linear but essentially always stops quickly.
	// Because p's queue separately from taking numbers,
	// there may be minor reorderings in the list, but we
	// expect the p we're looking for to be near the front.
	// The p has others in front of it on the list only to the
	// extent that it lost the race, so the iteration will not
	// be too long. This applies even when the p is missing:
	// it hasn't yet gotten to sleep and has lost the race to
	// the (few) other p's that we find on the list.
	mut p, mut s := (&parkerList)(nil), l.head
	for s != nil; p, s = s, s.next {
		if s.ticket == t {
			mut n := s.next
			if p != nil {
				p.next = n
			} else {
				l.head = n
			}
			if n == nil {
				l.tail = p
			}
			l.lock.unlock()
			s.next = nil
			unpark(&(*s.cp))
			ret
		}
	}

	l.lock.unlock()
}

// Notifies all entries in the list.
#disable nilptr
fn notifyListNotifyAll(mut &l: *notifyList) {
	// Fast-path: if there are no new waiters since the last notification
	// we don't need to acquire the lock.
	if atomic::Load(&l.wait, atomic::Acquire) == atomic::Load(&l.notify, atomic::Acquire) {
		ret
	}

	// Pull the list out into a local variable, waiters will be readied
	// outside the lock.
	l.lock.lock()
	mut s := l.head
	l.head = nil
	l.tail = nil

	// Update the next ticket to be notified. We can set it to the current
	// value of wait because any previous waiters are already in the list
	// or will notice that they have already been notified when trying to
	// add themselves to the list.
	wait := atomic::Load(&l.wait, atomic::Acquire)
	atomic::Store(&l.notify, wait, atomic::Release)
	l.lock.unlock()

	// Go through the local list and ready all waiters.
	for s != nil {
		mut next := s.next
		s.next = nil
		unpark(&(*s.cp))
		s = next
	}
}
// Copyright 2024 The Jule Project Contributors. All rights reserved.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/internal/cpu"
use "std/internal/runtime"
use "std/internal/runtime/atomic"

// Stores sema space for unique sema.
struct semaNode {
	sema: *u32
	tree: &parkerList // Root of tree of the waiters.
	next: &semaNode
}

const semaRootSize = qmutexSize + runtime::SmartptrSize + 4 // +4 for u32

// Stores all space collections of sema.
struct semaRoot {
	lock:  qmutex
	tree:  &semaNode // Root of tree of unique sema spaces.
	nwait: u32       // Number of waiters. Read w/o the lock, should be atomic.
}

impl semaRoot {
	#disable nilptr
	fn queue(mut *self, mut &sema: *u32, mut p: &parkerList, lifo: bool) {
		// The leaf may already used and some fields may be modified.
		// For example, a dequeued leaf may cannot acquaire sema and
		// enqueued again. So, data of old record may cause errors.
		// Reset them to default to avoid data misunderstanding.
		p.next = nil
		p.ticket = 0

		mut t := self.tree
		mut otru := (&semaNode)(nil)
		if t != nil {
			for {
				// Already have sema in list.
				if uintptr(t.sema) == uintptr(sema) {
					if lifo {
						// Add p to head of the wait list.
						p.next = t.tree
						t.tree = p
					} else {
						// Add p to end of the wait list.
						mut tp := t.tree
						for tp.next != nil; tp = tp.next {
						}
						tp.next = p
					}
					ret
				}
				if otru == nil && t.sema == nil {
					otru = t
				}
				if t.next == nil {
					// Break iteration here.
					// If needed the last non-nil node will be used.
					break
				}
				t = t.next
			}
		}
		// Add new semaNode for sema since it is not exist in the list.
		if otru != nil {
			// Found a node in open to reuse state, so use it.
			otru.sema = sema
			otru.tree = p
			ret
		}
		mut sn := new(semaNode)
		sn.sema = sema
		sn.tree = p
		if self.tree == nil {
			// Head is nil, so p will be.
			self.tree = sn
		} else {
			// Head is not nil and there is no reusable node.
			// So append p to nodes.
			t.next = sn
		}
	}

	#disable nilptr
	fn dequeue(mut *self, &sema: *u32): &parkerList {
		mut t := self.tree
		for t != nil; t = t.next {
			// Already have sema in list.
			if uintptr(t.sema) == uintptr(sema) {
				if t.tree == nil {
					break
				}
				mut p := t.tree
				t.tree = p.next
				// Remove sema if tree reached to nil.
				// So, open to reuse this allocation for other semas.
				if t.tree == nil {
					t.sema = nil
				}
				ret p
			}
		}
		ret nil
	}
}

// Prime to not correlate with any user patterns.
const semTabSize = 251

struct semTable {
	root: semaRoot
	_:    [cpu::CacheLinePadSize - semaRootSize]byte
}

let mut semtable: [semTabSize]semTable = []

// Returns sema space collection for the sema from semtable.
#disable nilptr
fn semtable_rootFor(&sema: *u32): &semaRoot {
	ret unsafe { (&semaRoot)(&semtable[(uintptr(sema)>>3)%semTabSize].root) }
}

#disable nilptr
fn cansemacquire(mut &sema: *u32): bool {
	for {
		v := atomic::Load(sema, atomic::Acquire)
		if v == 0 {
			ret false
		}
		if atomic::CompareAndSwap(sema, v, v-1, atomic::AcqRel, atomic::Acquire) {
			ret true
		}
	}
}

// Waits until sema > 0 and then atomically decrements it.
// It is intended as a simple sleep primitive for use by the synchronization
// library and should not be used directly.
// If lifo is true, queue waiter at the head of wait queue.
// wg reports whether the semacqure called by a waitgroup.
#disable nilptr
async fn semacquire(mut &sema: *u32, lifo: bool, reason: u32) {
	// Easy case.
	if cansemacquire(sema) {
		ret
	}

	// Harder case:
	//	increment waiter count
	//	try cansemacquire one more time, return if succeeded
	//	enqueue itself as a waiter
	//	sleep
	//	(waiter descriptor is dequeued by signaler)
	mut root := semtable_rootFor(sema)
	mut p := new(parkerList)
	for {
		root.lock.lock()
		// Add ourselves to nwait to disable "easy case" in semrelease.
		atomic::Add(&root.nwait, 1, atomic::AcqRel)
		// Check cansemacquire to avoid missed wakeup.
		if cansemacquire(sema) {
			atomic::Add(&root.nwait, ^u32(0), atomic::AcqRel)
			root.lock.unlock()
			break
		}
		// Any semrelease after the cansemacquire knows we're waiting
		// (we set nwait above), so go to sleep.
		root.queue(sema, p, lifo)
		mut c := gett().coro
		p.coro = unsafe { (&coro)(&c) }
		park(&(*p.coro), u64(uintptr(&root.lock)), reason).await
		// Try to acquire semaphore before enqueue again.
		if p.ticket != 0 || cansemacquire(sema) {
			break
		}
	}
}

// Atomically increments sema and notifies a waiting coroutine
// if one is blocked in semacquire.
// It is intended as a simple wakeup primitive for use by the synchronization
// library and should not be used directly.
// If handoff is true, tries to pass count directly to the first waiter.
#disable nilptr
fn semrelease(mut &sema: *u32, handoff: bool) {
	mut root := semtable_rootFor(sema)
	atomic::Add(sema, 1, atomic::AcqRel)

	// Easy case: no waiters?
	// This check must happen after the atomicAdd, to avoid a missed wakeup
	// (see loop in semacquire).
	if atomic::Load(&root.nwait, atomic::Acquire) == 0 {
		ret
	}

	// Harder case: search for a waiter and wake it.
	root.lock.lock()
	if atomic::Load(&root.nwait, atomic::Acquire) == 0 {
		// The count is already consumed by another coroutine,
		// so no need to wake up another coroutine.
		root.lock.unlock()
		ret
	}

	mut p := root.dequeue(sema)
	if p != nil {
		atomic::Add(&root.nwait, ^u32(0), atomic::AcqRel)
	}
	root.lock.unlock()
	// May be slow or even yield, so unlock first.
	if p != nil {
		if p.ticket != 0 {
			panic("runtime: invalid semaphore ticket")
		}
		if handoff && cansemacquire(sema) {
			p.ticket = 1
		}
		unpark(&(*p.coro))
	}
}

// Same as semacquire, but based-on thread parking instead of coroutine parking.
#disable nilptr
fn tsemacquire(mut &sema: *u32, lifo: bool, reason: u32) {
	// Easy case.
	if cansemacquire(sema) {
		ret
	}

	// Harder case:
	//	increment waiter count
	//	try cansemacquire one more time, return if succeeded
	//	enqueue itself as a waiter
	//	sleep
	//	(waiter descriptor is dequeued by signaler)
	mut root := semtable_rootFor(sema)
	mut p := new(parkerList)
	p.parker = new(parker)
	p.parker.init()
	for {
		root.lock.lock()
		// Add ourselves to nwait to disable "easy case" in semrelease.
		atomic::Add(&root.nwait, 1, atomic::AcqRel)
		// Check cansemacquire to avoid missed wakeup.
		if cansemacquire(sema) {
			atomic::Add(&root.nwait, ^u32(0), atomic::AcqRel)
			root.lock.unlock()
			p.parker.release() // Release memory.
			break
		}
		// Any semrelease after the cansemacquire knows we're waiting
		// (we set nwait above), so go to sleep.
		root.queue(sema, p, lifo)
		root.lock.unlock()
		p.parker.park()
		// Try to acquire semaphore before enqueue again.
		if p.ticket != 0 || cansemacquire(sema) {
			p.parker.release() // Release memory.
			break
		}
	}
}

// Same as semrelease, but based-on thread parking instead of coroutine parking.
#disable nilptr
fn tsemrelease(mut &sema: *u32, handoff: bool) {
	mut root := semtable_rootFor(sema)
	atomic::Add(sema, 1, atomic::AcqRel)

	// Easy case: no waiters?
	// This check must happen after the atomicAdd, to avoid a missed wakeup
	// (see loop in semacquire).
	if atomic::Load(&root.nwait, atomic::Acquire) == 0 {
		ret
	}

	// Harder case: search for a waiter and wake it.
	root.lock.lock()
	if atomic::Load(&root.nwait, atomic::Acquire) == 0 {
		// The count is already consumed by another thread,
		// so no need to wake up another thread.
		root.lock.unlock()
		ret
	}

	mut p := root.dequeue(sema)
	if p != nil {
		atomic::Add(&root.nwait, ^u32(0), atomic::AcqRel)
	}
	root.lock.unlock()
	// May be slow or even yield, so unlock first.
	if p != nil {
		if p.ticket != 0 {
			panic("runtime: invalid semaphore ticket")
		}
		if handoff && cansemacquire(sema) {
			p.ticket = 1
		}
		p.parker.unpark()
		// If handoff is true, immediately yield the CPU with no analysis.
		// This thread is not the expected owner of the next semacquire.
		// So this thread doesn't matter for now, yield the CPU to increase
		// the chances of semacquire of the dequeued thread.
		if handoff && p.ticket == 1 {
			osyield()
		}
	}
}

// Checks if a < b, considering a & b running counts that may overflow the
// 32-bit range, and that their "unwrapped" difference is always less than 2^31.
fn less(a: u32, b: u32): bool {
	ret i32(a-b) < 0
}

// Ticket-based notification list used to implement condition variable primitives.
// It can be used raw (without any wrapper), but designed for wrapped use cases.
struct notifyList {
	// Ticket number of the next waiter.
	// It is atomically incremented outside the lock.
	wait: u32

	// Ticket number of the next waiter to be notified. It can
	// be read outside the lock, but is only written to with lock held.
	//
	// Both wait & notify can wrap around, and such cases will be correctly
	// handled as long as their "unwrapped" difference is bounded by 2^31.
	// For this not to be the case, we'd need to have 2^31+ coroutines
	// blocked on the same condvar, which is currently not possible.
	notify: u32

	// List of parked waiters.
	head: &parkerList
	tail: &parkerList

	lock: mutex
}

// Adds new notify ticked to list l and returns the ticket number.
#disable nilptr
fn notifyListAdd(mut &l: *notifyList): u32 {
	ret atomic::Add(&l.wait, 1, atomic::AcqRel) - 1
}

// Waits for a notification. If one has been sent since
// notifyListAdd was called, it returns immediately. Otherwise, it blocks.
#disable nilptr
async fn notifyListWait(mut &l: *notifyList, t: u32) {
	// Return right away if this ticket has already been notified.
	l.lock.lock()
	if less(t, l.notify) {
		l.lock.unlock()
		ret
	}

	// Enqueue itself.
	mut p := new(parkerList)
	mut c := gett().coro
	p.coro = unsafe { (&coro)(&c) }
	p.ticket = t
	if l.tail == nil {
		l.head = p
	} else {
		l.tail.next = p
	}
	l.tail = p

	park(&(*p.coro), u64(uintptr(&l.lock)), reasonCond).await
}

// Notifies one entry in the list.
#disable nilptr
fn notifyListNotifyOne(mut &l: *notifyList) {
	// Fast-path: if there are no new waiters since the last notification
	// we don't need to acquire the lock at all.
	if atomic::Load(&l.wait, atomic::Acquire) == atomic::Load(&l.notify, atomic::Acquire) {
		ret
	}

	l.lock.lock()

	// Re-check under the lock if we need to do anything.
	t := l.notify
	if t == atomic::Load(&l.wait, atomic::Acquire) {
		l.lock.unlock()
		ret
	}

	// Update the next notify ticket number.
	atomic::Add(&l.notify, t+1, atomic::Release)

	// Try to find the p that needs to be notified.
	// If it hasn't made it to the list yet we won't find it,
	// but it won't park itself once it sees the new notify number.
	//
	// This scan looks linear but essentially always stops quickly.
	// Because p's queue separately from taking numbers,
	// there may be minor reorderings in the list, but we
	// expect the p we're looking for to be near the front.
	// The p has others in front of it on the list only to the
	// extent that it lost the race, so the iteration will not
	// be too long. This applies even when the p is missing:
	// it hasn't yet gotten to sleep and has lost the race to
	// the (few) other p's that we find on the list.
	mut p, mut s := (&parkerList)(nil), l.head
	for s != nil; p, s = s, s.next {
		if s.ticket == t {
			mut n := s.next
			if p != nil {
				p.next = n
			} else {
				l.head = n
			}
			if n == nil {
				l.tail = p
			}
			l.lock.unlock()
			s.next = nil
			unpark(&(*s.coro))
			ret
		}
	}

	l.lock.unlock()
}

// Notifies all entries in the list.
#disable nilptr
fn notifyListNotifyAll(mut &l: *notifyList) {
	// Fast-path: if there are no new waiters since the last notification
	// we don't need to acquire the lock.
	if atomic::Load(&l.wait, atomic::Acquire) == atomic::Load(&l.notify, atomic::Acquire) {
		ret
	}

	// Pull the list out into a local variable, waiters will be readied
	// outside the lock.
	l.lock.lock()
	mut s := l.head
	l.head = nil
	l.tail = nil

	// Update the next ticket to be notified. We can set it to the current
	// value of wait because any previous waiters are already in the list
	// or will notice that they have already been notified when trying to
	// add themselves to the list.
	wait := atomic::Load(&l.wait, atomic::Acquire)
	atomic::Store(&l.notify, wait, atomic::Release)
	l.lock.unlock()

	// Go through the local list and ready all waiters.
	for s != nil {
		mut next := s.next
		s.next = nil
		unpark(&(*s.coro))
		s = next
	}
}
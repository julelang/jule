// Copyright 2025 The Jule Project Contributors. All rights reserved.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

// TODO: consider io_uring backend for Linux once the runtime I/O abstraction is finalized.
// Currently deferred due to portability and stability concerns.

#build linux

use "std/sys"

extern use "<sys/epoll.h>"

let mut epfd: i32 = -1

fn eventpollinit() {
	(epfd), mut errno := syscall_EpollCreate1(sys::EPOLL_CLOEXEC)
	if errno != _NO_ERROR {
		panic("runtime: epoll init failed")
	}
}

#disable nilptr boundary
fn eventpollopen(fd: u64, mut &pd: *polldesc) {
	let mut ev: epollEvent
	ev.Events = sys::EPOLLIN | sys::EPOLLOUT | sys::EPOLLRDHUP | sys::EPOLLET
	ev.Data = pd
	e := syscall_EpollCtl(epfd, sys::EPOLL_CTL_ADD, i32(fd), &ev)
	if e != _NO_ERROR {
		panic("runtime: eventpollopen: epoll failed")
	}
}

fn eventpollclose(fd: u64): sys::Errno {
	let mut ev: epollEvent
	ret syscall_EpollCtl(epfd, sys::EPOLL_CTL_DEL, i32(fd), &ev)
}

// delay < 0: blocks indefinitely
// delay == 0: does not block, just polls
// delay > 0: block for up to that many nanoseconds
#disable nilptr boundary
fn eventpoll(delay: i64): coroq {
	if epfd == -1 {
		ret coroq{}
	}
	let mut wait: i32
	if delay < 0 {
		wait = -1
	} else if delay == 0 {
		wait = 0
	} else if delay < 1e6 {
		wait = 1
	} else if delay < 1e15 {
		// Convert delay to milliseconds, rounding *up* instead of truncating.
		//
		// This computation implements a ceiling division without using floating-point:
		//	wait = ceil(delay / 1ms)
		// which is equivalent to:
		//	(delay + 1ms - 1) / 1ms
		//
		// Rounding up is critical:
		//	- It guarantees that the timer never fires *earlier* than requested.
		//	- Early wakeups break scheduler semantics and can cause subtle race bugs.
		//
		// Any delay smaller than 1ms is clamped to 1ms intentionally.
		// This is NOT a loss of precision but a correctness requirement.
		//
		// Therefore, enforcing a minimum wait of 1ms preserves correctness,
		// avoids spin loops, and aligns with real OS timer granularity.
		wait = i32((delay + _Millisecond - 1) / _Millisecond)
	} else {
		// An arbitrary cap on how long to wait for a timer.
		// 1e9 ms == ~11.5 days.
		wait = 1e9
	}
	let mut events: [128]epollEvent
retry:
	n, errno := syscall_EpollWait(epfd, &events[0], i32(len(events)), wait)
	if errno != _NO_ERROR {
		if errno != sys::EINTR {
			panic("runtime: eventpoll: epoll failed")
		}
		// If a timed sleep was interrupted, just return to
		// recalculate how long we should sleep now.
		if wait >= 0 {
			ret coroq{}
		}
		goto retry
	}
	let mut toRun: coroq
	mut i := i32(0)
	for i < n; i++ {
		&ev := &events[i]
		if ev.Events == 0 {
			continue
		}

		let mut mode: i32
		if ev.Events&(sys::EPOLLIN|sys::EPOLLRDHUP|sys::EPOLLHUP|sys::EPOLLERR) != 0 {
			mode += 'r'
		}
		if ev.Events&(sys::EPOLLOUT|sys::EPOLLHUP|sys::EPOLLERR) != 0 {
			mode += 'w'
		}
		if mode == 0 {
			continue
		}
		mut &pd := unsafe { &(*(*polldesc)(ev.Data)) }
		pd.mu.lock()
		pd.eventerr = pd.eventerr || ev.Events == sys::EPOLLERR
		pollnotified(pd, mode, &toRun)
		pd.mu.unlock()
	}
	ret toRun
}
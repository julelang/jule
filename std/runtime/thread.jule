// Copyright 2024 The Jule Project Contributors. All rights reserved.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

extern let mut __jule_ct: &thread

const (
	// State flags of threads.
	threadRunning = 1 << iota // Header group specifier of running thread state.
	threadClosed              // Thread execution completed, thread closed.

	// Thread roles.
	roleProgram        // The main thread of the program.
	roleM              // A machine (M) thread.
	roleSysmon         // The sysmon thread.
	roleBlockingWorker // A worker thread for the blocking thread-pool.
)

// A thread instance is represents a spawned thread.
// Used by the Jule runtime to manage threads.
#export "__jule_thread"
struct thread {
	os: osthread

	// Thread state.
	state: u32

	// Role of the thread for runtime.
	role: int

	// Parker of the thread.
	parker: &parker

	// Pointer to the previous thread.
	// Threads stored in the thread stack with a doubly linked-list.
	prev: &thread

	// Pointer to the next thread.
	// Threads stored in the thread stack with a doubly linked-list.
	next: &thread

	// The P owned by the thread.
	pp: &p

	// Current coroutine of the thread.
	c: c

	// Local random state.
	rand:      randmach
	cheaprand: u64
}

// Returns the current thread.
// Uses the thread-local data.
fn gett(): &thread {
	ret extern.__jule_ct
}

// Sets the current thread as t.
// Writes to the thread-local data.
fn sett(mut t: &thread) {
	extern.__jule_ct = t
}

// A thread stack and associated lock.
// All spawned threads are stored in the threadHead and threadTail (linked-list).
// The threadHead variable will always point to the main program thread.
// A closed thread instance will not be released if it is cacheable,
// remains allocated and placed in the threads.
// Subsequent thread generations may use the same allocation
// of closed threads for the new spawned threads.
let threadMutex = mutex{}
let mut threadHead = (&thread)(nil)
let mut threadTail = (&thread)(nil)
let mut countm = 0  // Count of Ms at able to run a coroutine.
let mut cachedm = 0 // Count of cached and parked coroutine scheduler threads.

// Stores total number of logical threads.
let mut numcpu = 0

// Returns the number of logical CPUs usable by the current process.
//
// The set of available CPUs is checked by querying the operating system
// at process startup. Changes to operating system CPU allocation after
// process startup are not reflected.
fn NumCPU(): int { ret numcpu }

// Allocates a new thread and sets state as running.
#disable nilptr
fn newThread(role: int): &thread {
	mut t := new(thread)
	t.state |= threadRunning
	t.role = role

	// Initialized once and never deallocated if thread waiting for reuse.
	t.parker = new(parker)
	t.parker.init()

	// Initialize local random state.
	trandinit(t)

	ret t
}

// Pushes a new thread to the main thread stack and sets state as running.
// Returns the thread representing the created thread.
// Assumes the threadMutex is locked and will not release before return.
//
// This function assumes |threadHead| is not nil. So we must have a thread pointer
// associated with a thread in thread stack, it should be the main thread.
// New created threads should be added to the main thread's tail.
#disable nilptr
fn pushNewThread(role: int): &thread {
	// Lookup for empty threads to caught ready to reuse thread if exist.
	mut t := threadHead
	for t != nil; t = t.next {
		if t.role == role && t.state&threadClosed == threadClosed {
			t.state = threadRunning
			ret t
		}
	}
	// We have not any reusable thread, so create a new one.
	mut newt := newThread(role)
	newt.prev = threadTail
	threadTail.next = newt
	threadTail = newt
	ret newt
}

// Locks the thread-mutex and returns the thread associated with current thread.
// It does not release the thread-mutex before return.
#disable nilptr
fn acquireThread(): &thread {
	threadMutex.lock()
	ret getThread()
}

// Same as acquireThread, but assumes thread-mutex is already locked.
#disable nilptr
fn getThread(): &thread {
	id := currentThreadID()
	mut t := threadHead
	for t != nil; t = t.next {
		if t.os.equal(id) {
			ret t
		}
	}
	ret nil
}

// Removes thread t from the list, releases parker and drops references.
// Assumes the threadMutex is locked and will not release before return.
#disable nilptr
fn removeThread(mut t: &thread) {
	// Remove the instance from the queue.
	if t.prev != nil {
		t.prev.next = t.next
	} else {
		// This case must be unreachable, but be safe.
		threadHead = t.next
	}
	if t.next != nil {
		t.next.prev = t.prev
	} else {
		threadTail = t.prev
	}
	t.prev = nil
	t.next = nil
	t.pp = nil
	t.role = 0
	t.parker.release()
}

fn threadinit() {
	// Platform specific initialization.
	_threadinit()

	// Program started by the main thread.
	// Use `sett(threadHead)` to set thread-local &thread data for the main thread.
	sett(threadHead)
}
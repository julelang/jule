// Copyright 2024 The Jule Project Contributors. All rights reserved.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

extern let mut __jule_ct: &thread

const (
	// State flags of threads.
	threadRunning = 1 << iota // Header group specifier of running thread state.
	threadClosed              // Thread execution completed, thread closed.
)

// A thread instance is represents a spawned thread.
// Used by the Jule runtime to manage threads.
#export "__jule_thread"
struct thread {
	os: osthread

	// Thread state.
	state: u32

	// Parker of the thread.
	parker: &parker

	// Pointer to the previous thread.
	// Threads stored in the thread stack with a doubly linked-list.
	prev: &thread

	// Pointer to the next thread.
	// Threads stored in the thread stack with a doubly linked-list.
	next: &thread

	// The coroutine processor owned by the thread.
	proc: &coroproc

	// Current coroutine of the thread.
	coro: &coro
}

// Returns the current thread.
// Uses the thread-local data.
// On sync runtime, returns nil.
fn gett(): &thread {
	ret extern.__jule_ct
}

// Sets the current thread as t.
// Writes to the thread-local data.
fn sett(mut t: &thread) {
	extern.__jule_ct = t
}

// A thread stack and associated lock.
// All spawned threads are stored in the threadHead and threadTail (linked-list).
// The threadHead variable will always point to the main program thread.
// A closed thread instance will not be released if it is cacheable,
// remains allocated and placed in the threads.
// Subsequent thread generations may use the same allocation
// of closed threads for the new spawned threads.
let threadMutex = mutex{}
let mut threadHead = (&thread)(nil)
let mut threadTail = (&thread)(nil)
let mut cachedCount = 0 // Count of cached and parked coroutine scheduler threads.
let mut workerCount = 0 // Count of worker threads at least runs or able to run a coroutine.

// Stores total number of logical threads.
let mut numcpu = 0

// Returns the number of logical CPUs usable by the current process.
//
// The set of available CPUs is checked by querying the operating system
// at process startup. Changes to operating system CPU allocation after
// process startup are not reflected.
fn NumCPU(): int { ret numcpu }

// Allocates a new thread and sets state as running.
#disable nilptr
fn newThread(): &thread {
	mut t := new(thread)
	t.state |= threadRunning

	// Initialized once and never deallocated if thread waiting for reuse.
	t.parker = new(parker)
	t.parker.init()

	ret t
}

// Pushes a new thread to the main thread stack and sets state as running.
// Returns the thread representing the created thread.
// Assumes the threadMutex is locked and will not release before return.
//
// This function assumes |threadHead| is not nil. So we must have a thread pointer
// associated with a thread in thread stack, it should be the main thread.
// New created threads should be added to the main thread's tail.
#disable nilptr
fn pushNewThread(): &thread {
	// Lookup for empty threads to caught ready to reuse thread if exist.
	mut t := threadHead
	for t != nil; t = t.next {
		if t.state&threadClosed == threadClosed {
			t.state = threadRunning
			t.coro = nil
			ret t
		}
	}
	// We have not any reusable thread, so create a new one.
	mut newt := newThread()
	newt.prev = threadTail
	threadTail.next = newt
	threadTail = newt
	ret newt
}

// Closes the thread t, but it may be cached.
// The thread t must be a scheduler thread.
#disable nilptr
fn closeThread(mut t: &thread): (schedAgain: bool) {
	// Thread is have a coroutine processor.
	// We have to put back it to idle processes.
	if t.proc != nil {
		for {
			ok, _, full := sched.idleprocs.enqueue(&t.proc)
			if !ok && full {
				panic("malformed internal schedule queue")
			}
			if ok {
				break
			}
		}
	}

	threadMutex.lock()
	workerCount--
	if workerCount <= 0 {
		panic("runtime: all coroutines are asleep - deadlock!")
	}
	// We already cached a lot scheduler thread.
	// Do not cache it, but keeps it if it is the main thread of the program.
	if t != threadHead && cachedCount > COMAXPROCS() {
		// Remove the instance from the queue.
		if t.prev != nil {
			t.prev.next = t.next
		} else {
			// Be safe, but this case must be unreachable.
			threadHead = t.next
		}
		if t.next != nil {
			t.next.prev = t.prev
		} else {
			threadTail = t.prev
		}
		t.prev = nil
		t.next = nil
		t.coro = nil
		t.proc = nil
		threadMutex.unlock()
		t.parker.release()
		t = nil
		ret false
	}
	// There is space for caching, cache it.
	// Park the thread and report true, it will be continue to run when notified.
	cachedCount++
	t.coro = nil
	t.proc = nil
	t.state = threadClosed
	threadMutex.unlock()
	t.parker.park()
	ret true
}

// Locks the thread-mutex and returns the thread associated with current thread.
// It does not release the thread-mutex before return.
#disable nilptr
fn acquireThread(): &thread {
	threadMutex.lock()
	ret getThread()
}

// Same as acquireThread, but assumes thread-mutex is already locked.
#disable nilptr
fn getThread(): &thread {
	id := currentThreadID()
	mut t := threadHead
	for t != nil; t = t.next {
		if t.os.equal(id) {
			ret t
		}
	}
	ret nil
}

// Spawns a new scheduler thread with the coroutine processor.
// The thread-mutex must be acquired before the call, it will release before return.
#disable nilptr
fn newm(mut proc: &coroproc) {
	workerCount++
	// We have a cached scheduler thread.
	// Notify it.
	if cachedCount > 0 {
		mut t := pushNewThread() // It will return a cached thread instance.
		t.proc = proc
		cachedCount--
		threadMutex.unlock()
		t.parker.unpark()
		ret
	}
	// Spawn a new one.
	unsafe { threadSpawn(proc, (*unsafe)(uintptr(schedthread)), nil) }
}

fn threadinit() {
	// Platform specific initialization.
	_threadinit()

	workerCount = 1 // The main program thread.
}
// Copyright 2024 The Jule Project Contributors. All rights reserved.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

extern let mut __jule_ct: *thread

const (
	// Thread roles.
	roleProgram        = 1 << iota // The main thread of the program.
	roleM                          // A machine (M) thread.
	roleBlockingWorker             // A worker thread for the blocking thread pool.
)

// A thread instance is represents a spawned thread.
// Used by the Jule runtime to manage threads.
#export "__jule_thread"
struct thread {
	// Parker of the thread.
	parker: &parker

	// Role of the thread for runtime.
	role: int

	// The P owned by the thread.
	pp: &p

	// Current coroutine of the thread.
	c: c

	// Local random state.
	rand:      randmach
	cheaprand: u64

	// Actively searching for runnable coroutines instead of sleeping.
	spinning: bool

	// Link to the next thread.
	link: &thread
}

// Returns the current thread.
// Uses the thread-local data.
fn gett(): &thread {
	ret unsafe { (&thread)(extern.__jule_ct) }
}

// Sets the current thread as t.
// Writes to the thread-local data.
fn sett(mut t: &thread) {
	extern.__jule_ct = (*thread)(t)
}

// Pointer to the main M, the main program thread.
let mut mainm = (&thread)(nil)

// Stores total number of logical threads.
let mut numcpu = 0

// Returns the number of logical CPUs usable by the current process.
//
// The set of available CPUs is checked by querying the operating system
// at process startup. Changes to operating system CPU allocation after
// process startup are not reflected.
fn NumCPU(): int { ret numcpu }

// Allocates a new thread and sets state as running.
#disable nilptr
fn newThread(role: int): &thread {
	mut t := new(thread)
	t.role = role

	// Initialized once and never deallocated if thread waiting for reuse.
	t.parker = new(parker)
	t.parker.init()

	if role == roleProgram || role == roleM {
		// Initialize local random state.
		trandinit(t)
	}

	ret t
}

// Releases thread t, releases parker and drops references.
#disable nilptr
fn releaseThread(mut t: &thread) {
	t.pp = nil
	t.role = 0
	t.parker.release()
}

fn threadinit() {
	// Platform specific initialization.
	_threadinit()

	// Program started by the main thread.
	// Use `sett(mainm)` to set thread-local &thread data for the main thread.
	sett(mainm)
}
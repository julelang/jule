// Copyright 2024-2025 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/comptime"
use "std/internal/byteorder"
use "std/math/bits"
use "std/unsafe"

// Size of a pointer in bytes - mem::SizeOf(uintptr(0)) but as an ideal constant.
// It is also the size of the machine's native word size (that is, 4 on 32-bit systems, 8 on 64-bit).
const _ptrSize = 4 << (^uintptr(0) >> 63)

const c0 = uintptr((8-_ptrSize)/4*2860486313 + (_ptrSize-4)/4*33054211828000289)
const c1 = uintptr((8-_ptrSize)/4*3267000013 + (_ptrSize-4)/4*23344194077549503)

// NOTE: Because NaN != NaN, a map can contain any
// number of (mostly useless) entries keyed with NaNs.
// To avoid long hash chains, we assign a random number
// as the hash value for a NaN.

fn f32hash(f: f32, seed: uintptr): uintptr {
	match {
	| f == 0:
		ret c1 * (c0 ^ seed) // +0, -0
	| f != f:
		ret c1 * (c0 ^ seed ^ uintptr(rand())) // any kind of NaN
	|:
		ret 0 //ret memhash(p, seed, 4)
	}
}

fn f64hash(f: f64, seed: uintptr): uintptr {
	match {
	| f == 0:
		ret c1 * (c0 ^ seed) // +0, -0
	| f != f:
		ret c1 * (c0 ^ seed ^ uintptr(rand())) // any kind of NaN
	|:
		ret 0 //ret memhash(p, seed, 8)
	}
}

fn boolhash(b: bool, seed: uintptr): uintptr {
	if b {
		ret seed + 1
	}
	ret seed
}

fn structhash[S](s: S, mut seed: uintptr): uintptr {
	const v = comptime::ValueOf(s)
	const for i, field in v.Type().Decl().Fields() {
		const match {
		| field.Name() != "_":
			seed = maphash(v.FieldByIndex(i).Unwrap(), seed)
		}
	}
	ret seed
}

fn arrayhash[A](a: A, mut seed: uintptr): uintptr {
	for _, e in a {
		seed = maphash(e, seed)
	}
	ret seed
}

fn strhash(s: str, seed: uintptr): uintptr {
	unsafe {
		sp := (*strBase)(&s)
		ret memhash(sp.slice, uintptr(sp.len), seed)
	}
}

fn i32hash(i: u32, seed: uintptr): uintptr {
	ret unsafe { memhash32(&i, seed) }
}

fn i64hash(i: u64, seed: uintptr): uintptr {
	ret unsafe { memhash64(&i, seed) }
}

fn maphash[K](k: K, seed: uintptr): uintptr {
	const t = comptime::TypeOf(K)
	const match {
	| t.CanNil():
		if k == nil {
			ret seed
		}
	}
	const match t.Kind() {
	| comptime::Kind.Int | comptime::Kind.I8 | comptime::Kind.I16 | comptime::Kind.I32 | comptime::Kind.I64
	| comptime::Kind.Uint | comptime::Kind.U8 | comptime::Kind.U16 | comptime::Kind.U32 | comptime::Kind.U64:
		const match t.Bits() {
		| 64:
			ret i64hash(u64(k), seed)
		|:
			ret u32hash(u32(k), seed)
		}
	| comptime::Kind.Enum:
		comptime::TypeAlias(enumSource, t.Elem())
		ret maphash(enumSource(k), seed)
	| comptime::Kind.F32:
		ret f32hash(k, seed)
	| comptime::Kind.F64:
		ret f64hash(k, seed)
	| comptime::Kind.Trait | comptime::Kind.Any | comptime::Kind.TypeEnum:
		ret strhash(toStr(k), seed)
	| comptime::Kind.Str:
		ret strhash(k, seed)
	| comptime::Kind.Ptr | comptime::Kind.SmartPtr:
		ret unsafe { memhash((*unsafe)(uintptr(k)), _ptrSize, seed) }
	| comptime::Kind.Bool:
		ret boolhash(k, seed)
	| comptime::Kind.Array:
		ret arrayhash(k, seed)
	| comptime::Kind.Struct:
		ret structhash(k, seed)
	| comptime::Kind.Chan:
		ret unsafe { memhash((*unsafe)(uintptr(*(*&hchan)(&k))), _ptrSize, seed) }
	}
	panic("unreachable")
}

// Used to seed the hash function.
static mut hashkey: [4]uintptr = []

fn hashinit() {
	for i in hashkey {
		hashkey[i] = uintptr(rand())
	}
}
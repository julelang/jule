// Copyright 2025 The Jule Project Contributors. All rights reserved.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

// Represents a scheduled event.
// when is an absolute timestamp in nanoseconds.
struct timer {
	mu:    mutex
	theap: &timerheap                     // A fake smart-pointer to the owner timerheap.
	ifunc: fn(arg: uintptr, seq: uintptr) // A runtime-provided function will be invoked when timer fired.
	arg:   uintptr                        // Any argument provided by the runtime for f.
	seq:   uintptr                        // Any sequence value provided by the runtime for f.
	when:  i64                            // Timer wakes up at when. If <=0, should not fire.
	state: i32                            // State of the timer.
	index: int                            // Heap index, -1 if not in heap.
}

impl timer {
	// Returns new timer.
	#disable nilptr
	fn new(when: i64, ifunc: fn(arg: uintptr, seq: uintptr), arg: uintptr, seq: uintptr): &timer {
		mut t := new(timer)
		t.modify(when, ifunc, arg, seq)
		ret t
	}

	// Modifies an existing timer.
	// Reports whether the timer was modified before it was run.
	#disable nilptr
	fn modify(mut *self, when: i64, ifunc: fn(arg: uintptr, seq: uintptr), arg: uintptr, seq: uintptr) {
		self.mu.lock()
		self.when = when
		self.arg = arg
		self.seq = seq
		self.ifunc = ifunc
		if self.theap != nil && self.index != -1 {
			self.theap.mu.lock()
			self.theap.siftdown(self.index)
			self.theap.siftup(self.index)
			self.theap.mu.unlock()
		}
		self.mu.unlock()
	}

	// Stops the timer.
	#disable nilptr
	fn stop(mut *self) {
		self.mu.lock()
		self.ifunc = nil
		self.when = 0
		self.mu.unlock()
	}

	// Fires the timer, which is runtime timer associated with a raw function.
	#disable nilptr
	fn unlockAndFire(mut *self) {
		arg := self.arg
		seq := self.seq
		func := self.ifunc
		self.ifunc = nil
		self.mu.unlock()
		func(arg, seq)
	}
}

// A min-heap ordered by [timer.when].
struct timerheap {
	// A cached timer, it is used for stealing.
	// Lock-free, because it is used by the owner P only.
	cache: &timer

	// Protects the following fields.
	mu: mutex

	// All timers of the heap.
	// Timers are min-heap ordered.
	data: []&timer
}

impl timerheap {
	// Returns number of timers.
	#disable nilptr
	fn len(*self): int {
		ret len(self.data)
	}

	// Returns the earliest timer without removing it.
	#disable nilptr boundary
	fn peek(mut *self, delta: int): &timer {
		if delta >= len(self.data) {
			ret nil
		}
		ret self.data[0]
	}

	// Inserts a timer into the heap.
	#disable nilptr
	fn push(mut *self, mut t: &timer) {
		t.mu.lock()
		t.theap = unsafe { (&timerheap)(self) }
		t.index = len(self.data)
		self.data = append(self.data, t)
		self.siftup(t.index)
		t.mu.unlock()
	}

	// Removes and returns the earliest timer.
	// Timer lock must be held.
	#disable nilptr boundary
	fn pop(mut *self): &timer {
		n := len(self.data)
		if n == 0 {
			ret nil
		}

		mut min := self.data[0]
		mut last := self.data[n-1]

		self.data = self.data[:n-1]
		if n > 1 {
			self.data[0] = last
			last.index = 0
			self.siftdown(0)
		}

		min.index = -1
		min.theap = nil
		ret min
	}

	// Deletes a specific timer from the heap.
	// Timer lock must be held.
	#disable nilptr boundary
	fn remove(mut *self, mut t: &timer) {
		i := t.index
		if i < 0 || i >= len(self.data) {
			ret
		}

		mut last := self.data[len(self.data)-1]
		self.data = self.data[:len(self.data)-1]

		if i != len(self.data) {
			self.data[i] = last
			last.index = i
			self.siftdown(i)
			self.siftup(i)
		}

		t.index = -1
		t.theap = nil
	}

	#disable nilptr boundary
	fn siftup(mut *self, mut i: int) {
		for {
			parent := (i - 1) / 2
			if i == 0 || cmpwhen(self.data[parent].when, self.data[i].when) < 1 {
				break
			}
			self.swap(i, parent)
			i = parent
		}
	}

	#disable nilptr boundary
	fn siftdown(mut *self, mut i: int) {
		n := len(self.data)
		for {
			left := 2*i + 1
			if left >= n {
				break
			}

			mut smallest := left
			right := left + 1
			if right < n && cmpwhen(self.data[right].when, self.data[left].when) == -1 {
				smallest = right
			}

			if cmpwhen(self.data[i].when, self.data[smallest].when) < 1 {
				break
			}

			self.swap(i, smallest)
			i = smallest
		}
	}

	#disable nilptr boundary
	fn swap(mut *self, i: int, j: int) {
		self.data[i], self.data[j] = self.data[j], self.data[i]
		self.data[i].index = i
		self.data[j].index = j
	}

	// Checks the timer, pops and returns it if it should fire.
	// If there is no timer ready to fire, pollUntil indicates the delay
	// until the next possible firing time.
	// Safe for concurrent use by multiple coroutines.
	// The returned timer's lock will be acquired.
	#disable nilptr
	fn check(mut *self): (t: &timer, pollUntil: i64) {
		mut timerPeekOffs := 0
		self.mu.lock()
		for {
			t = self.peek(timerPeekOffs)
			if t == nil {
				break
			}
			t.mu.lock()
			// This timer cannot be fired.
			if t.when <= 0 {
				t.mu.unlock()
				timerPeekOffs++
				continue
			}
			break
		}
		if t == nil { // No suitable timer.
			self.mu.unlock()
			ret nil, -1
		}
		now := nanotime()
		// It's not the right time yet.
		if t.when > now {
			// Compute delay until the next timer fires.
			pollUntil = t.when - now
			t.mu.unlock()
			self.mu.unlock()
			t = nil
			if pollUntil <= 0 {
				panic("runtime: inconsistent timer state")
			}
			ret
		}
		// Timer should be fired.
		// Remove this timer from the heap.
		// But do not remove if the timer is an runtime internal timer
		// associated with a raw function to be invoked when timer fired.
		// Internal timers can only be removed by the timer owner.
		// Just clear "when" value and adjust timerheap for them.
		if t.ifunc != nil {
			self.remove(t)
		} else {
			t.when = 0
			if t.index != -1 {
				self.siftup(t.index)
			}
		}
		self.mu.unlock()
		pollUntil = 0
		ret
	}

	// Similar to check(), but does not remove the timer even if it is ready to fire.
	// Use this to peek at the earliest timer in the heap without consuming it.
	#disable nilptr
	fn wakeTime(mut *self): (pollUntil: i64) {
		// TODO: if it makes sense, make this lock-free.
		mut timerPeekOffs := 0
		self.mu.lock()
		let mut t: &timer
		for {
			t = self.peek(timerPeekOffs)
			if t == nil {
				break
			}
			t.mu.lock()
			// This timer cannot be fired.
			if t.when <= 0 {
				t.mu.unlock()
				timerPeekOffs++
				continue
			}
			break
		}
		if t == nil { // No suitable timer.
			self.mu.unlock()
			ret -1
		}
		now := nanotime()
		// It's not the right time yet.
		if t.when > now {
			// Compute delay until the next timer fires.
			pollUntil = t.when - now
			if pollUntil <= 0 {
				panic("runtime: inconsistent timer state")
			}
		} else {
			pollUntil = 0
		}
		t.mu.unlock()
		self.mu.unlock()
		ret
	}
}

// Compares two "when" timestamps w1 and w2 and returns their ordering.
//
// The comparison treats non-positive values (<= 0) as special cases,
// typically representing "unset", "inactive", or "no scheduled time".
//
// Ordering rules:
//	- If both w1 and w2 are <= 0, they are considered equal.
//	- If w1 <= 0 and w2 > 0, w1 is considered greater (returns +1).
//	- If w1 > 0 and w2 <= 0, w1 is considered smaller (returns -1).
//	- If both are > 0, they are compared numerically:
//		- returns -1 if w1 < w2
//		- returns +1 if w1 > w2
//		- returns  0 if w1 == w2
//
// Return values follow the conventional comparison contract:
//	-1 if w1 < w2
//	0 if w1 == w2
//	+1 if w1 > w2
fn cmpwhen(w1: i64, w2: i64): int {
	if w1 <= 0 {
		if w2 > 0 {
			ret +1
		}
		ret 0
	}
	if w2 <= 0 {
		ret -1
	}
	if w1 < w2 {
		ret -1
	}
	if w1 > w2 {
		ret +1
	}
	ret 0
}
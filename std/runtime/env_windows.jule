// Copyright 2024 The Jule Project Contributors. All rights reserved.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/integ"
use "std/integ/c"
use "std/sys"

extern fn GetCommandLineW(): *c::Wchar
extern unsafe fn CommandLineToArgvW(*c::Wchar, *c::Int): **c::Wchar
extern unsafe fn LocalFree(*unsafe)
extern fn GetEnvironmentStringsW(): *c::Wchar
extern unsafe fn FreeEnvironmentStringsW(*c::Wchar)
extern unsafe fn GetModuleFileNameW(*unsafe, *c::Wchar, int): int

#disable boundary
fn args(): []str {
	mut cmdl := extern.GetCommandLineW()
	mut argvw := unsafe { extern.CommandLineToArgvW(cmdl, (*c::Int)(&argc)) }
	mut args := make([]str, argc)
	for i in args {
		args[i] = unsafe { integ::UTF16PtrToStr((*u16)(argvw[i])) }
	}
	unsafe { extern.LocalFree(argvw) }
	ret args
}

fn env(): []str {
	const avgEnvVars = 20
	const NULL = 0
	mut env := make([]str, 0, avgEnvVars)
	mut envS := extern.GetEnvironmentStringsW()
	mut np := envS
	mut latest := envS
	unsafe {
		for *latest != NULL {
			for *np != NULL; np++ {
			}
			env = append(env, integ::UTF16PtrToStr((*u16)(latest)))
			np++
			latest = np
		}
	}
	unsafe { extern.FreeEnvironmentStringsW(envS) }
	ret env
}

fn executable(): str {
	const NULL = 0
	mut buf := make([]u16, sys::MAX_PATH)
	n := unsafe { extern.GetModuleFileNameW(nil, (*c::Wchar)(&buf[0]), sys::MAX_PATH) }
	if n > 0 {
		buf[n] = NULL
		ret unsafe { integ::UTF16PtrToStr(&buf[0]) }
	}
	panic("runtime: executable path read error")
}
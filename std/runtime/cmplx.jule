// Copyright 2025 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

// Built-in cmplx64 type.
struct _cmplx64 {
	real: f32
	imag: f32
}

fn cmplx64neg(c: _cmplx64): _cmplx64 {
	ret _cmplx64{
		real: -c.real,
		imag: -c.real,
	}
}

fn cmplx64add(m: _cmplx64, n: _cmplx64): _cmplx64 {
	ret _cmplx64{
		real: m.real + n.real,
		imag: m.imag + n.imag,
	}
}

fn cmplx64sub(m: _cmplx64, n: _cmplx64): _cmplx64 {
	ret _cmplx64{
		real: m.real - n.real,
		imag: m.imag - n.imag,
	}
}

fn cmplx64mul(m: _cmplx64, n: _cmplx64): _cmplx64 {
	ret _cmplx64{
		real: m.real*n.real + m.imag*n.imag*-1,
		imag: m.real*n.imag + m.imag*n.real,
	}
}

fn cmplx64div(m: _cmplx64, n: _cmplx64): _cmplx64 {
	ret cmplx128cmplx64(cmplx128div(cmplx64cmplx128(m), cmplx64cmplx128(n)))
}

// Built-in cmplx128 type.
struct _cmplx128 {
	real: f64
	imag: f64
}

fn cmplx128neg(c: _cmplx128): _cmplx128 {
	ret _cmplx128{
		real: -c.real,
		imag: -c.real,
	}
}

fn cmplx128add(m: _cmplx128, n: _cmplx128): _cmplx128 {
	ret _cmplx128{
		real: m.real + n.real,
		imag: m.imag + n.imag,
	}
}

fn cmplx128sub(m: _cmplx128, n: _cmplx128): _cmplx128 {
	ret _cmplx128{
		real: m.real - n.real,
		imag: m.imag - n.imag,
	}
}

fn cmplx128mul(m: _cmplx128, n: _cmplx128): _cmplx128 {
	ret _cmplx128{
		real: m.real*n.real + m.imag*n.imag*-1,
		imag: m.real*n.imag + m.imag*n.real,
	}
}

fn cmplx128div(n: _cmplx128, m: _cmplx128): _cmplx128 {
	// complex(e, f) = n/m
	let mut e: f64
	let mut f: f64

	// Algorithm for robust complex division as described in
	// Robert L. Smith: Algorithm 116: Complex division. Commun. ACM 5(8): 435 (1962).
	if abs(m.real) >= abs(m.imag) {
		ratio := m.imag / m.real
		denom := m.real + ratio*m.imag
		e = (n.real + n.imag*ratio) / denom
		f = (n.imag - n.real*ratio) / denom
	} else {
		ratio := m.real / m.imag
		denom := m.imag + ratio*m.real
		e = (n.real*ratio + n.imag) / denom
		f = (n.imag*ratio - n.real) / denom
	}

	if isNaN(e) && isNaN(f) {
		// Correct final result to infinities and zeros if applicable.
		// Matches C99: ISO/IEC 9899:1999 - G.5.1  Multiplicative operators.

		mut a, mut b := n.real, n.imag
		mut c, mut d := m.real, m.imag

		match {
		| c == 0 && d == 0 && (!isNaN(a) || !isNaN(b)):
			e = copysign(_inf, c) * a
			f = copysign(_inf, c) * b
		| (isInf(a) || isInf(b)) && isFinite(c) && isFinite(d):
			a = inf2one(a)
			b = inf2one(b)
			e = _inf * (a*c + b*d)
			f = _inf * (b*c - a*d)
		| (isInf(c) || isInf(d)) && isFinite(a) && isFinite(b):
			c = inf2one(c)
			d = inf2one(d)
			e = 0 * (a*c + b*d)
			f = 0 * (b*c - a*d)
		}
	}

	ret _cmplx128{
		real: e,
		imag: f,
	}
}

// Returns a signed 1 if f is an infinity and a signed 0 otherwise.
// The sign of the result is the sign of f.
fn inf2one(f: f64): f64 {
	mut g := 0.0
	if isInf(f) {
		g = 1.0
	}
	ret copysign(g, f)
}

fn cmplx64cmplx128(c: _cmplx64): _cmplx128 {
	ret _cmplx128{
		real: f64(c.real),
		imag: f64(c.imag),
	}
}

fn cmplx128cmplx64(c: _cmplx128): _cmplx64 {
	ret _cmplx64{
		real: f32(c.real),
		imag: f32(c.imag),
	}
}
// Copyright 2024-2025 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/comptime"
use integ "std/jule/integrated"
use "std/unsafe"

// Returns pointer in string form.
#export "__jule_ptrToStr"
fn ptrToStr(p: *unsafe): str {
	if p == nil {
		ret "<nil>"
	}
	const numbers = "0123456789abcdef"
	mut buf := make([]byte, 100)
	mut i := len(buf) - 1
	mut n := u64(uintptr(p))
	for i > 0; i-- {
		buf[i] = numbers[n%16]
		if n < 16 {
			break
		}
		n /= 16
	}
	i--
	buf[i] = 'x'
	i--
	buf[i] = '0'
	ret unsafe::StrFromBytes(buf[i:])
}

// Returns boolean in string form.
#export "__jule_boolToStr"
fn boolToStr(b: bool): str {
	if b {
		ret "true"
	}
	ret "false"
}

// Returns x in decimal string format.
#export "__jule_i64ToStr"
fn i64ToStr(x: i64): str {
	if x < 0 {
		ret "-" + u64ToStr(u64(-x))
	}
	ret u64ToStr(u64(x))
}

// Returns x in decimal string format.
#export "__jule_u64ToStr"
fn u64ToStr(mut x: u64): str {
	mut buf := make([]byte, 20) // big enough for 64bit value base 10
	n := u64ToBuf(buf, x)
	buf = buf[:n]
	ret unsafe::StrFromBytes(buf)
}

// Writes x in decimal string format into buf.
// Returns number of written bytes.
fn u64ToBuf(mut buf: []byte, mut x: u64): int {
	if x == 0 {
		buf[0] = '0'
		ret 1
	}
	mut i := 0
	for x >= 10 {
		q := x / 10
		buf[i] = byte('0' + x - q*10)
		i++
		x = q
	}
	// x < 10
	n := i + 1
	buf[i] = byte('0' + x)

	// reverse
	i = 0
	mut j := n - 1
	for i < j; i, j = i+1, j-1 {
		buf[i], buf[j] = buf[j], buf[i]
	}

	ret n
}

// Returns x in decimal string format.
#export "__jule_f64ToStr"
fn f64ToStr(mut f: f64): str {
	const mantbits = 52
	const expbits = 11
	bits := f64bits(f)
	neg := bits>>(expbits+mantbits) != 0
	exp := int(bits>>mantbits) & int(1<<expbits-1)
	mant := bits & (u64(1)<<mantbits - 1)

	// check cases for NaN or ±Inf
	if exp == int(1<<expbits)-1 {
		match {
		| mant != 0:
			ret "NaN"
		| neg:
			ret "-Inf"
		|:
			ret "+Inf"
		}
	}

	const Prec = 4 // Fraction precision.

	//   ±   u64  .   frac
	n := 1 + 20 + 1 + Prec // enough size for base 10
	mut buf := make([]byte, n)
	mut j := 0
	if neg {
		buf[0] = '-'
		j++
		f = -f
	}

	intPart := u64(f)
	j += u64ToBuf(buf[j:], intPart)

	buf[j] = '.'
	mut fracPart := f - f64(intPart)
	mut i := 0

	// 17 is a maximum precision, subtract j to find remaining precision for after dot
	prec := 17 - j
	for i < prec; i++ {
		fracPart *= 10
		digit := int(fracPart)
		if digit < 0 || digit > 9 {
			break
		}
		j++
		buf[j] = byte('0' + digit)
		fracPart -= f64(digit)
	}

	// trim trailing zeros
	for j >= 0; j-- {
		if buf[j] != '0' {
			break
		}
	}
	if buf[j] != '.' {
		j++
	}
	buf = buf[:j]

	ret unsafe::StrFromBytes(buf)
}

// Returns x in string form with default format.
// Compatible with slices.
fn arrToStr[T](x: T): str {
	mut buf := make([]byte, 0, 20)
	buf = append(buf, '[')
	for i, z in x {
		if i > 0 {
			buf = append(buf, ", "...)
		}
		buf = append(buf, toStr(z)...)
	}
	buf = append(buf, ']')
	ret unsafe::StrFromBytes(buf)
}

// Returns x in string form with default format.
fn mapToStr[T](x: T): str {
	mut buf := make([]byte, 0, 20)
	buf = append(buf, '{')
	mut written := false
	for key, val in x {
		if written {
			buf = append(buf, ", "...)
		} else {
			written = true
		}
		buf = append(buf, toStr(key)...)
		buf = append(buf, ':')
		buf = append(buf, toStr(val)...)
	}
	buf = append(buf, '}')
	ret unsafe::StrFromBytes(buf)
}

// Tries to call reserved Str method for type.
fn tryToCallStr[T](x: T): (str, ok: bool) {
	const t = comptime::TypeOf(T)
	const for _, method in t.Decl().Methods() {
		const match method.Name() {
		| "Str":
			const v = comptime::ValueOf(x)
			const methodv = v.Method(method.Name())
			const match {
			| !methodv.Type().Decl().Exceptional() &&
				methodv.Type().Result().Kind() == comptime::Kind.Str:
				const params = method.Params()
				const match {
				| len(params) == 1 && !params[0].Mutable():
					ret methodv.Unwrap()(), true
				}
			}
		}
	}
	ret "", false
}

// Returns x in string form with default format.
fn structToStr[T](x: T): str {
	r, ok := tryToCallStr(x)
	if ok {
		ret r
	}
	const t = comptime::TypeOf(T)
	const v = comptime::ValueOf(x)
	mut buf := make([]byte, 0, 20)
	buf = append(buf, '{')
	const for i, field in t.Fields() {
		const match {
		| i > 0:
			buf = append(buf, ", "...)
		}
		const match {
		| field.Type().Binded():
			buf = append(buf, field.Type().Str()...)
		|:
			buf = append(buf, toStr(v.FieldByIndex(i).Unwrap())...)
		}
	}
	buf = append(buf, '}')
	ret unsafe::StrFromBytes(buf)
}

// Returns x in string form with default format.
// It designed for general-purpose string conversion for built-in behavior.
fn toStr[T](x: T): str {
	const t = comptime::TypeOf(T)
	const match {
	| t.Binded():
		ret t.Str()
	| t.CanNil():
		if x == nil {
			ret "<nil>"
		}
	| t.Strict():
		// Lookup for the reserved Str method for the strict type like structures.
		r, ok := tryToCallStr(x)
		if ok {
			ret r
		}
		// If strict type have not the reserved Str method, handle by the source type.
		// Following analysis will do that.
	}

	const match t.Kind() {
	| comptime::Kind.Str:
		ret str(x)
	| comptime::Kind.Int | comptime::Kind.I8 | comptime::Kind.I16 | comptime::Kind.I32 | comptime::Kind.I64:
		ret i64ToStr(i64(x))
	| comptime::Kind.Uint | comptime::Kind.Uintptr | comptime::Kind.U8 | comptime::Kind.U16 | comptime::Kind.U32 | comptime::Kind.U64:
		ret u64ToStr(u64(x))
	| comptime::Kind.F32 | comptime::Kind.F64:
		ret f64ToStr(f64(x))
	| comptime::Kind.Bool:
		ret boolToStr(bool(x))
	| comptime::Kind.Any | comptime::Kind.TypeEnum | comptime::Kind.Trait:
		ret unsafe { integ::Emit[str]("{}.type->to_str({}.data.alloc)", x, x) }
	| comptime::Kind.Func:
		ret unsafe { ptrToStr(integ::Emit[*unsafe]("({}){}.f", *unsafe, x)) }
	| comptime::Kind.Slice | comptime::Kind.Array:
		ret arrToStr(x)
	| comptime::Kind.Map:
		ret mapToStr(x)
	| comptime::Kind.Struct:
		ret structToStr(x)
	| comptime::Kind.SmartPtr:
		ret unsafe { ptrToStr((*unsafe)(uintptr(x))) }
	| comptime::Kind.Ptr | comptime::Kind.UnsafePtr:
		ret ptrToStr(unsafe { (*unsafe)(uintptr(x)) })
	| comptime::Kind.Enum:
		comptime::TypeAlias(elemType, t.Elem())
		ret toStr(elemType(x))
	| comptime::Kind.Chan:
		// Channels are smart pointers behind the scene.
		// Take raw pointer, handle as &uintptr to read memory address of
		// smart pointer, and pass to ptrToStr as unsafe raw pointer to
		// print allocation address of the smart pointer.
		ret unsafe { ptrToStr((*unsafe)(uintptr(*(*&uintptr)(&x)))) }
	}
	panic("runtime: unsupported type for toStr")
}
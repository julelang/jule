// Copyright 2024-2025 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/internal/runtime/atomic"

// Ideal threshold for the wait/sleep time. Supports every possible platform.
// For sleep functions, on most UNIX-like systems we can sleep less than 1ms,
// but Windows supports minimum 1ms sleep. So, the threshold is 1ms to be portable.
// It also may be used as threshold for spinlocks before sleeping or fall in starvation mode.
const pauseThreshold = 1e6

const fmutexSize = 4 // i32

// Simple mutex implementation for elementary purposes.
// Suitable for quick Lock/Unlock arenas.
// It may be insufficient in long-term locks due to lack of thread parking integration.
struct fmutex {
	mut state: i32
}

impl fmutex {
	#disable nilptr
	fn lock(*self) {
		mut waitstart := i64(0)
		for {
			if self.tryLock() {
				ret
			}
			if waitstart == 0 {
				waitstart = nanotime()
				continue
			}
			// If mutex tries more than pauseThreshold, try to yield CPU.
			if nanotime()-waitstart > pauseThreshold {
				// Yield the CPU if possible, it may return immediately for the same thread.
				// However, this part of thread management belongs to the operating system.
				osyield()
				waitstart = nanotime()
			}
		}
	}

	#disable nilptr
	fn unlock(*self) {
		old := atomic::Swap(&self.state, 0, atomic::Release)
		if old == 0 {
			panic("runtime: mutex: unlock of unlocked mutex")
		}
	}

	#disable nilptr
	fn tryLock(*self): bool {
		ret atomic::CompareAndSwap(&self.state, 0, 1, atomic::Acquire, atomic::Relaxed)
	}
}

const qmutexSize = 4 // i32

// Simpler mutex implementation for elementary purposes.
// Suitable for quick Lock/Unlock arenas.
// It may be insufficient in long-term locks due to lack of thread parking integration.
// Unlike the fmutex, it uses pure spin-lock.
//
// Be careful when updating memory layout of the type.
// Because unsafe pointer conversions assumes
// fmutex and qmutex have the same memory layout.
struct qmutex {
	mut state: i32
}

impl qmutex {
	#disable nilptr
	fn lock(*self) {
		for !self.tryLock() {
		}
	}

	#disable nilptr
	fn unlock(*self) {
		old := atomic::Swap(&self.state, 0, atomic::Release)
		if old == 0 {
			panic("runtime: mutex: unlock of unlocked mutex")
		}
	}

	#disable nilptr
	fn tryLock(*self): bool {
		ret atomic::CompareAndSwap(&self.state, 0, 1, atomic::Acquire, atomic::Relaxed)
	}
}
// Copyright 2024 The Jule Project Contributors. All rights reserved.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/internal/runtime"

// The low-level base channel implementation of the language runtime.
// The generic type represents the data type of the channel. Instances required
// at compile-time are automatically instantiated by the compiler.
// Any channel algorithms that require generic types should be defined under
// this structure. A pchan should not be copied after being used.
// The compiler creates channels in the background using the [pchan[T].new].
// Behind the scenes, each channel is treated as a smart pointer.
struct pchan[T] {
	lock:   qmutex       // Protects all fields, except lock-free ones.
	cap:    int          // Immutable capacity of the channel. Zero if channel is unbuffered.
	closed: u32          // Closed state of the channel. Boolean.
	sendq:  waitq        // List of send waiters.
	recvq:  waitq        // List of recv waiters.
	queue:  mpmcQueue[T] // Lock-free MPMC data queue.
}

impl pchan {
	#disable nilptr
	fn new(mut cap: int): &pchan[T] {
		mut ch := new(pchan[T])
		if cap < 0 {
			panic("runtime: invalid channel buffer size, it was <0")
		}
		if cap > 0 {
			ch.queue = mpmcQueue[T].new(u64(cap))
			ch.cap = cap
		}
		ret ch
	}

	// Closes the channel.
	#disable nilptr
	fn close(mut *self) {
		self.queue.close()

		self.lock.lock()

		// Set state as closed.
		self.closed = 1

		// If channel is buffered, hand-off enqueued data to the waiting receivers.
		if self.cap > 0 {
			for {
				mut recvp := self.recvq.dequeueChan()
				if recvp == nil {
					break
				}
				let mut data: T
				self.queue.dequeue(&data)
				if recvp.stack != 0 {
					unsafe { *(*T)(recvp.stack) = data }
				}
				recvp.stack = 0  // Set stack pointer to zero, marked as received.
				recvp.ticket = 0 // Set ticket to zero, marked as received for select statements.
				unpark(&(*recvp.cp))
			}
		}

		// If channel is unbuffered, handle it like hand-off.
		// Unbuffered channels works with direct data hand-off.
		// Closing channel will notify them spuriously.
		// Since channel is closed, it can't try again.
		// Clear spurious wakeup signs to avoid try again in select statements.
		unparkAll(&self.recvq, self.cap == 0) // Unpark all receivers.
		unparkAll(&self.sendq, false)         // Unpark all senders (they will panic).

		self.lock.unlock()
	}

	// Final implementation of the [pchan.send] function.
	// Focuses on parked coroutines.
	// Mutex must be locked. It will be released before return.
	// Reports whether the stack pointer is used (data handled).
	#disable nilptr
	async fn sendFinal(mut *self, mut &data: *T): (spurious: bool) {
		// Before park the coroutine, check for a waiting receiver, if any.
		// If we lucky, write data to the stack of the receiver and return.
		mut recvp := self.recvq.dequeueChan()
		if recvp != nil {
			self.lock.unlock()
			if recvp.stack != 0 {
				unsafe { *(*T)(recvp.stack) = *data }
				recvp.stack = 0 // Set stack pointer to zero, marked as sent.
			}
			recvp.ticket = 0 // Set ticket to zero, marked as sent for select statements.
			unpark(&(*recvp.cp))
			ret false
		}

		// We have to park the coroutine.
		mut stackp := parkerList{}
		mut p := unsafe { (&parkerList)(&stackp) }
		mut tc := gett().c
		p.cp = unsafe { (&c)(&tc) }
		p.stack = uintptr(data)
		self.sendq.enqueue(p)
		park(&(*p.cp), uintptr(&self.lock), reasonSend).await
		ret isSpuriousWake(&stackp)
	}

	// Implementation of the buffered [pchan.send] function.
	#disable nilptr
	async fn sendBuffered(mut *self, mut data: T) {
		for {
			// Fast-path: enqueue data using the lock-free MPMC queue.
			mut enq, mut closed, full := self.queue.enqueue(&data)
			// If queue is full now (or with new sent data), wake a receiver.
			// This is a spurious wake, do not write the data to it's stack pointer.
			// It must be try to receive it from the queue.
			//
			// This is needed because all receivers might be parked.
			// Queue is full and no reader, deadlock. Bad.
			if full {
				self.lock.lock()
				mut recvp := self.recvq.dequeueChan()
				self.lock.unlock()
				if recvp != nil {
					unpark(&(*recvp.cp))
				}
			}
			// Enqueued, return.
			if enq {
				ret
			}
			if closed {
				panic("runtime: send on closed channel")
			}

			// Slow-path: enqueue the coroutine to waiters and park.
			// A coroutine must notify (might be spurious) this coroutine.
			self.lock.lock()
			if self.closed != 0 {
				panic("runtime: send on closed channel")
			}
			// Last chance, try the lock-free MPMC queue.
			// When we try to lock the channel mutex, a data might be received from queue.
			enq, _, _ = self.queue.enqueue(&data)
			// Enqueued, lucky. Return.
			if enq {
				self.lock.unlock()
				ret
			}
			// Send data (hand-off) to a waiting receiver, if any.
			// Otherwise, park the coroutine until a coroutine notify (might be spurious) us.
			if !self.sendFinal(&data).await {
				// Not a spurious wakeup, return.
				ret
			}
			// Spurious wakeup, we have to try again.
		}
	}

	// Implementation of the unbuffered [pchan.send] function.
	#disable nilptr
	async fn sendUnbuffered(mut *self, mut data: T) {
		self.lock.lock()

		// Check for closed case in lock, to make sure channel is alive.
		if self.closed != 0 {
			panic("runtime: send on closed channel")
		}

		// Unbuffered channels works with direct data hand-off.
		// No spurious wakeups, but closing channel will notify us spuriously.
		spurious := self.sendFinal(&data).await
		if spurious {
			panic("runtime: send on closed channel")
		}
	}

	// Sends the data to the channel.
	// Blocks until success.
	#disable nilptr
	async fn send(mut *self, mut data: T) {
		if self.cap == 0 {
			self.sendUnbuffered(data).await
		} else {
			self.sendBuffered(data).await
		}
	}

	// Tries to send a data to receiver from queue immediately.
	// Channel lock must be locked and it will not be released before return.
	#disable nilptr
	fn trySendImmediate(mut *self, mut &ok: *bool, mut &data: *T) {
		// Check for a waiting receiver, if any.
		// If we lucky, write data to the stack of the receiver and return.
		mut recvp := self.recvq.dequeueChan()
		if recvp != nil {
			if recvp.stack != 0 {
				unsafe { *(*T)(recvp.stack) = *data }
				recvp.stack = 0 // Set stack pointer to zero, marked as sent.
			}
			recvp.ticket = 0 // Set ticket to zero, marked as sent for select statements.
			unpark(&(*recvp.cp))
			*ok = true
		} else {
			// Fail.
			*ok = false
		}
	}

	// Implementation of the buffered [pchan.trySend] function.
	#disable nilptr
	fn trySendBuffered(mut *self, mut &ok: *bool, mut &data: *T) {
		// Enqueue data using lock-free MPMC queue.
		enq, _, full := self.queue.enqueue(data)
		// If queue is full now (or with new sent data), wake a receiver.
		// This is a spurious wake, do not write the data to it's stack pointer.
		// It must be try to receive it from the queue.
		//
		// This is needed because all receivers might be parked.
		// Queue is full and no reader, deadlock. Bad.
		if full {
			self.lock.lock()
			mut recvp := self.recvq.dequeueChan()
			self.lock.unlock()
			if recvp != nil {
				unpark(&(*recvp.cp))
			}
		}
		// Enqueued, return.
		if enq {
			*ok = true
			ret
		}
		*ok = false
	}

	// Implementation of the unbuffered [pchan.trySend] function.
	#disable nilptr
	fn trySendUnbuffered(mut *self, mut &ok: *bool, mut &data: *T) {
		// Check for a waiting receiver, if any.
		// If we lucky, write data to the stack of the receiver and return.
		self.lock.lock()
		mut recvp := self.recvq.dequeueChan()
		self.lock.unlock()
		if recvp != nil {
			if recvp.stack != 0 {
				unsafe { *(*T)(recvp.stack) = *data }
				recvp.stack = 0 // Set stack pointer to zero, marked as sent.
			}
			recvp.ticket = 0 // Set ticket to zero, marked as sent for select statements.
			unpark(&(*recvp.cp))
			*ok = true
		} else {
			// Fail.
			*ok = false
		}
	}

	// Tries to send the data to the channel.
	// Do not blocks until success.
	// The `ok` parameter must always not be nil.
	#disable nilptr
	fn trySend(mut *self, mut &ok: *bool, mut &data: *T) {
		if self == nil {
			*ok = false
		} else if self.cap == 0 {
			self.trySendUnbuffered(ok, data)
		} else {
			self.trySendBuffered(ok, data)
		}
	}

	// Final implementation of the [pchan.recv] function.
	// Focuses on parked coroutines.
	// Mutex must be locked. It will be released before return.
	// Reports whether the stack pointer is used (data handled).
	#disable nilptr
	async fn recvFinal(mut *self, mut &ok: *bool, mut &data: *T): (spurious: bool) {
		// Before park the coroutine, check for a waiting sender, if any.
		// If we lucky, read data from the stack of the sender and return.
		mut sendp := self.sendq.dequeueChan()
		if sendp != nil {
			self.lock.unlock()
			*data = unsafe { *(*T)(sendp.stack) }
			sendp.stack = 0  // Set stack pointer to zero, marked as received.
			sendp.ticket = 0 // Set ticket to zero, marked as received for select statements.
			unpark(&(*sendp.cp))
			if ok != nil {
				*ok = true
			}
			ret false
		}

		// We have to park the coroutine.
		mut stackp := parkerList{}
		mut p := unsafe { (&parkerList)(&stackp) }
		mut tc := gett().c
		p.cp = unsafe { (&c)(&tc) }
		p.stack = uintptr(data)
		self.recvq.enqueue(p)
		park(&(*p.cp), uintptr(&self.lock), reasonRecv).await
		spurious = isSpuriousWake(&stackp)
		if ok != nil {
			*ok = !spurious
		}
		ret
	}

	// Implementation of the buffered [pchan.recv] function.
	#disable nilptr
	async fn recvBuffered(mut *self, mut &ok: *bool): (data: T) {
		for {
			// Fast-path: dequeue data using the lock-free MPMC queue.
			mut deq, mut closed := self.queue.dequeue(&data)
			// Dequeued, return.
			if deq {
				if ok != nil {
					*ok = true
				}
				ret
			}
			// Not dequeued and MPMC queue is closed.
			// This means channel is closed and buffer is empty.
			if closed {
				if ok != nil {
					*ok = false
				}
				ret
			}

			// Slow-path: enqueue the coroutine to waiters and park.
			// A coroutine must notify (might be spurious) this coroutine.
			self.lock.lock()
			if self.closed != 0 {
				self.lock.unlock()
				if ok != nil {
					*ok = false
				}
				ret
			}
			// Last chance, try the lock-free MPMC queue.
			// When we try to lock the channel mutex, a data might be sent to queue.
			deq, closed = self.queue.dequeue(&data)
			// Dequeued, lucky. Return.
			if deq {
				self.lock.unlock()
				if ok != nil {
					*ok = true
				}
				ret
			}
			// Receive (hand-off) data from a waiting sender, if any.
			// Otherwise, park the coroutine until a coroutine notify (might be spurious) us.
			if !self.recvFinal(ok, &data).await {
				// Not a spurious wakeup, return.
				ret
			}
			// Spurious wakeup, we have to try again.
		}
	}

	// Implementation of the unbuffered [pchan.recv] function.
	#disable nilptr
	async fn recvUnbuffered(mut *self, mut &ok: *bool): (data: T) {
		self.lock.lock()

		// Check for closed case in lock, to make sure channel is alive.
		if self.closed != 0 {
			self.lock.unlock()
			if ok != nil {
				*ok = false
			}
			ret
		}

		// Unbuffered channels works with direct data hand-off.
		// No spurious wakeups, but closing channel will notify us spuriously.
		// Is is handled like hand-off but failed.
		self.recvFinal(ok, &data).await
		ret
	}

	// Receives the data from the channel.
	// Blocks until success.
	// The |ok| is the reference that points to boolean and
	// it reports whether data dequeued and received successfully.
	#disable nilptr
	async fn recv(mut *self, mut &ok: *bool): T {
		if self.cap == 0 {
			ret self.recvUnbuffered(ok).await
		} else {
			ret self.recvBuffered(ok).await
		}
	}

	// Tries to receive a data from sender queue immediately.
	// Channel lock must be locked and it will not be released before return.
	// The closed state pointer must be not nil.
	#disable nilptr
	fn tryRecvImmediate(mut *self, mut &ok: *bool, mut &data: *T, mut &closed: *bool) {
		*closed = self.closed != 0
		mut sendp := self.sendq.dequeueChan()
		if sendp != nil {
			if data != nil {
				*data = unsafe { *(*T)(sendp.stack) }
			}
			sendp.stack = 0  // Set stack pointer to zero, marked as received.
			sendp.ticket = 0 // Set ticket to zero, marked as received for select statements.
			unpark(&(*sendp.cp))
			*ok = true
		} else {
			// Fail.
			*ok = false
			if data != nil {
				let mut zero: T
				*data = zero
			}
		}
	}

	// Implementation of the buffered [pchan.tryRecv] function.
	// The closed state pointer must be not nil.
	#disable nilptr
	fn tryRecvBuffered(mut *self, mut &ok: *bool, mut &data: *T, mut &closed: *bool) {
		// Dequeue data using the lock-free MPMC queue.
		deq, (*closed) := self.queue.dequeue(data)
		if deq {
			*ok = true
			ret
		}
		*ok = false
		if data != nil {
			let mut zero: T
			*data = zero
		}
	}

	// Implementation of the unbuffered [pchan.tryRecv] function.
	#disable nilptr
	fn tryRecvUnbuffered(mut *self, mut &ok: *bool, mut &data: *T, mut &closed: *bool) {
		// Check for a waiting sender, if any.
		// If we lucky, read data from the stack of the sender and return.
		self.lock.lock()
		*closed = self.closed != 0
		mut sendp := self.sendq.dequeueChan()
		self.lock.unlock()
		if sendp != nil {
			if data != nil {
				*data = unsafe { *(*T)(sendp.stack) }
			}
			sendp.stack = 0  // Set stack pointer to zero, marked as received.
			sendp.ticket = 0 // Set ticket to zero, marked as received for select statements.
			unpark(&(*sendp.cp))
			*ok = true
		} else {
			// Fail.
			*ok = false
			if data != nil {
				let mut zero: T
				*data = zero
			}
		}
	}

	// Tries to receive a data from the channel.
	// The parameter ok and closed always must be not-nil.
	#disable nilptr
	fn tryRecv(mut *self, mut &ok: *bool, mut &data: *T, mut &closed: *bool) {
		if self == nil {
			*ok = false
			if data != nil {
				let mut zero: T
				*data = zero
			}
		} else if self.cap == 0 {
			self.tryRecvUnbuffered(ok, data, closed)
		} else {
			self.tryRecvBuffered(ok, data, closed)
		}
	}

	// Returns capacity of the channel.
	// Returns zero if channel is nil.
	#disable nilptr
	fn stdcap(mut *self): int {
		if self == nil {
			ret 0
		}
		ret self.cap
	}
}
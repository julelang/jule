// Copyright 2024 The Jule Project Contributors. All rights reserved.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/internal/runtime"
use "std/internal/runtime/atomic"
use "std/mem"

// The low-level base channel implementation of the language runtime.
// The generic type represents the data type of the channel. Instances required
// at compile-time are automatically instantiated by the compiler.
// Any channel algorithms that require generic types should be defined under
// this structure. A pchan should not be copied after being used.
// The compiler creates channels in the background using the [pchan[T].new].
// Behind the scenes, each channel is treated as a smart pointer.
struct pchan[T] {
	lock:   mutex        // Protects all fields, except lock-free ones.
	cap:    int          // Immutable capacity of the channel. Zero if channel is unbuffered.
	closed: u32          // Closed state of the channel. Boolean.
	sendq:  waitq        // List of send waiters.
	recvq:  waitq        // List of recv waiters.
	queue:  mpmcQueue[T] // Lock-free MPMC data queue.
}

impl pchan {
	#disable nilptr
	fn new(mut cap: int): &pchan[T] {
		mut ch := new(pchan[T])
		if cap < 0 {
			panic("runtime: invalid channel buffer size, it was <0")
		}
		if cap > 0 {
			ch.queue = mpmcQueue[T].new(u64(cap))
			ch.cap = cap
		}
		ret ch
	}

	// Closes the channel.
	#disable nilptr
	fn close(mut *self) {
		self.queue.close()

		self.lock.lock()

		// Set state as closed.
		self.closed = 1

		// If channel is buffered, hand-off enqueued data to the waiting receivers.
		if self.cap > 0 {
			for {
				mut recvp := self.recvq.dequeueChan()
				if recvp == nil {
					break
				}
				let mut data: T
				self.queue.dequeue(&data)
				if recvp.stack != 0 {
					unsafe { *(*T)(recvp.stack) = data }
				}
				recvp.stack = 0  // Set stack pointer to zero, marked as received.
				recvp.ticket = 0 // Set ticket to zero, marked as received for select statements.
				unsafe { unpark(&(*recvp.cp)) }
			}
		}

		// If channel is unbuffered, handle it like hand-off.
		// Unbuffered channels works with direct data hand-off.
		// Closing channel will notify them spuriously.
		// Since channel is closed, it can't try again.
		// Clear spurious wakeup signs to avoid try again in select statements.
		unparkAll(&self.recvq, self.cap == 0) // Unpark all receivers.
		unparkAll(&self.sendq, false)         // Unpark all senders (they will panic).

		self.lock.unlock()
	}

	// Sends the data to the channel.
	// Blocks until success.
	#disable nilptr
	async fn send(mut *self, mut data: T) {
		for {
			if self.cap > 0 {
				// Fast-path: enqueue data using the lock-free MPMC queue.
				mut enq, mut closed, full := self.queue.enqueue(&data)
				// If queue is full now (or with new sent data), wake a receiver.
				// This is a spurious wake, do not write the data to it's stack pointer.
				// It must be try to receive it from the queue.
				//
				// This is needed because all receivers might be parked.
				// Queue is full and no reader, deadlock. Bad.
				if full {
					self.lock.lock()
					mut recvp := self.recvq.dequeueChan()
					self.lock.unlock()
					if recvp != nil {
						unsafe { unpark(&(*recvp.cp)) }
					}
				}
				// Enqueued, return.
				if enq {
					ret
				}
				if closed {
					panic("runtime: send on closed channel")
				}
			}

			self.lock.lock()

			if self.cap > 0 {
				// Last chance, try the lock-free MPMC queue.
				// When we try to lock the channel mutex, a data might be received from queue.
				enq, _, _ := self.queue.enqueue(&data)
				// Enqueued, lucky. Return.
				if enq {
					self.lock.unlock()
					ret
				}
			}

			// Check for closed case in lock, to make sure channel is alive.
			if self.closed != 0 {
				panic("runtime: send on closed channel")
			}

			// Before park the coroutine, check for a waiting receiver, if any.
			// If we lucky, write data to the stack of the receiver and return.
			mut recvp := self.recvq.dequeueChan()
			if recvp != nil {
				self.lock.unlock()
				if recvp.stack != 0 {
					unsafe { *(*T)(recvp.stack) = data }
					recvp.stack = 0 // Set stack pointer to zero, marked as sent.
				}
				recvp.ticket = 0 // Set ticket to zero, marked as sent for select statements.
				unsafe { unpark(&(*recvp.cp)) }
				ret
			}

			// We have to park the coroutine.
			mut stackp := chanlist{}
			mut p := unsafe { (&chanlist)(&stackp) }
			mut tc := gett().c
			p.cp = &tc
			p.stack = uintptr(&data)
			self.sendq.enqueue(p)
			park(&tc, uintptr(&self.lock), reasonSend).await
			if isSpuriousWake(&stackp) {
				if self.cap > 0 {
					// Spurious wakeup, we have to try again.
					continue
				}
				panic("runtime: send on closed channel")
			}
			ret
		}
	}

	// Tries to send a data to receiver from queue immediately.
	// Channel lock must be locked and it will not be released before return.
	#disable nilptr
	fn trySendImmediate(mut *self, mut &ok: *bool, mut &data: *T) {
		// Check for a waiting receiver, if any.
		// If we lucky, write data to the stack of the receiver and return.
		mut recvp := self.recvq.dequeueChan()
		if recvp != nil {
			if recvp.stack != 0 {
				unsafe { *(*T)(recvp.stack) = *data }
				recvp.stack = 0 // Set stack pointer to zero, marked as sent.
			}
			recvp.ticket = 0 // Set ticket to zero, marked as sent for select statements.
			unsafe { unpark(&(*recvp.cp)) }
			*ok = true
		} else {
			// Fail.
			*ok = false
		}
	}

	// Implementation of the buffered [pchan.trySend] function.
	#disable nilptr
	fn trySendBuffered(mut *self, mut &ok: *bool, mut &data: *T) {
		// Enqueue data using lock-free MPMC queue.
		enq, _, full := self.queue.enqueue(data)
		// If queue is full now (or with new sent data), wake a receiver.
		// This is a spurious wake, do not write the data to it's stack pointer.
		// It must be try to receive it from the queue.
		//
		// This is needed because all receivers might be parked.
		// Queue is full and no reader, deadlock. Bad.
		if full {
			self.lock.lock()
			mut recvp := self.recvq.dequeueChan()
			self.lock.unlock()
			if recvp != nil {
				unsafe { unpark(&(*recvp.cp)) }
			}
		}
		// Enqueued, return.
		if enq {
			*ok = true
			ret
		}
		*ok = false
	}

	// Implementation of the unbuffered [pchan.trySend] function.
	#disable nilptr
	fn trySendUnbuffered(mut *self, mut &ok: *bool, mut &data: *T) {
		// Check for a waiting receiver, if any.
		// If we lucky, write data to the stack of the receiver and return.
		self.lock.lock()
		mut recvp := self.recvq.dequeueChan()
		self.lock.unlock()
		if recvp != nil {
			if recvp.stack != 0 {
				unsafe { *(*T)(recvp.stack) = *data }
				recvp.stack = 0 // Set stack pointer to zero, marked as sent.
			}
			recvp.ticket = 0 // Set ticket to zero, marked as sent for select statements.
			unsafe { unpark(&(*recvp.cp)) }
			*ok = true
		} else {
			// Fail.
			*ok = false
		}
	}

	// Tries to send the data to the channel.
	// Do not blocks until success.
	// The `ok` parameter must always not be nil.
	#disable nilptr
	fn trySend(mut *self, mut &ok: *bool, mut &data: *T) {
		if self == nil {
			*ok = false
		} else if self.cap == 0 {
			self.trySendUnbuffered(ok, data)
		} else {
			self.trySendBuffered(ok, data)
		}
	}

	// Receives the data from the channel.
	// Blocks until success.
	// The |ok| is the reference that points to boolean and
	// it reports whether data dequeued and received successfully.
	#disable nilptr
	async fn recv(mut *self, mut &ok: *bool): (data: T) {
		for {
			if self.cap > 0 {
				// Fast-path: dequeue data using the lock-free MPMC queue.
				mut deq, mut closed := self.queue.dequeue(&data)
				// Dequeued, return.
				if deq {
					if ok != nil {
						*ok = true
					}
					ret
				}
				// Not dequeued and MPMC queue is closed.
				// This means channel is closed and buffer is empty.
				if closed {
					if ok != nil {
						*ok = false
					}
					ret
				}
			}

			self.lock.lock()

			// Check for closed case in lock, to make sure channel is alive.
			if self.closed != 0 {
				self.lock.unlock()
				if ok != nil {
					*ok = false
				}
				ret
			}

			if self.cap > 0 {
				// Last chance, try the lock-free MPMC queue.
				// When we try to lock the channel mutex, a data might be sent to queue.
				deq, _ := self.queue.dequeue(&data)
				// Dequeued, lucky. Return.
				if deq {
					self.lock.unlock()
					if ok != nil {
						*ok = true
					}
					ret
				}
			}

			// Before park the coroutine, check for a waiting sender, if any.
			// If we lucky, read data from the stack of the sender and return.
			mut sendp := self.sendq.dequeueChan()
			if sendp != nil {
				self.lock.unlock()
				data = unsafe { *(*T)(sendp.stack) }
				sendp.stack = 0  // Set stack pointer to zero, marked as received.
				sendp.ticket = 0 // Set ticket to zero, marked as received for select statements.
				unsafe { unpark(&(*sendp.cp)) }
				if ok != nil {
					*ok = true
				}
				ret
			}

			// We have to park the coroutine.
			mut stackp := chanlist{}
			mut p := unsafe { (&chanlist)(&stackp) }
			mut tc := gett().c
			p.cp = &tc
			p.stack = uintptr(&data)
			self.recvq.enqueue(p)
			park(&tc, uintptr(&self.lock), reasonRecv).await
			spurious := isSpuriousWake(&stackp)
			if spurious && self.cap > 0 {
				// Spurious wakeup, we have to try again.
				continue
			}
			if ok != nil {
				*ok = !spurious
			}
			ret
		}
	}

	// Tries to receive a data from sender queue immediately.
	// Channel lock must be locked and it will not be released before return.
	// The closed state pointer must be not nil.
	#disable nilptr
	fn tryRecvImmediate(mut *self, mut &ok: *bool, mut &data: *T, mut &closed: *bool) {
		*closed = self.closed != 0
		mut sendp := self.sendq.dequeueChan()
		if sendp != nil {
			if data != nil {
				*data = unsafe { *(*T)(sendp.stack) }
			}
			sendp.stack = 0  // Set stack pointer to zero, marked as received.
			sendp.ticket = 0 // Set ticket to zero, marked as received for select statements.
			unsafe { unpark(&(*sendp.cp)) }
			*ok = true
		} else {
			// Fail.
			*ok = false
			if data != nil {
				let mut zero: T
				*data = zero
			}
		}
	}

	// Implementation of the buffered [pchan.tryRecv] function.
	// The closed state pointer must be not nil.
	#disable nilptr
	fn tryRecvBuffered(mut *self, mut &ok: *bool, mut &data: *T, mut &closed: *bool) {
		// Dequeue data using the lock-free MPMC queue.
		deq, (*closed) := self.queue.dequeue(data)
		if deq {
			*ok = true
			ret
		}
		*ok = false
		if data != nil {
			let mut zero: T
			*data = zero
		}
	}

	// Implementation of the unbuffered [pchan.tryRecv] function.
	#disable nilptr
	fn tryRecvUnbuffered(mut *self, mut &ok: *bool, mut &data: *T, mut &closed: *bool) {
		// Check for a waiting sender, if any.
		// If we lucky, read data from the stack of the sender and return.
		self.lock.lock()
		*closed = self.closed != 0
		mut sendp := self.sendq.dequeueChan()
		self.lock.unlock()
		if sendp != nil {
			if data != nil {
				*data = unsafe { *(*T)(sendp.stack) }
			}
			sendp.stack = 0  // Set stack pointer to zero, marked as received.
			sendp.ticket = 0 // Set ticket to zero, marked as received for select statements.
			unsafe { unpark(&(*sendp.cp)) }
			*ok = true
		} else {
			// Fail.
			*ok = false
			if data != nil {
				let mut zero: T
				*data = zero
			}
		}
	}

	// Tries to receive a data from the channel.
	// The parameter ok and closed always must be not-nil.
	#disable nilptr
	fn tryRecv(mut *self, mut &ok: *bool, mut &data: *T, mut &closed: *bool) {
		if self == nil {
			*ok = false
			if data != nil {
				let mut zero: T
				*data = zero
			}
		} else if self.cap == 0 {
			self.tryRecvUnbuffered(ok, data, closed)
		} else {
			self.tryRecvBuffered(ok, data, closed)
		}
	}

	// Returns capacity of the channel.
	// Returns zero if channel is nil.
	#disable nilptr
	fn stdcap(mut *self): int {
		if self == nil {
			ret 0
		}
		ret self.cap
	}
}

// Special flags for the ticket state.
const (
	parkerSelect = iota + 1
)

// Special flags for the state flags.
const (
	parkerSelectWaiting = iota
	parkerSelectConsumed
)

// Linked-list for coroutine parkers.
struct chanlist {
	cp: *c // A fake smart-pointer for stack allocated coroutine.

	state:  &int
	ticket: u32
	stack:  uintptr

	link: &chanlist
}

struct waitq {
	mut head: &chanlist
	tail:     &chanlist
}

impl waitq {
	#disable nilptr
	fn exist(*self, p: &chanlist): bool {
		mut i := self.head
		for i != nil; i = i.link {
			if i == p {
				ret true
			}
		}
		ret false
	}

	#disable nilptr
	fn enqueue(mut *self, mut p: &chanlist) {
		if self.tail == nil {
			self.head = p
		} else {
			self.tail.link = p
		}
		self.tail = p
	}

	#disable nilptr
	fn enqueueAvoidDuplicate(mut *self, mut p: &chanlist) {
		if !self.exist(p) {
			self.enqueue(p)
		}
	}

	#disable nilptr
	fn dequeue(mut *self): &chanlist {
		if self.head == nil {
			ret nil
		}
		mut p := self.head
		self.head = p.link
		if self.head == nil {
			self.tail = nil
		}
		p.link = nil
		ret p
	}

	// Dequeue according to channel tickets.
	// If waiter is a select statement coroutine, skips if it is consumed.
	#disable nilptr
	fn dequeueChan(mut *self): &chanlist {
		for {
			mut deq := self.dequeue()
			if deq == nil {
				ret nil
			}
			// If waiter is a select statement, check if it is consumed.
			// If the state is not zero, coroutine is consumed.
			// Set state as consumed to prevent false dequeue.
			if deq.ticket&parkerSelect == parkerSelect {
				if !atomic::CompareAndSwap(&(*deq.state), parkerSelectWaiting, parkerSelectConsumed, atomic::AcqRel, atomic::Relaxed) {
					// Lost race, skip.
					continue
				}
				unsafe {
					// Won race, make sure the park completed.
					// See the comment of tp, from the runselect function.
					for atomic::Load(&deq.cp.race, atomic::Acquire) != 0 {
						// This spin should be good because this race is short.
					}
				}
			}
			ret deq
		}
	}
}

// Unparks all coroutines from the waiters q.
#disable nilptr
fn unparkAll(mut &q: *waitq, clearSpuriousSigns: bool) {
	// Go through the local list and make ready all waiters.
	mut s := q.head
	for s != nil {
		mut next := s.link
		s.link = nil
		if clearSpuriousSigns {
			s.stack = 0  // Set stack pointer to zero, marked as received/sent.
			s.ticket = 0 // Set ticket to zero, marked as received/sent for select statements.
		}
		unsafe { unpark(&(*s.cp)) }
		s = next
	}
}

// Reports whether the parker is notified spuriously.
// Implemented for channels and select statements.
#disable nilptr
fn isSpuriousWake(&p: *chanlist): bool {
	// If stack is not zero, it is not consumed.
	// But select statement may pass zero stack pointer for no receiver memory cases.
	// Check for the ticket, if ticket is parkerSelect, it is not consumed.
	// Appropriate consumption will set them to zero.
	ret p.ticket != 0 || p.stack != 0
}
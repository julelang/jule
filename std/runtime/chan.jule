// Copyright 2024-2025 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/internal/runtime"

// Ideal threshold for the channel MPMC queue enqueue/dequeue time.
// If MPMC queue is failed and reached to threshold, then consider as fail.
const chanThreshold = 1e6

// The low-level base channel implementation of the language runtime.
// The generic type represents the data type of the channel. Instances required
// at compile-time are automatically instantiated by the compiler.
// Any channel algorithms that require generic types should be defined under
// this structure. A fchan should not be copied after being used.
// The compiler creates channels in the background using the [fchan[T].new].
// Behind the scenes, each channel is treated as a smart pointer.
struct pchan[T] {
	lock:   qmutex       // Protects all fields, except lock-free ones.
	cap:    int          // Immutable capacity of the channel. Zero if channel is unbuffered.
	closed: u32          // Closed state of the channel. Boolean.
	sendq:  waitq        // List of send waiters.
	recvq:  waitq        // List of recv waiters.
	queue:  mpmcQueue[T] // Lock-free MPMC data queue.
}

impl pchan {
	#disable nilptr
	fn new(cap: int): &pchan[T] {
		mut ch := new(pchan[T])
		if cap < 0 {
			panic("runtime: invalid channel buffer size, it was <0")
		}
		if cap > 0 {
			ch.queue = mpmcQueue[T].new(u64(cap))
			ch.cap = cap
		}
		ret ch
	}

	// Closes the channel.
	#disable nilptr
	fn close(mut *self) {
		self.queue.close() // Lock-free.
		self.lock.lock()
		self.closed = 1
		unparkAll(&self.recvq) // Release all readers.
		unparkAll(&self.sendq) // Release all writers (they will panic).
		self.lock.unlock()
	}

	// Implementation of the buffered [pchan.send] function.
	#disable nilptr
	fn sendBuffered(mut *self, mut data: T) {
		for {
			enq, closed := self.queue.enqueue(&data)
			if enq {
				ret
			}
			if closed {
				panic("runtime: send on closed channel")
			}
		}
	}

	// Implementation of the unbuffered [pchan.send] function.
	#disable nilptr
	fn sendUnbuffered(mut *self, mut data: T) {
		self.lock.lock()

		// Check for closed case in lock, to make sure channel is alive.
		if self.closed != 0 {
			panic("runtime: send on closed channel")
		}

		// Before park the thread, check for a waiting receiver, if any.
		// If we lucky, write data to the stack of the receiver and return.
		mut recvp := self.recvq.dequeue()
		if recvp != nil {
			self.lock.unlock()
			unsafe { *(*T)(recvp.stack) = data }
			recvp.stack = 0 // Set stack pointer to zero, marked as written.
			recvp.parker.unpark()
			ret
		}

		// We have to park the thread.
		mut thread := acquireThread()
		mut stackp := parkerList{}
		mut p := unsafe { (&parkerList)(&stackp) }
		p.parker = thread.parker
		p.stack = uintptr(&data)
		self.sendq.enqueue(p)
		park2(&(*thread), uintptr(&self.lock), &(*p.parker), reasonSend)
	}

	// Sends the data to the channel.
	// Blocks until success.
	#disable nilptr
	fn send(mut *self, mut data: T) {
		if self.cap == 0 {
			self.sendUnbuffered(data)
		} else {
			self.sendBuffered(data)
		}
	}

	// Implementation of the buffered [pchan.trySend] function.
	#disable nilptr
	fn trySendBuffered(mut *self, mut data: T): (ok: bool) {
		mut waitstart := i64(0)
		for {
			enq, closed := self.queue.enqueue(&data)
			if enq {
				ret true
			}
			if closed {
				ret false
			}
			if waitstart == 0 {
				waitstart = nanotime()
				continue
			}
			// If we tried much, according to chanThreshold,
			// then consider waiting receivers.
			if nanotime()-waitstart > chanThreshold {
				break
			}
		}
		ret false
	}

	// Implementation of the unbuffered [pchan.trySend] function.
	#disable nilptr
	fn trySendUnbuffered(mut *self, mut data: T): (ok: bool) {
		// Check for a waiting receiver, if any.
		// If we lucky, write data to the stack of the receiver and return.
		self.lock.lock()
		mut recvp := self.recvq.dequeue()
		self.lock.unlock()
		if recvp != nil {
			unsafe { *(*T)(recvp.stack) = data }
			recvp.stack = 0 // Set stack pointer to zero, marked as written.
			recvp.parker.unpark()
			ret true
		}

		// Fail.
		ret false
	}

	// Tries to send the data to the channel.
	// Do not blocks until success.
	#disable nilptr
	fn trySend(mut *self, mut data: T): bool {
		if self == nil {
			ret false
		} else if self.cap == 0 {
			ret self.trySendUnbuffered(data)
		} else {
			ret self.trySendBuffered(data)
		}
	}

	// Implementation of the buffered [pchan.recv] function.
	#disable nilptr
	fn recvBuffered(mut *self, mut &ok: *bool): (data: T) {
		for {
			deq, closed := self.queue.dequeue(&data)
			if deq {
				if ok != nil {
					*ok = true
				}
				ret
			}
			if closed {
				if ok != nil {
					*ok = false
				}
				ret
			}
		}
	}

	// Implementation of the unbuffered [pchan.recv] function.
	#disable nilptr
	fn recvUnbuffered(mut *self, mut &ok: *bool): (data: T) {
		self.lock.lock()

		// Check for closed case in lock, to make sure channel is alive.
		if self.closed != 0 {
			self.lock.unlock()
			if ok != nil {
				*ok = false
			}
			ret
		}

		// Before park the thread, check for a waiting sender, if any.
		// If we lucky, read data from the stack of the sender and return.
		mut sendp := self.sendq.dequeue()
		if sendp != nil {
			self.lock.unlock()
			data = unsafe { *(*T)(sendp.stack) }
			sendp.stack = 0 // Set stack pointer to zero, marked as consumed.
			sendp.parker.unpark()
			if ok != nil {
				*ok = true
			}
			ret
		}

		// We have to park the thread.
		mut thread := acquireThread()
		mut stackp := parkerList{}
		mut p := unsafe { (&parkerList)(&stackp) }
		p.parker = thread.parker
		p.stack = uintptr(&data)
		self.recvq.enqueue(p)
		park2(&(*thread), uintptr(&self.lock), &(*p.parker), reasonRecv)
		if ok != nil {
			*ok = true
		}
		ret
	}

	// Receives the data from the channel.
	// Blocks until success.
	// The |ok| is the reference that points to boolean and
	// it reports whether data dequeued and received successfully.
	#disable nilptr
	fn recv(mut *self, mut &ok: *bool): T {
		if self.cap == 0 {
			ret self.recvUnbuffered(ok)
		} else {
			ret self.recvBuffered(ok)
		}
	}

	// Implementation of the buffered [pchan.tryRecv] function.
	#disable nilptr
	fn tryRecvBuffered(mut *self, mut &ok: *bool): (data: T) {
		mut waitstart := i64(0)
		for {
			deq, closed := self.queue.dequeue(&data)
			if deq {
				*ok = true
				ret
			}
			if closed {
				*ok = false
				ret
			}
			if waitstart == 0 {
				waitstart = nanotime()
				continue
			}
			// If we tried much, according to chanThreshold,
			// then consider waiting senders.
			if nanotime()-waitstart > chanThreshold {
				break
			}
		}
		*ok = false
		ret
	}

	// Implementation of the unbuffered [pchan.tryRecv] function.
	#disable nilptr
	fn tryRecvUnbuffered(mut *self, mut &ok: *bool): (data: T) {
		// Check for a waiting sender, if any.
		// If we lucky, read data from the stack of the sender and return.
		self.lock.lock()
		mut sendp := self.sendq.dequeue()
		self.lock.unlock()
		if sendp != nil {
			data = unsafe { *(*T)(sendp.stack) }
			sendp.stack = 0 // Set stack pointer to zero, marked as consumed.
			sendp.parker.unpark()
			*ok = true
			ret
		}

		// Fail.
		*ok = false
		ret
	}

	// Tries to receive a data from the channel.
	// The parameter ok always must be not-nil.
	#disable nilptr
	fn tryRecv(mut *self, mut &ok: *bool): T {
		if self == nil {
			if ok != nil {
				*ok = false
			}
			let mut zero: T
			ret zero
		} else if self.cap == 0 {
			ret self.tryRecvUnbuffered(ok)
		} else {
			ret self.tryRecvBuffered(ok)
		}
	}
}

// Empty select statement implementation.
#disable nilptr
fn emptyselect() {
	mut t := acquireThread()
	t.state |= threadSuspended | reasonSelect | reasonSelectEmpty
	// Add special case for empty select.
	threadCases |= threadSC_EmptySelect
	// Check deadlock before sleep and release mutex.
	checkDeadlock(0, reasonSelect|reasonSelectEmpty)
	threadMutex.unlock()
	// Park thread indefinitely.
	// We do not need to yield CPU with temporary parking,
	// this thread will never continue to run.
	// It always yields CPU due to empty select statement,
	// so put it into deep sleep. Other threads can caught deadlocks,
	// if any, after this stage. If this thread is the single thread,
	// we already checked deadlocks. So put this thread into deep sleep
	// indefinitely.
	t.parker.park()
	panic("unreachable")
}
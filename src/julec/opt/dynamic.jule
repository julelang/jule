// Copyright 2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "obj"
use "std/jule/sema"
use "std/jule/token"

const invalidDynamic = uintptr(0x0)

struct dynamicVar {
	var:  uintptr
	kind: &sema::Type
}

// Information wrapper for type analysis for dynamic types.
struct dynamic {
	vars: []dynamicVar
}

impl dynamic {
	// Appends variable with initial kind.
	// If variable is already exist, updates kind information.
	fn pushVar(mut &self, var: uintptr, mut kind: &sema::Type) {
		if !Dynamic || var == invalidDynamic {
			// Ignore it, because this optimizations within scope of the --opt-access flag.
			ret
		}
		kind = isTypeGuaranteedDynamicData(self, kind, nil) // Just accept guaranteed types as kind.
		for i in self.vars {
			mut &v := unsafe { *(&self.vars[i]) }
			if v.var == var {
				v.kind = kind
				ret
			}
		}
		// Not exist, append new one.
		for i in self.vars {
			mut &v := unsafe { *(&self.vars[i]) }
			if v.var == invalidDynamic {
				// Empty place, use here instead of append.
				v.var, v.kind = var, kind
				ret
			}
		}
		self.vars = append(self.vars, dynamicVar{var: var, kind: kind})
	}

	fn removeVar(mut self, var: uintptr): bool {
		if var != invalidDynamic {
			for i in self.vars {
				mut &v := unsafe { *(&self.vars[i]) }
				if v.var == var {
					v.var = invalidDynamic
					v.kind = nil
					ret true
				}
			}
		}
		ret false
	}

	// Reports whether variable is fits with kind.
	fn isFits(mut self, var: uintptr, kind: &sema::Type): bool {
		if var != invalidDynamic {
			for _, v in self.vars {
				if v.var == var {
					ret v.kind != nil && v.kind.Equal(kind)
				}
			}
		}
		ret false
	}
}

fn possibleDynamicRemove(mut &d: &dynamic, m: sema::ExprModel) {
	if d != nil {
		_ = d.removeVar(getDynamicVar(m))
	}
}

fn isDynamicValidType(mut t: &sema::Type): bool { ret obj::IsAny(t) }

fn isTypeGuaranteedDynamicData(mut &dy: &dynamic, mut t: &sema::Type, mut m: sema::ExprModel): &sema::Type {
	if t.IsNil() {
		ret nil
	}
	isAny := obj::IsAny(t)
	if !isAny && t.Trait() == nil {
		ret t
	}
	if !isAny {
		ret nil
	}
	match type m {
	| &sema::CastingExprModel:
		mut cem := (&sema::CastingExprModel)(m)
		ret isTypeGuaranteedDynamicData(dy, cem.ExprType, cem.Expr.Model)
	}
	var := getDynamicVar(m)
	if var == invalidDynamic {
		ret nil
	}
	for (_, mut v) in dy.vars {
		if v.var == var {
			ret v.kind
		}
	}
	ret nil
}

fn getDynamicVar(m: sema::ExprModel): uintptr {
	if !Dynamic {
		ret invalidDynamic
	}
	match type m {
	| &sema::Var:
		v := (&sema::Var)(m)
		if !v.Reference {
			// Variable is not reference, return address of it.
			ret uintptr((&sema::Var)(m))
		}
		// Variable is reference, it should be initialized at source code.
		// Investigate the initial expression for variable address.
		ret getDynamicVar(v.Value.Data.Model)
	| &sema::StructSubIdentExprModel:
		ret uintptr((&sema::StructSubIdentExprModel)(m).Field)
	| &sema::UnaryExprModel:
		uem := (&sema::UnaryExprModel)(m)
		if uem.Op.Id == token::Id.Star { // Dereferencing.
			ret getDynamicVar(uem.Expr.Model)
		}
	}
	ret invalidDynamic
}
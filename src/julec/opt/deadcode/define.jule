// Copyright 2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "env"
use "obj"
use "std/comptime"
use "std/jule/build"
use "std/jule/ast"
use "std/jule/sema"

struct specialCaseDefines {
	runtime_Map:         &sema::Struct
	runtime_mapIterator: &sema::Struct
}

impl specialCaseDefines {
	// Reports whether all methods live of structure.
	fn isAllMethodsLive(self, s: &sema::Struct): bool {
		ret s == self.runtime_Map ||
			s == self.runtime_mapIterator
	}
}

struct liveTable {
	vars:    []&sema::Var
	fns:     []&sema::FnIns
	structs: []&sema::StructIns
	traits:  []&sema::Trait
}

struct ObjectDeadCode {
	live: liveTable
	ir:   &obj::IR
	scd:  specialCaseDefines
}

impl ObjectDeadCode {
	static fn new(mut &ir: &obj::IR): &ObjectDeadCode {
		ret &ObjectDeadCode{
			ir: ir,
		}
	}

	fn isLive[T](mut &self, &t: T): bool {
		let mut live: []T = nil
		const match type T {
		| &sema::FnIns:
			live = self.live.fns
		| &sema::Var:
			live = self.live.vars
		| &sema::StructIns:
			live = self.live.structs
		| &sema::Trait:
			live = self.live.traits
		}
		for i in live {
			if live[i] == t {
				ret true
			}
		}
		ret false
	}

	fn pushLive[T](mut &self, mut t: T) {
		const match type T {
		| &sema::Var:
			self.live.vars = append(self.live.vars, t)
		| &sema::FnIns:
			self.live.fns = append(self.live.fns, t)
		| &sema::StructIns:
			self.live.structs = append(self.live.structs, t)
		| &sema::Trait:
			self.live.traits = append(self.live.traits, t)
		}
	}

	fn pushStructAsLive(mut &self, mut &s: &sema::StructIns) {
		if self.isLive[&sema::StructIns](s) {
			ret
		}
		self.pushLive[&sema::StructIns](s)
		self.setReferencesAsLive(s.Refers)
		allLive := self.scd.isAllMethodsLive(s.Decl)
		for (_, mut m) in s.Methods {
			for (_, mut ins) in m.Instances {
				if self.isLive[&sema::FnIns](ins) {
					continue
				}

				// Push all methods as live if s is built-in map type.
				if allLive {
					self.pushLive[&sema::FnIns](ins)
					self.setReferencesAsLive(ins.Refers)
					continue
				}

				// Set trait implemented methods as alive.
				// Push as live the method if implements a trait's method.
				// Other methods will be marked as live by referenced defines,
				// no need for special tracking algorithm to caught.
				if obj::IsTraitMethod(s, ins) {
					self.pushLive[&sema::FnIns](ins)
					self.setReferencesAsLive(ins.Refers)
				}

				// Set operator overloading methods as alive.
				// Just cannot trace whether operator overloading is used yet.
				// So, removing these methods may cause compilation problems.
				const vs = comptime::ValueOf(*s)
				const om = vs.Field("Operators")
				const for _, field in om.Type().Decl().Fields() {
					if ins == om.Field(field.Name()).Unwrap() {
						self.pushLive[&sema::FnIns](ins)
						self.setReferencesAsLive(ins.Refers)
					}
				}

				// Set reserved methods as alive.
				// So, removing these methods may cause compilation problems,
				// or unexpected program bavior.
				const Binded = false

				mut dispose := s.FindMethod("Dispose", Binded)
				if dispose != nil && sema::FuncPattern.Dispose(dispose) {
					mut fins := dispose.Instances[0]
					self.pushLive[&sema::FnIns](fins)
					self.setReferencesAsLive(fins.Refers)
				}

				mut _str := s.FindMethod("Str", Binded)
				if _str != nil && sema::FuncPattern.Str(_str) {
					mut fins := _str.Instances[0]
					self.pushLive[&sema::FnIns](fins)
					self.setReferencesAsLive(fins.Refers)
				}
			}
		}
	}

	fn setReferencesAsLive(mut &self, mut &rs: &sema::ReferenceStack) {
		if rs == nil {
			ret
		}
		mut i := 0
		for i < rs.Len(); i++ {
			mut ref := rs.At(i)
			match type ref {
			| &sema::Trait:
				mut t := (&sema::Trait)(ref)
				if self.isLive[&sema::Trait](t) {
					continue
				}
				self.pushLive[&sema::Trait](t)
				for (_, mut ins) in t.Methods {
					for (_, mut mins) in ins.Instances {
						if self.isLive[&sema::FnIns](mins) {
							continue
						}
						self.pushLive[&sema::FnIns](mins)
						self.setReferencesAsLive(mins.Refers)
					}
				}
			| &sema::FnIns:
				mut f := (&sema::FnIns)(ref)
				if self.isLive[&sema::FnIns](f) {
					break
				}
				if f.Owner != nil && !f.Decl.Statically {
					if !self.isLive[&sema::StructIns](f.Owner) {
						self.pushLive[&sema::StructIns](f.Owner)
						self.setReferencesAsLive(f.Owner.Refers)
					}
				}
				self.pushLive[&sema::FnIns](f)
				self.setReferencesAsLive(f.Refers)
			| &sema::Var:
				mut v := (&sema::Var)(ref)
				if self.isLive[&sema::Var](v) {
					break
				}
				self.pushLive[&sema::Var](v)
				self.setReferencesAsLive(v.Refers)
			| &sema::StructIns:
				mut s := (&sema::StructIns)(ref)
				self.pushStructAsLive(s)
			}
		}
	}

	fn inits(mut &self, mut &pkg: &sema::Package) {
		for (_, mut file) in pkg.Files {
			for (_, mut f) in file.Funcs {
				if f.Ident == build::InitFn {
					mut ins := f.Instances[0]
					if !self.isLive[&sema::FnIns](ins) {
						self.pushLive[&sema::FnIns](ins)
					}
					self.setReferencesAsLive(ins.Refers)
				}
			}
		}
	}

	fn collectLivePackage(mut &self, mut &pkg: &sema::Package) {
		// Collect live references based on initializer functions.
		self.inits(pkg)

		// collect api defines as live
		obj::IterFiles(pkg, fn(mut &file: &sema::SymTab) {
			for (_, mut v) in file.Vars {
				if obj::HasDirective(v.Directives, build::Directive.Export) {
					if !self.isLive[&sema::Var](v) {
						self.pushLive[&sema::Var](v)
						self.setReferencesAsLive(v.Refers)
					}
				}
			}
			for (_, mut f) in file.Funcs {
				if obj::HasDirective(f.Directives, build::Directive.Export) {
					for (_, mut ins) in f.Instances {
						if !self.isLive[&sema::FnIns](ins) {
							self.pushLive[&sema::FnIns](ins)
							self.setReferencesAsLive(ins.Refers)
						}
					}
				}
			}
		})

		// Collect test functions and the std::testing::{T} struct if test compilation is enabled.
		if env::Test {
			if len(pkg.Files) > 0 && obj::IsStdPackage(pkg.Files[0].File.Path, "testing") {
				const Binded = false
				mut s := pkg.FindStruct("T", Binded)
				mut ins := s.Instances[0]
				self.pushStructAsLive(ins)
				for (_, mut m) in ins.Methods {
					for (_, mut mins) in m.Instances {
						if self.isLive[&sema::FnIns](mins) {
							continue
						}
						self.pushLive[&sema::FnIns](mins)
						self.setReferencesAsLive(mins.Refers)
					}
				}
			}
			for (_, mut file) in pkg.Files {
				for (_, mut f) in file.Funcs {
					if obj::HasDirective(f.Directives, build::Directive.Test) {
						mut ins := f.Instances[0]
						if !self.isLive[&sema::FnIns](ins) {
							self.pushLive[&sema::FnIns](ins)
						}
						self.setReferencesAsLive(ins.Refers)
					}
				}
			}
		}
	}

	fn collectLive(mut &self) {
		for (_, mut used) in self.ir.Used {
			if !used.Binded {
				self.collectLivePackage(used.Package)
			}
		}
		self.collectLivePackage(self.ir.Main)

		// Push live references based on entry point.
		mut main := self.ir.Main.FindFn(build::EntryPoint, false)
		if main != nil {
			mut ins := main.Instances[0]
			if !self.isLive[&sema::FnIns](ins) {
				self.pushLive[&sema::FnIns](ins)
			}
			self.setReferencesAsLive(ins.Refers)
		}
	}

	fn removeDeadGlobals(mut &self, mut &vars: []&sema::Var) {
		mut i := 0
		for i < len(vars) {
			v := vars[i]
			if self.isLive[&sema::Var](v) {
				i++
				continue
			}
			vars = append(vars[:i], vars[i+1:]...)
		}
	}

	fn removeDeadFns(mut &self, mut &funcs: []&sema::Fn) {
		mut i := 0
		for i < len(funcs) {
			mut f := funcs[i]
			mut j := 0
			for j < len(f.Instances) {
				ins := f.Instances[j]
				if self.isLive[&sema::FnIns](ins) {
					j++
					continue
				}
				f.Instances = append(f.Instances[:j], f.Instances[j+1:]...)
			}
			if len(f.Instances) == 0 {
				funcs = append(funcs[:i], funcs[i+1:]...)
				continue
			}
			i++
		}
	}

	fn removeDeadStructs(mut &self, mut &structs: []&sema::Struct) {
		mut i := 0
		for i < len(structs) {
			mut s := structs[i]
			mut j := 0
			for j < len(s.Instances) {
				mut ins := s.Instances[j]
				self.removeDeadFns(ins.Methods)
				if len(ins.Methods) != 0 || self.isLive[&sema::StructIns](ins) {
					j++
					continue
				}
				s.Instances = append(s.Instances[:j], s.Instances[j+1:]...)
			}
			if len(s.Instances) == 0 {
				structs = append(structs[:i], structs[i+1:]...)
				continue
			}
			i++
		}
	}

	fn removeDeadTraits(mut &self, mut &traits: []&sema::Trait) {
		mut i := 0
		for i < len(traits) {
			mut t := traits[i]
			if !self.isLive[&sema::Trait](t) {
				traits = append(traits[:i], traits[i+1:]...)
				continue
			}
			mut j := 0
			for j < len(t.Implemented) {
				s := t.Implemented[j]
				if len(s.Instances) > 0 {
					j++
					continue
				}
				t.Implemented = append(t.Implemented[:j], t.Implemented[j+1:]...)
			}
			i++
		}
	}

	fn removeDeadsFile(mut &self, mut &file: &sema::SymTab) {
		self.removeDeadFns(file.Funcs)
		self.removeDeadStructs(file.Structs)
		self.removeDeadTraits(file.Traits)
		self.removeDeadGlobals(file.Vars)
	}

	fn removeDeadsPackage(mut &self, mut &pkg: &sema::Package) {
		for (_, mut file) in pkg.Files {
			self.removeDeadsFile(file)
		}
	}

	fn removeDeads(mut &self) {
		for (_, mut used) in self.ir.Used {
			if !used.Binded {
				self.removeDeadsPackage(used.Package)
			}
		}
		self.removeDeadsPackage(self.ir.Main)
	}

	fn collectSpecialCaseDefines(mut &self) {
		self.scd.runtime_Map = obj::RuntimeFindStruct(self.ir.Runtime, obj::RuntimeStruct._Map)
		self.scd.runtime_mapIterator = obj::RuntimeFindStruct(self.ir.Runtime, obj::RuntimeStruct.mapIterator)
	}

	fn elimanate(mut &self) {
		self.collectSpecialCaseDefines()
		self.collectLive()
		self.removeDeads()
	}
}

fn EliminateDefines(mut &ir: &obj::IR) {
	mut ocd := ObjectDeadCode.new(ir)
	ocd.elimanate()
}
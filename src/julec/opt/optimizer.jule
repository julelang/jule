// Copyright 2023-2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "env"
use "obj"
use "opt/deadcode"
use "std/jule/sema"

static mut exprEnabled = false
static mut scopeEnabled = false

// Target-independent optimizer for IR.
// Use this optimizer for all optimizations with single instance.
struct Optimizer {
	ir: &obj::IR
}

impl Optimizer {
	// Returns new optimizer for IR.
	static fn New(mut &ir: &obj::IR): &Optimizer {
		ret &Optimizer{
			ir: ir,
		}
	}

	fn optimizeExpr(mut self, mut &model: sema::ExprModel) {
		exprOptimizer.optimize(model)
	}

	fn optimizeGlobal(mut self, mut &v: &sema::Var) {
		if !v.Binded {
			self.optimizeExpr(v.Value.Data.Model)
		}
	}

	fn optimizeFunction(mut self, mut &func: &sema::Fn) {
		if func.Binded {
			ret
		}
		for (_, mut ins) in func.Instances {
			mut so := scopeOptimizer.new(ins.Scope)
			so.optimize()
		}
	}

	fn optimizeStruct(mut self, mut &s: &sema::Struct) {
		if s.Binded {
			ret
		}
		for (_, mut ins) in s.Instances {
			for (_, mut f) in ins.Fields {
				if f.Default != nil {
					self.optimizeExpr(f.Default.Model)
				}
			}
			for (_, mut m) in ins.Methods {
				self.optimizeFunction(m)
			}
		}
	}

	fn optimizeGlobals(mut self, mut &p: &sema::Package) {
		for (_, mut f) in p.Files {
			for (_, mut v) in f.Vars {
				self.optimizeGlobal(v)
			}
		}
	}

	fn optimizeFunctions(mut self, mut &p: &sema::Package) {
		for (_, mut f) in p.Files {
			for (_, mut func) in f.Funcs {
				self.optimizeFunction(func)
			}
		}
	}

	fn optimizeStructs(mut self, mut &p: &sema::Package) {
		for (_, mut f) in p.Files {
			for (_, mut s) in f.Structs {
				self.optimizeStruct(s)
			}
		}
	}

	fn optimizePackage(mut self, mut &p: &sema::Package) {
		self.optimizeGlobals(p)
		self.optimizeFunctions(p)
		self.optimizeStructs(p)
	}

	// Optimizes IR by enabled optimizations.
	fn Optimize(mut self) {
		detectEnabled()

		// See compiler reference (2)
		if Deadcode {
			deadcode::EliminateDefines(self.ir)
		}

		if scopeEnabled || exprEnabled {
			for (_, mut u) in self.ir.Used {
				if !u.Binded {
					self.optimizePackage(u.Package)
				}
			}
			self.optimizePackage(self.ir.Main)
		}

		// See compiler reference (3)
		if Deadcode {
			deadcode::EliminateScopes(self.ir)
		}
	}
}

fn detectEnabled() {
	exprEnabled = StdStrings || Ptr || Math || Access || Cond
	scopeEnabled = Cond || Append || Copy || Str || Slice || Assign || Exceptional ||
		Iter || Dynamic
}
// Copyright 2023-2025 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "env"
use "obj"
use "obj/meta"
use "opt"
use "std/conv"
use "std/fmt"
use "std/jule/build"
use "std/jule/constant"
use "std/jule/sema"
use "std/jule/token"
use "std/jule/types"
use "std/math"
use "std/os"
use "std/runtime"
use "std/strings"
use "std/unicode/utf8"

const collectionIdent = "__jule_collection"
const collectionItIdent = "it"

// Common group of semantic analysis expression model types and optimizer specific types.
enum compExpr: type {
	Expr: sema::Expr,
	str,  // For built-in expressions.
	&str, // For built-in expressions.
	&opt::UnsafeBinaryExpr,
	&opt::UnsafeIndexingExpr,
	&opt::StrCompExpr,
	&opt::RefExpr,
	&opt::EmptyCompareExpr,
	&opt::UnsafeDerefExpr,
	&opt::UnsafeCastingExpr,
	&opt::FuncCallIgnoreExceptionalExpr,
	&opt::StrConcatExpr,
	&opt::StrFromBytes,
	&opt::ArrayAsSlice,
}

struct exprCoder {
	oc: &ObjectCoder

	// It will executed before common variable handling algorithm.
	// If it returns true, common algorithm will not be executed.
	varPrefixes: []fn(mut v: &sema::Var): bool
}

impl exprCoder {
	static fn new(mut &oc: &ObjectCoder): &exprCoder {
		ret &exprCoder{
			oc: oc,
		}
	}

	fn string(mut &self, &c: &constant::Const) {
		content := c.ReadStr()
		if len(content) == 0 { // Empty.
			self.oc.write(typeStr + "()")
			ret
		}
		len := conv::FmtInt(i64(len(content)), 10)
		strLit(self.oc.Buf, content, len)
	}

	fn boolean(mut &self, b: bool) {
		if b {
			self.oc.write("true")
		} else {
			self.oc.write("false")
		}
	}

	fn nilLit(mut &self) {
		self.oc.write("nullptr")
	}

	fn ftoaSpecialCases(mut &self, &x: f64): bool {
		match {
		| math::IsNaN(x):
			self.oc.write("NAN")
		| math::IsInf(x, 1):
			self.oc.write("INFINITY")
		| math::IsInf(x, -1):
			self.oc.write("-INFINITY")
		|:
			ret false
		}
		ret true
	}

	fn float32(mut &self, &c: &constant::Const) {
		x := c.AsF64()

		// Special cases.
		if self.ftoaSpecialCases(x) {
			ret
		}

		match {
		| x == types::MaxF32:
			self.oc.write("jule::MAX_F32")
		| x == types::MinF32:
			self.oc.write("jule::MIN_F32")
		|:
			ftoa(self.oc.Buf, x, 1<<5)
			self.oc.write("f")
		}
	}

	fn float64(mut &self, &c: &constant::Const) {
		x := c.AsF64()

		// Special cases.
		if self.ftoaSpecialCases(x) {
			ret
		}

		match {
		| x == types::MaxF64:
			self.oc.write("jule::MAX_F64")
		| x == types::MinF64:
			self.oc.write("jule::MIN_F64")
		|:
			ftoa(self.oc.Buf, x, 1<<6)
		}
	}

	fn constant(mut &self, mut c: &constant::Const) {
		match {
		| c.IsStr():
			self.string(c)
		| c.IsBool():
			self.boolean(c.ReadBool())
		| c.IsF64():
			match {
			| c.Kind == types::Kind.F32:
				self.float32(c)
			|:
				self.float64(c)
			}
		| c.IsI64():
			itoa(self.oc.Buf, c.ReadI64())
		| c.IsU64():
			utoa(self.oc.Buf, c.ReadU64())
		| c.IsNil():
			self.nilLit()
		|:
			self.oc.write("<unimplemented_constant_expression>")
		}
	}

	fn divByZeroBinary(mut &self, &op: &token::Token, mut &l: &sema::OperandExpr, mut &r: &sema::OperandExpr) {
		const xVar = "__jule_x"
		const yVar = "__jule_y"
		self.oc.write("({ ")
		self.oc.tc.kind(self.oc.Buf, l.Type)
		self.oc.write(" ")
		self.oc.write(xVar)
		self.oc.write(" = ")
		self.possibleRefExpr(l.Model)
		self.oc.write("; ")
		self.oc.tc.kind(self.oc.Buf, r.Type)
		self.oc.write(" ")
		self.oc.write(yVar)
		self.oc.write(" = ")
		self.possibleRefExpr(r.Model)
		self.oc.write("; if (")
		self.oc.write(yVar)
		self.oc.write(` == 0) __jule_panicStr(`)
		strLitF(self.oc.Buf, fn(): int {
			self.oc.write("\"runtime: divide by zero")
			mut len := 23 // runtime: divide by zero
			if !env::Production {
				self.oc.write("\\nlocation: ")
				len += 11 // \nlocation:
				len += unsafe { self.oc.locInfo(op) }
			}
			self.oc.write("\"")
			ret len
		})
		self.oc.write("); ((")
		self.oc.tc.kind(self.oc.Buf, l.Type)
		self.oc.write(")(")
		self.oc.write(xVar)
		match op.Id {
		| token::Id.Solidus
		| token::Id.SolidusEq:
			self.oc.write(" / ")
		| token::Id.Percent
		| token::Id.PercentEq:
			self.oc.write(" % ")
		}
		self.oc.write(yVar)
		self.oc.write(")); })")
	}

	// Tries to handle binary expressions with dynamic types and reports whether
	// it successful. Should support all dynamic types.
	fn unsafeDynamicBinary(mut &self, mut &buf: strings::Builder,
		mut l: sema::OperandExpr, mut r: sema::OperandExpr, op: token::Id): bool {
		// Return immediately if binary expression is not contain dynamic type.
		// Handle traits separately, see documentation of obj::IsAny.
		// They handled as <any> type, but not have pure any type implementation,
		// therefore we have to handle them separately.
		// The left operand must be enough to check because it will always be the dynamic type.
		// See "std/jule/sema" developer reference (7).
		if l.Type.Trait() == nil && !obj::IsAny(l.Type) {
			ret false
		}
		// Return immediately if right operand is nil.
		if r.Type.IsNil() {
			ret false
		}
		// If left and right operand is hard dynamic type, then report false.
		mut leftIsStrict := true
		mut dynT := l.Type
		mut e, mut t := obj::IsHardDynamicType(r.Model, r.Type)
		if e == nil && t == nil {
			e, t = obj::IsHardDynamicType(l.Model, l.Type)
			if e == nil && t == nil {
				ret false
			}
			leftIsStrict = false
			dynT = r.Type
		}

		ls := writeAndReadFromBuf(self.oc.Buf, fn() {
			if leftIsStrict {
				self.possibleRefExpr(l.Model)
			} else {
				self.possibleRefExpr(r.Model)
			}
		})
		rs := writeAndReadFromBuf(self.oc.Buf, fn() {
			self.possibleRefExpr(e)
		})

		buf.WriteByte('(')!
		if op == token::Id.NotEq {
			buf.WriteByte('!')!
		}
		i := self.oc.pushAnyType(t)
		si := conv::Itoa(i)
		buf.WriteStr(anyTypeIdent)!
		buf.WriteStr(si)!
		buf.WriteStr("_compare(")!
		buf.WriteStr(ls)!
		buf.WriteStr(", &")!
		if dynT.Trait() != nil { // Trait <any> type.
			trt := dynT.Trait()
			identCoder.traitDecl(buf, trt)
			buf.WriteStr("_mptr_data")!
			buf.WriteStr(conv::Itoa(obj::FindTraitTypeOffset(trt, t)))!
		} else { // Pure <any> type.
			buf.WriteStr(anyTypeIdent)!
			buf.WriteStr(si)!
		}
		buf.WriteStr(", ")!
		buf.WriteStr(rs)!
		buf.WriteStr("))")!
		ret true
	}

	fn _unsafeBinaryNoDynamic(mut &self, mut &buf: strings::Builder, &l: str,
		&r: str, mut &lk: &sema::Type, mut &rk: &sema::Type, op: token::Id, kind: str) {
		match {
		| lk.Array() != nil:
			// If this binary operator comparing array type.
			// The left operand is will be array one always.
			arr := lk.Array()
			mut ins := obj::FindFuncGenericInstance(meta::Program.Runtime.ArrayCmp, arr.Elem)
			if op == token::Id.NotEq {
				buf.WriteByte('!')!
			}
			identCoder.funcIns(buf, ins)
			buf.WriteByte('(')!
			buf.WriteStr(l)!
			buf.WriteStr(".begin(), ")!
			buf.WriteStr(r)!
			buf.WriteStr(".begin(), ")!
			buf.WriteStr(conv::Itoa(arr.N))!
			buf.WriteByte(')')!
			ret
		}

		if lk.Struct() != nil {
			mut s := lk.Struct()
			structBinary(buf, s, l, r, op, kind)
			ret
		}

		match op {
		| token::Id.Plus | token::Id.Minus | token::Id.Star | token::Id.Shl:
			// guarantee unsigned integer wrap around
			lp := lk.Prim()
			if lp != nil && types::IsUnsigInt(lp.Kind) {
				buf.WriteByte('(')!
				self.oc.tc.prim(buf, lp)
				buf.WriteByte(')')!
			}
		}

		buf.WriteByte('(')!
		buf.WriteStr(l)!
		buf.WriteByte(' ')!
		buf.WriteStr(kind)!
		buf.WriteByte(' ')!
		buf.WriteStr(r)!
		buf.WriteByte(')')!
	}

	fn _unsafeBinary(mut &self, mut &buf: strings::Builder, mut l: sema::OperandExpr,
		mut r: sema::OperandExpr, op: token::Id, kind: str) {
		// Special cases for comparable types.
		if (op == token::Id.Eqs || op == token::Id.NotEq) && self.unsafeDynamicBinary(buf, l, r, op) {
			ret
		}
		ls := writeAndReadFromBuf(self.oc.Buf, fn() { self.possibleRefExpr(l.Model) })
		rs := writeAndReadFromBuf(self.oc.Buf, fn() { self.possibleRefExpr(r.Model) })
		self._unsafeBinaryNoDynamic(buf, ls, rs, l.Type, r.Type, op, kind)
	}

	fn unsafeBinary(mut &self, mut m: &sema::BinaryExpr) {
		self._unsafeBinary(self.oc.Buf, *m.Left, *m.Right, m.Op.Id, m.Op.Kind)
	}

	fn shl(mut &self, mut &l: &sema::OperandExpr, mut &r: &sema::OperandExpr) {
		const xVar = "__jule_x"
		const yVar = "__jule_y"
		self.oc.write("({ ")
		self.oc.tc.kind(self.oc.Buf, l.Type)
		self.oc.write(" ")
		self.oc.write(xVar)
		self.oc.write(" = ")
		self.possibleRefExpr(l.Model)
		self.oc.write("; ")
		self.oc.tc.kind(self.oc.Buf, r.Type)
		self.oc.write(" ")
		self.oc.write(yVar)
		self.oc.write(" = ")
		self.possibleRefExpr(r.Model)
		self.oc.write("; ((")
		self.oc.tc.kind(self.oc.Buf, l.Type)
		self.oc.write(")(")
		self.oc.write(yVar)
		self.oc.write(" >= ")
		self.oc.write(conv::Itoa(types::BitSizeOf(l.Type.Prim().Kind)))
		self.oc.write(" ? 0 : ")
		self.oc.write(xVar)
		self.oc.write(" << ")
		self.oc.write(yVar)
		self.oc.write(")); })")
	}

	fn shr(mut &self, mut &l: &sema::OperandExpr, mut &r: &sema::OperandExpr) {
		const xVar = "__jule_x"
		const yVar = "__jule_y"
		self.oc.write("({ ")
		self.oc.tc.kind(self.oc.Buf, l.Type)
		self.oc.write(" ")
		self.oc.write(xVar)
		self.oc.write(" = ")
		self.possibleRefExpr(l.Model)
		self.oc.write("; ")
		self.oc.tc.kind(self.oc.Buf, r.Type)
		self.oc.write(" ")
		self.oc.write(yVar)
		self.oc.write(" = ")
		self.possibleRefExpr(r.Model)
		self.oc.write("; ((")
		self.oc.tc.kind(self.oc.Buf, l.Type)
		self.oc.write(")(")
		self.oc.write(yVar)
		self.oc.write(" >= ")
		self.oc.write(conv::Itoa(types::BitSizeOf(l.Type.Prim().Kind)))
		self.oc.write(" ? 0 : ")
		self.oc.write(xVar)
		self.oc.write(" >> ")
		self.oc.write(yVar)
		self.oc.write(")); })")
	}

	fn binary(mut &self, mut m: &sema::BinaryExpr) {
		match m.Op.Id {
		| token::Id.Solidus | token::Id.Percent:
			if env::Safety {
				self.divByZeroBinary(m.Op, m.Left, m.Right)
				ret
			}
		| token::Id.Shl:
			self.shl(m.Left, m.Right)
			ret
		| token::Id.Shr:
			self.shr(m.Left, m.Right)
			ret
		}
		self.unsafeBinary(m)
	}

	fn var(mut &self, mut m: &sema::Var) {
		for _, prefix in self.varPrefixes {
			if prefix(m) {
				ret
			}
		}
		if m.Binded {
			d := obj::FindDirective(m.Directives, build::Directive.Namespace)
			if d != nil {
				self.oc.writeBytes(concatAllParts(d.Args...))
				self.oc.write("::")
			}
		}
		identCoder.var(self.oc.Buf, m)
	}

	fn structureIns(mut &self, mut m: &sema::StructIns) {
		self.oc.tc.structureIns(self.oc.Buf, m)
	}

	fn unary(mut &self, mut m: &sema::UnaryExpr) {
		match m.Op.Id {
		| token::Id.Caret:
			self.oc.write("(~(")
			self.possibleRefExpr(m.Expr.Model)
			self.oc.write("))")
			ret
		| token::Id.Star:
			if env::Production || m.Expr.Type.Sptr() == nil {
				break
			}
			self.possibleRefExpr(m.Expr.Model)
			self.oc.write(".get(\"")
			self.oc.locInfo(m.Op)
			self.oc.write("\")")
			ret
		}
		self.oc.write("(")
		self.oc.write(m.Op.Kind)
		self.oc.write("(")
		self.possibleRefExpr(m.Expr.Model)
		self.oc.write("))")
	}

	fn structureLit(mut &self, mut m: &sema::StructLitExpr) {
		binded := obj::IsStructBinded(m.Strct)
		if binded {
			self.oc.write("(")
		}
		self.structureIns(m.Strct)
		if binded {
			self.oc.write(")")
		}
		self.oc.write("{")
		// Fields are should be in order.
		// In other words, GCC will produce error(s).
		mut inited := false
	fields:
		for (_, mut f) in m.Strct.Fields {
			for (_, mut arg) in m.Args {
				// Field exist, initialize it with literal expression.
				if arg.Field == f {
					if inited {
						self.oc.write(", ")
					}
					self.oc.write(".")
					identCoder.field(self.oc.Buf, f.Decl)
					self.oc.write("=")
					self.possibleRefExpr(arg.Expr.Model)
					inited = true
					continue fields
				}
			}
			if binded {
				// Do not initialize field of binded struct.
				inited = false
				continue
			}
			if inited {
				self.oc.write(", ")
			}
			// Field is not exist in literal arguments.
			// Initialize it by default.
			inited = self.handleFieldByDefault(f)
		}
		self.oc.write("}")
	}

	fn allocStructure(mut &self, mut m: &sema::AllocStructLitExpr) {
		self.oc.write("jule::new_ptr<")
		self.structureIns(m.Lit.Strct)
		self.oc.write(">(")
		self.structureLit(m.Lit)
		self.oc.write(")")
	}

	fn possibleRefExpr(mut &self, expr: compExpr) {
		match type expr {
		| &sema::Var:
			v := (&sema::Var)(expr)
			if v.Reference {
				self.oc.write("(*(")
				self.model(expr)
				self.oc.write("))")
				ret
			}
		}
		self.model(expr)
	}

	fn castTraitFromTrait(mut &self, mut &m: &sema::CastingExpr, mut t1: &sema::Trait, mut t2: &sema::Trait) {
		self.possibleRefExpr(m.Expr.Model)
		self.oc.write(".map(")
		self.oc.pushAndWriteMaskMapper(t1, t2)
		self.oc.write(")")
	}

	// Casting expression.
	//
	// Special cases:
	//	The any type castings should be came first than others.
	//	Otherwise, code generation might be wrong because <any> the
	//	uses special casting algorithms.
	fn casting(mut &self, mut m: &sema::CastingExpr) {
		if m.Type.ActualEqual(m.Expr.Type) {
			self.possibleRefExpr(m.Expr.Model)
			ret
		}

		match {
		| obj::IsAny(m.Type):
			if m.Expr.Type.IsNil() {
				self.oc.write(typeAny + "()")
				ret
			}
			if m.Expr.Type.TypeEnum() != nil {
				self.possibleRefExpr(m.Expr.Model)
				ret
			}
			i := self.oc.pushAnyType(m.Expr.Type)
			self.oc.write(typeAny + "(")
			match type m.Expr.Model {
			| &constant::Const:
				prim := m.Expr.Type.Prim()
				if prim != nil && types::IsInt(prim.Kind) {
					self.oc.write("static_cast<")
					self.oc.tc.prim(self.oc.Buf, prim)
					self.oc.write(">(")
					self.possibleRefExpr(m.Expr.Model)
					self.oc.write(")")
					break
				}
				fall
			|:
				self.possibleRefExpr(m.Expr.Model)
			}
			self.oc.write(", &" + anyTypeIdent)
			self.oc.write(conv::Itoa(i))
			self.oc.write(")")
			ret
		| obj::IsAny(m.Expr.Type):
			self.possibleRefExpr(m.Expr.Model)
			self.oc.write(".")
			// We handling map and channel types as smart pointer,
			// because this kind types implemented as smart pointers
			// at machine code level.
			match {
			| m.Type.Sptr() != nil:
				self.oc.write("cast_ptr<")
				self.oc.tc.kind(self.oc.Buf, m.Type.Sptr().Elem)
			| m.Type.Map() != nil:
				self.oc.write("cast_ptr<")
				mp := m.Type.Map()
				mut mps := obj::FindStructGenericInstance(meta::Program.Runtime.Map, mp.Key, mp.Val)
				self.oc.tc.structureIns(self.oc.Buf, mps)
			| m.Type.Chan() != nil:
				self.oc.write("cast_ptr<")
				ch := m.Type.Chan()
				mut chs := obj::FindStructGenericInstance(meta::Program.Runtime.Pchan, ch.Elem)
				self.oc.tc.structureIns(self.oc.Buf, chs)
			|:
				self.oc.write("cast<")
				self.oc.tc.kind(self.oc.Buf, m.Type)
			}
			self.oc.write(">(")
			if !env::Production {
				self.oc.write("\"")
				self.oc.locInfo(m.Token)
				self.oc.write("\", ")
			}
			self.oc.write("&" + anyTypeIdent)
			self.oc.write(conv::Itoa(self.oc.pushAnyType(m.Type)))
			self.oc.write(")")
			ret
		| m.Expr.Type.Ptr() != nil
		| m.Type.Ptr() != nil:
			self.oc.write("((")
			self.oc.tc.kind(self.oc.Buf, m.Type)
			self.oc.write(")(")
			self.possibleRefExpr(m.Expr.Model)
			self.oc.write("))")
			ret
		| m.Expr.Type.Trait() != nil:
			if m.Type.Trait() != nil {
				self.castTraitFromTrait(m, m.Type.Trait(), m.Expr.Type.Trait())
				ret
			}
			self.possibleRefExpr(m.Expr.Model)
			self.oc.write(".")
			// We handling map and channel types as smart pointer,
			// because this kind types implemented as smart pointers
			// at machine code level.
			match {
			| m.Type.Sptr() != nil:
				self.oc.write("cast_ptr<")
				self.oc.tc.kind(self.oc.Buf, m.Type.Sptr().Elem)
			| m.Type.Map() != nil:
				self.oc.write("cast_ptr<")
				mp := m.Type.Map()
				mut mps := obj::FindStructGenericInstance(meta::Program.Runtime.Map, mp.Key, mp.Val)
				self.oc.tc.structureIns(self.oc.Buf, mps)
			| m.Type.Chan() != nil:
				self.oc.write("cast_ptr<")
				ch := m.Type.Chan()
				mut chs := obj::FindStructGenericInstance(meta::Program.Runtime.Pchan, ch.Elem)
				self.oc.tc.structureIns(self.oc.Buf, chs)
			|:
				self.oc.write("cast<")
				self.oc.tc.kind(self.oc.Buf, m.Type)
			}
			self.oc.write(">(")
			if !env::Production {
				self.oc.write("\"")
				self.oc.locInfo(m.Token)
				self.oc.write("\", ")
			}
			self.oc.write("(" + typeTrait + "::Type*)&")
			identCoder.traitDecl(self.oc.Buf, m.Expr.Type.Trait())
			self.oc.write("_mptr_data")
			self.oc.write(conv::Itoa(obj::FindTraitTypeOffset(m.Expr.Type.Trait(), m.Type)))
			self.oc.write(")")
			ret
		| m.Type.Trait() != nil:
			if m.Expr.Type.IsNil() {
				self.oc.write(typeTrait + "()")
				ret
			}
			self.oc.tc.kind(self.oc.Buf, m.Type)
			self.oc.write("(")
			self.possibleRefExpr(m.Expr.Model)
			self.oc.write(", (" + typeTrait + "::Type*)&")
			identCoder.traitDecl(self.oc.Buf, m.Type.Trait())
			self.oc.write("_mptr_data")
			self.oc.write(conv::Itoa(obj::FindTraitTypeOffset(m.Type.Trait(), m.Expr.Type)))
			self.oc.write(")")
			ret
		}
		mut prim := m.Type.Prim()
		if prim != nil && prim.IsStr() {
			mut eprim := m.Expr.Type.Prim()
			if eprim != nil && prim != nil {
				if eprim.IsU8() {
					self.oc.write("__jule_strFromByte(")
				} else {
					self.oc.write("__jule_strFromRune(")
				}
				self.possibleRefExpr(m.Expr.Model)
				self.oc.write(")")
				ret
			}
			mut slc := m.Expr.Type.Slice()
			if slc != nil {
				eprim = slc.Elem.Prim()
				// []rune or []byte
				if eprim.IsI32() {
					self.oc.write("__jule_runesToStr(")
				} else {
					self.oc.write("__jule_bytesToStr(")
				}
				self.possibleRefExpr(m.Expr.Model)
				self.oc.write(")")
				ret
			}
		}
		prim = m.Expr.Type.Prim()
		if prim != nil && prim.IsStr() {
			mut slc := m.Type.Slice()
			if slc != nil {
				prim = slc.Elem.Prim()
				// []rune or []byte
				if prim.IsI32() {
					self.oc.write("__jule_strToRunes(")
				} else {
					self.oc.write("__jule_strToBytes(")
				}
				self.possibleRefExpr(m.Expr.Model)
				self.oc.write(")")
				ret
			}
		}
		self.oc.write("static_cast<")
		self.oc.tc.kind(self.oc.Buf, m.Type)
		self.oc.write(">(")
		self.possibleRefExpr(m.Expr.Model)
		self.oc.write(")")
	}

	fn args(mut &self, mut &m: &sema::FuncCallExpr) {
		mut j := 0
		if m.Func.Owner != nil && !m.Func.Decl.Statically ||
			len(m.Func.Params) > 0 && m.Func.Params[0].Decl.IsSelf() {
			j++ // Skip receiver parameter.
		}
		for i, arg in m.Args {
			p := m.Func.Params[j]
			if p.Decl != nil && p.Decl.Reference {
				match type arg {
				| &sema::Var:
					v := (&sema::Var)(arg)
					if v.Reference {
						self.model(arg)
						goto end
					}
				}
				self.oc.write("&(")
				self.model(arg)
				self.oc.write(")")
				goto end
			}
			self.possibleRefExpr(arg)
		end:
			if len(m.Args)-i > 1 {
				self.oc.write(", ")
			}
			j++
		}
	}

	fn modelForCall(mut &self, mut expr: compExpr) {
		match type expr {
		| &sema::FuncIns:
			self.funcIns((&sema::FuncIns)(expr))
			ret
		| &sema::StructSubIdentExpr:
			mut ssie := (&sema::StructSubIdentExpr)(expr)
			if ssie.Method != nil {
				self.funcIns(ssie.Method)
				ret
			}
		}
		self.possibleRefExpr(expr)
	}

	fn pushCallInf(mut &self, &m: &sema::FuncCallExpr) {
		if env::Production || !m.Func.Anon {
			self.oc.write("(")
			ret
		}
		if m.Func.Anon {
			match type m.Expr {
			| &sema::StructSubIdentExpr:
				if obj::IsStructBinded((&sema::StructSubIdentExpr)(m.Expr).Field.Owner) {
					self.oc.write("(")
					ret
				}
			}
			self.oc.write(".call")
		}
		self.oc.write("(\"")
		self.oc.locInfo(m.Token)
		self.oc.write("\"")
		if len(m.Args) != 0 {
			self.oc.write(", ")
		}
	}

	fn isWrapped(mut &self, mut &m: &sema::FuncCallExpr): bool {
		if !m.Func.IsBuiltin() && len(m.Func.Decl.Params) > 0 && m.Func.Decl.Params[0].IsSelf() {
			match type m.Expr {
			| &sema::StructSubIdentExpr:
				mut ssie := (&sema::StructSubIdentExpr)(m.Expr)
				if ssie.Expr.Lvalue {
					ret false
				}
				match {
				| m.Func.Decl.Params[0].IsRef()
				| ssie.Expr.Type.Sptr() != nil:
					ret false
				|:
					// Check whether expression type is struct to caught strict type alias structs.
					match type ssie.Expr.Type.Kind {
					| &sema::StructIns:
						self.oc.write("({ ")
						self.oc.tc.kind(self.oc.Buf, ssie.Expr.Type)
						self.oc.write(" _wrap_copy = ")
						self.model(ssie.Expr.Model)
						self.oc.write("; ")
						ret true
					}
				}
			}
		}
		ret false
	}

	fn writeReceiver(mut &self, mut m: compExpr): (safeDeref: bool) {
		match type m {
		| &sema::UnaryExpr:
			self.possibleRefExpr((&sema::UnaryExpr)(m).Expr.Model)
			ret true
		| &opt::UnsafeDerefExpr:
			self.possibleRefExpr((&opt::UnsafeDerefExpr)(m).Base.Expr.Model)
			ret false
		|:
			self.possibleRefExpr(m)
			ret false
		}
	}

	fn pureFuncCall(mut &self, mut &m: &sema::FuncCallExpr) {
		wrapped := self.isWrapped(m)
		self.modelForCall(m.Expr)
		if !m.Func.IsBuiltin() {
			if m.Func.Decl.Binded && len(m.Func.Generics) > 0 {
				if !obj::HasDirective(m.Func.Decl.Directives, build::Directive.Cdef) {
					self.oc.write("<")
					for (i, mut g) in m.Func.Generics {
						self.oc.tc.kind(self.oc.Buf, g.Type)
						if len(m.Func.Generics)-i > 1 {
							self.oc.write(", ")
						}
					}
					self.oc.write(">")
				}
			}
		}
		self.pushCallInf(m)
		if m.Func.AsAnon && !m.Func.Anon && m.Expr == m.Func {
			// Function used as anonymous.
			// So pass nullptr to ctx parameter.
			// Do not pass nullptr if function is anonymous,
			// because it stores ctx data internally and it will pass.
			self.oc.write("nullptr")
			if len(m.Args) > 0 {
				self.oc.write(", ")
			}
		}
		if !m.Func.IsBuiltin() && len(m.Func.Decl.Params) > 0 && m.Func.Decl.Params[0].IsSelf() {
			match type m.Expr {
			| &sema::StructSubIdentExpr:
				mut ssie := (&sema::StructSubIdentExpr)(m.Expr)
				match {
				| m.Func.Decl.Params[0].IsRef():
					// Ignore dereferencing, use data directly to call method.
					_ = self.writeReceiver(ssie.Expr.Model)
				|:
					match type ssie.Expr.Type.Kind {
					| &sema::Sptr:
						// Ignore dereferencing, use data directly to call [ptr] method.
						safe := self.writeReceiver(ssie.Expr.Model)
						if safe {
							self.oc.write(".ptr(")
							if !env::Production {
								self.oc.write("\"")
								self.oc.locInfo(m.Token)
								self.oc.write("\"")
							}
							self.oc.write(")")
						}
					|:
						match type ssie.Expr.Type.Kind {
						| &sema::StructIns:
							match type ssie.Expr.Model {
							| &sema::Var:
								v := (&sema::Var)(ssie.Expr.Model)
								if v.Reference {
									break
								}
								fall
							|:
								// Add address taking operation for non-pointers.
								self.oc.write("&")
							}
						}
						if wrapped {
							self.oc.write("_wrap_copy")
						} else if ssie.Expr.Type.Ptr() == nil {
							self.model(ssie.Expr.Model)
						} else {
							// Ignore dereferencing, use data directly to call method.
							self.possibleRefExpr((&sema::UnaryExpr)(ssie.Expr.Model).Expr.Model)
						}
					}
				}
				if len(m.Args) > 0 {
					self.oc.write(", ")
				}
			| &sema::TraitSubIdentExpr:
				self.possibleRefExpr((&sema::TraitSubIdentExpr)(m.Expr).Expr)
				self.oc.write(".data")
				if len(m.Args) > 0 {
					self.oc.write(", ")
				}
			}
		}
		self.args(m)
		self.oc.write(")")

		if wrapped {
			self.oc.write("; })")
		}
	}

	fn coFuncCall(mut &self, mut &m: &sema::FuncCallExpr) {
		self.oc.write("{\n")
		self.oc.addIndent()
		self.oc.indent()

		const noWrap = ""
		const argData = "__jule_argdata"
		mut i := noWrap
		if len(m.Func.Params) > 0 || m.Func.AsAnon {
			i = conv::Itoa(self.oc.pushCoSpawn(m.Func))
			t := coSpawnPrefix + coSpawnArgDataSuffix + i
			self.oc.write(t)
			self.oc.write(" *")
			self.oc.write(argData)
			self.oc.write(" = new (std::nothrow) ")
			self.oc.write(t)
			self.oc.write("; if (!")
			self.oc.write(argData)
			self.oc.write(`) __jule_panic((`)
			self.oc.write(typeU8)
			self.oc.write(`*)"memory allocation failed for concurrent call", 44);` + "\n")
			self.oc.indent()

			// setup function data
			self.oc.write(argData)
			self.oc.write("->")
			self.oc.write(coSpawnArgDataFunc)
			self.oc.write(" = ")
			self.modelForCall(m.Expr)
			self.oc.write(";\n")

			// setup argument data
			for j in m.Func.Params {
				self.oc.indent()
				self.oc.write(argData)
				self.oc.write("->")
				self.oc.write(coSpawnArgDataParam)
				self.oc.write(conv::Itoa(j))
				self.oc.write(" = ")
				self.possibleRefExpr(m.Args[j])
				self.oc.write(";\n")
			}
			self.oc.indent()
		}

		// spawn thread
		if i != noWrap {
			self.oc.write("if (!")
		}
		self.oc.write("__jule_coSpawn((void*)")
		if i == noWrap {
			identCoder.funcIns(self.oc.Buf, m.Func)
		} else {
			self.oc.write(coSpawnPrefix + coSpawnMethodSuffix + i)
		}
		self.oc.write(", ")
		if i == noWrap {
			self.oc.write("NULL")
		} else {
			self.oc.write("(void*)")
			self.oc.write(argData)
		}
		self.oc.write(")")
		if i == noWrap {
			self.oc.write(";")
		} else {
			self.oc.write(") { delete ")
			self.oc.write(argData)
			self.oc.write("; __jule_panic((")
			self.oc.write(typeU8)
			self.oc.write(`*)"thread creation failed for concurrent call", 42); }`)
		}
		self.oc.write("\n")
		self.oc.doneIndent()
		self.oc.indent()
		self.oc.write("}")
	}

	fn writeUseExpr(mut &self, mut &f: &sema::FuncIns, mut val: &sema::Value) {
		if val.Type.Tuple() == nil {
			self.possibleRefExpr(val.Model)
			self.oc.write(";")
			ret
		}
		mut tup := (&sema::TupleExpr)(val.Model)
		self.oc.tc.rc.tuple(self.oc.Buf, f.Result.Tuple())
		self.oc.write("{")
		for i, tupval in tup.Values {
			self.oc.write("." + resultArgName)
			self.oc.write(conv::Itoa(i))
			self.oc.write("=")
			self.possibleRefExpr(tupval.Model)
			if len(tup.Values)-i > 1 {
				self.oc.write(", ")
			}
		}
		self.oc.write("};")
	}

	fn funcCall(mut &self, mut m: &sema::FuncCallExpr, ignoreExceptional: bool) {
		if m.IsCo {
			// Do not check for exceptionals,
			// exceptional functions cannot be called with co.
			self.coFuncCall(m)
			ret
		}
		if m.Func.IsBuiltin() ||
			!m.Func.Decl.Exceptional ||
			m.Except != nil && len(m.Except.Stmts) == 0 {
			self.pureFuncCall(m)
			ret
		}

		if ignoreExceptional {
			// Ignore exceptional mode is on.
			// Just call function purely and use return value of exceptional if exist.
			self.pureFuncCall(m)
			if m.Func.Result != nil {
				self.oc.write(".result")
			}
			ret
		}

		// Generate code for exceptional.
		self.oc.write("({\n")
		self.oc.addIndent()
		self.oc.indent()
		self.oc.write("auto except = ")
		self.pureFuncCall(m)
		self.oc.write(";\n")
		self.oc.indent()
		if m.Except != nil {
			if m.Func.Result == nil || !m.Assigned {
				self.oc.write("if (!except.ok()) ")
				self.oc.sc.scope(m.Except)
				self.oc.write("\n")
			} else {
				forwarded := obj::IsForwarded(m.Except)
				self.oc.write("(except.ok()) ? (except.result) : (")
				if forwarded {
					self.oc.write("{")
				}
				mut stmt := m.Except.Stmts[len(m.Except.Stmts)-1]
				match type stmt {
				| &sema::Value:
					m.Except.Stmts = m.Except.Stmts[:len(m.Except.Stmts)-1]
					self.oc.write("{\n")
					self.oc.addIndent()
					self.oc.sc.scopeStmts(m.Except)
					self.oc.write("\n")
					self.oc.indent()
					self.writeUseExpr(m.Func, (&sema::Value)(stmt))
					self.oc.write("\n")
					self.oc.doneIndent()
					self.oc.indent()
					self.oc.write("}")
				|:
					self.oc.sc.scope(m.Except)
				}
				if forwarded {
					self.oc.write(" ")
					self.initExpr(m.Func.Result)
					self.oc.write(";}")
				}
				self.oc.write(");\n")
			}
			self.oc.doneIndent()
		} else {
			self.oc.write(`if (!except.ok()) __jule_panicStr(`)
			strLit(self.oc.Buf, "unhandled exceptional: ", "23")
			self.oc.write(" + except.error.type->to_str(except.error.data) + ")
			strLitF(self.oc.Buf, fn(): int {
				self.oc.write("\"\\nlocation: ")
				mut len := 11 // \nlocation:
				len += self.oc.locInfo(m.Token)
				self.oc.write("\"")
				ret len
			})
			self.oc.write(");\n")
			if !m.Func.Decl.IsVoid() {
				self.oc.indent()
				self.oc.write("(except.result);\n")
			}
			self.oc.doneIndent()
		}

		self.oc.indent()
		self.oc.write("})")
	}

	fn slice(mut &self, mut m: &sema::SliceExpr) {
		self.oc.write("({ auto " + collectionIdent + " = ")
		self.oc.tc.asSlice(self.oc.Buf, m.ElemType)
		size := conv::Itoa(len(m.Elems))
		self.oc.write("::alloc(")
		self.oc.write(size)
		self.oc.write(", ")
		self.oc.write(size)
		self.oc.write("); auto ")
		self.oc.write(collectionItIdent)
		self.oc.write(" = ")
		self.oc.write(collectionIdent)
		self.oc.write(".begin(); ")
		for i in m.Elems {
			self.oc.write("(*")
			self.oc.write(collectionItIdent)
			self.oc.write("++) = ")
			self.possibleRefExpr(m.Elems[i].Model)
			self.oc.write("; ")
		}
		self.oc.write(collectionIdent)
		self.oc.write("; })")
	}

	fn indexing(mut &self, mut m: &sema::IndexingExpr) {
		match type m.Expr.Model {
		| &constant::Const:
			// Constant string indexed. Use fast way, avoid making literal.
			self.oc.write(typeStr + "::at(")
			if !env::Production {
				self.oc.write("\"")
				self.oc.locInfo(m.Token)
				self.oc.write("\", ")
			}
			self.oc.write("reinterpret_cast<const " + typeU8 + "*>(")
			s := (&constant::Const)(m.Expr.Model).ReadStr()
			cstrLit(self.oc.Buf, s)
			self.oc.write("), ")
			self.oc.write(conv::Itoa(len(s)))
			self.oc.write(", ")
			self.possibleRefExpr(m.Index.Model)
			self.oc.write(")")
			ret
		}

		// Index access with safety measures.
		match {
		| m.Expr.Type.Map() != nil:
			mut _map := m.Expr.Type.Map()
			mut ins := obj::FindStructGenericInstance(meta::Program.Runtime.Map, _map.Key, _map.Val)
			const Static = false
			mut f := ins.FindMethod("get", Static).Instances[0]
			identCoder.funcIns(self.oc.Buf, f)
			self.oc.write("(")
			self.possibleRefExpr(m.Expr.Model)
			self.oc.write(", ")
			self.possibleRefExpr(m.Index.Model)
			self.oc.write(")")
		| env::Production
		| m.Expr.Type.Ptr() != nil
		| obj::IsExprComesFromBind(m.Expr):
			self.possibleRefExpr(m.Expr.Model)
			self.oc.write("[")
			self.possibleRefExpr(m.Index.Model)
			self.oc.write("]")
		|:
			self.possibleRefExpr(m.Expr.Model)
			self.oc.write(".at(\"")
			self.oc.locInfo(m.Token)
			self.oc.write("\", ")
			self.possibleRefExpr(m.Index.Model)
			self.oc.write(")")
		}
	}

	fn unsafeIndexing(mut &self, mut m: &opt::UnsafeIndexingExpr) {
		self.possibleRefExpr(m.Node.Expr.Model)
		// Index access with safety measures.
		match {
		| env::Production
		| m.Node.Expr.Type.Ptr() != nil
		| m.Node.Expr.Type.Map() != nil:
			self.oc.write("[")
			self.possibleRefExpr(m.Node.Index.Model)
			self.oc.write("]")
		|:
			self.oc.write(".__at(")
			self.possibleRefExpr(m.Node.Index.Model)
			self.oc.write(")")
		}
	}

	fn anonFunc(mut &self, mut m: &sema::AnonFuncExpr) {
		closure := obj::IsClosure(m)
		ident := self.oc.pushAnonFunc(m)
		self.oc.write("jule::__new_closure<")
		self.oc.tc.anonFunc(self.oc.Buf, m.Func)
		self.oc.write(">((void*)")
		self.oc.write(ident)
		if closure {
			self.oc.write(", jule::Ptr<")
			self.oc.write(ident)
			self.oc.write(anonFuncCtxSuffix)
			self.oc.write(">::make(")
			self.oc.write(ident)
			self.oc.write(anonFuncCtxSuffix + "{")
			for (i, mut v) in m.Captured {
				self.oc.write(".")
				identCoder.var(self.oc.Buf, v)
				self.oc.write("=")
				self.var(v)
				if len(m.Captured)-i > 1 {
					self.oc.write(",")
				}
			}
			self.oc.write("}).as<" + typeUintptr + ">(), ")
			self.oc.write(ident)
			self.oc.write(anonFuncCtxHandlerSuffix + ")")
		} else {
			self.oc.write(", nullptr, nullptr)")
		}
	}

	fn mapExpr(mut &self, mut m: &sema::MapExpr) {
		mut ins := obj::FindStructGenericInstance(meta::Program.Runtime.Map, m.Kind.Key, m.Kind.Val)
		const Static = true
		mut maker := ins.FindMethod("make", Static).Instances[0]
		if len(m.Entries) == 0 {
			identCoder.funcIns(self.oc.Buf, maker)
			self.oc.write("()")
			ret
		}

		mut f := ins.FindMethod("set", !Static).Instances[0]

		const mapVar = "__jule_map"
		self.oc.write("({ ")
		self.oc.tc.mapType(self.oc.Buf, m.Kind)
		self.oc.write(" ")
		self.oc.write(mapVar)
		self.oc.write(" = ")
		identCoder.funcIns(self.oc.Buf, maker)
		self.oc.write("(); ")
		for (_, mut pair) in m.Entries {
			self.oc.write("(*")
			identCoder.funcIns(self.oc.Buf, f)
			self.oc.write("(")
			self.oc.write(mapVar)
			self.oc.write(", ")
			self.possibleRefExpr(pair.Key)
			self.oc.write(")) = ")
			self.possibleRefExpr(pair.Val)
			self.oc.write("; ")
		}
		self.oc.write(mapVar)
		self.oc.write("; })")
	}

	fn slicing(mut &self, mut m: &sema::SlicingExpr) {
		self.possibleRefExpr(m.Expr.Model)
		self.oc.write(".slice(")
		if !env::Production {
			self.oc.write("\"")
			self.oc.locInfo(m.Token)
			self.oc.write("\", ")
		}
		self.possibleRefExpr(m.Left)
		if m.Right != nil {
			self.oc.write(", ")
			self.possibleRefExpr(m.Right)
		}
		if m.Cap != nil {
			self.oc.write(", ")
			self.possibleRefExpr(m.Cap)
		}
		self.oc.write(")")
	}

	fn traitSub(mut &self, mut m: &sema::TraitSubIdentExpr) {
		self.oc.write("((")
		identCoder.traitDecl(self.oc.Buf, m.Trt)
		self.oc.write("MptrData")
		self.oc.write("*)")
		self.possibleRefExpr(m.Expr)
		self.oc.write(".safe_type(")
		if !env::Production {
			self.oc.write("\"")
			self.oc.locInfo(m.Token)
			self.oc.write("\"")
		}
		self.oc.write("))->")
		identCoder.func(self.oc.Buf, m.Method)
	}

	fn structureSub(mut &self, mut m: &sema::StructSubIdentExpr) {
		self.possibleRefExpr(m.Expr.Model)
		if m.Field == nil {
			ret
		}
		self.oc.write(".")
		identCoder.field(self.oc.Buf, m.Field.Decl)
	}

	fn array(mut &self, mut m: &sema::ArrayExpr) {
		// Plain initialization if array is zero-length or
		// no specific expression and not able to init elements.
		if m.Kind.N == 0 || len(m.Elems) == 0 && !ableToInit(m.Kind.Elem) {
			self.oc.tc.array(self.oc.Buf, m.Kind)
			self.oc.write("()")
			ret
		}

		// Filled.
		if len(m.Elems) == 2 && m.Elems[1] == nil {
			self.oc.tc.array(self.oc.Buf, m.Kind)
			self.oc.write("(")
			self.possibleRefExpr(m.Elems[0].Model)
			self.oc.write(")")
			ret
		}

		self.oc.write("({ auto " + collectionIdent + " = ")
		self.oc.tc.array(self.oc.Buf, m.Kind)
		self.oc.write("(); auto ")
		self.oc.write(collectionItIdent)
		self.oc.write(" = ")
		self.oc.write(collectionIdent)
		self.oc.write(".begin(); ")
		if len(m.Elems) != m.Kind.N {
			// Define end pointer for remainders.
			self.oc.write("const auto ")
			self.oc.write(collectionIdent)
			self.oc.write("_end = ")
			self.oc.write(collectionIdent)
			self.oc.write(".end(); ")
		}
		for i in m.Elems {
			self.oc.write("(*")
			self.oc.write(collectionItIdent)
			self.oc.write("++) = ")
			self.possibleRefExpr(m.Elems[i].Model)
			self.oc.write("; ")
		}
		if len(m.Elems) != m.Kind.N && ableToInit(m.Kind.Elem) {
			self.fillCollectionByDefault(m.Kind.Elem)
		}
		self.oc.write(collectionIdent)
		self.oc.write("; })")
		ret
	}

	// Writes complete expression model of function instance.
	// Useful for strict type safety.
	fn funcInsCommon(mut &self, mut m: &sema::FuncIns) {
		self.oc.tc.func(self.oc.Buf, m)
		self.oc.write("(")
		self.funcIns(m)
		self.oc.write(")")
	}

	fn funcIns(mut &self, mut m: &sema::FuncIns) {
		if m.Decl != nil && m.Decl.Binded {
			d := obj::FindDirective(m.Decl.Directives, build::Directive.Namespace)
			if d != nil {
				self.oc.writeBytes(concatAllParts(d.Args...))
				self.oc.write("::")
			}
		}
		identCoder.funcIns(self.oc.Buf, m)
	}

	fn tuple(mut &self, mut m: &sema::TupleExpr) {
		for (i, mut v) in m.Values {
			self.possibleRefExpr(v.Model)
			self.oc.write(";")
			if len(m.Values)-i > 1 {
				self.oc.write("\n")
				self.oc.indent()
			}
		}
	}

	fn newCall(mut &self, mut m: &sema::BuiltinNewCallExpr) {
		self.oc.write("jule::new_ptr<")
		self.oc.tc.kind(self.oc.Buf, m.Type)
		self.oc.write(">(")
		if m.Init != nil {
			self.possibleRefExpr(m.Init)
		} else if ableToInit(m.Type) {
			self.initExpr(m.Type)
		}
		self.oc.write(")")
	}

	fn printCall(mut &self, mut m: &sema::BuiltinPrintCallExpr) {
		self.oc.write("jule::print(")
		mut f := obj::FindFuncGenericInstance(meta::Program.Runtime.ToStr, m.Expr.Type)
		identCoder.funcIns(self.oc.Buf, f)
		self.oc.write("(")
		self.possibleRefExpr(m.Expr.Model)
		self.oc.write("))")
	}

	fn printlnCall(mut &self, mut m: &sema::BuiltinPrintlnCallExpr) {
		self.oc.write("jule::println(")
		mut f := obj::FindFuncGenericInstance(meta::Program.Runtime.ToStr, m.Expr.Type)
		identCoder.funcIns(self.oc.Buf, f)
		self.oc.write("(")
		self.possibleRefExpr(m.Expr.Model)
		self.oc.write("))")
	}

	fn panicCall(mut &self, mut m: &sema::BuiltinPanicCallExpr) {
		self.oc.write("__jule_panicStr(")
		self.possibleRefExpr(m.Expr)
		self.oc.write(" + ")
		strLit(self.oc.Buf, "\nlocation: ", "12")
		self.oc.write(" + ")
		strLitF(self.oc.Buf, fn(): int {
			self.oc.write("\"")
			len := self.oc.locInfo(m.Token)
			self.oc.write("\"")
			ret len
		})
		self.oc.write(");")
	}

	fn errorCall(mut &self, mut m: &sema::BuiltinErrorCallExpr) {
		hasDefer := m.Func.Decl != nil && m.Func.Decl.HasDefer
		if m.Func.Decl.IsVoid() {
			match type m.Err.Model {
			| &sema::Var:
				v := (&sema::Var)(m.Err.Model)
				if v.Ident == token::Kind.Error {
					if hasDefer {
						self.oc.write(deferStackName + ".call();\n")
						self.oc.indent()
					}
					self.oc.write("return jule::VoidExceptional{.error=std::move(except.error)}")
					ret
				}
			}
			self.oc.write("return jule::VoidExceptional{.error=" + typeAny + "(")
		} else {
			self.oc.write("return jule::Exceptional<")
			self.oc.tc.rc.codeMut1(self.oc.Buf, m.Func.Result)
			match type m.Err.Model {
			| &sema::Var:
				v := (&sema::Var)(m.Err.Model)
				if v.Ident == token::Kind.Error {
					self.oc.write(">{.error=except.error}")
					ret
				}
			}
			self.oc.write(">{.error=" + typeAny + "(")
		}
		if hasDefer {
			self.oc.write("({ auto __result = ")
		}
		self.possibleRefExpr(m.Err.Model)
		if hasDefer {
			self.oc.write(";" + deferStackName + ".call(); __result; })")
		}
		i := self.oc.pushAnyType(m.Err.Type)
		self.oc.write(", &" + anyTypeIdent)
		self.oc.write(conv::Itoa(i))
		self.oc.write(")}")
	}

	fn copyCall(mut &self, mut m: &sema::BuiltinCopyCallExpr) {
		// We have to use mutable memory for the dest argument of copy due to lang spec.
		if opt::IsZCopyArray(m.Dest.Model) {
			mut ie := (&sema::SlicingExpr)(m.Dest.Model)
			mut model := any(&opt::ArrayAsSlice{
				Expr: ie.Expr.Model,
			})
			ie.Expr.Model = unsafe { *(*sema::Expr)(&model) }
		}
		self.oc.write("jule::copy(")
		self.possibleRefExpr(m.Dest.Model)
		self.oc.write(", ")
		self.possibleRefExpr(m.Src.Model)
		self.oc.write(")")
	}

	fn lenCall(mut &self, mut m: &sema::BuiltinLenCallExpr) {
		mut _map := m.Expr.Type.Map()
		if _map != nil {
			mut ins := obj::FindStructGenericInstance(meta::Program.Runtime.Map, _map.Key, _map.Val)
			const Static = false
			mut f := ins.FindMethod("len", Static).Instances[0]
			identCoder.funcIns(self.oc.Buf, f)
			self.oc.write("(")
			self.possibleRefExpr(m.Expr.Model)
			self.oc.write(")")
			ret
		}
		self.possibleRefExpr(m.Expr.Model)
		self.oc.write(".len()")
	}

	fn capCall(mut &self, mut m: &sema::BuiltinCapCallExpr) {
		self.possibleRefExpr(m.Expr.Model)
		self.oc.write(".cap()")
	}

	fn deleteCall(mut &self, mut m: &sema::BuiltinDeleteCallExpr) {
		mut _map := m.Dest.Type.Map()
		if _map == nil {
			panic("cxx: deleteCall: destination is not map")
		}
		mut ins := obj::FindStructGenericInstance(meta::Program.Runtime.Map, _map.Key, _map.Val)
		const Static = false
		if m.Key != nil {
			mut f := ins.FindMethod("del", Static).Instances[0]
			identCoder.funcIns(self.oc.Buf, f)
			self.oc.write("(")
			self.possibleRefExpr(m.Dest.Model)
			self.oc.write(", ")
			self.possibleRefExpr(m.Key.Model)
			self.oc.write(")")
		} else {
			mut f := ins.FindMethod("clear", Static).Instances[0]
			identCoder.funcIns(self.oc.Buf, f)
			self.oc.write("(")
			self.possibleRefExpr(m.Dest.Model)
			self.oc.write(")")
		}
	}

	fn makeCallSlice(mut &self, mut &m: &sema::BuiltinMakeCallExpr) {
		mut slice := m.Type.Slice()
		init := ableToInit(slice.Elem)
		if init {
			self.oc.write("({ auto " + collectionIdent + " = ")
		}
		self.oc.tc.kind(self.oc.Buf, m.Type)
		self.oc.write("::alloc(")
		self.possibleRefExpr(m.Len)
		self.oc.write(", ")
		if m.Cap != nil {
			self.possibleRefExpr(m.Cap)
		} else {
			self.possibleRefExpr(m.Len)
		}
		self.oc.write(")")
		if !init {
			ret
		}
		self.oc.write("; ")
		self.initCollection(slice.Elem)
		self.oc.write(" " + collectionIdent + "; })")
	}

	fn makeCallChan(mut &self, mut &m: &sema::BuiltinMakeCallExpr) {
		ch := m.Type.Chan()
		mut ins := obj::FindStructGenericInstance(meta::Program.Runtime.Pchan, ch.Elem)
		const Static = true
		mut f := ins.FindMethod("new", Static).Instances[0]
		identCoder.funcIns(self.oc.Buf, f)
		self.oc.write("(")
		if m.Cap == nil {
			// Channel is not buffered.
			// We have to initialize it with zero buffer-length.
			self.oc.write("0")
		} else {
			self.possibleRefExpr(m.Cap)
		}
		self.oc.write(")")
	}

	fn makeCall(mut &self, mut m: &sema::BuiltinMakeCallExpr) {
		if m.Type.Slice() != nil {
			self.makeCallSlice(m)
			ret
		}
		if m.Type.Chan() != nil {
			self.makeCallChan(m)
			ret
		}
	}

	fn pushToSlice(mut &self, mut m: &opt::PushToSliceExpr) {
		// Use l-value advantage and define reference variable to destination
		// in the child scope to avoid potential repeated high-cost memory access overhead.
		const destIdent = "__jule_push_dest"

		self.oc.write("{ ")
		self.oc.tc.asSlice(self.oc.Buf, m.Elems.ElemType)

		mut ptr := false
		match type m.Dest {
		| &sema::UnaryExpr:
			// Use raw pointer directly if exist.
			mut u := (&sema::UnaryExpr)(m.Dest)
			if u.Expr.Type.Ptr() != nil {
				self.oc.write(" *" + destIdent + " = ")
				self.possibleRefExpr(u.Expr.Model)
				self.oc.write("; ")
				ptr = true
				break
			}
			fall
		|:
			self.oc.write(" &" + destIdent + " = ")
			self.possibleRefExpr(m.Dest)
			self.oc.write("; ")
		}
		// Pushed single item.
		if len(m.Elems.Elems) == 1 {
			if ptr {
				self.oc.write(destIdent + "->push(")
			} else {
				self.oc.write(destIdent + ".push(")
			}
			self.possibleRefExpr(m.Elems.Elems[0].Model)
			self.oc.write("); }")
			ret
		}
		// Pushed more than single item.
		// Pre-allocate enough capacity if not exist for appendation.
		if ptr {
			self.oc.write(destIdent + "->alloc_for_append(")
		} else {
			self.oc.write(destIdent + ".alloc_for_append(")
		}
		self.oc.write(conv::Itoa(len(m.Elems.Elems)))
		self.oc.write("); ")
		for (_, mut e) in m.Elems.Elems {
			self.oc.write(destIdent)
			// Use the "__push" method to skip allocation boundary checking.
			if ptr {
				self.oc.write("->__push(")
			} else {
				self.oc.write(".__push(")
			}
			self.possibleRefExpr(e.Model)
			self.oc.write("); ")
		}
		self.oc.write("}")
	}

	fn appendToSlice(mut &self, mut m: &opt::AppendToSliceExpr) {
		self.oc.write("(")
		self.possibleRefExpr(m.Dest)
		self.oc.write(").append(")
		self.possibleRefExpr(m.Slice)
		self.oc.write(");")
	}

	fn appendCall(mut &self, mut m: &sema::BuiltinAppendCallExpr) {
		self.oc.write("jule::append(")
		self.possibleRefExpr(m.Dest)
		self.oc.write(",")
		self.possibleRefExpr(m.Elements)
		self.oc.write(")")
	}

	fn sizeof(mut &self, mut m: &sema::SizeofExpr) {
		self.oc.write("sizeof(")
		self.possibleRefExpr(m.Expr)
		self.oc.write(")")
	}

	fn alignof(mut &self, mut m: &sema::AlignofExpr) {
		self.oc.write("alignof(")
		self.possibleRefExpr(m.Expr)
		self.oc.write(")")
	}

	fn runeLit(mut &self, m: &sema::RuneExpr) {
		if m.Code <= 127 { // ASCII.
			self.oc.Buf.WriteByte('\'')!
			mut b := sbtoa(byte(m.Code))
			if b == "'" {
				self.oc.Buf.WriteByte('\\')!
			}
			self.oc.Buf.WriteStr(b)!
			self.oc.Buf.WriteByte('\'')!
			ret
		}
		itoa(self.oc.Buf, i64(m.Code))
	}

	fn structureStatic(mut &self, mut m: &sema::StructStaticIdentExpr) {
		identCoder.funcIns(self.oc.Buf, m.Method)
	}

	fn backendEmit(mut &self, mut m: &sema::BackendEmitExpr) {
		if len(m.Exprs) == 0 {
			self.oc.write(m.Code)
			ret
		}
		n := self.oc.Buf.Len()
		mut args := make([]any, len(m.Exprs))
		for (i, mut expr) in m.Exprs {
			self.possibleRefExpr(expr)
			mut buf := unsafe { self.oc.Buf.Buf() }
			args[i] = str(buf[n:])
			unsafe { self.oc.Buf.SetBuf(buf[:n]) }
		}
		self.oc.write(fmt::Format(m.Code, args...))
	}

	fn free(mut &self, mut m: &sema::FreeExpr) {
		self.possibleRefExpr(m.Expr)
		if env::RC {
			self.oc.write(".dealloc()")
			ret
		}
		self.oc.write(".__free()")
	}

	fn chanRecv(mut &self, mut m: &sema::ChanRecv, ok: fn(), owned: bool) {
		ch := m.Expr.Type.Chan()
		mut ins := obj::FindStructGenericInstance(meta::Program.Runtime.Pchan, ch.Elem)
		const Static = false
		mut f := ins.FindMethod("recv", Static).Instances[0]
		identCoder.funcIns(self.oc.Buf, f)
		self.oc.write("(")
		self.possibleRefExpr(m.Expr.Model)
		self.oc.write(".ptr(")
		if !env::Production {
			self.oc.write("\"")
			self.oc.locInfo(m.Token)
			self.oc.write("\"")
		}
		self.oc.write("), ")
		if ok != nil {
			// Write the reference expression to pass |ok| parameter.
			ok()
		} else {
			// Pass nil pointer to the reference.
			// It should be safe.
			self.oc.write("nullptr")
		}
		self.oc.write(", ")
		self.oc.write(conv::FmtBool(owned))
		self.oc.write(")")
	}

	fn chanSend(mut &self, mut m: &sema::ChanSend, owned: bool) {
		c := m.Chan.Type.Chan()
		mut ins := obj::FindStructGenericInstance(meta::Program.Runtime.Pchan, c.Elem)
		const Static = false
		mut f := ins.FindMethod("send", Static).Instances[0]
		identCoder.funcIns(self.oc.Buf, f)
		self.oc.write("(")
		self.possibleRefExpr(m.Chan.Model)
		self.oc.write(".ptr(")
		if !env::Production {
			self.oc.write("\"")
			self.oc.locInfo(m.Token)
			self.oc.write("\"")
		}
		self.oc.write("), ")
		self.possibleRefExpr(m.Data.Model)
		self.oc.write(", ")
		self.oc.write(conv::FmtBool(owned))
		self.oc.write(")")
	}

	fn closeCall(mut &self, mut m: &sema::BuiltinCloseCallExpr) {
		ch := m.Chan.Type.Chan()
		mut ins := obj::FindStructGenericInstance(meta::Program.Runtime.Pchan, ch.Elem)
		const Static = false
		mut f := ins.FindMethod("close", Static).Instances[0]
		identCoder.funcIns(self.oc.Buf, f)
		self.oc.write("(")
		self.possibleRefExpr(m.Chan.Model)
		self.oc.write(".ptr(")
		if !env::Production {
			self.oc.write("\"")
			self.oc.locInfo(m.Token)
			self.oc.write("\"")
		}
		self.oc.write("))")
	}

	fn strComp(mut &self, mut m: &opt::StrCompExpr) {
		if m.NotEq {
			self.oc.write("(!")
		}
		s := m.Right.ReadStr()
		self.possibleRefExpr(m.Left)
		self.oc.write(".equal(")
		cstrLit(self.oc.Buf, s)
		self.oc.write(", ")
		self.oc.write(conv::Itoa(len(s)))
		self.oc.write(")")
		if m.NotEq {
			self.oc.write(")")
		}
	}

	fn emptyCompare(mut &self, mut m: &opt::EmptyCompareExpr) {
		if m.Neg {
			self.oc.write("!")
		}
		self.oc.write("(")
		self.possibleRefExpr(m.Expr)
		self.oc.write(").empty()")
	}

	fn unsafeDeref(mut &self, mut m: &opt::UnsafeDerefExpr) {
		match {
		| m.Base.Expr.Type.Sptr() != nil:
			self.oc.write("(*")
			self.possibleRefExpr(m.Base.Expr.Model)
			self.oc.write(".alloc)")
		|:
			panic("cxx: implementation mistake, this panic call should be unreachable")
		}
	}

	fn unsafeCasting(mut &self, mut m: &opt::UnsafeCastingExpr) {
		match {
		| obj::IsAny(m.Base.Expr.Type):
			self.possibleRefExpr(m.Base.Expr.Model)
			// We handling map and channel types as smart pointer,
			// because this kind types implemented as smart pointers
			// at machine code level.
			match {
			| m.Base.Type.Sptr() != nil:
				self.oc.write(".unsafe_cast_ptr<")
				self.oc.tc.kind(self.oc.Buf, m.Base.Type.Sptr().Elem)
			| m.Base.Type.Map() != nil:
				self.oc.write(".unsafe_cast_ptr<")
				mp := m.Base.Type.Map()
				mut mps := obj::FindStructGenericInstance(meta::Program.Runtime.Map, mp.Key, mp.Val)
				self.oc.tc.structureIns(self.oc.Buf, mps)
			| m.Base.Type.Chan() != nil:
				self.oc.write(".unsafe_cast_ptr<")
				ch := m.Base.Type.Chan()
				mut chs := obj::FindStructGenericInstance(meta::Program.Runtime.Pchan, ch.Elem)
				self.oc.tc.structureIns(self.oc.Buf, chs)
			|:
				self.oc.write(".unsafe_cast<")
				self.oc.tc.kind(self.oc.Buf, m.Base.Type)
			}
			self.oc.write(">()")
		|:
			panic("cxx: implementation mistake, this panic call should be unreachable")
		}
	}

	fn strConcat(mut &self, mut m: &opt::StrConcatExpr) {
		self.oc.write("({ " + typeInt + " size = 0; ")
		for i, p in m.Parts {
			ident := "part" + conv::Itoa(i)
			self.oc.write(typeStr + " ")
			self.oc.write(ident)
			self.oc.write(" = std::move(")
			self.possibleRefExpr(p)
			self.oc.write("); size += ")
			self.oc.write(ident)
			self.oc.write(".len(); ")
		}
		self.oc.write("jule::Slice<" + typeU8 + "> buf; buf.alloc_new(0, size); ")
		for i in m.Parts {
			ident := "part" + conv::Itoa(i)
			self.oc.write("buf.append(")
			self.oc.write(ident)
			self.oc.write("); ")
		}
		self.oc.write(typeStr + " result; result._len = buf._len; result.buffer = std::move(buf.data); result._slice = buf._slice; std::move(result); })")
	}

	fn strFromBytes(mut &self, mut m: &opt::StrFromBytes) {
		identCoder.funcIns(self.oc.Buf, meta::Program.Runtime.SliceAsStr)
		self.oc.write("(")
		self.possibleRefExpr(m.Expr)
		self.oc.write(")")
	}

	fn arrayAsSlice(mut &self, mut m: &opt::ArrayAsSlice) {
		self.oc.write("(")
		self.possibleRefExpr(m.Expr)
		self.oc.write(").as_slice()")
	}

	fn model(mut &self, mut m: compExpr) {
		match type m {
		| str:
			self.oc.write(str(m))
		| &str:
			self.oc.write(*(&str)(m))
		| &constant::Const:
			self.constant((&constant::Const)(m))
		| &sema::Type:
			self.oc.tc.kind(self.oc.Buf, (&sema::Type)(m))
		| &sema::Var:
			self.var((&sema::Var)(m))
		| &sema::StructIns:
			self.structureIns((&sema::StructIns)(m))
		| &sema::FuncIns:
			self.funcInsCommon((&sema::FuncIns)(m))
		| &sema::BinaryExpr:
			self.binary((&sema::BinaryExpr)(m))
		| &sema::UnaryExpr:
			self.unary((&sema::UnaryExpr)(m))
		| &sema::StructLitExpr:
			self.structureLit((&sema::StructLitExpr)(m))
		| &sema::AllocStructLitExpr:
			self.allocStructure((&sema::AllocStructLitExpr)(m))
		| &sema::CastingExpr:
			self.casting((&sema::CastingExpr)(m))
		| &sema::FuncCallExpr:
			self.funcCall((&sema::FuncCallExpr)(m), false)
		| &sema::SliceExpr:
			self.slice((&sema::SliceExpr)(m))
		| &sema::ArrayExpr:
			self.array((&sema::ArrayExpr)(m))
		| &opt::UnsafeIndexingExpr:
			self.unsafeIndexing((&opt::UnsafeIndexingExpr)(m))
		| &sema::IndexingExpr:
			self.indexing((&sema::IndexingExpr)(m))
		| &sema::AnonFuncExpr:
			self.anonFunc((&sema::AnonFuncExpr)(m))
		| &sema::MapExpr:
			self.mapExpr((&sema::MapExpr)(m))
		| &sema::SlicingExpr:
			self.slicing((&sema::SlicingExpr)(m))
		| &sema::TraitSubIdentExpr:
			self.traitSub((&sema::TraitSubIdentExpr)(m))
		| &sema::StructSubIdentExpr:
			self.structureSub((&sema::StructSubIdentExpr)(m))
		| &sema::TupleExpr:
			self.tuple((&sema::TupleExpr)(m))
		| &sema::BuiltinPrintCallExpr:
			self.printCall((&sema::BuiltinPrintCallExpr)(m))
		| &sema::BuiltinPrintlnCallExpr:
			self.printlnCall((&sema::BuiltinPrintlnCallExpr)(m))
		| &sema::BuiltinNewCallExpr:
			self.newCall((&sema::BuiltinNewCallExpr)(m))
		| &sema::BuiltinPanicCallExpr:
			self.panicCall((&sema::BuiltinPanicCallExpr)(m))
		| &sema::BuiltinErrorCallExpr:
			self.errorCall((&sema::BuiltinErrorCallExpr)(m))
		| &sema::BuiltinMakeCallExpr:
			self.makeCall((&sema::BuiltinMakeCallExpr)(m))
		| &sema::BuiltinAppendCallExpr:
			self.appendCall((&sema::BuiltinAppendCallExpr)(m))
		| &sema::BuiltinCopyCallExpr:
			self.copyCall((&sema::BuiltinCopyCallExpr)(m))
		| &sema::BuiltinLenCallExpr:
			self.lenCall((&sema::BuiltinLenCallExpr)(m))
		| &sema::BuiltinCapCallExpr:
			self.capCall((&sema::BuiltinCapCallExpr)(m))
		| &sema::BuiltinDeleteCallExpr:
			self.deleteCall((&sema::BuiltinDeleteCallExpr)(m))
		| &sema::SizeofExpr:
			self.sizeof((&sema::SizeofExpr)(m))
		| &sema::AlignofExpr:
			self.alignof((&sema::AlignofExpr)(m))
		| &sema::RuneExpr:
			self.runeLit((&sema::RuneExpr)(m))
		| &sema::StructStaticIdentExpr:
			self.structureStatic((&sema::StructStaticIdentExpr)(m))
		| &sema::BackendEmitExpr:
			self.backendEmit((&sema::BackendEmitExpr)(m))
		| &sema::FreeExpr:
			self.free((&sema::FreeExpr)(m))
		| &sema::ChanRecv:
			self.chanRecv((&sema::ChanRecv)(m), nil, false)
		| &sema::ChanSend:
			self.chanSend((&sema::ChanSend)(m), false)
		| &sema::BuiltinCloseCallExpr:
			self.closeCall((&sema::BuiltinCloseCallExpr)(m))
		| &opt::UnsafeBinaryExpr:
			self.unsafeBinary((&opt::UnsafeBinaryExpr)(m).Node)
		| &opt::StrCompExpr:
			self.strComp((&opt::StrCompExpr)(m))
		| &opt::RefExpr:
			self.var((&opt::RefExpr)(m).Var)
		| &opt::EmptyCompareExpr:
			self.emptyCompare((&opt::EmptyCompareExpr)(m))
		| &opt::UnsafeDerefExpr:
			self.unsafeDeref((&opt::UnsafeDerefExpr)(m))
		| &opt::UnsafeCastingExpr:
			self.unsafeCasting((&opt::UnsafeCastingExpr)(m))
		| &opt::FuncCallIgnoreExceptionalExpr:
			self.funcCall((&opt::FuncCallIgnoreExceptionalExpr)(m).Base, true)
		| &opt::StrConcatExpr:
			self.strConcat((&opt::StrConcatExpr)(m))
		| &opt::StrFromBytes:
			self.strFromBytes((&opt::StrFromBytes)(m))
		| &opt::ArrayAsSlice:
			self.arrayAsSlice((&opt::ArrayAsSlice)(m))
		|:
			self.oc.write("<unimplemented_expression_model>")
		}
	}

	// Writes default initialization of struct field.
	fn handleFieldByDefault(mut &self, mut &f: &sema::FieldIns): (inited: bool) {
		// If field have default expression, initialize with it.
		// Otherwise, initialize it by default expression.
		if f.Default != nil {
			self.oc.write(".")
			identCoder.field(self.oc.Buf, f.Decl)
			self.oc.write("=")
			self.possibleRefExpr(f.Default.Model)
			ret true
		}
		if !ableToInit(f.Type) {
			ret false
		}
		self.oc.write(".")
		identCoder.field(self.oc.Buf, f.Decl)
		self.oc.write("=")
		self.initExpr(f.Type)
		ret true
	}

	// Writes default struct literal expression to initialize it by default.
	fn initStructLit(mut &self, mut &s: &sema::StructIns) {
		if obj::IsStructBinded(s) {
			self.oc.write("(")
			self.structureIns(s)
			self.oc.write("){}")
			ret
		}
		self.structureIns(s)
		self.oc.write("{")
		mut inited := false
		for (_, mut f) in s.Fields {
			if inited {
				self.oc.write(", ")
			}
			inited = self.handleFieldByDefault(f)
		}
		self.oc.write("}")
	}

	// Writes iteration to initialize collection elements by default.
	// Assumes collectionItIdent and collectionIdent + "_end" is already defined.
	// Assumes collection element kind able to init.
	fn fillCollectionByDefault(mut &self, mut &elem: &sema::Type) {
		self.oc.write("for (; ")
		self.oc.write(collectionItIdent)
		self.oc.write(" < ")
		self.oc.write(collectionIdent)
		self.oc.write("_end; ++")
		self.oc.write(collectionItIdent)
		self.oc.write(") *")
		self.oc.write(collectionItIdent)
		self.oc.write(" = ")
		self.initExpr(elem)
		self.oc.write(";")
	}

	// Assumes collection element kind able to init.
	fn initCollection(mut &self, mut &elem: &sema::Type) {
		self.oc.write("auto ")
		self.oc.write(collectionItIdent)
		self.oc.write(" = ")
		self.oc.write(collectionIdent)
		self.oc.write(".begin(); const auto ")
		self.oc.write(collectionIdent)
		self.oc.write("_end = ")
		self.oc.write(collectionIdent)
		self.oc.write(".end(); ")
		self.fillCollectionByDefault(elem)
	}

	// Writes default array literal expression to initialize it by default.
	fn initArray(mut &self, mut &arr: &sema::Array) {
		// Plain initialization if array is zero-length.
		if arr.N == 0 {
			self.oc.tc.array(self.oc.Buf, arr)
			self.oc.write("()")
			ret
		}
		self.oc.write("({ auto " + collectionIdent + " = ")
		self.oc.tc.array(self.oc.Buf, arr)
		self.oc.write("(); ")
		self.initCollection(arr.Elem)
		self.oc.write(" " + collectionIdent + "; })")
	}

	fn initExpr(mut &self, mut t: &sema::Type) {
		if t.NilCompatible() {
			if t.Map() != nil {
				self.oc.tc.kind(self.oc.Buf, t)
				self.oc.write("{}")
				ret
			}
			if t.Ptr() != nil {
				self.oc.write("nullptr")
			} else {
				self.oc.tc.kind(self.oc.Buf, t)
				self.oc.write("(nullptr)")
			}
			ret
		}
		mut tup := t.Tuple()
		if tup != nil {
			self.oc.tc.rc.tuple(self.oc.Buf, tup)
			self.oc.write("{")
			for (i, mut tt) in tup.Types {
				if !shouldInitialized(tt) {
					continue
				}
				self.oc.write("." + resultArgName)
				self.oc.write(conv::Itoa(i))
				self.oc.write("=")
				self.initExpr(tt)
				if len(tup.Types)-i > 1 {
					self.oc.write(", ")
				}
			}
			self.oc.write("}")
			ret
		}
		mut enm := t.Enum()
		if enm != nil {
			self.model(enm.Items[0].ValueSym.Value.Model)
			ret
		}
		prim := t.Prim()
		if prim != nil {
			if types::IsNum(prim.Kind) {
				self.oc.write("0")
			} else if prim.IsBool() {
				self.oc.write("false")
			} else if prim.IsStr() {
				self.oc.write(typeStr + "()")
			}
			ret
		}
		if t.Array() != nil {
			mut arr := t.Array()
			self.initArray(arr)
			ret
		}
		mut s := t.Struct()
		if s != nil {
			self.initStructLit(s)
			ret
		}
		self.oc.tc.kind(self.oc.Buf, t)
		self.oc.write("()")
	}
}

fn decomposeCommonEsq(b: byte): str {
	match b {
	| '\\':
		ret "\\\\"
	| '\'':
		ret "'"
	| '"':
		ret `\"`
	| '\a':
		ret `\a`
	| '\b':
		ret `\b`
	| '\f':
		ret `\f`
	| '\n':
		ret `\n`
	| '\r':
		ret `\r`
	| '\t':
		ret `\t`
	| '\v':
		ret `\v`
	|:
		ret ""
	}
}

fn sbtoa(b: byte): str {
	if b == 0 {
		ret "\\x00"
	}
	if b < utf8::RuneSelf { // ASCII, fast way.
		seq := decomposeCommonEsq(b)
		if seq != "" {
			ret seq
		}
		if 32 <= b && b <= 126 {
			ret str(b)
		}
	}
	seq := conv::FmtUint(u64(b), 8)
	if len(seq) == 2 {
		ret "\\0" + seq
	}
	ret "\\" + seq
}

fn cstrBytes(mut &s: strings::Builder, ctx: str) {
	for _, b in ctx {
		s.WriteStr(sbtoa(b))!
	}
}

fn cstrLit(mut &s: strings::Builder, ctx: str) {
	s.WriteByte('"')!
	cstrBytes(s, ctx)
	s.WriteByte('"')!
}

fn ftoa(mut &s: strings::Builder, f: f64, bitsize: int) {
	if bitsize != 32 {
		if f == f64(i64(f)) {
			itoa(s, i64(f))
			ret
		}
		if f == f64(u64(f)) {
			utoa(s, u64(f))
			ret
		}
	}
	m := conv::FmtFloat(f, 'f', -1, bitsize)
	s.WriteStr(m)!
	if !strings::Contains(m, ".") {
		s.WriteStr(".0")!
	}
}

fn itoa(mut &s: strings::Builder, x: i64) {
	match {
	| x == types::MaxI64:
		s.WriteStr("jule::MAX_I64")!
		ret
	| x == types::MinI64:
		s.WriteStr("jule::MIN_I64")!
		ret
	}

	s.WriteStr(conv::FmtInt(x, 10))!
	if build::Is64Bit(runtime::Arch) {
		s.WriteByte('L')!
	}
	s.WriteByte('L')!
}

fn utoa(mut &s: strings::Builder, x: u64) {
	match {
	| x == types::MaxU64:
		s.WriteStr("jule::MAX_U64")!
		ret
	}

	s.WriteStr(conv::FmtUint(x, 10))!
	if build::Is64Bit(runtime::Arch) {
		s.WriteByte('L')!
	}
	s.WriteStr("LU")!
}

fn structBinary(mut &buf: strings::Builder, mut &s: &sema::StructIns, &l: str,
	&r: str, op: token::Id, kind: str) {
	if op != token::Id.Eqs && op != token::Id.NotEq {
		panic("cxx: unsupported token occurred for structure binary, this is an implementation mistake")
	}
	if op == token::Id.NotEq {
		buf.WriteByte('!')!
	}
	identCoder.structureIns(buf, s)
	buf.WriteStr(structDefaultEqMethodSuffix)!
	buf.WriteStr("(&")!
	buf.WriteStr(l)!
	buf.WriteStr(", ")!
	buf.WriteStr(r)!
	buf.WriteByte(')')!
}

// Writes string literal expression for constant literal to buf.
// Literal is not including quotes, just string content in bytes.
fn strLit(mut &buf: strings::Builder, lit: str, len: str) {
	identCoder.funcIns(buf, meta::Program.Runtime.StrBytePtr)
	buf.WriteStr("((" + typeU8 + "*)")!
	cstrLit(buf, lit)
	buf.WriteByte(',')!
	buf.WriteStr(len)!
	buf.WriteByte(')')!
}

// Same as the strLit function, but uses the lit function to write content.
// The lit function should return the length of content.
fn strLitF(mut &buf: strings::Builder, lit: fn(): int) {
	identCoder.funcIns(buf, meta::Program.Runtime.StrBytePtr)
	buf.WriteStr("((" + typeU8 + "*)")!
	len := conv::Itoa(lit())
	buf.WriteByte(',')!
	buf.WriteStr(len)!
	buf.WriteByte(')')!
}

// Like the strLit function, but writes as slice (will not perform allocation).
fn strLitAsSlice(mut &buf: strings::Builder, lit: str, len: str) {
	identCoder.funcIns(buf, meta::Program.Runtime.SliceBytePtr)
	buf.WriteStr("((" + typeU8 + "*)")!
	cstrLit(buf, lit)
	buf.WriteByte(',')!
	buf.WriteStr(len)!
	buf.WriteByte(',')!
	buf.WriteStr(len)!
	buf.WriteByte(')')!
}

// Returns string expr as byte slice (will not perform allocation).
fn strToSlice(mut &buf: strings::Builder, expr: str) {
	identCoder.funcIns(buf, meta::Program.Runtime.StrAsSlice)
	buf.WriteByte('(')!
	buf.WriteStr(expr)!
	buf.WriteByte(')')!
}

// Function f writes buffer buf and this function returns
// as separate string the written part. Buffer will not contain
// written part.
fn writeAndReadFromBuf(mut &buf: strings::Builder, f: fn()): str {
	mut i := buf.Len()
	f()
	s := str(unsafe { buf.Buf()[i:] })
	unsafe { buf.SetBuf(buf.Buf()[:i]) }
	ret s
}
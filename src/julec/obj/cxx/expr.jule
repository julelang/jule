// Copyright 2023-2025 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "julec/env"
use "julec/obj"
use "julec/obj/meta"
use "julec/opt"
use "std/conv"
use "std/fmt"
use "std/jule/build"
use "std/jule/constant"
use "std/jule/directive"
use "std/jule/dist"
use "std/jule/sema"
use "std/jule/token"
use "std/jule/types"
use "std/math"
use "std/os"
use "std/runtime"
use "std/strings"
use "std/unicode/utf8"

const (
	collectionIdent   = "__jule_collection"
	collectionItIdent = "it"
)

// Common group of semantic analysis expression model types and optimizer specific types.
enum compExpr: type {
	sema::Expr,
	str,  // For built-in expressions.
	&str, // For built-in expressions.
	&opt::UnsafeBinaryExpr,
	&opt::UnsafeIndexingExpr,
	&opt::StrCompExpr,
	&opt::EmptyCompareExpr,
	&opt::UnsafeDerefExpr,
	&opt::UnsafeTypeAssertionExpr,
	&opt::FuncCallIgnoreExceptionalExpr,
	&opt::StrConcatExpr,
	&opt::StrFromBytes,
	&opt::ArrayAsSlice,
	&opt::BytesFromStr,
}

struct exprCoder {
	oc: &ObjectCoder

	// It will executed before common variable handling algorithm.
	// If it returns true, common algorithm will not be executed.
	varPrefixes: []fn(mut v: &sema::Var): bool
}

impl exprCoder {
	fn new(mut oc: &ObjectCoder): &exprCoder {
		ret &exprCoder{
			oc: oc,
		}
	}

	fn string(mut &self, c: &constant::Const) {
		content := c.ReadStr()
		if len(content) == 0 { // Empty.
			self.oc.write(typeStr + "()")
			ret
		}
		len := conv::FormatInt(i64(len(content)), 10)
		strLit(&self.oc.Buf, content, len)
	}

	fn boolean(mut &self, b: bool) {
		if b {
			self.oc.write("true")
		} else {
			self.oc.write("false")
		}
	}

	fn nilLit(mut &self) {
		self.oc.write("nullptr")
	}

	fn ftoaSpecialCases(mut &self, x: f64): bool {
		match {
		| math::IsNaN(x):
			self.oc.write("__jule_NaN()")
		| math::IsInf(x, 1):
			self.oc.write("__jule_Inf(1)")
		| math::IsInf(x, -1):
			self.oc.write("__jule_Inf(-1)")
		|:
			ret false
		}
		ret true
	}

	fn float32(mut &self, c: &constant::Const) {
		x := c.AsF64()

		self.oc.write("__jule_F32(")

		// Special cases.
		if self.ftoaSpecialCases(x) {
			self.oc.write(")")
			ret
		}

		ftoa(&self.oc.Buf, x, 32)
		self.oc.write("f)")
	}

	fn float64(mut &self, c: &constant::Const) {
		x := c.AsF64()

		self.oc.write("__jule_F64(")

		// Special cases.
		if self.ftoaSpecialCases(x) {
			self.oc.write(")")
			ret
		}

		ftoa(&self.oc.Buf, x, 64)
		self.oc.write(")")
	}

	fn cmplx64(mut &self, c: &constant::Const) {
		cmplx := c.AsCmplx128()

		self.oc.tc.toType(&self.oc.Buf, types::Cmplx64)
		self.oc.write("{")
		ftoa(&self.oc.Buf, real(cmplx), 32)
		self.oc.write(", ")
		ftoa(&self.oc.Buf, imag(cmplx), 32)
		self.oc.write("}")
	}

	fn cmplx128(mut &self, c: &constant::Const) {
		cmplx := c.AsCmplx128()

		self.oc.tc.toType(&self.oc.Buf, types::Cmplx128)
		self.oc.write("{")
		ftoa(&self.oc.Buf, real(cmplx), 64)
		self.oc.write(", ")
		ftoa(&self.oc.Buf, imag(cmplx), 64)
		self.oc.write("}")
	}

	fn constant(mut &self, mut c: &constant::Const) {
		match {
		| c.IsStr():
			self.string(c)
		| c.IsBool():
			self.boolean(c.ReadBool())
		| c.IsF64():
			match {
			| c.Kind == types::F32:
				self.float32(c)
			|:
				self.float64(c)
			}
		| c.IsCmplx128():
			match {
			| c.Kind == types::Cmplx64:
				self.cmplx64(c)
			|:
				self.cmplx128(c)
			}
		| c.IsInt():
			i := c.ReadInt()
			if c.Kind != "" {
				self.oc.tc.toType(&self.oc.Buf, c.Kind)
				self.oc.write("(")
			}
			if i.IsI64() {
				itoa(&self.oc.Buf, i.I64())
			} else {
				utoa(&self.oc.Buf, i.U64())
			}
			if c.Kind != "" {
				self.oc.write(")")
			}
		| c.IsNil():
			self.nilLit()
		|:
			self.oc.write("<unimplemented_constant_expression>")
		}
	}

	fn divByZeroBinary(mut &self, op: &token::Token, mut l: &sema::OperandExpr, mut r: &sema::OperandExpr) {
		const (
			xVar = "__jule_x"
			yVar = "__jule_y"
		)
		self.oc.write("({ ")
		self.oc.tc.kind(&self.oc.Buf, l.Type)
		self.oc.write(" ")
		self.oc.write(xVar)
		self.oc.write(" = ")
		self.possibleRefExpr(l.Model)
		self.oc.write("; ")
		self.oc.tc.kind(&self.oc.Buf, r.Type)
		self.oc.write(" ")
		self.oc.write(yVar)
		self.oc.write(" = ")
		self.possibleRefExpr(r.Model)
		self.oc.write("; if (")
		self.oc.write(yVar)
		self.oc.write(` == 0) `)
		lp, rp := l.Type.Prim(), r.Type.Prim()
		if types::IsFloat(lp.Kind) || types::IsFloat(rp.Kind) {
			if types::IsFloat(lp.Kind) {
				self.oc.tc.kind(&self.oc.Buf, l.Type)
			} else {
				self.oc.tc.kind(&self.oc.Buf, r.Type)
			}
			self.oc.write("(__jule_Inf(")
			self.oc.write(xVar)
			self.oc.write(" > 0 && ")
			self.oc.write(yVar)
			self.oc.write(" > 0 ? 1 : -1)); ")
		} else {
			self.oc.write(`__jule_panicStr(`)
			strLitF(&self.oc.Buf, fn|| {
				self.oc.write("\"runtime: divide by zero")
				mut len := 23 // runtime: divide by zero
				if !env::Production {
					self.oc.write("\\nlocation: ")
					len += 11 // \nlocation:
					len += unsafe { self.oc.locInfo(op) }
				}
				self.oc.write("\"")
				ret len
			})
			self.oc.write("); ")
		}
		self.oc.write("((")
		self.oc.tc.kind(&self.oc.Buf, l.Type)
		self.oc.write(")(")
		self.oc.write(xVar)
		match op.ID {
		| token::QUO
		| token::QUO_ASSIGN:
			self.oc.write(" / ")
		| token::REM
		| token::REM_ASSIGN:
			self.oc.write(" % ")
		}
		self.oc.write(yVar)
		self.oc.write(")); })")
	}

	// Tries to handle binary expressions with dynamic types and reports whether
	// it successful. Should support all dynamic types.
	fn unsafeDynamicBinary(mut &self, mut &buf: *strings::Builder,
		mut l: sema::OperandExpr, mut r: sema::OperandExpr, op: int): bool {
		// Return immediately if binary expression is not contain dynamic type.
		// Handle traits separately, see documentation of obj::IsAny.
		// They handled as <any> type, but not have pure any type implementation,
		// therefore we have to handle them separately.
		// The left operand must be enough to check because it will always be the dynamic type.
		// See "std/jule/sema" developer reference (7).
		if l.Type.Trait() == nil && !obj::IsAny(l.Type) {
			ret false
		}
		// Return immediately if right operand is nil.
		if r.Type.IsNil() {
			ret false
		}
		// If left and right operand is hard dynamic type, then report false.
		mut leftIsStrict := true
		mut dynT := l.Type
		mut e, mut t := obj::IsHardDynamicType(r.Model, r.Type)
		if e == nil && t == nil {
			e, t = obj::IsHardDynamicType(l.Model, l.Type)
			if e == nil && t == nil {
				ret false
			}
			leftIsStrict = false
			dynT = r.Type
		}

		ls := writeAndReadFromBuf(&self.oc.Buf, fn|| {
			if leftIsStrict {
				self.possibleRefExpr(l.Model)
			} else {
				self.possibleRefExpr(r.Model)
			}
		})
		rs := writeAndReadFromBuf(&self.oc.Buf, fn|| self.possibleRefExpr(e))

		buf.WriteByte('(')!
		if op == token::NEQ {
			buf.WriteByte('!')!
		}
		i := self.oc.pushAnyType(t)
		si := conv::Itoa(i)
		buf.WriteStr(anyTypeIdent)!
		buf.WriteStr(si)!
		buf.WriteStr("_compare(")!
		buf.WriteStr(ls)!
		buf.WriteStr(", &")!
		if dynT.Trait() != nil { // Trait <any> type.
			trt := dynT.Trait()
			identCoder.traitDecl(buf, trt)
			buf.WriteStr("_mptr_data")!
			buf.WriteStr(conv::Itoa(obj::FindTraitTypeOffset(trt, t)))!
		} else { // Pure <any> type.
			buf.WriteStr(anyTypeIdent)!
			buf.WriteStr(si)!
		}
		buf.WriteStr(", ")!
		buf.WriteStr(rs)!
		buf.WriteStr("))")!
		ret true
	}

	fn _unsafeBinaryNoDynamic(mut &self, mut &buf: *strings::Builder, l: str,
		r: str, mut lk: &sema::Type, mut rk: &sema::Type, op: int, kind: str) {
		lp := lk.Prim()
		match {
		| lp != nil && (lp.IsCmplx128() || lp.IsCmplx64()):
			match op {
			| token::EQL | token::NEQ:
				if op == token::NEQ {
					buf.WriteByte('!')!
				}
				if lp.IsCmplx128() {
					identCoder.funcIns(buf, meta::Program.Runtime.Cmplx128Eq)
				} else {
					identCoder.funcIns(buf, meta::Program.Runtime.Cmplx64Eq)
				}
			| token::ADD:
				if lp.IsCmplx128() {
					identCoder.funcIns(buf, meta::Program.Runtime.Cmplx128Add)
				} else {
					identCoder.funcIns(buf, meta::Program.Runtime.Cmplx64Add)
				}
			| token::SUB:
				if lp.IsCmplx128() {
					identCoder.funcIns(buf, meta::Program.Runtime.Cmplx128Sub)
				} else {
					identCoder.funcIns(buf, meta::Program.Runtime.Cmplx64Sub)
				}
			| token::MUL:
				if lp.IsCmplx128() {
					identCoder.funcIns(buf, meta::Program.Runtime.Cmplx128Mul)
				} else {
					identCoder.funcIns(buf, meta::Program.Runtime.Cmplx64Mul)
				}
			| token::QUO:
				if lp.IsCmplx128() {
					identCoder.funcIns(buf, meta::Program.Runtime.Cmplx128Div)
				} else {
					identCoder.funcIns(buf, meta::Program.Runtime.Cmplx64Div)
				}
			|:
				panic("unreachable")
			}
			buf.WriteStr("(")!
			buf.WriteStr(l)!
			buf.WriteStr(", ")!
			buf.WriteStr(r)!
			buf.WriteStr(")")!
			ret
		| lk.Array() != nil:
			// If this binary operator comparing array type.
			// The left operand is will be array one always.
			arr := lk.Array()
			mut ins := obj::FindFuncGenericInstance(meta::Program.Runtime.ArrayCmp, arr.Value)
			if op == token::NEQ {
				buf.WriteByte('!')!
			}
			identCoder.funcIns(buf, ins)
			buf.WriteStr("((")!
			buf.WriteStr(l)!
			buf.WriteStr(").begin(), (")!
			buf.WriteStr(r)!
			buf.WriteStr(").begin(), ")!
			buf.WriteStr(conv::Itoa(arr.N))!
			buf.WriteByte(')')!
			ret
		}

		if lk.Struct() != nil {
			mut s := lk.Struct()
			structBinary(buf, s, l, r, op, kind)
			ret
		}

		// guarantee integer wrap around if expressions is not a condition
		match op {
		| token::GTR | token::GEQ
		| token::LSS | token::LEQ
		| token::EQL | token::NEQ:
			// No op.
		|:
			if lp != nil && types::IsInt(lp.Kind) {
				buf.WriteByte('(')!
				self.oc.tc.prim(buf, lp)
				buf.WriteByte(')')!
				buf.WriteByte('(')!
				defer {
					buf.WriteByte(')')!
				}
			}
		}

		buf.WriteByte('(')!
		buf.WriteStr(l)!
		buf.WriteByte(' ')!
		buf.WriteStr(kind)!
		buf.WriteByte(' ')!
		buf.WriteStr(r)!
		buf.WriteByte(')')!
	}

	fn _unsafeBinary(mut &self, mut &buf: *strings::Builder, mut l: sema::OperandExpr,
		mut r: sema::OperandExpr, op: int, kind: str) {
		// Special cases for comparable types.
		if (op == token::EQL || op == token::NEQ) && self.unsafeDynamicBinary(buf, l, r, op) {
			ret
		}
		ls := writeAndReadFromBuf(&self.oc.Buf, fn|| self.possibleRefExpr(l.Model))
		rs := writeAndReadFromBuf(&self.oc.Buf, fn|| self.possibleRefExpr(r.Model))
		self._unsafeBinaryNoDynamic(buf, ls, rs, l.Type, r.Type, op, kind)
	}

	fn unsafeBinary(mut &self, mut m: &sema::BinaryExpr) {
		self._unsafeBinary(&self.oc.Buf, *m.Left, *m.Right, m.Op.ID, m.Op.Kind)
	}

	fn shl(mut &self, mut l: &sema::OperandExpr, mut r: &sema::OperandExpr) {
		const (
			xVar = "__jule_x"
			yVar = "__jule_y"
		)
		self.oc.write("({ ")
		self.oc.tc.kind(&self.oc.Buf, l.Type)
		self.oc.write(" ")
		self.oc.write(xVar)
		self.oc.write(" = ")
		self.possibleRefExpr(l.Model)
		self.oc.write("; ")
		self.oc.tc.kind(&self.oc.Buf, r.Type)
		self.oc.write(" ")
		self.oc.write(yVar)
		self.oc.write(" = ")
		self.possibleRefExpr(r.Model)
		self.oc.write("; ((")
		self.oc.tc.kind(&self.oc.Buf, l.Type)
		self.oc.write(")(")
		self.oc.write(yVar)
		self.oc.write(" >= ")
		self.oc.write(conv::Itoa(types::BitSizeOf(l.Type.Prim().Kind)))
		self.oc.write(" ? 0 : ")
		self.oc.write(xVar)
		self.oc.write(" << ")
		self.oc.write(yVar)
		self.oc.write(")); })")
	}

	fn shr(mut &self, mut l: &sema::OperandExpr, mut r: &sema::OperandExpr) {
		const (
			xVar = "__jule_x"
			yVar = "__jule_y"
		)
		self.oc.write("({ ")
		self.oc.tc.kind(&self.oc.Buf, l.Type)
		self.oc.write(" ")
		self.oc.write(xVar)
		self.oc.write(" = ")
		self.possibleRefExpr(l.Model)
		self.oc.write("; ")
		self.oc.tc.kind(&self.oc.Buf, r.Type)
		self.oc.write(" ")
		self.oc.write(yVar)
		self.oc.write(" = ")
		self.possibleRefExpr(r.Model)
		self.oc.write("; ((")
		self.oc.tc.kind(&self.oc.Buf, l.Type)
		self.oc.write(")(")
		self.oc.write(yVar)
		self.oc.write(" >= ")
		self.oc.write(conv::Itoa(types::BitSizeOf(l.Type.Prim().Kind)))
		self.oc.write(" ? 0 : ")
		self.oc.write(xVar)
		self.oc.write(" >> ")
		self.oc.write(yVar)
		self.oc.write(")); })")
	}

	fn binary(mut &self, mut m: &sema::BinaryExpr) {
		match m.Op.ID {
		| token::QUO:
			// DivByZero analysis no necessary for complex types.
			lp := m.Left.Type.Prim()
			if lp != nil && types::IsCmplx(lp.Kind) {
				break
			}
			fall
		| token::REM:
			if env::Safety {
				self.divByZeroBinary(m.Op, m.Left, m.Right)
				ret
			}
		| token::SHL:
			self.shl(m.Left, m.Right)
			ret
		| token::SHR:
			self.shr(m.Left, m.Right)
			ret
		}
		self.unsafeBinary(m)
	}

	fn var(mut &self, mut m: &sema::Var) {
		for _, prefix in self.varPrefixes {
			if prefix(m) {
				ret
			}
		}
		if m.Bind {
			d := obj::FindDirective(m.Directives, directive::Namespace)
			if d != nil {
				self.oc.writeBytes(concatAllParts(d.Args...))
				self.oc.write("::")
			}
		}
		identCoder.var(&self.oc.Buf, m)
	}

	fn structureIns(mut &self, mut m: &sema::StructIns) {
		self.oc.tc.structureIns(&self.oc.Buf, m)
	}

	fn unary(mut &self, mut m: &sema::UnaryExpr) {
		lp := m.Expr.Type.Prim()

		if lp != nil && types::IsCmplx(lp.Kind) {
			if m.Op.ID == token::SUB {
				if lp.IsCmplx128() {
					identCoder.funcIns(&self.oc.Buf, meta::Program.Runtime.Cmplx128Neg)
				} else {
					identCoder.funcIns(&self.oc.Buf, meta::Program.Runtime.Cmplx64Neg)
				}
				self.oc.write("(")
				defer {
					self.oc.write(")")
				}
			}
			self.possibleRefExpr(m.Expr.Model)
			ret
		}

		// guarantee integer wrap around
		match m.Op.ID {
		| token::ADD | token::SUB | token::XOR:
			if lp != nil && types::IsInt(lp.Kind) {
				self.oc.write("(")
				self.oc.tc.prim(&self.oc.Buf, lp)
				self.oc.write(")(")
				defer {
					self.oc.write(")")
				}
			}
		}

		match m.Op.ID {
		| token::XOR:
			self.oc.write("(~(")
			self.possibleRefExpr(m.Expr.Model)
			self.oc.write("))")
			ret
		| token::MUL:
			nilptr := self.oc.mode&_OBJC_DISABLE_NILPTR == _OBJC_DISABLE_NILPTR
			mut v, _ := m.Expr.Model.(&sema::Var)
			if v != nil && v.Reference {
				self.oc.write("(*")
				if nilptr {
					self.possibleRefExpr(v)
				} else {
					self.checkNilRef(v)
				}
				self.oc.write(")")
				ret
			}
			if env::Production || m.Expr.Type.Sptr() == nil {
				break
			}
			self.possibleRefExpr(m.Expr.Model)
			if !nilptr {
				self.oc.write(".must_ok(\"")
				self.oc.locInfo(m.Op)
				self.oc.write("\")")
			}
			self.oc.write(".get()")
			ret
		}
		self.oc.write("(")
		self.oc.write(m.Op.Kind)
		self.oc.write("(")
		self.possibleRefExpr(m.Expr.Model)
		self.oc.write("))")
	}

	fn structureLit(mut &self, mut m: &sema::StructLitExpr) {
		binded := obj::IsBindStruct(m.Strct)
		if binded {
			self.oc.write("(")
		}
		self.structureIns(m.Strct)
		if binded {
			self.oc.write(")")
		}
		self.oc.write("{")
		// Fields are should be in order.
		// In other words, GCC will produce error(s).
		mut inited := false
	fields:
		for (_, mut f) in m.Strct.Fields {
			for (_, mut arg) in m.Args {
				// Field exist, initialize it with literal expression.
				if arg.Field == f {
					if inited {
						self.oc.write(", ")
					}
					self.oc.write(".")
					identCoder.field(&self.oc.Buf, f.Decl)
					self.oc.write("=")
					self.possibleRefExpr(arg.Expr.Model)
					inited = true
					continue fields
				}
			}
			if binded {
				// Do not initialize field of binded struct.
				inited = false
				continue
			}
			if inited {
				self.oc.write(", ")
			}
			// Field is not exist in literal arguments.
			// Initialize it by default.
			inited = self.handleFieldByDefault(f)
		}
		self.oc.write("}")
	}

	fn allocStructure(mut &self, mut m: &sema::AllocStructLitExpr) {
		self.oc.write("__jule_new_ptr<")
		self.structureIns(m.Lit.Strct)
		self.oc.write(">(")
		self.structureLit(m.Lit)
		self.oc.write(")")
	}

	fn checkNilRef(mut &self, mut v: &sema::Var) {
		self.oc.write("((")
		self.oc.tc.kind(&self.oc.Buf, v.TypeSym.Type)
		self.oc.write(")(")
		identCoder.funcIns(&self.oc.Buf, meta::Program.Runtime.CheckNilRef)
		self.oc.write("((void*)(")
		self.model(v)
		self.oc.write("))))")
	}

	fn possibleRefExpr(mut &self, mut expr: compExpr) {
		// This function equals to self.model.
		// But historically, it used to dereference reference variables implicitly,
		// if expression model is a reference variable.
		// This function will remain in the source code for now.
		self.model(expr)
	}

	fn castTraitFromTrait(mut &self, mut m: &sema::CastingExpr, mut t1: &sema::Trait, mut t2: &sema::Trait) {
		self.possibleRefExpr(m.Expr.Model)
		self.oc.write(".map(")
		self.oc.pushAndWriteMaskMapper(t1, t2)
		self.oc.write(")")
	}

	fn typeAssertion(mut &self, mut m: &sema::TypeAssertionExpr) {
		if obj::IsAny(m.Expr.Type) {
			self.possibleRefExpr(m.Expr.Model)
			self.oc.write(".")
			// We handling map and channel types as smart pointer,
			// because this kind types implemented as smart pointers
			// at machine code level.
			match {
			| m.Type.Sptr() != nil:
				self.oc.write("cast_ptr<")
				self.oc.tc.kind(&self.oc.Buf, m.Type.Sptr().Value)
			| m.Type.Map() != nil:
				self.oc.write("cast_ptr<")
				mp := m.Type.Map()
				mut mps := obj::FindStructGenericInstance(meta::Program.Runtime.Map, mp.Key, mp.Value)
				self.oc.tc.structureIns(&self.oc.Buf, mps)
			| m.Type.Chan() != nil:
				self.oc.write("cast_ptr<")
				ch := m.Type.Chan()
				mut chs := obj::FindStructGenericInstance(meta::Program.Runtime.Pchan, ch.Value)
				self.oc.tc.structureIns(&self.oc.Buf, chs)
			|:
				self.oc.write("cast<")
				self.oc.tc.kind(&self.oc.Buf, m.Type)
			}
			self.oc.write(">(")
			if !env::Production {
				self.oc.write("\"")
				self.oc.locInfo(m.Token)
				self.oc.write("\", ")
			}
			self.oc.write("&" + anyTypeIdent)
			self.oc.write(conv::Itoa(self.oc.pushAnyType(m.Type)))
			self.oc.write(")")
			ret
		}
		if m.Expr.Type.Trait() != nil {
			self.possibleRefExpr(m.Expr.Model)
			self.oc.write(".")
			// We handling map and channel types as smart pointer,
			// because this kind types implemented as smart pointers
			// at machine code level.
			match {
			| m.Type.Sptr() != nil:
				self.oc.write("cast_ptr<")
				self.oc.tc.kind(&self.oc.Buf, m.Type.Sptr().Value)
			| m.Type.Map() != nil:
				self.oc.write("cast_ptr<")
				mp := m.Type.Map()
				mut mps := obj::FindStructGenericInstance(meta::Program.Runtime.Map, mp.Key, mp.Value)
				self.oc.tc.structureIns(&self.oc.Buf, mps)
			| m.Type.Chan() != nil:
				self.oc.write("cast_ptr<")
				ch := m.Type.Chan()
				mut chs := obj::FindStructGenericInstance(meta::Program.Runtime.Pchan, ch.Value)
				self.oc.tc.structureIns(&self.oc.Buf, chs)
			|:
				self.oc.write("cast<")
				self.oc.tc.kind(&self.oc.Buf, m.Type)
			}
			self.oc.write(">(")
			if !env::Production {
				self.oc.write("\"")
				self.oc.locInfo(m.Token)
				self.oc.write("\", ")
			}
			self.oc.write("(__jule_TypeMeta*)&")
			identCoder.traitDecl(&self.oc.Buf, m.Expr.Type.Trait())
			self.oc.write("_mptr_data")
			self.oc.write(conv::Itoa(obj::FindTraitTypeOffset(m.Expr.Type.Trait(), m.Type)))
			self.oc.write(")")
			ret
		}
		panic("unreachable")
	}

	// Casting expression.
	//
	// Special cases:
	//	The any type castings should be came first than others.
	//	Otherwise, code generation might be wrong because <any> the
	//	uses special casting algorithms.
	fn casting(mut &self, mut m: &sema::CastingExpr) {
		// Return the expression with no casting if actual types are equal.
		if m.Type.ActualEqual(m.Expr.Type) {
			self.possibleRefExpr(m.Expr.Model)
			ret
		}
		if obj::IsAny(m.Type) {
			if m.Expr.Type.IsNil() {
				self.oc.write(typeAny + "()")
				ret
			}
			i := self.oc.pushAnyType(m.Expr.Type)
			self.oc.write(typeAny + "(")
			match type m.Expr.Model {
			| &constant::Const:
				prim := m.Expr.Type.Prim()
				if prim != nil && types::IsInt(prim.Kind) {
					self.oc.write("static_cast<")
					self.oc.tc.prim(&self.oc.Buf, prim)
					self.oc.write(">(")
					self.possibleRefExpr(m.Expr.Model)
					self.oc.write(")")
					break
				}
				fall
			|:
				self.possibleRefExpr(m.Expr.Model)
			}
			self.oc.write(", &" + anyTypeIdent)
			self.oc.write(conv::Itoa(i))
			self.oc.write(")")
			ret
		}
		if m.Expr.Type.Trait() != nil {
			if m.Type.Trait() != nil {
				self.castTraitFromTrait(m, m.Type.Trait(), m.Expr.Type.Trait())
				ret
			}
			self.possibleRefExpr(m.Expr.Model)
			self.oc.write(".")
			// We handling map and channel types as smart pointer,
			// because this kind types implemented as smart pointers
			// at machine code level.
			match {
			| m.Type.Sptr() != nil:
				self.oc.write("cast_ptr<")
				self.oc.tc.kind(&self.oc.Buf, m.Type.Sptr().Value)
			| m.Type.Map() != nil:
				self.oc.write("cast_ptr<")
				mp := m.Type.Map()
				mut mps := obj::FindStructGenericInstance(meta::Program.Runtime.Map, mp.Key, mp.Value)
				self.oc.tc.structureIns(&self.oc.Buf, mps)
			| m.Type.Chan() != nil:
				self.oc.write("cast_ptr<")
				ch := m.Type.Chan()
				mut chs := obj::FindStructGenericInstance(meta::Program.Runtime.Pchan, ch.Value)
				self.oc.tc.structureIns(&self.oc.Buf, chs)
			|:
				self.oc.write("cast<")
				self.oc.tc.kind(&self.oc.Buf, m.Type)
			}
			self.oc.write(">(")
			if !env::Production {
				self.oc.write("\"")
				self.oc.locInfo(m.Token)
				self.oc.write("\", ")
			}
			self.oc.write("(__jule_TypeMeta*)&")
			identCoder.traitDecl(&self.oc.Buf, m.Expr.Type.Trait())
			self.oc.write("_mptr_data")
			self.oc.write(conv::Itoa(obj::FindTraitTypeOffset(m.Expr.Type.Trait(), m.Type)))
			self.oc.write(")")
			ret
		}
		if m.Expr.Type.Ptr() != nil || m.Type.Ptr() != nil {
			self.oc.write("((")
			self.oc.tc.kind(&self.oc.Buf, m.Type)
			self.oc.write(")(")
			self.possibleRefExpr(m.Expr.Model)
			self.oc.write("))")
			ret
		}
		if m.Type.Trait() != nil {
			if m.Expr.Type.IsNil() {
				self.oc.write(typeTrait + "()")
				ret
			}
			self.oc.tc.kind(&self.oc.Buf, m.Type)
			self.oc.write("(")
			self.possibleRefExpr(m.Expr.Model)
			self.oc.write(", (__jule_TypeMeta*)&")
			identCoder.traitDecl(&self.oc.Buf, m.Type.Trait())
			self.oc.write("_mptr_data")
			self.oc.write(conv::Itoa(obj::FindTraitTypeOffset(m.Type.Trait(), m.Expr.Type)))
			self.oc.write(")")
			ret
		}
		mut prim := m.Type.Prim()
		if prim != nil {
			match {
			| prim.IsCmplx64():
				identCoder.funcIns(&self.oc.Buf, meta::Program.Runtime.Cmplx128cmplx64)
				self.oc.write("(")
				self.possibleRefExpr(m.Expr.Model)
				self.oc.write(")")
				ret
			| prim.IsCmplx128():
				identCoder.funcIns(&self.oc.Buf, meta::Program.Runtime.Cmplx64cmplx128)
				self.oc.write("(")
				self.possibleRefExpr(m.Expr.Model)
				self.oc.write(")")
				ret
			| prim.IsStr():
				mut eprim := m.Expr.Type.Prim()
				if eprim != nil && prim != nil {
					if eprim.IsU8() {
						self.oc.write("__jule_strFromByte(")
					} else {
						self.oc.write("__jule_strFromRune(")
					}
					self.possibleRefExpr(m.Expr.Model)
					self.oc.write(")")
					ret
				}
				mut slc := m.Expr.Type.Slice()
				if slc != nil {
					eprim = slc.Value.Prim()
					// []rune or []byte
					if eprim.IsI32() {
						self.oc.write("__jule_runesToStr(")
					} else {
						self.oc.write("__jule_bytesToStr(")
					}
					self.possibleRefExpr(m.Expr.Model)
					self.oc.write(")")
					ret
				}
			}
		}
		prim = m.Expr.Type.Prim()
		if prim != nil && prim.IsStr() {
			mut slc := m.Type.Slice()
			if slc != nil {
				prim = slc.Value.Prim()
				// []rune or []byte
				if prim.IsI32() {
					self.oc.write("__jule_strToRunes(")
				} else {
					self.oc.write("__jule_strToBytes(")
				}
				self.possibleRefExpr(m.Expr.Model)
				self.oc.write(")")
				ret
			}
		}
		self.oc.write("static_cast<")
		self.oc.tc.kind(&self.oc.Buf, m.Type)
		self.oc.write(">(")
		self.possibleRefExpr(m.Expr.Model)
		self.oc.write(")")
	}

	fn args(mut &self, mut m: &sema::FuncCallExpr) {
		mut j := 0
		if m.Func.Owner != nil && !m.Func.Decl.Static ||
			len(m.Func.Params) > 0 && m.Func.Params[0].Decl.IsSelf() {
			j++ // Skip receiver parameter.
		}
		for (i, mut arg) in m.Args {
			self.possibleRefExpr(arg)
			if len(m.Args)-i > 1 {
				self.oc.write(", ")
			}
			j++
		}
	}

	fn modelForCall(mut &self, mut expr: compExpr) {
		match type expr {
		| &sema::FuncIns:
			self.funcIns(expr.(&sema::FuncIns))
			ret
		| &sema::StructSubIdentExpr:
			mut ssie := expr.(&sema::StructSubIdentExpr)
			if ssie.Method != nil {
				self.funcIns(ssie.Method)
				ret
			}
		|:
			// no-op
		}
		self.possibleRefExpr(expr)
	}

	fn pushCallInf(mut &self, m: &sema::FuncCallExpr) {
		if env::Production || !m.Func.Anon {
			self.oc.write("(")
			ret
		}
		if m.Func.Anon {
			ssie, _ := m.Expr.(&sema::StructSubIdentExpr)
			if ssie != nil && obj::IsBindStruct(ssie.Field.Owner) {
				self.oc.write("(")
				ret
			}
			self.oc.write(".call")
		}
		self.oc.write("(\"")
		self.oc.locInfo(m.Token)
		self.oc.write("\"")
		if len(m.Args) != 0 {
			self.oc.write(", ")
		}
	}

	fn isWrapped(mut &self, mut m: &sema::FuncCallExpr): bool {
		if !m.Func.IsBuiltin() && len(m.Func.Decl.Params) > 0 && m.Func.Decl.Params[0].IsSelf() {
			mut ssie, _ := m.Expr.(&sema::StructSubIdentExpr)
			if ssie != nil {
				if ssie.Expr.Lvalue {
					ret false
				}
				match {
				| m.Func.Decl.Params[0].IsSmartptr()
				| ssie.Expr.Type.Sptr() != nil:
					ret false
				| ssie.Expr.Type.SoftStruct() != nil:
					// Check whether expression type is struct to caught strict type alias structs.
					self.oc.write("({ ")
					self.oc.tc.kind(&self.oc.Buf, ssie.Expr.Type)
					self.oc.write(" _wrap_copy = ")
					self.model(ssie.Expr.Model)
					self.oc.write("; ")
					ret true
				}
			}
		}
		ret false
	}

	fn writeReceiver(mut &self, mut m: compExpr): (safeDeref: bool) {
		match type m {
		| &sema::UnaryExpr:
			self.possibleRefExpr(m.(&sema::UnaryExpr).Expr.Model)
			ret true
		| &opt::UnsafeDerefExpr:
			self.possibleRefExpr(m.(&opt::UnsafeDerefExpr).Base.Expr.Model)
			ret false
		|:
			self.possibleRefExpr(m)
			ret false
		}
	}

	fn pureFuncCall(mut &self, mut m: &sema::FuncCallExpr) {
		wrapped := self.isWrapped(m)
		self.modelForCall(m.Expr)
		if !m.Func.IsBuiltin() {
			if m.Func.Decl.Bind && len(m.Func.Generics) > 0 {
				if !obj::HasDirective(m.Func.Decl.Directives, directive::Cdef) {
					self.oc.write("<")
					for (i, mut g) in m.Func.Generics {
						self.oc.tc.kind(&self.oc.Buf, g.Type)
						if len(m.Func.Generics)-i > 1 {
							self.oc.write(", ")
						}
					}
					self.oc.write(">")
				}
			}
		}
		self.pushCallInf(m)
		if m.Func.AsAnon && !m.Func.Anon && m.Expr == m.Func {
			// Function used as anonymous.
			// So pass nullptr to ctx parameter.
			// Do not pass nullptr if function is anonymous,
			// because it stores ctx data internally and it will pass.
			self.oc.write("nullptr")
			if len(m.Args) > 0 {
				self.oc.write(", ")
			}
		}
		if !m.Func.IsBuiltin() && len(m.Func.Decl.Params) > 0 && m.Func.Decl.Params[0].IsSelf() {
			match type m.Expr {
			| &sema::StructSubIdentExpr:
				mut ssie := m.Expr.(&sema::StructSubIdentExpr)
				match {
				| m.Func.Decl.Params[0].IsSmartptr():
					// Ignore dereferencing, use data directly to call method.
					_ = self.writeReceiver(ssie.Expr.Model)
				|:
					match type ssie.Expr.Type.Kind {
					| &sema::Sptr:
						// Ignore dereferencing, use data directly to call [ptr] method.
						safe := self.writeReceiver(ssie.Expr.Model)
						if safe {
							self.oc.write(".must_ok(\"")
							self.oc.locInfo(m.Token)
							self.oc.write("\").alloc")
						}
					|:
						match type ssie.Expr.Type.Kind {
						| &sema::StructIns:
							match type ssie.Expr.Model {
							| &sema::Var:
								v := ssie.Expr.Model.(&sema::Var)
								if v.Reference {
									break
								}
								fall
							|:
								// Add address taking operation for non-pointers.
								self.oc.write("&")
							}
						}
						if wrapped {
							self.oc.write("_wrap_copy")
						} else if ssie.Expr.Type.Ptr() == nil {
							self.model(ssie.Expr.Model)
						} else {
							// Ignore dereferencing, use data directly to call method.
							self.writeReceiver(ssie.Expr.Model)
						}
					}
				}
				if len(m.Args) > 0 {
					self.oc.write(", ")
				}
			| &sema::TraitSubIdentExpr:
				self.possibleRefExpr(m.Expr.(&sema::TraitSubIdentExpr).Expr)
				self.oc.write(".data")
				if len(m.Args) > 0 {
					self.oc.write(", ")
				}
			|:
				// no-op
			}
		}
		self.args(m)
		self.oc.write(")")

		if wrapped {
			self.oc.write("; })")
		}
	}

	fn coFuncCall(mut &self, mut m: &sema::FuncCallExpr) {
		self.oc.write("{\n")
		self.oc.addIndent()
		self.oc.indent()

		const noWrap = ""
		const argData = "__jule_argdata"
		mut i := noWrap
		if len(m.Func.Params) > 0 || m.Func.AsAnon {
			i = conv::Itoa(self.oc.pushCoSpawn(m.Func))
			t := coSpawnPrefix + coSpawnArgDataSuffix + i
			self.oc.write(t)
			self.oc.write(" *")
			self.oc.write(argData)
			self.oc.write(" = new (std::nothrow) ")
			self.oc.write(t)
			self.oc.write("; if (!")
			self.oc.write(argData)
			self.oc.write(`) __jule_panic((`)
			self.oc.write(typeU8)
			self.oc.write(`*)"memory allocation failed for concurrent call", 44);` + "\n")
			self.oc.indent()

			// setup function data
			self.oc.write(argData)
			self.oc.write("->")
			self.oc.write(coSpawnArgDataFunc)
			self.oc.write(" = ")
			self.modelForCall(m.Expr)
			self.oc.write(";\n")

			// setup argument data
			for j in m.Func.Params {
				self.oc.indent()
				self.oc.write(argData)
				self.oc.write("->")
				self.oc.write(coSpawnArgDataParam)
				self.oc.write(conv::Itoa(j))
				self.oc.write(" = ")
				self.possibleRefExpr(m.Args[j])
				self.oc.write(";\n")
			}
			self.oc.indent()
		}

		// spawn thread
		if i != noWrap {
			self.oc.write("if (!")
		}
		self.oc.write("__jule_coSpawn((void*)")
		if i == noWrap {
			identCoder.funcIns(&self.oc.Buf, m.Func)
		} else {
			self.oc.write(coSpawnPrefix + coSpawnMethodSuffix + i)
		}
		self.oc.write(", ")
		if i == noWrap {
			self.oc.write("NULL")
		} else {
			self.oc.write("(void*)")
			self.oc.write(argData)
		}
		self.oc.write(")")
		if i == noWrap {
			self.oc.write(";")
		} else {
			self.oc.write(") { delete ")
			self.oc.write(argData)
			self.oc.write("; __jule_panic((")
			self.oc.write(typeU8)
			self.oc.write(`*)"thread creation failed for concurrent call", 42); }`)
		}
		self.oc.write("\n")
		self.oc.doneIndent()
		self.oc.indent()
		self.oc.write("}")
	}

	fn writeUseExpr(mut &self, mut f: &sema::FuncIns, mut val: &sema::Value, mut dest: useExprMemory) {
		if dest.Model != nil {
			mut fc, ok := val.Model.(&sema::FuncCallExpr)
			if ok && fc.Func.Decl != nil && fc.Func.Decl.Exceptional {
				self.handleExceptionalCallWithData(fc, dest)
				ret
			}
			// If value is not tuple, handle directly with the write method.
			// This is required to handle += like assignment expressions.
			if val.Type.Tuple() == nil {
				dest.write(self, val.Model, val.Type)
				self.oc.write(";")
				ret
			}
			dest.write(self, nil, nil)
			self.oc.write(" = ")
		}
		if val.Type.Tuple() == nil {
			self.possibleRefExpr(val.Model)
			self.oc.write(";")
			ret
		}
		mut tup := val.Model.(&sema::TupleExpr)
		self.oc.tc.rc.tuple(&self.oc.Buf, f.Result.Tuple())
		self.oc.write("{")
		for (i, mut tupval) in tup.Values {
			self.oc.write("." + resultArgName)
			self.oc.write(conv::Itoa(i))
			self.oc.write("=")
			self.possibleRefExpr(tupval.Model)
			if len(tup.Values)-i > 1 {
				self.oc.write(", ")
			}
		}
		self.oc.write("};")
	}

	fn handleExceptionalCallWithData(mut &self, mut m: &sema::FuncCallExpr, mut dest: useExprMemory) {
		// Use unique identifier to handle each call with explicit variable.
		// Otherwise back-end compiler may use wrong variable, which is may lead even segfault.
		// To generate unique identifier, use the memory address of function call.
		// But the error variable is not have associated function data, but scope.
		// Therefore, if exceptional handler scope exist, use the scope address.
		mut exceptName := "__jule_except_"
		if m.Except != nil {
			exceptName += conv::FormatUint(u64(uintptr(m.Except)), 16)
		} else {
			exceptName += conv::FormatUint(u64(uintptr(m)), 16)
		}

		let mut destData: sema::Expr = &sema::Var{
			Bind: true, // to use identifier directly
			Name: exceptName + ".result",
		}

		self.oc.write("{\n")
		// Generate code for exceptional.

		self.oc.addIndent()
		self.oc.indent()
		self.oc.tc.funcInsResult(&self.oc.Buf, m.Func)
		self.oc.write(" ")
		self.oc.write(exceptName)
		self.oc.write(" = ")
		self.pureFuncCall(m)
		self.oc.write(";\n")
		self.oc.indent()
		if m.Except != nil {
			if m.Func.Result == nil || dest.Model == nil {
				self.oc.write("if (!")
				self.oc.write(exceptName)
				self.oc.write(".ok()) ")
				self.oc.sc.scope(m.Except)
				self.oc.write("\n")
			} else {
				self.oc.write("if (")
				self.oc.write(exceptName)
				self.oc.write(".ok()) { ")
				dest.write(self, destData, m.Func.Result)
				self.oc.write("; }\n")
				self.oc.indent()
				self.oc.write("else ")
				mut stmt := m.Except.Stmts[len(m.Except.Stmts)-1]
				self.oc.write("{\n")
				self.oc.addIndent()
				match type stmt {
				| &sema::Use:
					m.Except.Stmts = m.Except.Stmts[:len(m.Except.Stmts)-1]
					self.oc.sc.scopeStmts(m.Except)
					self.oc.write("\n")
					self.oc.indent()
					mut v := stmt.(&sema::Use).Value
					self.writeUseExpr(m.Func, v, dest)
				|:
					self.oc.sc.scopeStmts(m.Except)
				}
				self.oc.write("\n")
				self.oc.doneIndent()
				self.oc.indent()
				self.oc.write("}\n")
			}
			self.oc.doneIndent()
		} else {
			self.oc.write("if (!")
			self.oc.write(exceptName)
			self.oc.write(".ok()) __jule_panicStr(")
			strLit(&self.oc.Buf, "unhandled exceptional: ", "23")
			self.oc.write(" + ")
			self.oc.write(exceptName)
			self.oc.write(".error.type->to_str(")
			self.oc.write(exceptName)
			self.oc.write(".error.data) + ")
			strLitF(&self.oc.Buf, fn|| {
				self.oc.write("\"\\nlocation: ")
				mut len := 11 // \nlocation:
				len += self.oc.locInfo(m.Token)
				self.oc.write("\"")
				ret len
			})
			self.oc.write(");\n")
			if dest.Model != nil {
				self.oc.indent()
				dest.write(self, destData, m.Func.Result)
				self.oc.write(";\n")
			}
			self.oc.doneIndent()
		}

		self.oc.indent()
		self.oc.write("}")
	}

	fn funcCall(mut &self, mut m: &sema::FuncCallExpr, ignoreExceptional: bool) {
		if m.Func == meta::Program.Runtime.FastmemcopyImpl {
			self.oc.write("memmove(")
			self.args(m)
			self.oc.write(")")
			ret
		}

		if m.IsCo {
			// Do not check for exceptionals,
			// exceptional functions cannot be called with co.
			self.coFuncCall(m)
			ret
		}
		if m.Func.IsBuiltin() ||
			!m.Func.Decl.Exceptional ||
			m.Except != nil && len(m.Except.Stmts) == 0 {
			self.pureFuncCall(m)
			ret
		}

		// Ignore exceptional mode is on.
		// Just call function purely and use return value of exceptional if exist.
		if ignoreExceptional {
			self.pureFuncCall(m)
			if m.Func.Result != nil {
				self.oc.write(".result")
			}
			ret
		}

		// Code for exceptional.
		// Result must be not assigned in this case.
		// For result needed cases, use the handleExceptionalCallWithData method instead.
		self.handleExceptionalCallWithData(m, useExprMemory{})
	}

	fn slice(mut &self, mut m: &sema::SliceExpr) {
		// Using initializer list for slice literal is more efficient than manually initializing.
		// C++ compiler compiles more slow when we use manual initialization.
		// On runtime, there is no notable performance impact using of initializer lists.
		self.oc.tc.asSlice(&self.oc.Buf, m.ElemType)
		self.oc.write("::make({")
		for i in m.Elems {
			if i > 0 {
				self.oc.write(", ")
			}
			self.possibleRefExpr(m.Elems[i].Model)
		}
		self.oc.write("})")
	}

	fn indexingWithSafety(mut &self, mut m: &sema::IndexingExpr, safe: bool) {
		match {
		| m.Expr.Type.Map() != nil:
			mut _map := m.Expr.Type.Map()
			mut ins := obj::FindStructGenericInstance(meta::Program.Runtime.Map, _map.Key, _map.Value)
			const Static = false
			mut f := ins.FindMethod("get", Static).Instances[0]
			identCoder.funcIns(&self.oc.Buf, f)
			self.oc.write("(")
			self.possibleRefExpr(m.Expr.Model)
			self.oc.write(".alloc, ")
			self.possibleRefExpr(m.Index.Model)
			self.oc.write(")")
		| env::Production && safe
		| m.Expr.Type.Ptr() != nil
		| obj::IsExprComesFromBind(m.Expr):
			self.possibleRefExpr(m.Expr.Model)
			self.oc.write("[")
			self.possibleRefExpr(m.Index.Model)
			self.oc.write("]")
		|:
			self.possibleRefExpr(m.Expr.Model)
			if safe {
				self.oc.write(".safe_at(\"")
				self.oc.locInfo(m.Token)
				self.oc.write("\", ")
			} else {
				self.oc.write(".at(")
			}
			self.possibleRefExpr(m.Index.Model)
			self.oc.write(")")
		}
	}

	fn indexing(mut &self, mut m: &sema::IndexingExpr) {
		match type m.Expr.Model {
		| &constant::Const:
			// Constant string indexed. Use fast way, avoid making literal.
			self.oc.write(typeStr + "::at(")
			if !env::Production {
				self.oc.write("\"")
				self.oc.locInfo(m.Token)
				self.oc.write("\", ")
			}
			self.oc.write("reinterpret_cast<const " + typeU8 + "*>(")
			s := m.Expr.Model.(&constant::Const).ReadStr()
			cstrLit(&self.oc.Buf, s)
			self.oc.write("), ")
			self.oc.write(conv::Itoa(len(s)))
			self.oc.write(", ")
			self.possibleRefExpr(m.Index.Model)
			self.oc.write(")")
		|:
			// Index access with safety measures, by configuration.
			self.indexingWithSafety(m, self.oc.mode&_OBJC_DISABLE_BOUNDARY != _OBJC_DISABLE_BOUNDARY)
		}
	}

	fn unsafeIndexing(mut &self, mut m: &opt::UnsafeIndexingExpr) {
		self.indexingWithSafety(m.Node, false)
	}

	fn anonFunc(mut &self, mut m: &sema::AnonFuncExpr) {
		closure := obj::IsClosure(m)
		ident := self.oc.pushAnonFunc(m)
		self.oc.write("__jule_new_closure<")
		self.oc.tc.anonFunc(&self.oc.Buf, m.Func)
		self.oc.write(">((void*)")
		self.oc.write(ident)
		if closure {
			self.oc.write(", __jule_Ptr<")
			self.oc.write(ident)
			self.oc.write(anonFuncCtxSuffix)
			self.oc.write(">::make(")
			self.oc.write(ident)
			self.oc.write(anonFuncCtxSuffix + "{")
			for (i, mut v) in m.Captured {
				self.oc.write(".")
				identCoder.anonFuncVar(&self.oc.Buf, v)
				self.oc.write("=")
				self.var(v)
				if len(m.Captured)-i > 1 {
					self.oc.write(",")
				}
			}
			self.oc.write("}).as<" + typeUintptr + ">(), ")
			self.oc.write(ident)
			self.oc.write(anonFuncCtxHandlerSuffix + ")")
		} else {
			self.oc.write(", nullptr, nullptr)")
		}
	}

	fn mapExpr(mut &self, mut m: &sema::MapExpr) {
		mut ins := obj::FindStructGenericInstance(meta::Program.Runtime.Map, m.Kind.Key, m.Kind.Value)
		const Static = true
		mut maker := ins.FindMethod("make", Static).Instances[0]
		if len(m.Entries) == 0 {
			identCoder.funcIns(&self.oc.Buf, maker)
			self.oc.write("(0)")
			ret
		}

		mut f := ins.FindMethod("set", !Static).Instances[0]

		const mapVar = "__jule_map"
		self.oc.write("({ ")
		self.oc.tc.mapType(&self.oc.Buf, m.Kind)
		self.oc.write(" ")
		self.oc.write(mapVar)
		self.oc.write(" = ")
		identCoder.funcIns(&self.oc.Buf, maker)
		self.oc.write("(")
		self.oc.write(conv::Itoa(len(m.Entries)))
		self.oc.write("); ")
		for (_, mut pair) in m.Entries {
			self.oc.write("(*")
			identCoder.funcIns(&self.oc.Buf, f)
			self.oc.write("(")
			self.oc.write(mapVar)
			self.oc.write(", ")
			self.possibleRefExpr(pair.Key)
			self.oc.write(")) = ")
			self.possibleRefExpr(pair.Value)
			self.oc.write("; ")
		}
		self.oc.write(mapVar)
		self.oc.write("; })")
	}

	fn slicing(mut &self, mut m: &sema::SlicingExpr) {
		self.possibleRefExpr(m.Expr.Model)
		self.oc.write(".safe_slice(\"")
		self.oc.locInfo(m.Token)
		self.oc.write("\", ")
		self.possibleRefExpr(m.Left)
		if m.Right != nil {
			self.oc.write(", ")
			self.possibleRefExpr(m.Right)
		}
		if m.Cap != nil {
			self.oc.write(", ")
			self.possibleRefExpr(m.Cap)
		}
		self.oc.write(")")
	}

	fn traitSub(mut &self, mut m: &sema::TraitSubIdentExpr) {
		self.oc.write("((")
		identCoder.traitDecl(&self.oc.Buf, m.Trt)
		self.oc.write("MptrData")
		self.oc.write("*)")
		self.possibleRefExpr(m.Expr)
		self.oc.write(".safe_type(")
		if !env::Production {
			self.oc.write("\"")
			self.oc.locInfo(m.Token)
			self.oc.write("\"")
		}
		self.oc.write("))->")
		identCoder.func(&self.oc.Buf, m.Method)
	}

	fn structureSub(mut &self, mut m: &sema::StructSubIdentExpr) {
		self.possibleRefExpr(m.Expr.Model)
		if m.Field == nil {
			ret
		}
		self.oc.write(".")
		identCoder.field(&self.oc.Buf, m.Field.Decl)
	}

	fn array(mut &self, mut m: &sema::ArrayExpr) {
		// Plain initialization if array is zero-length or
		// no specific expression and not able to init elements.
		if m.Kind.N == 0 || len(m.Elems) == 0 && !ableToInit(m.Kind.Value) {
			self.oc.tc.array(&self.oc.Buf, m.Kind)
			self.oc.write("()")
			ret
		}

		// Filled.
		if len(m.Elems) == 2 && m.Elems[1] == nil {
			self.oc.tc.array(&self.oc.Buf, m.Kind)
			self.oc.write("(")
			self.possibleRefExpr(m.Elems[0].Model)
			self.oc.write(")")
			ret
		}

		self.oc.write("({ auto " + collectionIdent + " = ")
		self.oc.tc.array(&self.oc.Buf, m.Kind)
		self.oc.write("(); auto ")
		self.oc.write(collectionItIdent)
		self.oc.write(" = ")
		self.oc.write(collectionIdent)
		self.oc.write(".begin(); ")
		if len(m.Elems) != m.Kind.N {
			// Define end pointer for remainders.
			self.oc.write("const auto ")
			self.oc.write(collectionIdent)
			self.oc.write("_end = ")
			self.oc.write(collectionIdent)
			self.oc.write(".hard_end(); ")
		}
		for i in m.Elems {
			self.oc.write("(*")
			self.oc.write(collectionItIdent)
			self.oc.write("++) = ")
			self.possibleRefExpr(m.Elems[i].Model)
			self.oc.write("; ")
		}
		if len(m.Elems) != m.Kind.N && ableToInit(m.Kind.Value) {
			self.fillCollectionByDefault(m.Kind.Value)
		}
		self.oc.write(collectionIdent)
		self.oc.write("; })")
		ret
	}

	// Writes complete expression model of function instance.
	// Useful for strict type safety.
	fn funcInsCommon(mut &self, mut m: &sema::FuncIns) {
		self.oc.tc.func(&self.oc.Buf, m)
		self.oc.write("(")
		self.funcIns(m)
		self.oc.write(")")
	}

	fn funcIns(mut &self, mut m: &sema::FuncIns) {
		if m.Decl != nil && m.Decl.Bind {
			d := obj::FindDirective(m.Decl.Directives, directive::Namespace)
			if d != nil {
				self.oc.writeBytes(concatAllParts(d.Args...))
				self.oc.write("::")
			}
		}
		identCoder.funcIns(&self.oc.Buf, m)
	}

	fn tuple(mut &self, mut m: &sema::TupleExpr) {
		for (i, mut v) in m.Values {
			self.possibleRefExpr(v.Model)
			self.oc.write(";")
			if len(m.Values)-i > 1 {
				self.oc.write("\n")
				self.oc.indent()
			}
		}
	}

	fn newCall(mut &self, mut m: &sema::BuiltinNewCallExpr) {
		self.oc.write("__jule_new_ptr<")
		self.oc.tc.kind(&self.oc.Buf, m.Type)
		self.oc.write(">(")
		if m.Init != nil {
			self.possibleRefExpr(m.Init)
		} else if ableToInit(m.Type) {
			self.initExpr(m.Type)
		}
		self.oc.write(")")
	}

	fn printCall(mut &self, mut m: &sema::BuiltinPrintCallExpr) {
		identCoder.funcIns(&self.oc.Buf, meta::Program.Runtime.Zprint)
		self.oc.write("(")
		mut f := obj::FindFuncGenericInstance(meta::Program.Runtime.ToStr, m.Expr.Type)
		identCoder.funcIns(&self.oc.Buf, f)
		self.oc.write("(")
		self.possibleRefExpr(m.Expr.Model)
		self.oc.write("))")
	}

	fn printlnCall(mut &self, mut m: &sema::BuiltinPrintlnCallExpr) {
		identCoder.funcIns(&self.oc.Buf, meta::Program.Runtime.Zprintln)
		self.oc.write("(")
		mut f := obj::FindFuncGenericInstance(meta::Program.Runtime.ToStr, m.Expr.Type)
		identCoder.funcIns(&self.oc.Buf, f)
		self.oc.write("(")
		self.possibleRefExpr(m.Expr.Model)
		self.oc.write("))")
	}

	fn panicCall(mut &self, mut m: &sema::BuiltinPanicCallExpr) {
		self.oc.write("__jule_panicStr(")
		self.possibleRefExpr(m.Expr)
		self.oc.write(" + ")
		strLit(&self.oc.Buf, "\nlocation: ", "12")
		self.oc.write(" + ")
		strLitF(&self.oc.Buf, fn|| {
			self.oc.write("\"")
			len := self.oc.locInfo(m.Token)
			self.oc.write("\"")
			ret len
		})
		self.oc.write(");")
	}

	fn errorCall(mut &self, mut m: &sema::BuiltinErrorCallExpr) {
		hasDefer := m.Func.Decl != nil && m.Func.Decl.HasDefer
		if m.Func.Decl.IsVoid() {
			mut v, _ := m.Err.Model.(&sema::Var)
			if v != nil && v.Name == "error" {
				if hasDefer {
					self.oc.write(deferStackName + ".call();\n")
					self.oc.indent()
				}
				self.oc.write("return __jule_VoidExceptional{.error=std::move(")
				// Handle error variable like ordinary variable.
				// Because it may be captured, use captured variable handler.
				self.var(v)
				self.oc.write(")}")
				ret
			}
			self.oc.write("return __jule_VoidExceptional{.error=")
		} else {
			self.oc.write("return __jule_Exceptional<")
			self.oc.tc.rc.codeMut1(&self.oc.Buf, m.Func.Result)
			mut v, _ := m.Err.Model.(&sema::Var)
			if v != nil && v.Name == "error" {
				self.oc.write(">{.error=")
				// Handle error variable like ordinary variable.
				// Because it may be captured, use captured variable handler.
				self.var(v)
				self.oc.write("}")
				ret
			}
			self.oc.write(">{.error=")
		}
		if hasDefer {
			self.oc.write("({ auto __result = ")
		}
		self.possibleRefExpr(m.Err.Model)
		if hasDefer {
			self.oc.write(";" + deferStackName + ".call(); __result; })")
		}
		self.oc.write("}")
	}

	fn copyCall(mut &self, mut m: &sema::BuiltinCopyCallExpr) {
		// We have to use mutable memory for the dest argument of copy due to lang spec.
		if opt::IsZCopyArray(m.Dest.Model) {
			mut ie := m.Dest.Model.(&sema::SlicingExpr)
			mut model := any(&opt::ArrayAsSlice{
				Expr: ie.Expr.Model,
			})
			ie.Expr.Model = unsafe { *(*sema::Expr)(&model) }
		}

		if sema::Fastmemcopy(m.Dest.Type.Slice().Value) {
			mut ins := obj::FindFuncGenericInstance(meta::Program.Runtime.Fastmemcopy, m.Dest.Type, m.Src.Type)
			identCoder.funcIns(&self.oc.Buf, ins)
		} else {
			mut ins := obj::FindFuncGenericInstance(meta::Program.Runtime.Memcopy, m.Dest.Type, m.Src.Type)
			identCoder.funcIns(&self.oc.Buf, ins)
		}

		self.oc.write("(")
		self.possibleRefExpr(m.Dest.Model)
		self.oc.write(", ")
		self.possibleRefExpr(m.Src.Model)
		self.oc.write(")")
	}

	fn lenCall(mut &self, mut m: &sema::BuiltinLenCallExpr) {
		mut _map := m.Expr.Type.Map()
		if _map != nil {
			mut ins := obj::FindStructGenericInstance(meta::Program.Runtime.Map, _map.Key, _map.Value)
			const Static = false
			mut f := ins.FindMethod("len", Static).Instances[0]
			identCoder.funcIns(&self.oc.Buf, f)
			self.oc.write("(")
			self.possibleRefExpr(m.Expr.Model)
			self.oc.write(")")
			ret
		}
		self.possibleRefExpr(m.Expr.Model)
		self.oc.write(".len()")
	}

	fn capCall(mut &self, mut m: &sema::BuiltinCapCallExpr) {
		self.possibleRefExpr(m.Expr.Model)
		self.oc.write(".cap()")
	}

	fn deleteCall(mut &self, mut m: &sema::BuiltinDeleteCallExpr) {
		mut _map := m.Dest.Type.Map()
		if _map == nil {
			panic("cxx: deleteCall: destination is not map")
		}
		mut ins := obj::FindStructGenericInstance(meta::Program.Runtime.Map, _map.Key, _map.Value)
		const Static = false
		if m.Key != nil {
			mut f := ins.FindMethod("delete", Static).Instances[0]
			identCoder.funcIns(&self.oc.Buf, f)
			self.oc.write("(")
			self.possibleRefExpr(m.Dest.Model)
			self.oc.write(".alloc, ")
			self.possibleRefExpr(m.Key.Model)
			self.oc.write(")")
		} else {
			mut f := ins.FindMethod("clear", Static).Instances[0]
			identCoder.funcIns(&self.oc.Buf, f)
			self.oc.write("(")
			self.possibleRefExpr(m.Dest.Model)
			self.oc.write(".alloc)")
		}
	}

	fn realCall(mut &self, mut m: &sema::BuiltinRealCallExpr) {
		self.possibleRefExpr(m.Cmplx.Model)
		self.oc.write(".")
		p := m.Cmplx.Type.Prim()
		match {
		| p.IsCmplx64():
			identCoder.field(&self.oc.Buf, meta::Program.Runtime.Cmplx64.FindField("real").Decl)
		| p.IsCmplx128():
			identCoder.field(&self.oc.Buf, meta::Program.Runtime.Cmplx128.FindField("real").Decl)
		|:
			panic("unreachable")
		}
	}

	fn imagCall(mut &self, mut m: &sema::BuiltinImagCallExpr) {
		self.possibleRefExpr(m.Cmplx.Model)
		self.oc.write(".")
		p := m.Cmplx.Type.Prim()
		match {
		| p.IsCmplx64():
			identCoder.field(&self.oc.Buf, meta::Program.Runtime.Cmplx64.FindField("imag").Decl)
		| p.IsCmplx128():
			identCoder.field(&self.oc.Buf, meta::Program.Runtime.Cmplx128.FindField("imag").Decl)
		|:
			panic("unreachable")
		}
	}

	fn cmplxCall(mut &self, mut m: &sema::BuiltinCmplxCallExpr) {
		p := m.Real.Type.Prim()
		match {
		| p.IsF32():
			identCoder.structureIns(&self.oc.Buf, meta::Program.Runtime.Cmplx64)
		| p.IsF64():
			identCoder.structureIns(&self.oc.Buf, meta::Program.Runtime.Cmplx128)
		|:
			panic("unreachable")
		}
		self.oc.write("{")
		self.possibleRefExpr(m.Real.Model)
		self.oc.write(", ")
		self.possibleRefExpr(m.Imag.Model)
		self.oc.write("}")
	}

	fn makeCallSlice(mut &self, mut m: &sema::BuiltinMakeCallExpr) {
		mut slice := m.Type.Slice()
		init := ableToInit(slice.Value)
		if init {
			self.oc.write("({ auto " + collectionIdent + " = ")
		}
		self.oc.tc.kind(&self.oc.Buf, m.Type)
		self.oc.write("::alloc(")
		self.possibleRefExpr(m.Len)
		self.oc.write(", ")
		if m.Cap != nil {
			self.possibleRefExpr(m.Cap)
		} else {
			self.possibleRefExpr(m.Len)
		}
		self.oc.write(")")
		if !init {
			ret
		}
		self.oc.write("; ")
		self.initCollection(slice.Value, collectionIdent+"._cap")
		self.oc.write(" " + collectionIdent + "; })")
	}

	fn makeCallChan(mut &self, mut m: &sema::BuiltinMakeCallExpr) {
		ch := m.Type.Chan()
		mut ins := obj::FindStructGenericInstance(meta::Program.Runtime.Pchan, ch.Value)
		const Static = true
		mut f := ins.FindMethod("new", Static).Instances[0]
		identCoder.funcIns(&self.oc.Buf, f)
		self.oc.write("(")
		if m.Cap == nil {
			// Channel is not buffered.
			// We have to initialize it with zero buffer-length.
			self.oc.write("0")
		} else {
			self.possibleRefExpr(m.Cap)
		}
		self.oc.write(")")
	}

	fn makeCall(mut &self, mut m: &sema::BuiltinMakeCallExpr) {
		if m.Type.Slice() != nil {
			self.makeCallSlice(m)
			ret
		}
		if m.Type.Chan() != nil {
			self.makeCallChan(m)
			ret
		}
	}

	fn pushToSlice(mut &self, mut m: &opt::PushToSliceExpr) {
		// Use l-value advantage and define reference variable to destination
		// in the child scope to avoid potential repeated high-cost memory access overhead.
		const destIdent = "__jule_push_dest"

		mut s := m.Base.Elements.Model.(&sema::SliceExpr)

		self.oc.write("{ ")
		self.oc.tc.asSlice(&self.oc.Buf, s.ElemType)

		mut ptr := false
		match type m.Base.Dest.Model {
		| &sema::UnaryExpr:
			// Use raw pointer directly if exist.
			mut u := m.Base.Dest.Model.(&sema::UnaryExpr)
			if u.Expr.Type.Ptr() != nil {
				self.oc.write(" *" + destIdent + " = ")
				self.possibleRefExpr(u.Expr.Model)
				self.oc.write("; ")
				ptr = true
				break
			}
			fall
		|:
			self.oc.write(" &" + destIdent + " = ")
			self.possibleRefExpr(m.Base.Dest.Model)
			self.oc.write("; ")
		}
		// Pushed more than single item.
		// Pre-allocate enough capacity if not exist for appendation.
		mut ins := obj::FindFuncGenericInstance(meta::Program.Runtime.Prememappend, m.Base.Dest.Type, s.ElemType)
		identCoder.funcIns(&self.oc.Buf, ins)
		self.oc.write("(")
		if !ptr {
			self.oc.write("&")
		}
		self.oc.write(destIdent + ", ")
		self.oc.write(conv::Itoa(len(s.Elems)))
		self.oc.write("); ")
		for (_, mut e) in s.Elems {
			self.oc.write(destIdent)
			// Use the "__push" method to skip allocation boundary checking.
			if ptr {
				self.oc.write("->__push(")
			} else {
				self.oc.write(".__push(")
			}
			self.possibleRefExpr(e.Model)
			self.oc.write("); ")
		}
		self.oc.write("}")
	}

	fn appendCall(mut &self, mut m: &sema::BuiltinAppendCallExpr) {
		mut ins := obj::FindFuncGenericInstance(meta::Program.Runtime.Memappend, m.Dest.Type, m.Elements.Type)
		identCoder.funcIns(&self.oc.Buf, ins)
		self.oc.write("(")
		self.possibleRefExpr(m.Dest.Model)
		self.oc.write(",")
		self.possibleRefExpr(m.Elements.Model)
		self.oc.write(")")
	}

	fn sizeof(mut &self, mut m: &sema::SizeofExpr) {
		self.oc.write("sizeof(")
		self.possibleRefExpr(m.Expr)
		self.oc.write(")")
	}

	fn alignof(mut &self, mut m: &sema::AlignofExpr) {
		self.oc.write("alignof(")
		self.possibleRefExpr(m.Expr)
		self.oc.write(")")
	}

	fn runeLit(mut &self, m: &sema::RuneExpr) {
		if m.Code <= 127 { // ASCII.
			self.oc.Buf.WriteByte('\'')!
			mut b := sbtoa(byte(m.Code))
			if b == "'" {
				self.oc.Buf.WriteByte('\\')!
			}
			self.oc.Buf.WriteStr(b)!
			self.oc.Buf.WriteByte('\'')!
			ret
		}
		itoa(&self.oc.Buf, i64(m.Code))
	}

	fn structureStatic(mut &self, mut m: &sema::StructStaticIdentExpr) {
		identCoder.funcIns(&self.oc.Buf, m.Method)
	}

	fn backendEmit(mut &self, mut m: &sema::BackendEmitExpr) {
		if len(m.Exprs) == 0 {
			self.oc.write(m.Code)
			ret
		}
		n := self.oc.Buf.Len()
		mut args := make([]any, len(m.Exprs))
		for (i, mut expr) in m.Exprs {
			self.possibleRefExpr(expr)
			mut buf := unsafe { self.oc.Buf.Buf() }
			args[i] = str(buf[n:])
			unsafe { self.oc.Buf.SetBuf(buf[:n]) }
		}
		self.oc.write(fmt::Sprintf(m.Code, args...))
	}

	fn chanRecv(mut &self, mut m: &sema::ChanRecv, ok: fn(), block: bool) {
		ch := m.Expr.Type.Chan()
		mut ins := obj::FindStructGenericInstance(meta::Program.Runtime.Pchan, ch.Value)
		const Static = false
		let mut f: &sema::FuncIns
		if block {
			f = ins.FindMethod("recv", Static).Instances[0]
		} else {
			f = ins.FindMethod("tryRecv", Static).Instances[0]
		}
		identCoder.funcIns(&self.oc.Buf, f)
		self.oc.write("(")
		self.possibleRefExpr(m.Expr.Model)
		if block {
			self.oc.write(".must_ok(\"")
			self.oc.locInfo(m.Token)
			self.oc.write("\")")
		}
		self.oc.write(".alloc, ")
		if ok != nil {
			// Write the reference expression to pass |ok| parameter.
			ok()
		} else {
			// Pass nil pointer to the reference.
			// It should be safe.
			self.oc.write("nullptr")
		}
		self.oc.write(")")
	}

	fn chanSend(mut &self, mut m: &sema::ChanSend, block: bool) {
		c := m.Chan.Type.Chan()
		mut ins := obj::FindStructGenericInstance(meta::Program.Runtime.Pchan, c.Value)
		const Static = false
		let mut f: &sema::FuncIns
		if block {
			f = ins.FindMethod("send", Static).Instances[0]
		} else {
			f = ins.FindMethod("trySend", Static).Instances[0]
		}
		identCoder.funcIns(&self.oc.Buf, f)
		self.oc.write("(")
		self.possibleRefExpr(m.Chan.Model)
		if block {
			self.oc.write(".must_ok(\"")
			self.oc.locInfo(m.Token)
			self.oc.write("\")")
		}
		self.oc.write(".alloc, ")
		self.possibleRefExpr(m.Data.Model)
		self.oc.write(")")
	}

	fn closeCall(mut &self, mut m: &sema::BuiltinCloseCallExpr) {
		ch := m.Chan.Type.Chan()
		mut ins := obj::FindStructGenericInstance(meta::Program.Runtime.Pchan, ch.Value)
		const Static = false
		mut f := ins.FindMethod("close", Static).Instances[0]
		identCoder.funcIns(&self.oc.Buf, f)
		self.oc.write("(")
		self.possibleRefExpr(m.Chan.Model)
		self.oc.write(".must_ok(\"")
		self.oc.locInfo(m.Token)
		self.oc.write("\").alloc)")
	}

	fn addrcallExpr(mut &self, mut m: &sema::AddrcallExpr) {
		self.oc.write("((")
		if m.Result == nil {
			self.oc.write("void")
		} else {
			self.oc.tc.kind(&self.oc.Buf, m.Result)
		}
		self.oc.write("(*)(")
		if len(m.Args) == 0 {
			self.oc.write("void")
		} else {
			for (i, mut arg) in m.Args {
				if i > 0 {
					self.oc.write(", ")
				}
				self.oc.tc.kind(&self.oc.Buf, arg.Type)
			}
		}
		self.oc.write("))(")
		self.possibleRefExpr(m.Addr.Model)
		self.oc.write("))(")
		for (i, mut arg) in m.Args {
			if i > 0 {
				self.oc.write(", ")
			}
			self.possibleRefExpr(arg.Model)
		}
		self.oc.write(")")
	}

	fn strComp(mut &self, mut m: &opt::StrCompExpr) {
		if m.NotEq {
			self.oc.write("(!")
		}
		s := m.Right.ReadStr()
		self.possibleRefExpr(m.Left)
		self.oc.write(".equal(")
		cstrLit(&self.oc.Buf, s)
		self.oc.write(", ")
		self.oc.write(conv::Itoa(len(s)))
		self.oc.write(")")
		if m.NotEq {
			self.oc.write(")")
		}
	}

	fn emptyCompare(mut &self, mut m: &opt::EmptyCompareExpr) {
		if m.Neg {
			self.oc.write("!")
		}
		self.oc.write("(")
		self.possibleRefExpr(m.Expr)
		self.oc.write(").empty()")
	}

	fn unsafeDeref(mut &self, mut m: &opt::UnsafeDerefExpr) {
		match {
		| m.Base.Expr.Type.Ptr() != nil:
			self.oc.write("(*")
			self.possibleRefExpr(m.Base.Expr.Model)
			self.oc.write(")")
		| m.Base.Expr.Type.Sptr() != nil:
			self.oc.write("(*")
			self.possibleRefExpr(m.Base.Expr.Model)
			self.oc.write(".alloc)")
		|:
			panic("cxx: implementation mistake, this panic call should be unreachable")
		}
	}

	fn unsafeTypeAssertion(mut &self, mut m: &opt::UnsafeTypeAssertionExpr) {
		match {
		| obj::IsAny(m.Base.Expr.Type):
			self.possibleRefExpr(m.Base.Expr.Model)
			// We handling map and channel types as smart pointer,
			// because this kind types implemented as smart pointers
			// at machine code level.
			match {
			| m.Base.Type.Sptr() != nil:
				self.oc.write(".unsafe_cast_ptr<")
				self.oc.tc.kind(&self.oc.Buf, m.Base.Type.Sptr().Value)
			| m.Base.Type.Map() != nil:
				self.oc.write(".unsafe_cast_ptr<")
				mp := m.Base.Type.Map()
				mut mps := obj::FindStructGenericInstance(meta::Program.Runtime.Map, mp.Key, mp.Value)
				self.oc.tc.structureIns(&self.oc.Buf, mps)
			| m.Base.Type.Chan() != nil:
				self.oc.write(".unsafe_cast_ptr<")
				ch := m.Base.Type.Chan()
				mut chs := obj::FindStructGenericInstance(meta::Program.Runtime.Pchan, ch.Value)
				self.oc.tc.structureIns(&self.oc.Buf, chs)
			|:
				self.oc.write(".unsafe_cast<")
				self.oc.tc.kind(&self.oc.Buf, m.Base.Type)
			}
			self.oc.write(">()")
		|:
			panic("cxx: implementation mistake, this panic call should be unreachable")
		}
	}

	fn strConcat(mut &self, mut m: &opt::StrConcatExpr) {
		self.oc.write("({ " + typeInt + " size = 0; ")
		for (i, mut p) in m.Parts {
			ident := "part" + conv::Itoa(i)
			self.oc.write(typeStr + " ")
			self.oc.write(ident)
			self.oc.write(" = std::move(")
			self.possibleRefExpr(p)
			self.oc.write("); size += ")
			self.oc.write(ident)
			self.oc.write(".len(); ")
		}
		self.oc.write("__jule_Slice<" + typeU8 + "> buf; buf.alloc_new(0, size); ")
		for i in m.Parts {
			ident := "part" + conv::Itoa(i)
			self.oc.write("buf.append(")
			self.oc.write(ident)
			self.oc.write("); ")
		}
		self.oc.write(typeStr + " result; result._len = buf._len; result.buffer = std::move(buf.data); result._slice = buf._slice; std::move(result); })")
	}

	fn strFromBytes(mut &self, mut m: &opt::StrFromBytes) {
		identCoder.funcIns(&self.oc.Buf, meta::Program.Runtime.SliceAsStr)
		self.oc.write("(")
		self.possibleRefExpr(m.Expr)
		self.oc.write(")")
	}

	fn bytesFromStr(mut &self, mut m: &opt::BytesFromStr) {
		identCoder.funcIns(&self.oc.Buf, meta::Program.Runtime.StrAsSlice)
		self.oc.write("(")
		self.possibleRefExpr(m.Expr)
		self.oc.write(")")
	}

	fn arrayAsSlice(mut &self, mut m: &opt::ArrayAsSlice) {
		self.oc.write("(")
		self.possibleRefExpr(m.Expr)
		self.oc.write(").as_slice()")
	}

	fn model(mut &self, mut m: compExpr) {
		match type m {
		| str:
			self.oc.write(m.(str))
		| &str:
			self.oc.write(*m.(&str))
		| &constant::Const:
			self.constant(m.(&constant::Const))
		| &sema::Type:
			self.oc.tc.kind(&self.oc.Buf, m.(&sema::Type))
		| &sema::Var:
			self.var(m.(&sema::Var))
		| &sema::StructIns:
			self.structureIns(m.(&sema::StructIns))
		| &sema::FuncIns:
			self.funcInsCommon(m.(&sema::FuncIns))
		| &sema::BinaryExpr:
			self.binary(m.(&sema::BinaryExpr))
		| &sema::UnaryExpr:
			self.unary(m.(&sema::UnaryExpr))
		| &sema::StructLitExpr:
			self.structureLit(m.(&sema::StructLitExpr))
		| &sema::AllocStructLitExpr:
			self.allocStructure(m.(&sema::AllocStructLitExpr))
		| &sema::CastingExpr:
			self.casting(m.(&sema::CastingExpr))
		| &sema::FuncCallExpr:
			self.funcCall(m.(&sema::FuncCallExpr), false)
		| &sema::SliceExpr:
			self.slice(m.(&sema::SliceExpr))
		| &sema::ArrayExpr:
			self.array(m.(&sema::ArrayExpr))
		| &opt::UnsafeIndexingExpr:
			self.unsafeIndexing(m.(&opt::UnsafeIndexingExpr))
		| &sema::IndexingExpr:
			self.indexing(m.(&sema::IndexingExpr))
		| &sema::AnonFuncExpr:
			self.anonFunc(m.(&sema::AnonFuncExpr))
		| &sema::MapExpr:
			self.mapExpr(m.(&sema::MapExpr))
		| &sema::SlicingExpr:
			self.slicing(m.(&sema::SlicingExpr))
		| &sema::TraitSubIdentExpr:
			self.traitSub(m.(&sema::TraitSubIdentExpr))
		| &sema::StructSubIdentExpr:
			self.structureSub(m.(&sema::StructSubIdentExpr))
		| &sema::TupleExpr:
			self.tuple(m.(&sema::TupleExpr))
		| &sema::BuiltinPrintCallExpr:
			self.printCall(m.(&sema::BuiltinPrintCallExpr))
		| &sema::BuiltinPrintlnCallExpr:
			self.printlnCall(m.(&sema::BuiltinPrintlnCallExpr))
		| &sema::BuiltinNewCallExpr:
			self.newCall(m.(&sema::BuiltinNewCallExpr))
		| &sema::BuiltinPanicCallExpr:
			self.panicCall(m.(&sema::BuiltinPanicCallExpr))
		| &sema::BuiltinErrorCallExpr:
			self.errorCall(m.(&sema::BuiltinErrorCallExpr))
		| &sema::BuiltinMakeCallExpr:
			self.makeCall(m.(&sema::BuiltinMakeCallExpr))
		| &sema::BuiltinAppendCallExpr:
			self.appendCall(m.(&sema::BuiltinAppendCallExpr))
		| &sema::BuiltinCopyCallExpr:
			self.copyCall(m.(&sema::BuiltinCopyCallExpr))
		| &sema::BuiltinLenCallExpr:
			self.lenCall(m.(&sema::BuiltinLenCallExpr))
		| &sema::BuiltinCapCallExpr:
			self.capCall(m.(&sema::BuiltinCapCallExpr))
		| &sema::BuiltinDeleteCallExpr:
			self.deleteCall(m.(&sema::BuiltinDeleteCallExpr))
		| &sema::BuiltinRealCallExpr:
			self.realCall(m.(&sema::BuiltinRealCallExpr))
		| &sema::BuiltinImagCallExpr:
			self.imagCall(m.(&sema::BuiltinImagCallExpr))
		| &sema::BuiltinCmplxCallExpr:
			self.cmplxCall(m.(&sema::BuiltinCmplxCallExpr))
		| &sema::SizeofExpr:
			self.sizeof(m.(&sema::SizeofExpr))
		| &sema::AlignofExpr:
			self.alignof(m.(&sema::AlignofExpr))
		| &sema::RuneExpr:
			self.runeLit(m.(&sema::RuneExpr))
		| &sema::StructStaticIdentExpr:
			self.structureStatic(m.(&sema::StructStaticIdentExpr))
		| &sema::BackendEmitExpr:
			self.backendEmit(m.(&sema::BackendEmitExpr))
		| &sema::ChanRecv:
			self.chanRecv(m.(&sema::ChanRecv), nil, true)
		| &sema::ChanSend:
			self.chanSend(m.(&sema::ChanSend), true)
		| &sema::BuiltinCloseCallExpr:
			self.closeCall(m.(&sema::BuiltinCloseCallExpr))
		| &sema::TypeAssertionExpr:
			self.typeAssertion(m.(&sema::TypeAssertionExpr))
		| &sema::AddrcallExpr:
			self.addrcallExpr(m.(&sema::AddrcallExpr))
		| &opt::UnsafeBinaryExpr:
			self.unsafeBinary(m.(&opt::UnsafeBinaryExpr).Node)
		| &opt::StrCompExpr:
			self.strComp(m.(&opt::StrCompExpr))
		| &opt::EmptyCompareExpr:
			self.emptyCompare(m.(&opt::EmptyCompareExpr))
		| &opt::UnsafeDerefExpr:
			self.unsafeDeref(m.(&opt::UnsafeDerefExpr))
		| &opt::UnsafeTypeAssertionExpr:
			self.unsafeTypeAssertion(m.(&opt::UnsafeTypeAssertionExpr))
		| &opt::FuncCallIgnoreExceptionalExpr:
			self.funcCall(m.(&opt::FuncCallIgnoreExceptionalExpr).Base, true)
		| &opt::StrConcatExpr:
			self.strConcat(m.(&opt::StrConcatExpr))
		| &opt::StrFromBytes:
			self.strFromBytes(m.(&opt::StrFromBytes))
		| &opt::BytesFromStr:
			self.bytesFromStr(m.(&opt::BytesFromStr))
		| &opt::ArrayAsSlice:
			self.arrayAsSlice(m.(&opt::ArrayAsSlice))
		}
	}

	// Writes default initialization of struct field.
	fn handleFieldByDefault(mut &self, mut f: &sema::FieldIns): (inited: bool) {
		// If field have default expression, initialize with it.
		// Otherwise, initialize it by default expression.
		if !ableToInit(f.Type) {
			ret false
		}
		self.oc.write(".")
		identCoder.field(&self.oc.Buf, f.Decl)
		self.oc.write("=")
		self.initExpr(f.Type)
		ret true
	}

	// Writes default struct literal expression to initialize it by default.
	fn initStructLit(mut &self, mut s: &sema::StructIns) {
		if obj::IsBindStruct(s) {
			self.oc.write("(")
			self.structureIns(s)
			self.oc.write("){}")
			ret
		}
		self.structureIns(s)
		self.oc.write("{")
		mut inited := false
		for (_, mut f) in s.Fields {
			if inited {
				self.oc.write(", ")
			}
			inited = self.handleFieldByDefault(f)
		}
		self.oc.write("}")
	}

	// Writes iteration to initialize collection elements by default.
	// Assumes collectionItIdent and collectionIdent + "_end" is already defined.
	// Assumes collection element kind able to init.
	fn fillCollectionByDefault(mut &self, mut elem: &sema::Type) {
		self.oc.write("for (; ")
		self.oc.write(collectionItIdent)
		self.oc.write(" < ")
		self.oc.write(collectionIdent)
		self.oc.write("_end; ++")
		self.oc.write(collectionItIdent)
		self.oc.write(") *")
		self.oc.write(collectionItIdent)
		self.oc.write(" = ")
		self.initExpr(elem)
		self.oc.write(";")
	}

	// Assumes collection element kind able to init.
	fn initCollection(mut &self, mut elem: &sema::Type, size: str) {
		// If element type supports fastmemcopy implementation, use it to initialize.
		if sema::Fastmemcopy(elem) {
			self.oc.write("memset(")
			self.oc.write(collectionIdent)
			self.oc.write(".begin(), 0, sizeof(")
			self.oc.tc.kind(&self.oc.Buf, elem)
			self.oc.write(")*")
			self.oc.write(size)
			self.oc.write(");")
			ret
		}

		self.oc.write("std::fill(")
		self.oc.write(collectionIdent)
		self.oc.write(".begin(), ")
		self.oc.write(collectionIdent)
		self.oc.write(".hard_end(), ")
		self.initExpr(elem)
		self.oc.write(");")
	}

	// Writes default array literal expression to initialize it by default.
	fn initArray(mut &self, mut arr: &sema::Array) {
		// Plain initialization if array is zero-length.
		if arr.N == 0 {
			self.oc.tc.array(&self.oc.Buf, arr)
			self.oc.write("()")
			ret
		}
		self.oc.write("({ auto " + collectionIdent + " = ")
		self.oc.tc.array(&self.oc.Buf, arr)
		self.oc.write("(); ")
		self.initCollection(arr.Value, toStrArraySize(i64(arr.N), 10))
		self.oc.write(" " + collectionIdent + "; })")
	}

	fn initExpr(mut &self, mut t: &sema::Type) {
		if t.NilCompatible() {
			if t.Map() != nil {
				self.oc.tc.kind(&self.oc.Buf, t)
				self.oc.write("{}")
				ret
			}
			if t.Ptr() != nil {
				self.oc.write("nullptr")
			} else {
				self.oc.tc.kind(&self.oc.Buf, t)
				self.oc.write("(nullptr)")
			}
			ret
		}
		mut tup := t.Tuple()
		if tup != nil {
			self.oc.tc.rc.tuple(&self.oc.Buf, tup)
			self.oc.write("{")
			for (i, mut tt) in tup.Types {
				if !shouldInitialized(tt) {
					continue
				}
				self.oc.write("." + resultArgName)
				self.oc.write(conv::Itoa(i))
				self.oc.write("=")
				self.initExpr(tt)
				if len(tup.Types)-i > 1 {
					self.oc.write(", ")
				}
			}
			self.oc.write("}")
			ret
		}
		mut enm := t.Enum()
		if enm != nil {
			self.model(enm.Items[0].ValueSym.Value.Model)
			ret
		}
		prim := t.Prim()
		if prim != nil {
			match {
			| prim.IsCmplx64():
				identCoder.structureIns(&self.oc.Buf, meta::Program.Runtime.Cmplx64)
				self.oc.write("{0, 0}")
			| prim.IsCmplx128():
				identCoder.structureIns(&self.oc.Buf, meta::Program.Runtime.Cmplx128)
				self.oc.write("{0, 0}")
			| types::IsNum(prim.Kind):
				self.oc.write("0")
			| prim.IsBool():
				self.oc.write("false")
			| prim.IsStr():
				self.oc.write(typeStr + "()")
			}
			ret
		}
		if t.Array() != nil {
			mut arr := t.Array()
			self.initArray(arr)
			ret
		}
		mut s := t.Struct()
		if s != nil {
			self.initStructLit(s)
			ret
		}
		self.oc.tc.kind(&self.oc.Buf, t)
		self.oc.write("()")
	}
}

fn decomposeCommonEsq(b: byte): str {
	match b {
	| '\\':
		ret "\\\\"
	| '\'':
		ret "'"
	| '"':
		ret `\"`
	| '\a':
		ret `\a`
	| '\b':
		ret `\b`
	| '\f':
		ret `\f`
	| '\n':
		ret `\n`
	| '\r':
		ret `\r`
	| '\t':
		ret `\t`
	| '\v':
		ret `\v`
	|:
		ret ""
	}
}

fn sbtoa(b: byte): str {
	if b == 0 {
		ret "\\000"
	}
	if b < utf8::RuneSelf { // ASCII, fast way.
		seq := decomposeCommonEsq(b)
		if seq != "" {
			ret seq
		}
		if 32 <= b && b <= 126 {
			ret str(b)
		}
	}
	seq := conv::FormatUint(u64(b), 8)
	match len(seq) {
	| 1:
		ret "\\00" + seq
	| 2:
		ret "\\0" + seq
	|:
		ret "\\" + seq
	}
}

fn cstrBytes(mut &s: *strings::Builder, ctx: str) {
	for _, b in []byte(ctx) {
		s.WriteStr(sbtoa(b))!
	}
}

fn cstrLit(mut &s: *strings::Builder, ctx: str) {
	s.WriteByte('"')!
	cstrBytes(s, ctx)
	s.WriteByte('"')!
}

fn ftoa(mut &s: *strings::Builder, f: f64, bitsize: int) {
	if bitsize != 32 {
		if f == f64(i64(f)) {
			itoa(s, i64(f))
			ret
		}
		if f == f64(u64(f)) {
			utoa(s, u64(f))
			ret
		}
	}
	m := conv::FormatFloat(f, 'f', -1, bitsize)
	s.WriteStr(m)!
	if !strings::Contains(m, ".") {
		s.WriteStr(".0")!
	}
}

fn itoa(mut &s: *strings::Builder, x: i64) {
	if x == types::MinI64 {
		s.WriteStr("(-9223372036854775807LL-1LL)")!
		ret
	}

	s.WriteStr(conv::FormatInt(x, 10))!
	if dist::Is64bit(runtime::Arch) {
		s.WriteByte('L')!
	}
	s.WriteByte('L')!
}

fn utoa(mut &s: *strings::Builder, x: u64) {
	s.WriteStr(conv::FormatUint(x, 10))!
	if dist::Is64bit(runtime::Arch) {
		s.WriteByte('L')!
	}
	s.WriteStr("LU")!
}

fn structBinary(mut &buf: *strings::Builder, mut s: &sema::StructIns, l: str,
	r: str, op: int, kind: str) {
	if op != token::EQL && op != token::NEQ {
		panic("cxx: unsupported token occurred for structure binary, this is an implementation mistake")
	}
	if op == token::NEQ {
		buf.WriteByte('!')!
	}
	identCoder.structureIns(buf, s)
	buf.WriteStr(structDefaultEqMethodSuffix)!
	buf.WriteStr("(&")!
	buf.WriteStr(l)!
	buf.WriteStr(", ")!
	buf.WriteStr(r)!
	buf.WriteByte(')')!
}

// Writes string literal expression for constant literal to buf.
// Literal is not including quotes, just string content in bytes.
fn strLit(mut &buf: *strings::Builder, lit: str, len: str) {
	identCoder.funcIns(buf, meta::Program.Runtime.StrBytePtr)
	buf.WriteStr("((" + typeU8 + "*)")!
	cstrLit(buf, lit)
	buf.WriteByte(',')!
	buf.WriteStr(len)!
	buf.WriteByte(')')!
}

// Same as the strLit function, but uses the lit function to write content.
// The lit function should return the length of content.
fn strLitF(mut &buf: *strings::Builder, lit: fn(): int) {
	identCoder.funcIns(buf, meta::Program.Runtime.StrBytePtr)
	buf.WriteStr("((" + typeU8 + "*)")!
	len := conv::Itoa(lit())
	buf.WriteByte(',')!
	buf.WriteStr(len)!
	buf.WriteByte(')')!
}

// Like the strLit function, but writes as slice (will not perform allocation).
fn strLitAsSlice(mut &buf: *strings::Builder, lit: str, len: str) {
	identCoder.funcIns(buf, meta::Program.Runtime.SliceBytePtr)
	buf.WriteStr("((" + typeU8 + "*)")!
	cstrLit(buf, lit)
	buf.WriteByte(',')!
	buf.WriteStr(len)!
	buf.WriteByte(',')!
	buf.WriteStr(len)!
	buf.WriteByte(')')!
}

// Returns string expr as byte slice (will not perform allocation).
fn strToSlice(mut &buf: *strings::Builder, expr: str) {
	identCoder.funcIns(buf, meta::Program.Runtime.StrAsSlice)
	buf.WriteByte('(')!
	buf.WriteStr(expr)!
	buf.WriteByte(')')!
}

// Function f writes buffer buf and this function returns
// as separate string the written part. Buffer will not contain
// written part.
fn writeAndReadFromBuf(mut &buf: *strings::Builder, f: fn()): str {
	mut i := buf.Len()
	f()
	s := str(unsafe { buf.Buf()[i:] })
	unsafe { buf.SetBuf(buf.Buf()[:i]) }
	ret s
}

// Use expression model type.
const (
	useExprPlain = 1 << iota
	useExprAssignment
)

struct useExprMemory {
	DestType: &sema::Type
	Model:    compExpr
	Type:     int
	OpId:     int
	OpKind:   str
}

impl useExprMemory {
	fn write(mut *self, mut e: &exprCoder, mut src: compExpr, mut srcType: &sema::Type) {
		match self.Type {
		| useExprPlain:
			if src != nil && self.DestType != nil {
				e.oc.sc.assignWithPossibleCast(self.Model, self.DestType, src, srcType)
			} else {
				e.possibleRefExpr(self.Model)
				if src != nil {
					e.oc.write(" ")
					e.oc.write(self.OpKind)
					e.oc.write(" ")
					e.possibleRefExpr(src)
				}
			}
		| useExprAssignment:
			if src == nil {
				e.oc.sc.assignLeft(self.Model)
				ret
			}
			mut assign := new(sema::Assign)
			assign.Op = &token::Token{
				ID: self.OpId,
				Kind: self.OpKind,
			}
			assign.Left = &sema::OperandExpr{
				Type: self.DestType,
				Model: unsafe { *(*sema::Expr)(&self.Model) },
			}
			assign.Right = &sema::OperandExpr{
				Type: srcType,
				Model: unsafe { *(*sema::Expr)(&src) },
			}
			e.oc.sc.assign(assign)
		|:
			panic("unreachable")
		}
	}
}

fn isExceptionalResult(mut m: sema::Expr): (fc: &sema::FuncCallExpr) {
	mut c, mut ok := m.(&sema::CastingExpr)
	if ok {
		m = c.Expr.Model
	}
	fc, ok := m.(&sema::FuncCallExpr)
	if !ok || fc.Func.Decl == nil || !fc.Func.Decl.Exceptional {
		fc = nil
	}
	ret
}
// Copyright 2023-2025 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "env"
use "obj"
use "std/conv"
use "std/jule"
use "std/jule/build"
use "std/jule/directive"
use "std/jule/sema"
use "std/jule/token"
use "std/strings"
use "std/unicode/utf8"
use "std/unsafe"

// Identifier of initialize function caller function.
const initCallerIdent = "__jule_call_initializers"

const identSelf = "_self_"

struct identCoder{}

impl identCoder {
	// Write identifiers to buf. If identifier contains unicode runes,
	// handle as ASCII characters. Some backend compilers are not supports
	// unicode identifiers and causes compile errors.
	static fn writeIdentTo(mut &buf: strings::Builder, &ident: str) {
		for _, b in ident {
			if b >= utf8::RuneSelf {
				// ident contains unicode runes.
				goto unicode
			}
		}
		// ident is ASCII, append directly.
		buf.WriteStr(ident)!
		ret
	unicode:
		for _, r in ident {
			if r < utf8::RuneSelf { // ASCII
				// Cast to byte to enable compiler optimization.
				// Append directly to buf.
				buf.WriteByte(byte(r))!
				continue
			}
			// Unicode, handle as ASCII.
			buf.WriteStr(conv::FormatInt(i64(r), 0xF))!
		}
	}

	// Writes cpp output identifier form of given identifier.
	//
	// Parameters:
	//	ident: Identifier.
	//	addr:  Pointer address of package file handler.
	static fn toOut(mut &buf: strings::Builder, ident: str, addr: uintptr) {
		buf.WriteByte('_')!
		if addr != 0 {
			buf.WriteStr(conv::FormatUint(u64(addr), 0xF))!
			buf.WriteByte('_')!
		}
		identCoder.writeIdentTo(buf, ident)
	}

	// Writes cpp output local identifier form of given identifier.
	//
	// Parameters:
	//	row:   Row of definition.
	//	col:   Column of definition.
	//	ident: Identifier of definition.
	static fn toLocal(mut &buf: strings::Builder, row: int, col: int, &ident: str) {
		buf.WriteByte('_')!
		buf.WriteStr(conv::Itoa(row))!
		buf.WriteStr(conv::Itoa(col))!
		buf.WriteByte('_')!
		identCoder.writeIdentTo(buf, ident)
	}

	static fn func(mut &buf: strings::Builder, mut &f: &sema::Func) {
		match {
		| f.Binded:
			buf.WriteStr(f.Ident)!
			ret
		| f.IsMethod():
			if f.Statically {
				buf.WriteStr("static_")!
			}
		}
		export := obj::FindDirective(f.Directives, directive::Export)
		if export != nil {
			buf.WriteStr(export.Args[0].Kind)!
			ret
		}
		identCoder.toOut(buf, f.Ident, uintptr(f))
	}

	static fn funcIns(mut &buf: strings::Builder, mut &f: &sema::FuncIns) {
		if f.IsBuiltin() {
			// Do not use [identCoder.writeIdentTo] for this.
			// Built-in functions are always ASCII.
			buf.WriteStr("jule::")!
			buf.WriteStr(f.Decl.Ident)!
			ret
		}
		if f.Decl.Binded || len(f.Generics) == 0 {
			identCoder.func(buf, f.Decl)
			ret
		}
		identCoder.toOut(buf, f.Decl.Ident, uintptr(f))
	}

	static fn traitDecl(mut &buf: strings::Builder, t: &sema::Trait) {
		identCoder.toOut(buf, t.Ident, uintptr(t))
	}

	static fn param(mut &buf: strings::Builder, &p: &sema::Param) {
		if jule::IsAnon(p.Ident) || jule::IsBlank(p.Ident) {
			ret
		}
		if p.IsSelf() {
			buf.WriteStr(identSelf)!
			ret
		}
		if p.Token == nil {
			identCoder.toLocal(buf, 0, 0, p.Ident)
			ret
		}
		identCoder.toLocal(buf, p.Token.Row, p.Token.Column, p.Ident)
	}

	static fn structure(mut &buf: strings::Builder, &s: &sema::Struct) {
		if s.Binded {
			if !obj::HasDirective(s.Directives, directive::Typedef) {
				buf.WriteStr("struct ")!
			}
			buf.WriteStr(s.Ident)!
			ret
		}
		identCoder.toOut(buf, s.Ident, uintptr(s))
	}

	static fn structureIns(mut &buf: strings::Builder, &s: &sema::StructIns) {
		if s.Decl.Binded || len(s.Generics) == 0 {
			identCoder.structure(buf, s.Decl)
			ret
		}
		identCoder.toOut(buf, s.Decl.Ident, uintptr(s))
	}

	static fn field(mut &buf: strings::Builder, &f: &sema::Field) {
		if f.Owner.Binded {
			buf.WriteStr(f.Ident)!
			ret
		}
		if jule::IsBlank(f.Ident) {
			// If the identifier is blank, there may be other fields like that.
			// So handle them with unique identifier, avoid duplication.
			buf.WriteStr("_field_")!
			buf.WriteStr(conv::FormatUint(u64(uintptr(f)), 0xF))!
			ret
		}
		buf.WriteStr("_field_")!
		identCoder.writeIdentTo(buf, f.Ident)
	}

	// Returns output identifier of captured variable by anonymous function.
	static fn anonFuncVar(mut &buf: strings::Builder, mut v: &sema::Var) {
		match {
		| v.RetOrder >= 0:
			// If the RetOrder>=0, this means variable one of the structure fields of multiple-return.
			// To avoid generating invalid IR code, use the variable's unique identifier.
			identCoder.toOut(buf, v.Ident, uintptr(v))
		|:
			// Use the common identifier coder.
			identCoder.var(buf, v)
		}
	}

	// Returns output identifier of variable.
	static fn var(mut &buf: strings::Builder, mut v: &sema::Var) {
		match {
		| v.Binded:
			buf.WriteStr(v.Ident)!
		| v.Ident == "error":
			buf.WriteStr("except.error")!
		| v.Ident == "self":
			buf.WriteStr(identSelf)!
		| v.RetOrder == -1:
			// The single return variable is just this one.
			// Return directly [resultName] because of generated with this identifier.
			buf.WriteStr(resultName)!
		| v.RetOrder >= 0:
			buf.WriteStr(resultName + "." + resultArgName)!
			buf.WriteStr(conv::Itoa(v.RetOrder))!
		| v.Scope != nil:
			identCoder.toLocal(buf, v.Token.Row, v.Token.Column, v.Ident)
		|:
			export := obj::FindDirective(v.Directives, directive::Export)
			if export != nil {
				buf.WriteStr(export.Args[0].Kind)!
				ret
			}
			identCoder.toOut(buf, v.Ident, uintptr(v))
		}
	}

	static fn iterBegin(mut &buf: strings::Builder, it: uintptr) {
		buf.WriteStr("_iter_begin_")!
		buf.WriteStr(conv::FormatUint(u64(it), 0xF))!
	}

	static fn iterEnd(mut &buf: strings::Builder, it: uintptr) {
		buf.WriteStr("_iter_end_")!
		buf.WriteStr(conv::FormatUint(u64(it), 0xF))!
	}

	static fn iterNext(mut &buf: strings::Builder, it: uintptr) {
		buf.WriteStr("_iter_next_")!
		buf.WriteStr(conv::FormatUint(u64(it), 0xF))!
	}

	static fn label(mut &buf: strings::Builder, u: uintptr) {
		buf.WriteStr("_julec_label_")!
		buf.WriteStr(conv::FormatUint(u64(u), 0xF))!
	}

	static fn matchEnd(mut &buf: strings::Builder, m: uintptr) {
		buf.WriteStr("_match_end_")!
		buf.WriteStr(conv::FormatUint(u64(m), 0xF))!
	}

	static fn caseBegin(mut &buf: strings::Builder, c: uintptr) {
		buf.WriteStr("_case_begin_")!
		buf.WriteStr(conv::FormatUint(u64(c), 0xF))!
	}
}
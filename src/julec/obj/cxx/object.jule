// Copyright 2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "env"
use "obj"
use "opt"
use "std/comptime"
use "std/conv"
use "std/fs/path"
use "std/jule"
use "std/jule/build"
use "std/jule/lex"
use "std/jule/sema"
use "std/jule/types"
use "std/strings"
use "std/time"
use "std/unsafe"

const ctxParamIdent = "__f_ctx"
const anonFnCtxSuffix = "_ctx"                              // Anon fn identifier suffix for ctx struct identifier.
const anonFnCtxHandlerSuffix = anonFnCtxSuffix + "_handler" // Anon fn identifier suffix for ctx allocation handler.
const anyTypeIdent = "__jule_any_type"
const deallocatedTypeIdent = "__jule_type_deallocator"
const traitMethodWrapperPrefix = "__jule_trait_method_wrapper_"

// coSpawn prefix should take suffix before offset data
// example: coSpawnPrefix + coSpawnMethodSuffix + offsetString
//
// argData structure:
//   the argData structure will be generated by function parameters.
//   Each function parameter will be mapped as: coSpawnArgDataParam + offsetString
//   The first parameter always will be a Jule function pointer wrapper.
//   The function parameter name is always will be coSpawnArgDataFunc.
const coSpawnPrefix = "__jule_cospawn"  // general for coSpawn data
const coSpawnMethodSuffix = "_method"   // method suffix for coSpawn data prefix
const coSpawnArgDataSuffix = "_argdata" // argdata suffix for coSpawn data prefix
const coSpawnArgDataParam = "__juleCoParam"
const coSpawnArgDataFunc = "__juleCoFunc"

const structDefaultEqMethodSuffix = "_eq"
const indentKind = '\t'

// General pointer type for GC pointers.
static mut generalGCPtr = &sema::TypeKind{
	Kind: &sema::Sptr{
		Elem: &sema::TypeKind{
			Kind: &sema::Prim{
				Kind: types::TypeKind.Uintptr,
			},
		},
	},
}

struct SerializationInfo {
	Compiler:        str
	CompilerCommand: str
}

struct traitCast {
	t1: &sema::Trait
	t2: &sema::Trait
}

struct anonHash {
	expr:  &sema::AnonFnExprModel
	ident: str
}

struct metadata {
	concurrent: bool // Whether built-in concurrency used.
}

struct ObjectCoder {
	// Internal buffer which is commonly used.
	Buf: strings::Builder

	resultDecls: strings::Builder // Struct wrappers for multi-ret function types.
	anyObj:      strings::Builder // Type handlers and others for the <any> type.
	anonObj:     strings::Builder // Anonymous functions.
	deallocObj:  strings::Builder // Deallocation function for [self.deallocated] types.
	coSpawnObj:  strings::Builder // Wrapper defines for co-spawns.

	ir:          &obj::IR
	info:        SerializationInfo
	anons:       []&anonHash
	deallocated: []&sema::TypeKind // GC deallocated types for dynamic programming.

	// Current indentation.
	indentBuffer: []byte

	resultMap:    map[str]bool
	anyTypeMap:   []&sema::TypeKind
	traitCastMap: []traitCast
	coSpawnMap:   []&sema::FnIns

	// Pairs for methods and structure instances.
	// Used to avoid duplicated wrapper function generation.
	traitMetMap: map[&sema::FnIns][]uintptr

	ec: &exprCoder
	sc: &scopeCoder
	tc: &typeCoder

	headPos: int
	declPos: int
	wrapPos: int

	meta: metadata
}

impl ObjectCoder {
	static fn New(mut &ir: &obj::IR, info: SerializationInfo): &ObjectCoder {
		mut oc := &ObjectCoder{
			ir: ir,
			info: info,
			resultMap: {},
			traitMetMap: {},
		}
		oc.ec = exprCoder.new(oc)
		oc.sc = scopeCoder.new(oc)
		oc.tc = typeCoder.new(oc)
		ret oc
	}

	fn write(mut &self, s: str) {
		self.Buf.WriteStr(s)
	}

	fn writeBytes(mut &self, b: []byte) {
		self.Buf.Write(b)
	}

	// Increase indentation.
	fn addIndent(mut &self) {
		self.indentBuffer = append(self.indentBuffer, indentKind)
	}

	// Decrase indentation.
	fn doneIndent(mut &self) {
		self.indentBuffer = self.indentBuffer[:len(self.indentBuffer)-1]
	}

	// Writes indention string by indentBuffer.
	fn indent(mut &self) {
		self.Buf.Write(self.indentBuffer)
	}

	fn findAnyType(mut &self, mut &t: &sema::TypeKind): int {
		for (i, mut at) in self.anyTypeMap {
			if at.Equal(t) {
				ret i
			}
		}
		ret -1
	}

	fn pushCoSpawn(mut &self, mut f: &sema::FnIns): int {
		for i, sf in self.coSpawnMap {
			if len(sf.Params) == len(f.Params) {
				for j, sp in sf.Params {
					if !sp.Kind.Equal(sf.Params[j].Kind) {
						break
					}
				}
				ret i
			}
		}
		i := len(self.coSpawnMap)
		is := conv::Itoa(i)
		self.coSpawnMap = append(self.coSpawnMap, f)
		self.coSpawnObj.WriteStr("struct ")
		self.coSpawnObj.WriteStr(coSpawnPrefix + coSpawnArgDataSuffix)
		self.coSpawnObj.WriteStr(is)
		self.coSpawnObj.WriteStr("{\n")

		// setup func data
		self.coSpawnObj.WriteByte(indentKind)
		self.tc.func(self.coSpawnObj, f)
		self.coSpawnObj.WriteByte(' ')
		self.coSpawnObj.WriteStr(coSpawnArgDataFunc)
		self.coSpawnObj.WriteByte(';')
		self.coSpawnObj.WriteByte('\n')

		// setup argument data
		for (j, mut p) in f.Params {
			self.coSpawnObj.WriteByte(indentKind)
			self.tc.kind(self.coSpawnObj, p.Kind)
			self.coSpawnObj.WriteByte(' ')
			self.coSpawnObj.WriteStr(coSpawnArgDataParam)
			self.coSpawnObj.WriteStr(conv::Itoa(j))
			self.coSpawnObj.WriteByte(';')
			self.coSpawnObj.WriteByte('\n')
		}
		self.coSpawnObj.WriteByte('}')
		self.coSpawnObj.WriteByte(';')
		self.coSpawnObj.WriteByte('\n')

		match {
		| build::Os == build::DistOs.Windows:
			self.coSpawnObj.WriteStr("unsigned long ")
		| build::IsUnix(build::Os):
			self.coSpawnObj.WriteStr("void *")
		|:
			panic("cxx: pushCoSpawn: unimeplemented operating system for return type")
		}
		self.coSpawnObj.WriteStr(coSpawnPrefix + coSpawnMethodSuffix)
		self.coSpawnObj.WriteStr(is)
		const argData = "__jule_argdata"
		self.coSpawnObj.WriteStr("(void *")
		self.coSpawnObj.WriteStr(argData)
		self.coSpawnObj.WriteStr("_param) {\n")
		self.coSpawnObj.WriteByte(indentKind)
		self.coSpawnObj.WriteStr(coSpawnPrefix + coSpawnArgDataSuffix)
		self.coSpawnObj.WriteStr(is)
		self.coSpawnObj.WriteStr(" *")
		self.coSpawnObj.WriteStr(argData)
		self.coSpawnObj.WriteStr(" = (")
		self.coSpawnObj.WriteStr(coSpawnPrefix + coSpawnArgDataSuffix)
		self.coSpawnObj.WriteStr(is)
		self.coSpawnObj.WriteStr("*)")
		self.coSpawnObj.WriteStr(argData)
		self.coSpawnObj.WriteStr("_param;\n")
		self.coSpawnObj.WriteByte(indentKind)
		self.coSpawnObj.WriteStr(argData)
		self.coSpawnObj.WriteStr("->")
		self.coSpawnObj.WriteStr(coSpawnArgDataFunc)
		self.coSpawnObj.WriteStr("(")

		// pass arguments
		for j in f.Params {
			self.coSpawnObj.WriteStr(argData)
			self.coSpawnObj.WriteStr("->")
			self.coSpawnObj.WriteStr(coSpawnArgDataParam)
			self.coSpawnObj.WriteStr(conv::Itoa(j))
			if len(f.Params)-j > 1 {
				self.coSpawnObj.WriteStr(", ")
			}
		}
		self.coSpawnObj.WriteStr(");\n")

		self.coSpawnObj.WriteByte(indentKind)
		self.coSpawnObj.WriteStr("delete ")
		self.coSpawnObj.WriteStr(argData)
		self.coSpawnObj.WriteStr(";\n")
		match {
		| build::Os == build::DistOs.Windows:
			self.coSpawnObj.WriteByte(indentKind)
			self.coSpawnObj.WriteStr("return 0;\n")
		| build::IsUnix(build::Os):
			self.coSpawnObj.WriteByte(indentKind)
			self.coSpawnObj.WriteStr("return NULL;\n")
		|:
			panic("cxx: pushCoSpawn: unimeplemented operating system for return type")
		}
		self.coSpawnObj.WriteStr("}\n")

		ret i
	}

	fn pushDealloc(mut &self, mut t: &sema::TypeKind): int {
		for i, dt in self.deallocated {
			if dt.Equal(t) {
				ret i
			}
		}
		i := len(self.deallocated)
		self.deallocated = append(self.deallocated, t)
		self.deallocObj.WriteStr("void " + deallocatedTypeIdent)
		self.deallocObj.WriteStr(conv::Itoa(i))
		self.deallocObj.WriteStr("(jule::Ptr<jule::Uintptr> &alloc) noexcept { alloc.__as<")
		self.tc.kind(self.deallocObj, t)
		self.deallocObj.WriteStr(">().dealloc(); }\n")
		ret i
	}

	fn pushAnonFn(mut &self, mut &m: &sema::AnonFnExprModel): (ident: str) {
		self.meta.concurrent = self.meta.concurrent || m.Func.CalledCo

		closure := obj::IsClosure(m)
		if closure { // Closure?
			// Handle identifier and generate ctx.
			self.anonObj.WriteStr("struct ")
			l := self.anonObj.Len()
			self.anonObj.WriteStr("__jule_anon_")
			self.anonObj.WriteStr(conv::FmtUint(u64(uintptr(m.Func)), 0xF))
			ident = str(unsafe { self.anonObj.Buf()[l:] })
			self.anonObj.WriteStr(anonFnCtxSuffix + "{\n")
			for (_, mut v) in m.Captured {
				self.anonObj.WriteByte(indentKind) // 1x indent
				self.tc.kind(self.anonObj, v.Kind.Kind)
				self.anonObj.WriteByte(' ')
				if v.Reference {
					self.anonObj.WriteByte('*')
				}
				identCoder.var(self.anonObj, v)
				self.anonObj.WriteStr(";\n")
			}
			self.anonObj.WriteStr("};\n")

			// Ctx handler function.
			self.anonObj.WriteStr("static void ")
			self.anonObj.WriteStr(ident)
			self.anonObj.WriteStr(anonFnCtxHandlerSuffix + "(jule::Ptr<" + typeCoder.Uintptr + "> &ptr) { ptr.__as<")
			self.anonObj.WriteStr(ident)
			self.anonObj.WriteStr(anonFnCtxSuffix + ">().dealloc(); }\n")
		} else {
			ident = "__jule_anon"
			ident += conv::FmtUint(u64(uintptr(m.Func)), 0xF)
		}

		// Anonymous function.
		self.anons = append(self.anons, &anonHash{expr: m, ident: ident})
		self.anonFuncInsDecl(m, ident)
		self.anonObj.WriteByte('\n')
		ret
	}

	fn pushAnyType(mut &self, mut t: &sema::TypeKind): int {
		mut orig := t
		if t.Enum() != nil {
			t = t.Enum().Kind.Kind
		}
		mut i := self.findAnyType(t)
		if i != -1 {
			ret i
		}
		i = len(self.anyTypeMap)
		self.anyTypeMap = append(self.anyTypeMap, t)
		si := conv::Itoa(i)
		if t.Sptr() != nil {
			mut elemKind := strings::Builder.New(40)
			self.tc.kind(elemKind, t.Sptr().Elem)

			// Deallocator function.
			di := self.pushDealloc(t.Sptr().Elem)

			// Type structure.
			self.anyObj.WriteStr("struct " + typeCoder.Any + "::Type ")
			self.anyObj.WriteStr(anyTypeIdent)
			self.anyObj.WriteStr(si)
			self.anyObj.WriteStr("{.dealloc=" + deallocatedTypeIdent)
			self.anyObj.WriteStr(conv::Itoa(di))
			self.anyObj.WriteStr(", .eq=__jule_ptrEqual, .to_str=__jule_ptrToStr};\n")

			// comparison function.
			self.anyObj.WriteStr(typeCoder.Bool + " " + anyTypeIdent)
			self.anyObj.WriteStr(si)
			self.anyObj.WriteStr("_compare(const " + typeCoder.Any + " &any, const ")
			self.tc.asSptr(self.anyObj, unsafe { elemKind.Buf() })
			self.anyObj.WriteStr(" &other) { return any.type == &" + anyTypeIdent)
			self.anyObj.WriteStr(si)
			self.anyObj.WriteStr(" && __jule_ptrEqual(any.data.alloc, other.alloc); }\n")
		} else {
			mut kindB := strings::Builder.New(40)
			self.tc.kind(kindB, t)
			kind := kindB.Str()

			// Deallocator function.
			di := self.pushDealloc(t)

			// eq function.

			// Common model for custom expressions.
			mut lmodel := "*reinterpret_cast<"
			lmodel += kind
			lmodel += "*>("
			mut rmodel := lmodel
			rmodel += "other)"
			lmodel += "alloc)"

			self.anyObj.WriteStr(typeCoder.Bool + " " + anyTypeIdent)
			self.anyObj.WriteStr(si)
			self.anyObj.WriteStr("_eq(void *alloc, void *other) noexcept { ")
			if t.Comparable() {
				self.anyObj.WriteStr("return ")
				self.ec._unsafeBinary(self.anyObj, lmodel, rmodel, t, t, lex::TokenId.Eqs, lex::TokenKind.Eqs)
				self.anyObj.WriteStr("; }\n")
			} else {
				self.anyObj.WriteStr(`__jule_panic((`)
				self.anyObj.WriteStr(typeCoder.U8)
				self.anyObj.WriteStr(`*)"runtime: comparing uncomparable type " "`)
				mut n := self.anyObj.Len()
				cstrBytes(self.anyObj, t.Str())
				n = self.anyObj.Len() - n
				n += 37 // offset of message prefix
				self.anyObj.WriteStr("\", ")
				self.anyObj.WriteStr(conv::Itoa(n))
				self.anyObj.WriteStr("); return false; }\n")
			}

			// to_str function.
			self.anyObj.WriteStr(typeCoder.Str + " " + anyTypeIdent)
			self.anyObj.WriteStr(si)
			self.anyObj.WriteStr("_to_str(void *alloc) noexcept { return ")
			mut decl := obj::RuntimeFindFn(self.ir.Runtime, obj::RuntimeFunc.toStr)
			mut f := obj::FindFnGenericInstance(decl, orig)
			identCoder.funcIns(self.anyObj, f)
			self.anyObj.WriteStr("(*reinterpret_cast<")
			if t.Ptr() == nil {
				self.anyObj.WriteStr("const ")
				self.anyObj.WriteStr(kind)
			} else {
				self.anyObj.WriteStr(kind)
				self.anyObj.WriteStr("* const")
			}
			self.anyObj.WriteStr("*>(alloc)); }\n")

			// Type structure.
			self.anyObj.WriteStr("struct " + typeCoder.Any + "::Type ")
			self.anyObj.WriteStr(anyTypeIdent)
			self.anyObj.WriteStr(si)
			self.anyObj.WriteStr("{.dealloc=" + deallocatedTypeIdent)
			self.anyObj.WriteStr(conv::Itoa(di))
			self.anyObj.WriteStr(", .eq=" + anyTypeIdent)
			self.anyObj.WriteStr(si)
			self.anyObj.WriteStr("_eq, .to_str=" + anyTypeIdent)
			self.anyObj.WriteStr(si)
			self.anyObj.WriteStr("_to_str};\n")
		}
		ret i
	}

	fn pushResultIns(mut &self, mut &f: &sema::FnIns) {
		s := str(self.tc.rc.code(f.Result))
		_, ok := self.resultMap[s]
		if ok {
			ret
		}
		self.resultMap[s] = false
		self.resultDecls.WriteStr("struct ")
		self.resultDecls.WriteStr(s)
		self.resultDecls.WriteStr(" {\n")
		for (i, mut t) in f.Result.Tup().Types {
			self.resultDecls.WriteByte(indentKind)
			self.tc.kind(self.resultDecls, t)
			self.resultDecls.WriteByte(' ')
			self.resultDecls.WriteStr(resultArgName)
			self.resultDecls.WriteStr(conv::Itoa(i))
			self.resultDecls.WriteStr(";\n")
		}
		self.resultDecls.WriteStr("};\n")
	}

	fn pushResult(mut &self, mut &f: &sema::Fn) {
		if f.IsVoid() || len(f.Result.Idents) <= 1 {
			ret
		}
		mut n := len(f.Instances)
		if len(f.Generics) == 0 {
			n = 1
		}
		for (_, mut ins) in f.Instances[:n] {
			self.pushResultIns(ins)
		}
	}

	fn pushAndWriteMaskMapper(mut &self, mut t1: &sema::Trait, mut t2: &sema::Trait) {
		mut ident := strings::Builder.New(1 << 5)
		ident.WriteStr("__jule_trait_offset_mapper_")
		ident.WriteStr(conv::FmtUint(u64(uintptr(t2)), 0xF))
		ident.WriteStr("_to_")
		ident.WriteStr(conv::FmtUint(u64(uintptr(t1)), 0xF))
		self.Buf.Write(unsafe { ident.Buf() })

		// Lookup and push if this match is not exist.
		for _, m in self.traitCastMap {
			if m.t1 == t1 && m.t2 == t2 {
				ret
			}
		}

		self.traitCastMap = append(self.traitCastMap, traitCast{t1: t1, t2: t2})

		// Not exist, push.
		const data = "data"
		self.anyObj.WriteStr("void *")
		self.anyObj.Write(unsafe { ident.Buf() })
		self.anyObj.WriteStr("(const void *" + data + ") noexcept { ")

		mut t1Ident := strings::Builder.New(1 << 4)
		mut t2Ident := strings::Builder.New(1 << 4)
		identCoder.traitDecl(t1Ident, t1)
		identCoder.traitDecl(t2Ident, t2)

		for (_, mut s1) in t1.Implemented {
			for _, s2 in t2.Implemented {
				if s1 == s2 {
					for (_, mut s1i) in s1.Instances {
						i1 := obj::FindTraitTypeOffsetS(t1, s1i)
						i2 := obj::FindTraitTypeOffsetS(t2, s1i)
						self.anyObj.WriteStr("if (data == &")
						self.anyObj.Write(unsafe { t2Ident.Buf() })
						self.anyObj.WriteStr("_mptr_data")
						self.anyObj.WriteStr(conv::Itoa(i2))
						self.anyObj.WriteStr(") return &")
						self.anyObj.Write(unsafe { t1Ident.Buf() })
						self.anyObj.WriteStr("_mptr_data")
						self.anyObj.WriteStr(conv::Itoa(i1))
						self.anyObj.WriteStr("; ")
					}
				}
			}
		}
		self.anyObj.WriteStr(" __jule_panic_s(\"trait casting failed because of an implementation mistake, this is a JuleC bug\"); return nullptr; }\n")
	}

	// Writes location information of token as cstr bytes.
	fn locInfo(mut &self, &t: &lex::Token) {
		&loc := t.File.Path

		// Normalize path if production compilation enabled.
		if env::Production {
			match {
			| strings::HasPrefix(loc, build::PathStdlib):
				// Remove absolute path prefix of standard library.
				// Just keeps "std/" prefix.
				cstrBytes(self.Buf, loc[len(path::Dir(build::PathStdlib))+1:])
			| strings::HasPrefix(loc, self.ir.Root):
				// Remove absolute path prefix of root package.
				// Just keeps "[package_dir]/" prefix.
				cstrBytes(self.Buf, loc[len(path::Dir(self.ir.Root))+1:])
			|:
				cstrBytes(self.Buf, loc)
			}
		} else {
			cstrBytes(self.Buf, loc)
		}
		self.write(":")
		self.write(conv::Itoa(t.Row))
		self.write(":")
		self.write(conv::Itoa(t.Column))
	}

	fn head(mut &self) {
		time := time::Time.Now()
		abs := time.Abs()
		self.write("// Auto generated by JuleC.\n")
		self.write("// JuleC version: ")
		self.write(jule::Version)
		self.write("\n")
		self.write("// Date: ")
		self.write(conv::FmtUint(abs.Day, 10))
		self.write("/")
		self.write(conv::FmtUint(abs.Month, 10))
		self.write("/")
		self.write(conv::FmtUint(abs.Year, 10))
		self.write(" (DD/MM/YYYY) UTC\n//\n// Recomended Compile Command;\n// ")
		self.write(self.info.Compiler)
		self.write(" ")
		self.write(self.info.CompilerCommand)
		self.write("\n\n")

		if env::Production {
			self.write("#define __JULE_ENABLE__PRODUCTION\n")
		}
		if !env::RC {
			self.write("#define __JULE_DISABLE__REFERENCE_COUNTING\n")
		}
		if !env::Safety {
			self.write("#define __JULE_DISABLE__SAFETY\n")
		}

		// Include binded standard library headers here, before the API header.
		// See developer reference (4).
		self.links(true)

		self.write("\n\n#include \"")
		self.write(build::PathApi)
		self.write("\"\n\n")

		// Include user-defined headers after including API header.
		self.links(false)
	}

	fn links(mut &self, std: bool) {
		for _, used in self.ir.Used {
			match {
			| !used.Binded:
				continue
			| build::IsStdHeaderPath(used.Path):
				if !std {
					continue
				}
				self.write("#include ")
				self.write(used.Path)
				self.write("\n")
			| build::IsValidHeaderExt(path::Ext(used.Path)):
				if std {
					continue
				}
				self.write("#include \"")
				self.write(used.Path)
				self.write("\"\n")
			}
		}
	}

	fn prepareStructure(mut self, mut &s: &sema::Struct) {
		for (_, mut ins) in s.Instances {
			for (_, mut m) in ins.Methods {
				if m.Statically {
					continue
				}
				for (_, mut mins) in m.Instances {
					mut p := mins.Params[0]
					mut kind := strings::Builder.New(40)
					self.tc.kind(kind, p.Kind)
					if !p.Decl.IsRef() {
						kind.WriteStr("*")
					}
					p.Kind = &sema::TypeKind{
						Kind: &customType{
							kind: kind.Str(),
						},
					}
				}
			}
		}
	}

	fn prepareStructures(mut &self) {
		for (_, mut s) in self.ir.Ordered.Structs {
			if s.Token != nil {
				self.prepareStructure(s)
			}
		}
	}

	fn structurePlainDecl(mut &self, mut &s: &sema::Struct) {
		for (_, mut ins) in s.Instances {
			self.write("struct ")
			identCoder.structureIns(self.Buf, ins)
			self.write(";\n")
		}
	}

	fn structurePlainDecls(mut &self) {
		for (_, mut s) in self.ir.Ordered.Structs {
			if s.Token != nil {
				self.structurePlainDecl(s)
			}
		}
	}

	fn fieldDecl(mut &self, mut &f: &sema::FieldIns) {
		self.tc.kind(self.Buf, f.Kind)
		self.write(" ")
		identCoder.field(self.Buf, f.Decl)
		self.write(";")
	}

	fn structureDestructor(mut &self, mut &s: &sema::StructIns) {
		// Dispose method must be non-static
		const Static = false
		mut disposeMethod := s.FindMethod("Dispose", Static)
		mut disposed := sema::FuncPattern.Dispose(disposeMethod)
		// Call destructor if implemented.
		if !disposed {
			ret
		}
		self.write("~")
		identCoder.structureIns(self.Buf, s)
		self.write("(void) { ")
		identCoder.func(self.Buf, disposeMethod)
		self.write("(this); }")
	}

	fn structureOperatorEq(mut &self, ident: str, mut &s: &sema::StructIns, decl: bool) {
		if !defaultEq(s) {
			ret
		}
		self.write("\n")
		if opt::Inline {
			self.write("inline ")
		}
		self.write(typeCoder.Bool + " ")
		self.write(ident)
		self.write(structDefaultEqMethodSuffix)
		self.write("(")
		self.write(ident)
		self.write(" *_self_, ")
		self.write(ident)
		self.write(" _other_)")
		if decl {
			// Declaration only.
			self.write(";\n\n")
			ret
		}
		self.write(" {")
		if len(s.Fields) == 0 {
			self.write(" return true; }\n\n")
			ret
		}
		self.addIndent()
		self.write("\n")
		self.indent()
		self.write("return ")
		self.addIndent()
		mut writed := false

		// Common model for custom expressions.
		mut lmodel := "_self_->"
		mut rmodel := "_other_."

		for (_, mut f) in s.Fields {
			// Skip binded struct kinds.
			strct := f.Kind.Struct()
			if strct != nil && strct.Decl != nil && strct.Decl.Binded {
				continue
			}
			if writed {
				self.write(" &&")
			}
			writed = true
			self.write("\n")
			self.indent()

			mut fIdent := strings::Builder.New(len(f.Decl.Ident))
			identCoder.field(fIdent, f.Decl)
			lmodel += unsafe { unsafe::BytesStr(fIdent.Buf()) }
			rmodel += unsafe { unsafe::BytesStr(fIdent.Buf()) }
			self.ec._unsafeBinary(self.Buf, lmodel, rmodel, f.Kind, f.Kind, lex::TokenId.Eqs, lex::TokenKind.Eqs)
			lmodel = lmodel[:len(lmodel)-fIdent.Len()]
			rmodel = lmodel[:len(rmodel)-fIdent.Len()]
		}
		self.doneIndent()
		if !writed {
			self.write("true")
		}
		self.write(";\n")
		self.doneIndent()
		self.indent()
		self.write("}\n\n")
	}

	fn structureOperators(mut &self, mut &s: &sema::StructIns, decl: bool) {
		mut sb := strings::Builder.New(40)
		identCoder.structureIns(sb, s)
		ident := sb.Str()

		// Binary.
		self.structureOperatorEq(ident, s, decl)
	}

	fn structureInsDecl(mut &self, mut &s: &sema::StructIns) {
		for (_, mut m) in s.Methods {
			// Operator methods are declared by [structureDecl].
			if isHeadDecl(m) {
				self.funcDecl(m, false)
			}
		}
		self.write("struct ")
		identCoder.structureIns(self.Buf, s)
		self.write(" {\n")

		self.addIndent()
		for (_, mut f) in s.Fields {
			self.indent()
			self.fieldDecl(f)
			self.write("\n")
		}

		self.indent()
		self.structureDestructor(s)
		self.write("\n\n")

		self.doneIndent()
		self.indent()
		self.write("};")

		const DeclOnly = true
		self.structureOperators(s, DeclOnly)
	}

	fn structureDecl(mut &self, mut &s: &sema::Struct) {
		for (_, mut ins) in s.Instances {
			self.structureInsDecl(ins)
		}
	}

	fn structureDecls(mut &self) {
		for (_, mut s) in self.ir.Ordered.Structs {
			if s.Token != nil {
				self.structureDecl(s)
				self.write("\n")
			}
		}
	}

	fn structureMethodDecls(mut &self) {
		for (_, mut s) in self.ir.Ordered.Structs {
			if s.Token != nil {
				for (_, mut ins) in s.Instances {
					for (_, mut m) in ins.Methods {
						// Operator methods are declared by [structureDecl].
						if !isHeadDecl(m) {
							self.pushResult(m)
							self.funcDecl(m, false)
						}
					}
				}
			}
		}
	}

	// The ident parameter means this function is anon, mostly.
	// But this parameter not only for anonymous functions.
	// It also useable as custom identifiers for functions.
	fn funcHead(mut &self, mut &buf: strings::Builder, mut &f: &sema::FnIns, ptr: bool, ident: str) {
		if !ptr && opt::Inline && !f.Decl.IsEntryPoint() {
			buf.WriteStr("inline ")
		}
		self.tc.funcInsResult(buf, f)
		if ptr {
			buf.WriteStr("(*")
			identCoder.funcIns(buf, f)
			buf.WriteByte(')')
		} else {
			buf.WriteByte(' ')
			if ident == "" {
				identCoder.funcIns(buf, f)
			} else {
				buf.WriteStr(ident)
			}
		}
	}

	fn funcDeclIns(mut &self, mut &f: &sema::FnIns, ptr: bool) {
		self.meta.concurrent = self.meta.concurrent || f.CalledCo
		self.indent()
		self.funcHead(self.Buf, f, ptr, "")
		self.paramsIns(self.Buf, f)
		self.write(";\n")
	}

	fn funcDecl(mut &self, mut &f: &sema::Fn, ptr: bool) {
		for (_, mut c) in f.Instances {
			self.funcDeclIns(c, ptr)
		}
	}

	fn funcDeclTrait(mut &self, mut &f: &sema::Fn) {
		for (_, mut c) in f.Instances {
			mut k := c.Params[0].Kind
			c.Params[0].Kind = generalGCPtr
			self.funcDeclIns(c, true)
			c.Params[0].Kind = k
		}
	}

	fn funcDecls(mut &self) {
		obj::IterPackages(self.ir, fn(mut &pkg: &sema::Package) {
			obj::IterFiles(pkg, fn(mut &file: &sema::SymTab) {
				for (_, mut f) in file.Funcs {
					if !f.Binded && f.Token != nil {
						self.pushResult(f)
						self.funcDecl(f, false)
					}
				}
			})
		})
	}

	fn traitDataTypeMethods(mut &self, mut &t: &sema::Trait) {
		obj::IterTraitMethods(t, fn(mut &m: &sema::Fn) {
			mut ins := m.Instances[0]
			for (i, mut ip) in ins.Params[1:] {
				if lex::IsAnonIdent(ip.Decl.Ident) {
					ip.Decl.Ident = "_" + conv::Itoa(i)
				}
			}
			self.pushResult(m)
			self.funcDeclTrait(m)
		})
	}

	fn traitDataTypes(mut &self) {
		obj::IterPackages(self.ir, fn(mut &pkg: &sema::Package) {
			obj::IterFiles(pkg, fn(mut &file: &sema::SymTab) {
				for (_, mut t) in file.Traits {
					if t.Token == nil {
						continue
					}
					self.write("struct ")
					identCoder.traitDecl(self.Buf, t)
					self.write("MptrData")
					self.write(" {\n")
					self.addIndent()
					self.indent()
					self.write("void (*dealloc)(" + typeCoder.Ptr + "<" + typeCoder.Uintptr + ">&);\n")
					self.traitDataTypeMethods(t)
					self.doneIndent()
					self.indent()
					self.write("};\n\n")
				}
			})
		})
	}

	fn paramIns(mut &self, mut &buf: strings::Builder, mut &p: &sema::ParamIns) {
		self.tc.paramIns(buf, p)
		buf.WriteByte(' ')
		identCoder.param(buf, p.Decl)
	}

	fn paramsIns(mut &self, mut &buf: strings::Builder, mut &f: &sema::FnIns) {
		if !f.AsAnon && len(f.Params) == 0 {
			buf.WriteStr("(void)")
			ret
		}
		buf.WriteByte('(')
		if f.AsAnon {
			buf.WriteStr(ctxParamType + " " + ctxParamIdent)
			if len(f.Params) > 0 {
				buf.WriteStr(", ")
			}
		}
		for (i, mut p) in f.Params {
			self.paramIns(buf, p)
			if len(f.Params)-i > 1 {
				buf.WriteStr(", ")
			}
		}
		buf.WriteByte(')')
	}

	fn varInitExpr(mut &self, mut &v: &sema::Var, init: fn()) {
		if v.Statically {
			self.write("static ")
		}

		self.tc.kind(self.Buf, v.Kind.Kind)
		self.write(" ")
		if v.Reference {
			self.write("*")
		}
		identCoder.var(self.Buf, v)
		if init != nil {
			self.write(" = ")
			init()
		}
		self.write(";")
	}

	fn var(mut &self, mut v: &sema::Var) {
		if lex::IsIgnoreIdent(v.Ident) {
			ret
		}
		if v.Value != nil && v.Value.Expr != nil {
			if v.Value.Data.Model != nil {
				if v.Reference {
					self.varInitExpr(v, fn() {
						self.write("&(")
						self.ec.model(v.Value.Data.Model)
						self.write(")")
					})
				} else {
					self.varInitExpr(v, fn() { self.ec.possibleRefExpr(v.Value.Data.Model) })
				}
				ret
			}
			self.varInitExpr(v, nil)
			ret
		}
		if v.Reference {
			self.varInitExpr(v, fn() { self.write("nullptr") })
			ret
		}
		if shouldInitialized(v.Kind.Kind) {
			self.varInitExpr(v, fn() { self.ec.initExpr(v.Kind.Kind) })
			ret
		}
		self.varInitExpr(v, nil)
	}

	fn anonFuncInsDecl(mut &self, mut &m: &sema::AnonFnExprModel, ident: str) {
		self.funcHead(self.anonObj, m.Func, false, ident)
		self.paramsIns(self.anonObj, m.Func)
		self.anonObj.WriteByte(';')
	}

	fn anonFuncIns(mut &self, mut &m: &sema::AnonFnExprModel, ident: str) {
		self.funcHead(self.Buf, m.Func, false, ident)
		self.paramsIns(self.Buf, m.Func)
		self.write(" ")
		self.sc.anonFuncScope(m, ident)
		if m.Func.Scope != nil {
			self.write("\n\n")
		}
	}

	fn funcIns(mut &self, mut f: &sema::FnIns, ident: str) {
		self.funcHead(self.Buf, f, false, ident)
		self.paramsIns(self.Buf, f)
		self.write(" ")
		self.sc.funcScope(f)
		if f.Scope != nil {
			self.write("\n\n")
		}
	}

	fn func(mut &self, mut &f: &sema::Fn) {
		for (_, mut ins) in f.Instances {
			self.funcIns(ins, "")
		}
	}

	fn funcTrait(mut &self, &s: &sema::StructIns, mut &f: &sema::FnIns) {
		f.Scope = nil

		mut nident := strings::Builder.New(30)
		nident.WriteStr("__jule_trait_method_")
		nident.WriteStr(conv::FmtUint(u64(uintptr(f)), 0xF))
		nident.WriteStr("_")
		nident.WriteStr(conv::FmtUint(u64(uintptr(s)), 0xF))

		mut k := f.Params[0].Kind
		f.Params[0].Kind = generalGCPtr
		self.funcIns(f, nident.Str())
		f.Params[0].Kind = k
	}

	fn findTraitMetMap(mut &self, mut &m: &sema::Fn): (&sema::FnIns, bool) {
		mut mins := m.Instances[0]
		for (mut f, _) in self.traitMetMap {
			if f.Decl.Public == m.Public &&
				f.Decl.Ident == m.Ident &&
				f.EqualFn(mins) {
				ret f, true
			}
		}
		ret mins, false
	}

	fn traitWrapper(mut &self, mut &t: &sema::Trait, mut &m: &sema::Fn) {
	impls:
		for (_, mut imp) in t.Implemented {
			mut mepf, exist := self.findTraitMetMap(m)
			if exist {
				// Is handled pair?
				mut vals := self.traitMetMap[mepf]
				for _, val in vals {
					if val == uintptr(imp) {
						// Exist, skip this step.
						continue impls
					}
				}
				self.traitMetMap[mepf] = append(vals, uintptr(imp))
			} else {
				self.traitMetMap[mepf] = append(make([]uintptr, 0), uintptr(imp))
			}
			for (_, mut ins) in imp.Instances {
				self.funcTrait(ins, mepf)

				const Static = false
				mut sm := ins.FindMethod(m.Ident, Static)
				if sm == nil || len(sm.Instances) == 0 {
					ret
				}

				self.addIndent()
				self.write("{\n")
				self.indent()
				if m.Exceptional || !m.IsVoid() {
					self.write("return ")
				}
				identCoder.func(self.Buf, sm)
				self.write("(")
				self.write("_self_.as<")
				self.tc.structureIns(self.Buf, ins)
				self.write(">()")

				ptr := !m.Params[0].IsRef()
				if ptr {
					self.write(".alloc")
				}
				for _, mp in m.Params[1:] {
					self.write(", ")
					identCoder.param(self.Buf, mp)
				}
				self.write(");\n}\n")
				self.doneIndent()
			}
		}
	}

	fn traitWrappers(mut &self) {
		obj::IterPackages(self.ir, fn(mut &pkg: &sema::Package) {
			obj::IterFiles(pkg, fn(mut &file: &sema::SymTab) {
				for (_, mut t) in file.Traits {
					if len(t.Implemented) == 0 {
						continue
					}
					obj::IterTraitMethods(t, fn(mut &m: &sema::Fn) {
						self.traitWrapper(t, m)
					})
				}
			})
		})
	}

	fn traitDataMethods(mut &self, mut &t: &sema::Trait, s: &sema::StructIns) {
		obj::IterTraitMethods(t, fn(mut &m: &sema::Fn) {
			self.indent()
			self.write(".")
			identCoder.func(self.Buf, m)
			self.write("=__jule_trait_method_")
			mepf, exist := self.findTraitMetMap(m)
			if !exist {
				panic("cxx: implementation mistake, [traitDataMethods] could not found MepMap record")
			}
			self.write(conv::FmtUint(u64(uintptr(mepf)), 0xF))
			self.write("_")
			self.write(conv::FmtUint(u64(uintptr(s)), 0xF))
			self.write(",\n")
		})
	}

	fn traitData(mut &self, mut &t: &sema::Trait, i: int, mut &s: &sema::StructIns) {
		mut ident := strings::Builder.New(len(t.Ident))
		identCoder.traitDecl(ident, t)
		self.write("static ")
		self.writeBytes(unsafe { ident.Buf() })
		self.write("MptrData ")
		self.writeBytes(unsafe { ident.Buf() })
		self.write("_mptr_data")
		self.write(conv::Itoa(i))
		self.write(" {\n")
		self.addIndent()
		self.indent()
		self.write(".dealloc=" + deallocatedTypeIdent)
		self.write(conv::Itoa(self.pushDealloc(&sema::TypeKind{Kind: s})))
		self.write(",\n")
		self.traitDataMethods(t, s)
		self.doneIndent()
		self.write("};\n")
	}

	fn traitDatas(mut &self) {
		obj::IterPackages(self.ir, fn(mut &pkg: &sema::Package) {
			obj::IterFiles(pkg, fn(mut &file: &sema::SymTab) {
				for (_, mut t) in file.Traits {
					mut i := 0
					for (_, mut s) in t.Implemented {
						for (_, mut ins) in s.Instances {
							self.traitData(t, i, ins)
							i++
						}
					}
				}
			})
		})
	}

	fn globalDecls(mut &self) {
		for (_, mut v) in self.ir.Ordered.Globals {
			self.tc.kind(self.Buf, v.Kind.Kind)
			self.write(" ")
			identCoder.var(self.Buf, v)
			self.write(";\n")
		}
	}

	fn decls(mut &self) {
		self.structurePlainDecls()
		self.structureDecls()
		self.headPos = self.Buf.Len()
		self.structureMethodDecls()
		self.funcDecls()
		self.write("\n\n")
		self.traitDataTypes()
		self.write("\n\n")
		self.wrapPos = self.Buf.Len()
		self.traitWrappers()
		self.write("\n\n")
		self.traitDatas()
		self.write("\n\n")
		self.declPos = self.Buf.Len()
		self.globalDecls()
	}

	fn structureMethods(mut &self, mut &s: &sema::StructIns) {
		for (_, mut f) in s.Methods {
			self.func(f)
			self.write("\n\n")
		}
	}

	fn structureIns(mut &self, mut &s: &sema::StructIns) {
		const DeclOnly = false
		self.structureOperators(s, DeclOnly)
		self.structureMethods(s)
	}

	fn structure(mut &self, mut &s: &sema::Struct) {
		for (_, mut ins) in s.Instances {
			self.structureIns(ins)
			self.write("\n\n")
		}
	}

	fn structures(mut &self) {
		for (_, mut s) in self.ir.Ordered.Structs {
			if s.Token != nil {
				self.structure(s)
				self.write("\n\n")
			}
		}
	}

	fn funcs(mut &self) {
		obj::IterPackages(self.ir, fn(mut &pkg: &sema::Package) {
			obj::IterFiles(pkg, fn(mut &file: &sema::SymTab) {
				for (_, mut f) in file.Funcs {
					if !env::Test && obj::HasDirective(f.Directives, build::Directive.Test) {
						continue
					}
					// skip special runtime functions
					if unsafe { pkg == self.ir.Runtime.Package } {
						match f.Ident {
						| "_RCAdd" | "_RCLoad" | "_RCDrop":
							continue
						}
					}
					if !f.Binded && f.Token != nil {
						self.func(f)
						self.write("\n\n")
					}
				}
			})
		})
	}

	fn pushInit(mut &self, mut &pkg: &sema::Package) {
		obj::IterFiles(pkg, fn(mut &file: &sema::SymTab) {
			for (_, mut f) in file.Funcs {
				if f.Ident == build::InitFn {
					self.indent()
					identCoder.func(self.Buf, f)
					self.write("();\n")
				}
			}
		})
	}

	fn anonHashes(mut &self) {
		// Use recursive algorithm, because anonymous function may have
		// anonymous functions, so [self.anons] may grow.
		// Make sure whether all anonymous functions are handled.
	repeat:
		mut anons := self.anons
		self.anons = nil
		for (_, mut h) in anons {
			self.anonFuncIns(h.expr, h.ident)
		}
		if len(self.anons) > 0 {
			goto repeat
		}
	}

	fn initGlobals(mut &self) {
		for (_, mut v) in self.ir.Ordered.Globals {
			self.Buf.WriteByte(indentKind)
			identCoder.var(self.Buf, v)
			self.write(" = ")
			self.ec.model(v.Value.Data.Model)
			self.write(";\n")
		}
	}

	fn initCaller(mut &self) {
		self.write("void " + initCallerIdent + "(void) {\n")
		self.addIndent()
		obj::IterPackages(self.ir, fn(mut &pkg: &sema::Package) {
			self.pushInit(pkg)
		})
		self.doneIndent()
		self.write("\n}")
	}

	fn end(mut &self) {
		self.write(`int main(int argc, char *argv[], char *envp[]) {`)
		self.write("\n\n")
		self.initGlobals()
		self.write(`
	__jule_argc = static_cast<jule::Int>(argc);
	__jule_argv = reinterpret_cast<jule::U8**>(argv);
	__jule_envp = reinterpret_cast<jule::U8**>(envp);

	__jule_call_initializers();
	`)

		if env::Test {
			self.write("test_point();")
		} else {
			self.write("entry_point();")
		}

		self.write(`

	return EXIT_SUCCESS;
}`)
	}

	fn insertBuf(mut &self, mut &buf: strings::Builder, pos: int) {
		if buf.Len() > 0 {
			mut head := make([]byte, 0, self.Buf.Len()+buf.Len())
			head = append(head, unsafe { self.Buf.Buf() }[:pos]...)
			head = append(head, unsafe { buf.Buf() }...)
			head = append(head, unsafe { self.Buf.Buf() }[pos:]...)
			unsafe { self.Buf.SetBuf(head) }
		}
	}

	// Implement RC functions of runtime.
	// Checks concurrency state of program and updates function implementations
	// to thread-safe variants if necessary.
	fn implementRC(mut &self) {
		if self.meta.concurrent {
			// enable thread-safety for safe concurrency
			self.funcIns(obj::RuntimeFindFn(self.ir.Runtime, obj::RuntimeFunc._RCAddAtomic).Instances[0], "__jule_RCAdd")
			self.funcIns(obj::RuntimeFindFn(self.ir.Runtime, obj::RuntimeFunc._RCLoadAtomic).Instances[0], "__jule_RCLoad")
			self.funcIns(obj::RuntimeFindFn(self.ir.Runtime, obj::RuntimeFunc._RCDropAtomic).Instances[0], "__jule_RCDrop")
		} else {
			// no thread-safety
			self.funcIns(obj::RuntimeFindFn(self.ir.Runtime, obj::RuntimeFunc._RCAdd).Instances[0], "")
			self.funcIns(obj::RuntimeFindFn(self.ir.Runtime, obj::RuntimeFunc._RCLoad).Instances[0], "")
			self.funcIns(obj::RuntimeFindFn(self.ir.Runtime, obj::RuntimeFunc._RCDrop).Instances[0], "")
		}
	}

	fn serializeHead(mut &self) {
		self.prepareStructures()
		self.head()
		self.write("\n")
		self.decls()

		self.insertBuf(self.resultDecls, self.headPos)
		self.wrapPos += self.resultDecls.Len()
		self.declPos += self.resultDecls.Len()

		self.write("\n")
		self.structures()
		self.funcs()
		self.initCaller()
		self.write("\n\n")

		self.anonHashes()

		// Concurrency analysis done.
		// Implement RC functions.
		self.implementRC()

		self.insertBuf(self.deallocObj, self.wrapPos)
		self.wrapPos += self.deallocObj.Len()
		self.declPos += self.deallocObj.Len()

		self.insertBuf(self.anyObj, self.declPos)
		self.declPos += self.anyObj.Len()

		self.insertBuf(self.anonObj, self.declPos)
		self.declPos += self.anonObj.Len()

		self.insertBuf(self.coSpawnObj, self.declPos)
		self.declPos += self.coSpawnObj.Len()
	}

	fn Serialize(mut &self) {
		self.serializeHead()
		self.end()
	}
}

// Concatenate all strings into single string.
fn concatAllParts(parts: ...&lex::Token): []byte {
	mut n := 0
	for _, part in parts {
		n += len(part.Kind)
	}
	if n == 0 {
		ret nil
	}
	mut s := strings::Builder.New(n)
	for _, p in parts {
		s.WriteStr(p.Kind)
	}
	ret unsafe { s.Buf() }
}

// Reports whether the m is a method which is declarated top of the struct.
fn isHeadDecl(mut &m: &sema::Fn): bool {
	if len(m.Generics) > 0 || len(m.Instances) == 0 {
		ret false
	}
	if obj::IsOpMethod(m) {
		ret true
	}
	mut mi := m.Instances[0]
	const Static = false
	ret sema::FuncPattern.Dispose(mi.Owner.FindMethod("Dispose", Static))
}

// Reports whether structure needs default compare method.
fn defaultEq(&s: &sema::StructIns): bool {
	ret s.Comparable && s.Operators.Eq == nil
}
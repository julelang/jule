// Copyright 2024-2025 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "env"
use "obj"
use "obj/meta"
use "opt"
use "std/comptime"
use "std/conv"
use "std/jule"
use "std/jule/build"
use "std/jule/directive"
use "std/jule/dist"
use "std/jule/sema"
use "std/jule/token"
use "std/jule/types"
use "std/os/filepath"
use "std/slices"
use "std/strings"
use "std/time"

const (
	ctxParamIdent            = "__f_ctx"
	anonFuncCtxSuffix        = "_ctx"                         // Anon fn identifier suffix for ctx struct identifier.
	anonFuncCtxHandlerSuffix = anonFuncCtxSuffix + "_handler" // Anon fn identifier suffix for ctx allocation handler.
	anyTypeIdent             = "__jule_any_type"
	deallocatedTypeIdent     = "__jule_type_deallocator"
	traitMethodWrapperPrefix = "__jule_trait_method_wrapper_"
)

// coSpawn prefix should take suffix before offset data
// example: coSpawnPrefix + coSpawnMethodSuffix + offsetString
//
// argData structure:
//	the argData structure will be generated by function parameters.
//	Each function parameter will be mapped as: coSpawnArgDataParam + offsetString
//	The first parameter always will be a Jule function pointer wrapper.
//	The function parameter name is always will be coSpawnArgDataFunc.
const (
	coSpawnPrefix        = "__jule_cospawn" // general for coSpawn data
	coSpawnMethodSuffix  = "_method"        // method suffix for coSpawn data prefix
	coSpawnArgDataSuffix = "_argdata"       // argdata suffix for coSpawn data prefix
	coSpawnArgDataParam  = "__juleCoParam"
	coSpawnArgDataFunc   = "__juleCoFunc"
	coSpawnThreadData    = "__juleThread"
)

const (
	structDefaultEqMethodSuffix = "_eq"
	indentKind                  = '\t'
)

// General pointer type for GC pointers.
let mut generalGCPtr = &sema::Type{
	Kind: &sema::Sptr{
		Value: &sema::Type{
			Kind: &sema::Prim{
				Kind: types::Uintptr,
			},
		},
	},
}

struct SerializationInfo {
	Compiler:     str
	CompilerArgs: []str
}

struct traitCast {
	t1: &sema::Trait
	t2: &sema::Trait
}

struct anonHash {
	expr: &sema::AnonFuncExpr
	name: str
	mode: int // ObjectCoder mode when this anonymous function appears.
}

struct traitHash {
	traitDecl: &sema::Trait
	methods:   []&sema::Func // All unique methods of trait, including inherited ones.
}

struct metadata {
	concurrent: bool // Whether built-in concurrency used.
}

// Internal ObjectCoder modes.
const (
	_OBJC_DEFAULT          = iota            // Default configuration.
	_OBJC_DISABLE_BOUNDARY = 1 << (iota - 1) // Disable boundary checking.

	// All disable flags.
	_OBJ_DISABLE = _OBJC_DISABLE_BOUNDARY
)

struct ObjectCoder {
	mode: int

	// Internal buffer which is commonly used.
	Buf: strings::Builder

	resultProto: strings::Builder // Prototype declarations of the result declarations.
	resultDecls: strings::Builder // Struct wrappers for multi-ret function types.
	anyObj:      strings::Builder // Type handlers and others for the <any> type.
	anonObj:     strings::Builder // Anonymous functions, but also used for trait type mappers.
	deallocObj:  strings::Builder // Deallocation function for [self.deallocated] types.
	coSpawnObj:  strings::Builder // Wrapper defines for co-spawns.

	ir:          &obj::IR
	info:        SerializationInfo
	anons:       []&anonHash
	deallocated: []&sema::Type // GC deallocated types for dynamic programming.

	// Current indentation.
	indentBuffer: []byte

	resultMap:    map[str]bool
	anyTypeMap:   []&sema::Type
	traitCastMap: []traitCast
	coSpawnMap:   []&sema::FuncIns
	traitMap:     []&traitHash

	// Pairs for methods and structure instances.
	// Used to avoid duplicated wrapper function generation.
	traitMetMap: map[&sema::FuncIns][]uintptr

	ec: &exprCoder
	sc: &scopeCoder
	tc: &typeCoder

	headPos:  int
	declPos:  int
	wrapPos:  int
	plainPos: int

	meta: metadata
}

impl ObjectCoder {
	fn New(mut ir: &obj::IR, mut info: SerializationInfo): &ObjectCoder {
		mut oc := &ObjectCoder{
			mode: _OBJC_DEFAULT,
			ir: ir,
			info: info,
			resultMap: {},
			traitMetMap: {},
		}
		oc.ec = exprCoder.new(oc)
		oc.sc = scopeCoder.new(oc)
		oc.tc = typeCoder.new(oc)
		ret oc
	}

	fn write(mut &self, s: str) {
		self.Buf.WriteStr(s)!
	}

	fn writeBytes(mut &self, b: []byte) {
		self.Buf.Write(b)!
	}

	// Increase indentation.
	fn addIndent(mut &self) {
		self.indentBuffer = append(self.indentBuffer, indentKind)
	}

	// Decrase indentation.
	fn doneIndent(mut &self) {
		self.indentBuffer = self.indentBuffer[:len(self.indentBuffer)-1]
	}

	// Writes indention string by indentBuffer.
	fn indent(mut &self) {
		self.Buf.Write(self.indentBuffer)!
	}

	fn findAnyType(mut &self, mut t: &sema::Type): int {
		for (i, mut at) in self.anyTypeMap {
			if at.Equal(t) {
				ret i
			}
		}
		ret -1
	}

	fn pushCoSpawn(mut &self, mut f: &sema::FuncIns): int {
	Lookup:
		for i, sf in self.coSpawnMap {
			if len(sf.Params) == len(f.Params) {
				for j, sp in sf.Params {
					if !sp.Type.Equal(f.Params[j].Type) {
						continue Lookup
					}
				}
				ret i
			}
		}
		i := len(self.coSpawnMap)
		is := conv::Itoa(i)
		self.coSpawnMap = append(self.coSpawnMap, f)
		self.coSpawnObj.WriteStr("struct ")!
		self.coSpawnObj.WriteStr(coSpawnPrefix + coSpawnArgDataSuffix)!
		self.coSpawnObj.WriteStr(is)!
		self.coSpawnObj.WriteStr("{\n")!

		// setup thread data
		self.coSpawnObj.WriteByte(indentKind)!
		writeThreadType(&self.coSpawnObj)
		self.coSpawnObj.WriteStr(" *")!
		self.coSpawnObj.WriteStr(coSpawnThreadData)!
		self.coSpawnObj.WriteByte(';')!
		self.coSpawnObj.WriteByte('\n')!

		// setup func data
		self.coSpawnObj.WriteByte(indentKind)!
		self.tc.func(&self.coSpawnObj, f)
		self.coSpawnObj.WriteByte(' ')!
		self.coSpawnObj.WriteStr(coSpawnArgDataFunc)!
		self.coSpawnObj.WriteByte(';')!
		self.coSpawnObj.WriteByte('\n')!

		// setup argument data
		for (j, mut p) in f.Params {
			self.coSpawnObj.WriteByte(indentKind)!
			self.tc.kind(&self.coSpawnObj, p.Type)
			self.coSpawnObj.WriteByte(' ')!
			self.coSpawnObj.WriteStr(coSpawnArgDataParam)!
			self.coSpawnObj.WriteStr(conv::Itoa(j))!
			self.coSpawnObj.WriteByte(';')!
			self.coSpawnObj.WriteByte('\n')!
		}
		self.coSpawnObj.WriteByte('}')!
		self.coSpawnObj.WriteByte(';')!
		self.coSpawnObj.WriteByte('\n')!

		match {
		| dist::IsWindows(build::OS):
			self.coSpawnObj.WriteStr("unsigned long ")!
		| dist::IsUnix(build::OS):
			self.coSpawnObj.WriteStr("void *")!
		|:
			panic("cxx: pushCoSpawn: unimeplemented operating system for return type")
		}
		self.coSpawnObj.WriteStr(coSpawnPrefix + coSpawnMethodSuffix)!
		self.coSpawnObj.WriteStr(is)!
		const argData = "__jule_argdata"
		self.coSpawnObj.WriteStr("(void *")!
		self.coSpawnObj.WriteStr(argData)!
		self.coSpawnObj.WriteStr("_param) {\n")!
		self.coSpawnObj.WriteByte(indentKind)!
		self.coSpawnObj.WriteStr(coSpawnPrefix + coSpawnArgDataSuffix)!
		self.coSpawnObj.WriteStr(is)!
		self.coSpawnObj.WriteStr(" *")!
		self.coSpawnObj.WriteStr(argData)!
		self.coSpawnObj.WriteStr(" = (")!
		self.coSpawnObj.WriteStr(coSpawnPrefix + coSpawnArgDataSuffix)!
		self.coSpawnObj.WriteStr(is)!
		self.coSpawnObj.WriteStr("*)")!
		self.coSpawnObj.WriteStr(argData)!
		self.coSpawnObj.WriteStr("_param;\n")!
		self.coSpawnObj.WriteByte(indentKind)!
		self.coSpawnObj.WriteStr(argData)!
		self.coSpawnObj.WriteStr("->")!
		self.coSpawnObj.WriteStr(coSpawnArgDataFunc)!
		self.coSpawnObj.WriteStr("(")!

		// pass arguments
		for j in f.Params {
			self.coSpawnObj.WriteStr(argData)!
			self.coSpawnObj.WriteStr("->")!
			self.coSpawnObj.WriteStr(coSpawnArgDataParam)!
			self.coSpawnObj.WriteStr(conv::Itoa(j))!
			if len(f.Params)-j > 1 {
				self.coSpawnObj.WriteStr(", ")!
			}
		}
		self.coSpawnObj.WriteStr(");\n")!

		self.coSpawnObj.WriteByte(indentKind)!
		identCoder.funcIns(&self.coSpawnObj, meta::Program.Runtime.CloseThread)
		self.coSpawnObj.WriteStr("(")!
		self.coSpawnObj.WriteStr(argData)!
		self.coSpawnObj.WriteStr("->")!
		self.coSpawnObj.WriteStr(coSpawnThreadData)!
		self.coSpawnObj.WriteStr(");\n")!
		self.coSpawnObj.WriteByte(indentKind)!
		self.coSpawnObj.WriteStr("delete ")!
		self.coSpawnObj.WriteStr(argData)!
		self.coSpawnObj.WriteStr(";\n")!
		match {
		| build::OS == dist::Windows:
			self.coSpawnObj.WriteByte(indentKind)!
			self.coSpawnObj.WriteStr("return 0;\n")!
		| dist::IsUnix(build::OS):
			self.coSpawnObj.WriteByte(indentKind)!
			self.coSpawnObj.WriteStr("return NULL;\n")!
		|:
			panic("cxx: pushCoSpawn: unimeplemented operating system for return type")
		}
		self.coSpawnObj.WriteStr("}\n")!

		ret i
	}

	fn pushDealloc(mut &self, mut t: &sema::Type): int {
		for i, dt in self.deallocated {
			if dt.Equal(t) {
				ret i
			}
		}
		i := len(self.deallocated)
		self.deallocated = append(self.deallocated, t)
		self.deallocObj.WriteStr("void " + deallocatedTypeIdent)!
		self.deallocObj.WriteStr(conv::Itoa(i))!
		self.deallocObj.WriteStr("(jule::Ptr<jule::Uintptr> &alloc) noexcept { alloc.__as<")!
		// We handling map and channel types as smart pointer,
		// because this kind types implemented as smart pointers
		// at machine code level.
		match {
		| t.Sptr() != nil:
			self.tc.kind(&self.deallocObj, t.Sptr().Value)
		| t.Map() != nil:
			mp := t.Map()
			mut mps := obj::FindStructGenericInstance(meta::Program.Runtime.Map, mp.Key, mp.Value)
			self.tc.structureIns(&self.deallocObj, mps)
		| t.Chan() != nil:
			ch := t.Chan()
			mut chs := obj::FindStructGenericInstance(meta::Program.Runtime.Pchan, ch.Value)
			self.tc.structureIns(&self.deallocObj, chs)
		|:
			self.tc.kind(&self.deallocObj, t)
		}
		self.deallocObj.WriteStr(">().dealloc(); }\n")!
		ret i
	}

	fn pushAnonFunc(mut &self, mut m: &sema::AnonFuncExpr): (name: str) {
		self.meta.concurrent = self.meta.concurrent || m.Func.CalledCo

		closure := obj::IsClosure(m)
		if closure { // Closure?
			// Handle identifier and generate ctx.
			self.anonObj.WriteStr("struct ")!
			l := self.anonObj.Len()
			self.anonObj.WriteStr("__jule_anon_")!
			self.anonObj.WriteStr(conv::FormatUint(u64(uintptr(m.Func)), 0xF))!
			name = str(unsafe { self.anonObj.Buf()[l:] })
			self.anonObj.WriteStr(anonFuncCtxSuffix + "{\n")!
			for (_, mut v) in m.Captured {
				self.anonObj.WriteByte(indentKind)! // 1x indent
				self.tc.kind(&self.anonObj, v.TypeSym.Type)
				self.anonObj.WriteByte(' ')!
				identCoder.anonFuncVar(&self.anonObj, v)
				self.anonObj.WriteStr(";\n")!
			}
			self.anonObj.WriteStr("};\n")!

			// Ctx handler function.
			self.anonObj.WriteStr("static void ")!
			self.anonObj.WriteStr(name)!
			self.anonObj.WriteStr(anonFuncCtxHandlerSuffix + "(jule::Ptr<" + typeUintptr + "> &ptr) { ptr.__as<")!
			self.anonObj.WriteStr(name)!
			self.anonObj.WriteStr(anonFuncCtxSuffix + ">().dealloc(); }\n")!
		} else {
			name = "__jule_anon"
			name += conv::FormatUint(u64(uintptr(m.Func)), 0xF)
		}

		// Anonymous function.
		self.anons = append(self.anons, &anonHash{expr: m, name: name, mode: self.mode})
		self.anonFuncInsDecl(m, name)
		self.anonObj.WriteByte('\n')!
		ret
	}

	fn pushAnyType(mut &self, mut t: &sema::Type): (i: int) {
		i = self.findAnyType(t)
		if i != -1 {
			ret
		}
		i = len(self.anyTypeMap)
		self.anyTypeMap = append(self.anyTypeMap, t)
		si := conv::Itoa(i)
		// We handling map and channel types as smart pointer,
		// because this kind types implemented as smart pointers
		// at machine code level.
		match {
		| t.Sptr() != nil | t.Chan() != nil:
			// Deallocator function.
			di := self.pushDealloc(t)

			mut sptr := t.Sptr()

			// Whether we have to use generic runtime stringer function.
			runtimeToStr := t.SoftStruct() != nil || sptr != nil && sptr.Value.SoftStruct() != nil

			// Write to_str function.
			// If type is a soft struct type, or element of smart pointer is,
			// we have to use runtime string conversion function, because it
			// might be have custom stringer function.
			if runtimeToStr {
				self.anyObj.WriteStr(typeStr + " " + anyTypeIdent)!
				self.anyObj.WriteStr(si)!
				self.anyObj.WriteStr("_to_str(void *alloc) noexcept { ")!
				mut f := obj::FindFuncGenericInstanceNoPanic(meta::Program.Runtime.ToStr, t)
				// If function f is nil, it have not to implement runtime string function.
				// This means program will not use in any case this function.
				// Otherwise, it means the compiler have issues for analysis.
				if f == nil {
					// This method should be unused.
					// Implement as a panic call to help debugging.
					self.anyObj.WriteStr(`__jule_panicStr(__jule_strBytePtr((jule::U8*)"runtime: type data have not string conversion data but used at runtime", 70)); }` + "\n")!
				} else {
					self.anyObj.WriteStr("return ")!
					identCoder.funcIns(&self.anyObj, f)
					self.anyObj.WriteStr("(")!
					// If type is a smart pointer, we have to point to element.
					// See memory model of dynamic types.
					if sptr != nil {
						self.tc.kind(&self.anyObj, t)
						self.anyObj.WriteStr("::make(reinterpret_cast<")!
						self.tc.kind(&self.anyObj, sptr.Value)
						self.anyObj.WriteStr("*>(alloc), nullptr)); }\n")!
					} else {
						self.anyObj.WriteStr("*reinterpret_cast<")!
						self.tc.kind(&self.anyObj, t)
						self.anyObj.WriteStr("*>(alloc)); }\n")!
					}
				}
			}

			// Type structure.
			self.anyObj.WriteStr("struct " + typeAny + "::Type ")!
			self.anyObj.WriteStr(anyTypeIdent)!
			self.anyObj.WriteStr(si)!
			self.anyObj.WriteStr("{.dealloc=" + deallocatedTypeIdent)!
			self.anyObj.WriteStr(conv::Itoa(di))!
			self.anyObj.WriteStr(", .hash=__jule_priv_dynhash, .eq=__jule_ptrEqual, .to_str=")!
			if runtimeToStr {
				self.anyObj.WriteStr(anyTypeIdent)!
				self.anyObj.WriteStr(si)!
				self.anyObj.WriteStr("_to_str")!
			} else {
				self.anyObj.WriteStr("__jule_ptrToStr")!
			}
			self.anyObj.WriteStr("};\n")!

			// comparison function.
			self.anyObj.WriteStr(typeBool + " " + anyTypeIdent)!
			self.anyObj.WriteStr(si)!
			self.anyObj.WriteStr("_compare(" + typeAny + " &any, void *type, ")!
			self.tc.kind(&self.anyObj, t)
			self.anyObj.WriteStr(" other) { return any.type == type && __jule_ptrEqual(any.data.alloc, other.alloc); }\n")!
		| t.Map() != nil:
			// Consider map as a smart pointer.
			// But it supports content-based string conversion unlike channels.
			// Channels are just handled like pointers, no difference.
			// But we have to handle special cases of maps here.
			mp := t.Map()
			mut mps := obj::FindStructGenericInstance(meta::Program.Runtime.Map, mp.Key, mp.Value)

			// Get deallocator function based on map type for unique distribution.
			di := self.pushDealloc(t)

			// eq function. Map is not comparable, so panic if called.
			{
				self.anyObj.WriteStr(typeBool + " " + anyTypeIdent)!
				self.anyObj.WriteStr(si)!
				self.anyObj.WriteStr("_eq(void *alloc, void *other) noexcept { __jule_panic((")!
				self.anyObj.WriteStr(typeU8)!
				self.anyObj.WriteStr(`*)"runtime: comparing uncomparable type " "`)!
				mut n := self.anyObj.Len()
				cstrBytes(&self.anyObj, t.Str())
				n = self.anyObj.Len() - n
				n += 37 // offset of message prefix
				self.anyObj.WriteStr("\", ")!
				self.anyObj.WriteStr(conv::Itoa(n))!
				self.anyObj.WriteStr("); return false; }\n")!
			}

			// to_str function.
			self.anyObj.WriteStr(typeStr + " " + anyTypeIdent)!
			self.anyObj.WriteStr(si)!
			self.anyObj.WriteStr("_to_str(void *alloc) noexcept { ")!
			mut f := obj::FindFuncGenericInstanceNoPanic(meta::Program.Runtime.ToStr, t)
			// If function f is nil, it have not to implement runtime string function.
			// This means program will not use in any case this function.
			// Otherwise, it means the compiler have issues for analysis.
			if f == nil {
				// This method should be unused.
				// Implement as a panic call to help debugging.
				self.anyObj.WriteStr(`__jule_panicStr(__jule_strBytePtr((jule::U8*)"runtime: type data have not string conversion data but used at runtime", 70)); }` + "\n")!
			} else {
				self.anyObj.WriteStr("return ")!
				identCoder.funcIns(&self.anyObj, f)
				self.anyObj.WriteStr("(")!
				self.tc.kind(&self.anyObj, t)
				self.anyObj.WriteStr("::make((")!
				self.tc.structureIns(&self.anyObj, mps)
				self.anyObj.WriteStr("*)alloc, nullptr)); }\n")!
			}

			// Type structure.
			self.anyObj.WriteStr("struct " + typeAny + "::Type ")!
			self.anyObj.WriteStr(anyTypeIdent)!
			self.anyObj.WriteStr(si)!
			self.anyObj.WriteStr("{.dealloc=" + deallocatedTypeIdent)!
			self.anyObj.WriteStr(conv::Itoa(di))!
			self.anyObj.WriteStr(", .hash=nullptr, .eq=" + anyTypeIdent)!
			self.anyObj.WriteStr(si)!
			self.anyObj.WriteStr("_eq, .to_str=" + anyTypeIdent)!
			self.anyObj.WriteStr(si)!
			self.anyObj.WriteStr("_to_str};\n")!

			// comparison function.
			self.anyObj.WriteStr(typeBool + " " + anyTypeIdent)!
			self.anyObj.WriteStr(si)!
			self.anyObj.WriteStr("_compare(" + typeAny + " &any, void *type, ")!
			self.tc.kind(&self.anyObj, t)
			self.anyObj.WriteStr(" other) { return any.type == type && __jule_ptrEqual(any.data.alloc, other.alloc); }\n")!
		|:
			mut kindB := strings::Builder{}
			self.tc.kind(&kindB, t)
			kind := kindB.Str()

			// Deallocator function.
			di := self.pushDealloc(t)

			// Hasher function.
			comparable := t.Comparable()
			mut hashhable := false
			if comparable {
				// Lookup hasher function for the type with no panic.
				// Because trait data may push type t as dynamic type, but this
				// type may be not used, so we have not any possible hashing by dynamic type.
				mut f := obj::FindFuncGenericInstanceNoPanic(meta::Program.Runtime.Maphash, t)
				if f != nil {
					hashhable = true
					self.anyObj.WriteStr(typeUintptr + " " + anyTypeIdent)!
					self.anyObj.WriteStr(si)!
					self.anyObj.WriteStr("_hash(jule::Ptr<jule::Uintptr> *ptr, jule::Uintptr seed) noexcept { return ")!
					identCoder.funcIns(&self.anyObj, f)
					self.anyObj.WriteStr("(*reinterpret_cast<")!
					self.anyObj.WriteStr(kind)!
					self.anyObj.WriteStr("*>(ptr->alloc), seed); }\n")!
				}
			}

			// eq function.

			// Common model for custom expressions.
			mut lmodel := "*reinterpret_cast<"
			lmodel += kind
			lmodel += "*>("
			mut rmodel := lmodel
			rmodel += "other)"
			lmodel += "alloc)"

			self.anyObj.WriteStr(typeBool + " " + anyTypeIdent)!
			self.anyObj.WriteStr(si)!
			self.anyObj.WriteStr("_eq(void *alloc, void *other) noexcept { ")!
			if comparable {
				self.anyObj.WriteStr("return ")!
				self.ec._unsafeBinaryNoDynamic(&self.anyObj, lmodel, rmodel, t, t, token::EQL, "==")
				self.anyObj.WriteStr("; }\n")!
			} else {
				self.anyObj.WriteStr(`__jule_panic((`)!
				self.anyObj.WriteStr(typeU8)!
				self.anyObj.WriteStr(`*)"runtime: comparing uncomparable type " "`)!
				mut n := self.anyObj.Len()
				cstrBytes(&self.anyObj, t.Str())
				n = self.anyObj.Len() - n
				n += 37 // offset of message prefix
				self.anyObj.WriteStr("\", ")!
				self.anyObj.WriteStr(conv::Itoa(n))!
				self.anyObj.WriteStr("); return false; }\n")!
			}

			// to_str function.
			self.anyObj.WriteStr(typeStr + " " + anyTypeIdent)!
			self.anyObj.WriteStr(si)!
			self.anyObj.WriteStr("_to_str(void *alloc) noexcept { ")!
			mut f := obj::FindFuncGenericInstanceNoPanic(meta::Program.Runtime.ToStr, t)
			// If function f is nil, it have not to implement runtime string function.
			// This means program will not use in any case this function.
			// Otherwise, it means the compiler have issues for analysis.
			if f == nil {
				// This method should be unused.
				// Implement as a panic call to help debugging.
				self.anyObj.WriteStr(`__jule_panicStr(__jule_strBytePtr((jule::U8*)"runtime: type data have not string conversion data but used at runtime", 70)); }` + "\n")!
			} else {
				self.anyObj.WriteStr("return ")!
				identCoder.funcIns(&self.anyObj, f)
				self.anyObj.WriteStr("(*reinterpret_cast<")!
				self.anyObj.WriteStr(kind)!
				self.anyObj.WriteStr("*>(alloc)); }\n")!
			}

			// Type structure.
			self.anyObj.WriteStr("struct " + typeAny + "::Type ")!
			self.anyObj.WriteStr(anyTypeIdent)!
			self.anyObj.WriteStr(si)!
			self.anyObj.WriteStr("{.dealloc=" + deallocatedTypeIdent)!
			self.anyObj.WriteStr(conv::Itoa(di))!
			if hashhable {
				self.anyObj.WriteStr(", .hash=" + anyTypeIdent)!
				self.anyObj.WriteStr(si)!
				self.anyObj.WriteStr("_hash")!
			} else {
				self.anyObj.WriteStr(", .hash=nullptr")!
			}
			self.anyObj.WriteStr(", .eq=" + anyTypeIdent)!
			self.anyObj.WriteStr(si)!
			self.anyObj.WriteStr("_eq, .to_str=" + anyTypeIdent)!
			self.anyObj.WriteStr(si)!
			self.anyObj.WriteStr("_to_str};\n")!

			// comparison function.
			self.anyObj.WriteStr(typeBool + " " + anyTypeIdent)!
			self.anyObj.WriteStr(si)!
			self.anyObj.WriteStr("_compare(" + typeAny + " &any, void *type, ")!
			self.tc.kind(&self.anyObj, t)
			self.anyObj.WriteStr(" other) { return any.type == type && any.type->eq(any.data.alloc, (void*)&other); }\n")!
		}
		ret i
	}

	fn pushResultIns(mut &self, mut f: &sema::FuncIns) {
		s := str(self.tc.rc.code(f.Result))
		_, ok := self.resultMap[s]
		if ok {
			ret
		}
		self.resultMap[s] = false
		self.resultProto.WriteStr("struct ")!
		self.resultDecls.WriteStr("struct ")!
		self.resultDecls.WriteStr(s)!
		self.resultProto.WriteStr(s)!
		self.resultProto.WriteStr(";\n")!
		self.resultDecls.WriteStr(" {\n")!
		for (i, mut t) in f.Result.Tuple().Types {
			self.resultDecls.WriteByte(indentKind)!
			self.tc.kind(&self.resultDecls, t)
			self.resultDecls.WriteByte(' ')!
			self.resultDecls.WriteStr(resultArgName)!
			self.resultDecls.WriteStr(conv::Itoa(i))!
			self.resultDecls.WriteStr(";\n")!
		}
		self.resultDecls.WriteStr("};\n")!
	}

	fn pushResult(mut &self, mut f: &sema::Func) {
		if f.IsVoid() || len(f.Result.Names) <= 1 {
			ret
		}
		mut n := len(f.Instances)
		if len(f.Generics) == 0 {
			n = 1
		}
		for (_, mut ins) in f.Instances[:n] {
			self.pushResultIns(ins)
		}
	}

	// See memory handling of traits to understand trait type handling.
	// https://manual.jule.dev/memory/memory-model#traits
	fn pushAndWriteMaskMapper(mut &self, mut t1: &sema::Trait, mut t2: &sema::Trait) {
		mut ident := strings::Builder{}
		ident.Grow(1 << 5)
		ident.WriteStr("__jule_trait_offset_mapper_")!
		ident.WriteStr(conv::FormatUint(u64(uintptr(t2)), 0xF))!
		ident.WriteStr("_to_")!
		ident.WriteStr(conv::FormatUint(u64(uintptr(t1)), 0xF))!
		self.Buf.Write(unsafe { ident.Buf() })!

		// Lookup and push if this match is not exist.
		for _, m in self.traitCastMap {
			if m.t1 == t1 && m.t2 == t2 {
				ret
			}
		}

		self.traitCastMap = append(self.traitCastMap, traitCast{t1: t1, t2: t2})

		// Not exist, push.
		const data = "data"
		self.anonObj.WriteStr("void *")!
		self.anonObj.Write(unsafe { ident.Buf() })!
		self.anonObj.WriteStr("(const void *" + data + ") noexcept { ")!

		mut t1Ident := strings::Builder{}
		mut t2Ident := strings::Builder{}
		identCoder.traitDecl(&t1Ident, t1)
		identCoder.traitDecl(&t2Ident, t2)

		for (_, mut s1) in t1.Implemented {
			for _, s2 in t2.Implemented {
				if s1 == s2 {
					for (_, mut s1i) in s1.Instances {
						i1 := obj::FindTraitTypeOffsetS(t1, s1i)
						i2 := obj::FindTraitTypeOffsetS(t2, s1i)
						// For: Type.
						self.anonObj.WriteStr("if (data == &")!
						self.anonObj.Write(unsafe { t2Ident.Buf() })!
						self.anonObj.WriteStr("_mptr_data")!
						self.anonObj.WriteStr(conv::Itoa(i2))!
						self.anonObj.WriteStr(") return &")!
						self.anonObj.Write(unsafe { t1Ident.Buf() })!
						self.anonObj.WriteStr("_mptr_data")!
						self.anonObj.WriteStr(conv::Itoa(i1))!
						self.anonObj.WriteStr("; ")!
						// For: &Type.
						self.anonObj.WriteStr("if (data == &")!
						self.anonObj.Write(unsafe { t2Ident.Buf() })!
						self.anonObj.WriteStr("_mptr_data")!
						self.anonObj.WriteStr(conv::Itoa(i2 + 1))!
						self.anonObj.WriteStr(") return &")!
						self.anonObj.Write(unsafe { t1Ident.Buf() })!
						self.anonObj.WriteStr("_mptr_data")!
						self.anonObj.WriteStr(conv::Itoa(i1 + 1))!
						self.anonObj.WriteStr("; ")!
					}
				}
			}
		}
		self.anonObj.WriteStr("__jule_panicStr(")!
		strLit(&self.anonObj, "trait casting failed because of an implementation mistake, this is a JuleC bug", "78")
		self.anonObj.WriteStr("); return nullptr; }\n")!
	}

	// Writes location information of token as cstr bytes.
	// Returns count of written bytes.
	fn locInfo(mut &self, t: &token::Token): (n: int) {
		loc := t.File.Path

		// Normalize path if production compilation enabled.
		if env::Production {
			match {
			| strings::HasPrefix(loc, build::PathStdlib()):
				// Remove absolute path prefix of standard library.
				// Just keeps "std/" prefix.
				path := loc[len(filepath::Dir(build::PathStdlib()))+1:]
				n = len(path)
				cstrBytes(&self.Buf, path)
			| strings::HasPrefix(loc, self.ir.Root):
				// Remove absolute path prefix of root package.
				// Just keeps "[PackageDirectory]/" prefix.
				path := loc[len(filepath::Dir(self.ir.Root))+1:]
				n = len(path)
				cstrBytes(&self.Buf, path)
			|:
				n = len(loc)
				cstrBytes(&self.Buf, loc)
			}
		} else {
			n = len(loc)
			cstrBytes(&self.Buf, loc)
		}
		self.write(":")
		n++
		mut i := conv::Itoa(t.Row)
		n += len(i)
		self.write(i)
		self.write(":")
		n++
		i = conv::Itoa(t.Column)
		n += len(i)
		self.write(i)
		ret
	}

	fn head(mut &self) {
		t := time::Now()
		self.write("// Auto generated by JuleC.\n")
		self.write("// JuleC version: ")
		self.write(jule::Version)
		self.write("\n")
		self.write("// Time: ")
		self.write(t.Format("2006-01-02 (YYYY/MM/DD) 3:04PM MST"))
		self.write("\n//\n// Recommended Compile Command;\n// ")
		self.write(self.info.Compiler)
		for _, arg in self.info.CompilerArgs {
			self.write(" ")
			self.write(arg)
		}
		self.write("\n\n")

		if env::Production {
			self.write("#define __JULE_ENABLE__PRODUCTION\n")
		}
		if !env::RC {
			self.write("#define __JULE_DISABLE__REFERENCE_COUNTING\n")
		}
		if !env::Safety {
			self.write("#define __JULE_DISABLE__SAFETY\n")
		}

		// Include binded standard library headers here, before the API header.
		// See developer reference (4).
		self.links(true)

		self.write("\n\n#include \"")
		self.write(build::PathAPI())
		self.write("\"\n\n")

		// Include user-defined headers after including API header.
		self.links(false)
	}

	fn links(mut &self, std: bool) {
		for _, used in self.ir.Used {
			match {
			| !used.Bind:
				continue
			| build::IsStdHeaderPath(used.Path):
				if !std {
					continue
				}
				self.write("#include ")
				self.write(used.Path)
				self.write("\n")
			| build::IsValidHeaderExt(filepath::Ext(used.Path)):
				if std {
					continue
				}
				self.write("#include \"")
				self.write(used.Path)
				self.write("\"\n")
			}
		}
	}

	fn prepareStructure(mut self, mut s: &sema::Struct) {
		for (_, mut ins) in s.Instances {
			for (_, mut m) in ins.Methods {
				if m.Static {
					continue
				}
				for (_, mut mins) in m.Instances {
					mut p := mins.Params[0]
					mut kind := strings::Builder{}
					self.tc.kind(&kind, p.Type)
					if !p.Decl.IsRef() {
						kind.WriteStr("*")!
					}
					p.Type = &sema::Type{
						Kind: &customType{
							kind: kind.Str(),
						},
					}
				}
			}
		}
	}

	fn prepareStructures(mut &self) {
		for (_, mut s) in self.ir.Ordered.Structs {
			if s.Token != nil {
				self.prepareStructure(s)
			}
		}
	}

	fn structurePlainDecl(mut &self, mut s: &sema::Struct) {
		for (_, mut ins) in s.Instances {
			self.write("struct ")
			identCoder.structureIns(&self.Buf, ins)
			self.write(";\n")
		}
	}

	fn structurePlainDecls(mut &self) {
		for (_, mut s) in self.ir.Ordered.Structs {
			if s.Token != nil {
				self.structurePlainDecl(s)
			}
		}
	}

	fn fieldDecl(mut &self, mut f: &sema::FieldIns) {
		self.tc.kind(&self.Buf, f.Type)
		self.write(" ")
		identCoder.field(&self.Buf, f.Decl)
		self.write(";")
	}

	fn structureOperatorEq(mut &self, name: str, mut s: &sema::StructIns, decl: bool) {
		if !s.Comparable {
			ret
		}
		self.write("\n")
		if opt::Inline {
			self.write("inline ")
		}
		self.write(typeBool + " ")
		self.write(name)
		self.write(structDefaultEqMethodSuffix)
		self.write("(")
		self.write(name)
		self.write(" *_self_, ")
		self.write(name)
		self.write(" _other_)")
		if decl {
			// Declaration only.
			self.write(";\n\n")
			ret
		}
		self.write(" {")
		if len(s.Fields) == 0 {
			self.write(" return true; }\n\n")
			ret
		}
		self.addIndent()
		self.write("\n")
		self.indent()
		self.write("return ")
		self.addIndent()
		mut written := false

		// Common model for custom expressions.
		mut lmodel := "_self_->"
		mut rmodel := "_other_."

		for (_, mut f) in s.Fields {
			// Skip binded struct kinds.
			strct := f.Type.Struct()
			if strct != nil && strct.Decl != nil && strct.Decl.Bind {
				continue
			}
			if written {
				self.write(" &&")
			}
			written = true
			self.write("\n")
			self.indent()

			mut fName := strings::Builder{}
			identCoder.field(&fName, f.Decl)
			lmodel += fName.Str()
			rmodel += fName.Str()
			self.ec._unsafeBinaryNoDynamic(&self.Buf, lmodel, rmodel, f.Type, f.Type, token::EQL, "==")
			lmodel = lmodel[:len(lmodel)-fName.Len()]
			rmodel = rmodel[:len(rmodel)-fName.Len()]
		}
		self.doneIndent()
		if !written {
			self.write("true")
		}
		self.write(";\n")
		self.doneIndent()
		self.indent()
		self.write("}\n\n")
	}

	fn structureOperators(mut &self, mut s: &sema::StructIns, decl: bool) {
		mut sb := strings::Builder{}
		identCoder.structureIns(&sb, s)
		ident := sb.Str()

		// Binary.
		self.structureOperatorEq(ident, s, decl)
	}

	fn structureInsDecl(mut &self, mut s: &sema::StructIns) {
		self.write("struct ")
		identCoder.structureIns(&self.Buf, s)
		self.write(" {\n")

		self.addIndent()
		for (_, mut f) in s.Fields {
			self.indent()
			self.fieldDecl(f)
			self.write("\n")
		}

		self.doneIndent()
		self.indent()
		self.write("};")

		const DeclOnly = true
		self.structureOperators(s, DeclOnly)
	}

	fn structureDecl(mut &self, mut s: &sema::Struct) {
		for (_, mut ins) in s.Instances {
			self.structureInsDecl(ins)
		}
	}

	fn structureDecls(mut &self) {
		for (_, mut s) in self.ir.Ordered.Structs {
			if s.Token != nil {
				self.structureDecl(s)
				self.write("\n")
			}
		}
	}

	fn structureMethodDecls1(mut &self, mut s: &sema::Struct) {
		for (_, mut ins) in s.Instances {
			for (_, mut m) in ins.Methods {
				self.pushResult(m)
				self.funcDecl(m, false)
			}
		}
	}

	fn structureMethodDecls(mut &self) {
		for (_, mut s) in self.ir.Ordered.Structs {
			if s.Token != nil {
				self.structureMethodDecls1(s)
			}
		}
	}

	// The identifier parameter means this function is anon, mostly.
	// But this parameter not only for anonymous functions.
	// It also useable as custom identifiers for functions.
	fn funcHead(mut &self, mut &buf: *strings::Builder, mut f: &sema::FuncIns, ptr: bool, name: str) {
		if !ptr && opt::Inline && !f.Decl.IsEntryPoint() {
			buf.WriteStr("inline ")!
		}
		self.tc.funcInsResult(buf, f)
		if ptr {
			buf.WriteStr("(*")!
			identCoder.funcIns(buf, f)
			buf.WriteByte(')')!
		} else {
			buf.WriteByte(' ')!
			if name == "" {
				identCoder.funcIns(buf, f)
			} else {
				buf.WriteStr(name)!
			}
		}
	}

	fn funcDeclIns(mut &self, mut f: &sema::FuncIns, ptr: bool) {
		self.meta.concurrent = self.meta.concurrent || f.CalledCo
		self.indent()
		self.funcHead(&self.Buf, f, ptr, "")
		self.paramsIns(&self.Buf, f)
		self.write(";\n")
	}

	fn funcDecl(mut &self, mut f: &sema::Func, ptr: bool) {
		for (_, mut c) in f.Instances {
			self.funcDeclIns(c, ptr)
		}
	}

	fn funcDeclTrait(mut &self, mut f: &sema::Func) {
		for (_, mut c) in f.Instances {
			mut k := c.Params[0].Type
			c.Params[0].Type = generalGCPtr
			self.funcDeclIns(c, true)
			c.Params[0].Type = k
		}
	}

	fn funcDecls(mut &self) {
		obj::IterPackages(self.ir, fn|mut pkg| {
			obj::IterFiles(pkg, fn|mut file| {
				for (_, mut f) in file.Funcs {
					if !f.Bind && f.Token != nil {
						self.pushResult(f)
						self.funcDecl(f, false)
					}
				}
			})
		})
	}

	fn traitDataTypeMethods(mut &self, mut hash: &traitHash) {
		for (_, mut m) in hash.methods {
			mut ins := m.Instances[0]
			for (i, mut ip) in ins.Params[1:] {
				if jule::IsAnon(ip.Decl.Name) {
					ip.Decl.Name = "_" + conv::Itoa(i)
				}
			}
			self.pushResult(m)
			self.funcDeclTrait(m)
		}
	}

	// See memory handling of traits to understand trait type handling.
	// https://manual.jule.dev/memory/memory-model#traits
	fn traitDataTypes(mut &self) {
		for (_, mut hash) in self.traitMap {
			self.write("struct ")
			identCoder.traitDecl(&self.Buf, hash.traitDecl)
			self.write("MptrData {\n")
			self.addIndent()

			// The type Any is also a trait data container for Jule's traits.
			// The `type` field points to `jule::Trait::Type` for deallocation ant etc.,
			// but it actually points to static data for trait's runtime data type if type is trait.
			// So, compiler may cast it to actual data type to use it. Therefore,
			// the first field of the static data is should be always common function pointers.
			self.indent()
			self.write("void(*dealloc)(jule::Ptr < jule::Uintptr > &alloc);\n")
			self.indent()
			self.write("jule::Uintptr (*hash)(jule::Ptr<jule::Uintptr> *hash, jule::Uintptr seed);\n")
			self.indent()
			self.write("jule::Bool(*eq)(void*alloc, void*other);\n")
			self.indent()
			self.write("jule::Str(*to_str)(void * alloc);\n")

			self.traitDataTypeMethods(hash)
			self.doneIndent()
			self.indent()
			self.write("};\n\n")
		}
	}

	fn paramIns(mut &self, mut &buf: *strings::Builder, mut p: &sema::ParamIns) {
		self.tc.paramIns(buf, p)
		buf.WriteByte(' ')!
		identCoder.param(buf, p.Decl)
	}

	fn paramsIns(mut &self, mut &buf: *strings::Builder, mut f: &sema::FuncIns) {
		if !f.AsAnon && len(f.Params) == 0 {
			buf.WriteStr("(void)")!
			ret
		}
		buf.WriteByte('(')!
		if f.AsAnon {
			buf.WriteStr(ctxParamType + " " + ctxParamIdent)!
			if len(f.Params) > 0 {
				buf.WriteStr(", ")!
			}
		}
		for (i, mut p) in f.Params {
			self.paramIns(buf, p)
			if len(f.Params)-i > 1 {
				buf.WriteStr(", ")!
			}
		}
		buf.WriteByte(')')!
	}

	fn varInitExpr(mut &self, mut v: &sema::Var, init: fn()) {
		if v.Static {
			self.write("static ")
		}

		self.tc.kind(&self.Buf, v.TypeSym.Type)
		self.write(" ")
		identCoder.var(&self.Buf, v)
		if init != nil {
			self.write(" = ")
			init()
		}
		self.write(";")
	}

	fn commonVarInit(mut &self, mut v: &sema::Var) {
		mut fc := isExceptionalResult(v.ValueSym.Value.Model)
		if fc != nil {
			self.ec.handleExceptionalCallWithData(fc, useExprMemory{
				DestType: v.TypeSym.Type,
				Model: v,
				Type: useExprPlain,
				OpId: token::ASSIGN,
				OpKind: "=",
			})
		} else {
			identCoder.var(&self.Buf, v)
			self.write(" = ")
			self.ec.possibleRefExpr(v.ValueSym.Value.Model)
			self.write(";")
		}
	}

	fn var(mut &self, mut v: &sema::Var) {
		if jule::IsBlank(v.Name) {
			ret
		}
		if v.ValueSym != nil && v.ValueSym.Expr != nil {
			if v.ValueSym.Value.Model != nil {
				if v.Static {
					self.varInitExpr(v, fn|| self.ec.possibleRefExpr(v.ValueSym.Value.Model))
				} else {
					self.varInitExpr(v, nil)
					self.write(" ")
					self.commonVarInit(v)
				}
				ret
			}
			self.varInitExpr(v, nil)
			ret
		}
		if shouldInitialized(v.TypeSym.Type) {
			self.varInitExpr(v, fn|| self.ec.initExpr(v.TypeSym.Type))
			ret
		}
		self.varInitExpr(v, nil)
	}

	fn anonFuncInsDecl(mut &self, mut m: &sema::AnonFuncExpr, name: str) {
		self.funcHead(&self.anonObj, m.Func, false, name)
		self.paramsIns(&self.anonObj, m.Func)
		self.anonObj.WriteByte(';')!
	}

	fn anonFuncIns(mut &self, mut m: &sema::AnonFuncExpr, name: str) {
		self.funcHead(&self.Buf, m.Func, false, name)
		self.paramsIns(&self.Buf, m.Func)
		self.write(" ")
		self.sc.anonFuncScope(m, name)
		if m.Func.Scope != nil {
			self.write("\n\n")
		}
	}

	fn funcIns(mut &self, mut f: &sema::FuncIns, name: str) {
		self.funcHead(&self.Buf, f, false, name)
		self.paramsIns(&self.Buf, f)
		self.write(" ")
		self.sc.funcScope(f)
		if f.Scope != nil {
			self.write("\n\n")
		}
	}

	fn func(mut &self, mut f: &sema::Func) {
		for (_, mut ins) in f.Instances {
			self.funcIns(ins, "")
		}
	}

	fn funcTrait(mut &self, s: &sema::StructIns, mut f: &sema::FuncIns) {
		f.Scope = nil

		mut nname := strings::Builder{}
		nname.Grow(30)
		nname.WriteStr("__jule_trait_method_")!
		nname.WriteStr(conv::FormatUint(u64(uintptr(f)), 0xF))!
		nname.WriteStr("_")!
		nname.WriteStr(conv::FormatUint(u64(uintptr(s)), 0xF))!

		mut k := f.Params[0].Type
		f.Params[0].Type = generalGCPtr
		self.funcIns(f, nname.Str())
		f.Params[0].Type = k
	}

	fn findTraitMetMap(mut &self, mut m: &sema::Func): (&sema::FuncIns, bool) {
		mut mins := m.Instances[0]
		for (mut f, _) in self.traitMetMap {
			if f.Decl.Public == m.Public &&
				f.Decl.Name == m.Name &&
				f.EqualFunc(mins, false) {
				ret f, true
			}
		}
		ret mins, false
	}

	// See memory handling of traits to understand trait type handling.
	// https://manual.jule.dev/memory/memory-model#traits
	fn traitWrapper(mut &self, mut t: &sema::Trait, mut m: &sema::Func) {
	impls:
		for (_, mut imp) in t.Implemented {
			mut mepf, exist := self.findTraitMetMap(m)
			if exist {
				// Is handled pair?
				mut vals := self.traitMetMap[mepf]
				for _, val in vals {
					if val == uintptr(imp) {
						// Exist, skip this step.
						continue impls
					}
				}
				self.traitMetMap[mepf] = append(vals, uintptr(imp))
			} else {
				self.traitMetMap[mepf] = append(make([]uintptr, 0), uintptr(imp))
			}
			for (_, mut ins) in imp.Instances {
				self.funcTrait(ins, mepf)

				const Static = false
				mut sm := ins.FindMethod(m.Name, Static)
				if sm == nil || len(sm.Instances) == 0 {
					ret
				}

				self.addIndent()
				self.write("{\n")
				self.indent()
				if m.Exceptional || !m.IsVoid() {
					self.write("return ")
				}
				identCoder.func(&self.Buf, sm)
				self.write("(")
				mut ptr := !m.Params[0].IsRef()
				// Structure uses source type. Handle it.
				if ins.Source != nil {
					// Use the actual type for the allocation handling.
					mut act := &sema::Type{Kind: ins.Source.ActualKind()}
					// We handling map and channel types as smart pointer,
					// because this kind types implemented as smart pointers
					// at machine code level.
					//
					// Smart pointers:
					//	If method uses pass-by-reference self parameter and
					//	source type is smart pointer, by Jule Memory Model,
					//	trait uses base smart pointer of the allocation.
					//	So cast to element type for correct handling.
					//	Then pass address of the temporary variable to receiver.
					if ptr && act.Sptr() != nil {
						self.write("((jule::Ptr<")
						self.tc.kind(&self.Buf, act.Sptr().Value)
						self.write(">*)&_self_)")
						ptr = false // Avoid ".alloc" suffix. We have a pointer already.
					} else if ptr && act.Map() != nil {
						self.write("((jule::Ptr<")
						mp := act.Map()
						mut mps := obj::FindStructGenericInstance(meta::Program.Runtime.Map, mp.Key, mp.Value)
						self.tc.structureIns(&self.Buf, mps)
						self.write(">*)&_self_)")
						ptr = false // Avoid ".alloc" suffix. We have a pointer already.
					} else if ptr && act.Chan() != nil {
						self.write("((jule::Ptr<")
						ch := act.Chan()
						mut chs := obj::FindStructGenericInstance(meta::Program.Runtime.Pchan, ch.Value)
						self.tc.structureIns(&self.Buf, chs)
						self.write(">*)&_self_)")
						ptr = false // Avoid ".alloc" suffix. We have a pointer already.
					} else {
						// Function uses smart pointer self parameter.
						// By Jule Memory Model, trait uses base smart pointer
						// of the allocation. So cast to full type directly.
						self.write("_self_.as<")
						self.tc.kind(&self.Buf, act)
						self.write(">()")
					}
				} else {
					// Structure is plain. Use the type directly.
					self.write("_self_.as<")
					self.tc.structureIns(&self.Buf, ins)
					self.write(">()")
				}
				if ptr {
					self.write(".alloc")
				}
				for _, mp in m.Params[1:] {
					self.write(", ")
					identCoder.param(&self.Buf, mp)
				}
				self.write(");\n}\n")
				self.doneIndent()
			}
		}
	}

	fn traitWrappers(mut &self) {
		for (_, mut hash) in self.traitMap {
			if len(hash.traitDecl.Implemented) == 0 {
				continue
			}
			for (_, mut m) in hash.methods {
				self.traitWrapper(hash.traitDecl, m)
			}
		}
	}

	// Generates wrapper methods object code for the implemented structure.
	fn traitDataMethods(mut &self, mut hash: &traitHash, s: &sema::StructIns) {
		for (_, mut m) in hash.methods {
			self.indent()
			self.write(".")
			identCoder.func(&self.Buf, m)
			self.write("=__jule_trait_method_")
			mepf, exist := self.findTraitMetMap(m)
			if !exist {
				panic("cxx: implementation mistake, [traitDataMethods] could not found MepMap record")
			}
			self.write(conv::FormatUint(u64(uintptr(mepf)), 0xF))
			self.write("_")
			self.write(conv::FormatUint(u64(uintptr(s)), 0xF))
			self.write(",\n")
		}
	}

	// Generates VTM (virtual method table) object code for the traitHash.
	//
	// See memory handling of traits to understand trait type handling.
	// https://manual.jule.dev/memory/memory-model#traits
	fn traitDataForHash(mut &self, mut hash: &traitHash, i: int, mut s: &sema::StructIns) {
		mut name := strings::Builder{}
		identCoder.traitDecl(&name, hash.traitDecl)
		// For: Type.
		{
			mut j := self.pushAnyType(&sema::Type{Kind: s})
			self.write("static ")
			self.writeBytes(unsafe { name.Buf() })
			self.write("MptrData ")
			self.writeBytes(unsafe { name.Buf() })
			self.write("_mptr_data")
			self.write(conv::Itoa(i))
			self.write(" {\n")
			self.addIndent()

			// Store common data of the any type specification.
			// See: traitDataTypes method for details.
			mut jtoa := conv::Itoa(j)
			self.indent()
			self.write(".dealloc=" + anyTypeIdent + jtoa + ".dealloc,\n")
			self.indent()
			self.write(".hash=" + anyTypeIdent + jtoa + ".hash,\n")
			self.indent()
			self.write(".eq=" + anyTypeIdent + jtoa + ".eq,\n")
			self.indent()
			self.write(".to_str=" + anyTypeIdent + jtoa + ".to_str,\n")

			self.traitDataMethods(hash, s)
			self.doneIndent()
			self.write("};\n")
		}
		// For: &Type.
		{
			mut j := self.pushAnyType(&sema::Type{Kind: &sema::Sptr{Value: &sema::Type{Kind: s}}})
			self.write("static ")
			self.writeBytes(unsafe { name.Buf() })
			self.write("MptrData ")
			self.writeBytes(unsafe { name.Buf() })
			self.write("_mptr_data")
			self.write(conv::Itoa(i + 1))
			self.write(" {\n")
			self.addIndent()

			// Store common data of the any type specification.
			// See: traitDataTypes method for details.
			mut jtoa := conv::Itoa(j)
			self.indent()
			self.write(".dealloc=" + anyTypeIdent + jtoa + ".dealloc,\n")
			self.indent()
			self.write(".hash=" + anyTypeIdent + jtoa + ".hash,\n")
			self.indent()
			self.write(".eq=" + anyTypeIdent + jtoa + ".eq,\n")
			self.indent()
			self.write(".to_str=" + anyTypeIdent + jtoa + ".to_str,\n")

			self.traitDataMethods(hash, s)
			self.doneIndent()
			self.write("};\n")
		}
		ret
	}

	// Generates VTM (virtual method table) object code for traits.
	fn traitData(mut &self) {
		for (_, mut hash) in self.traitMap {
			mut i := 0
			for (_, mut s) in hash.traitDecl.Implemented {
				for (_, mut ins) in s.Instances {
					self.traitDataForHash(hash, i, ins)
					i += 2
				}
			}
		}
	}

	fn globalDecls(mut &self) {
		for (_, mut v) in self.ir.Ordered.Globals {
			// Skip blank identifiers, do not declare them.
			// Initialization expressions will be executed when variables initializing.
			if jule::IsBlank(v.Name) {
				continue
			}
			self.tc.kind(&self.Buf, v.TypeSym.Type)
			self.write(" ")
			identCoder.var(&self.Buf, v)
			self.write(";\n")
		}
	}

	fn decls(mut &self) {
		self.structurePlainDecls()
		self.plainPos = self.Buf.Len()
		self.structureDecls()
		self.headPos = self.Buf.Len()
		self.structureMethodDecls()
		self.funcDecls()
		self.write("\n\n")
		self.traitDataTypes()
		self.write("\n\n")
		self.wrapPos = self.Buf.Len()
		self.traitWrappers()
		self.write("\n\n")
		self.traitData()
		self.write("\n\n")
		self.declPos = self.Buf.Len()
		self.globalDecls()
	}

	fn structureMethods(mut &self, mut s: &sema::StructIns) {
		for (_, mut f) in s.Methods {
			self.func(f)
			self.write("\n\n")
		}
	}

	fn structureIns(mut &self, mut s: &sema::StructIns) {
		if s.Source == nil {
			// source type will implement
			const DeclOnly = false
			self.structureOperators(s, DeclOnly)
		}
		self.structureMethods(s)
	}

	fn structure(mut &self, mut s: &sema::Struct) {
		for (_, mut ins) in s.Instances {
			self.structureIns(ins)
			self.write("\n\n")
		}
	}

	fn structures(mut &self) {
		for (_, mut s) in self.ir.Ordered.Structs {
			if s.Token != nil {
				self.structure(s)
				self.write("\n\n")
			}
		}
	}

	fn funcs(mut &self) {
		obj::IterPackages(self.ir, fn|mut pkg| {
			obj::IterFiles(pkg, fn|mut file| {
				for (_, mut f) in file.Funcs {
					if !env::Test && obj::HasDirective(f.Directives, directive::Test) {
						continue
					}
					// skip special runtime functions
					if unsafe { pkg == self.ir.Runtime.Package } {
						match f.Name {
						| "_RCAdd" | "_RCLoad" | "_RCDrop":
							continue
						}
					}
					if !f.Bind && f.Token != nil {
						self.func(f)
						self.write("\n\n")
					}
				}
			})
		})
	}

	fn pushInit(mut &self, mut pkg: &sema::Package) {
		obj::IterFiles(pkg, fn|mut file| {
			for (_, mut f) in file.Funcs {
				if f.Name == jule::InitFunc {
					self.indent()
					identCoder.func(&self.Buf, f)
					self.write("();\n")
				}
			}
		})
	}

	fn anonHashes(mut &self) {
		// Save the current mode and restore before return.
		mode := self.mode
		defer { self.mode = mode }

		// Use recursive algorithm, because anonymous function may have
		// anonymous functions, so [self.anons] may grow.
		// Make sure whether all anonymous functions are handled.
	repeat:
		mut anons := self.anons
		self.anons = nil
		for (_, mut h) in anons {
			self.mode = h.mode
			self.anonFuncIns(h.expr, h.name)
		}
		if len(self.anons) > 0 {
			goto repeat
		}
	}

	fn initGlobals(mut &self) {
		for (_, mut v) in self.ir.Ordered.Globals {
			// Skip special cases
			if v == meta::Program.Runtime.Threads ||
				v == meta::Program.Runtime.NumCPU ||
				v == meta::Program.Runtime.Argc ||
				v == meta::Program.Runtime.Argv ||
				v == meta::Program.Runtime.Envp {
				continue
			}
			self.Buf.WriteByte(indentKind)!
			// If variable have blank identifier, just execute the initialization expression.
			if jule::IsBlank(v.Name) {
				self.ec.model(v.ValueSym.Value.Model)
				self.write(";\n")
				continue
			}
			self.commonVarInit(v)
			self.write(";\n")
		}
	}

	fn initCaller(mut &self) {
		self.write("void " + initCallerIdent + "(void) {\n")
		self.addIndent()
		obj::IterPackages(self.ir, fn|mut pkg| self.pushInit(pkg))
		self.doneIndent()
		self.write("\n}")
	}

	fn end(mut &self) {
		self.addIndent()
		self.write(`int main(int argc, char *argv[], char *envp[]) {
	__jule_argc = static_cast<jule::Int>(argc);
	__jule_argv = reinterpret_cast<jule::U8**>(argv);
	__jule_envp = reinterpret_cast<jule::U8**>(envp);

	`)
		identCoder.funcIns(&self.Buf, meta::Program.Runtime.Init)
		self.write("();\n\n")
		self.initGlobals()
		self.write(`
	__jule_call_initializers();
	`)

		if env::Test {
			self.write("test_point();")
		} else {
			identCoder.func(&self.Buf, meta::Program.EntryPoint)
			self.write("();")
		}

		self.write(`

	return EXIT_SUCCESS;
}`)

		self.anonHashes()

		// Concurrency analysis done.
		// Implement RC functions.
		self.implementRC()

		self.insertBuf(&self.resultDecls, self.headPos)
		self.wrapPos += self.resultDecls.Len()
		self.declPos += self.resultDecls.Len()

		self.insertBuf(&self.resultProto, self.plainPos)
		self.headPos += self.resultProto.Len()
		self.wrapPos += self.resultProto.Len()
		self.declPos += self.resultProto.Len()

		self.insertBuf(&self.deallocObj, self.wrapPos)
		self.wrapPos += self.deallocObj.Len()
		self.declPos += self.deallocObj.Len()

		self.insertBuf(&self.anyObj, self.wrapPos)
		self.wrapPos += self.deallocObj.Len()
		self.declPos += self.anyObj.Len()

		self.insertBuf(&self.anonObj, self.declPos)
		self.declPos += self.anonObj.Len()

		self.insertBuf(&self.coSpawnObj, self.declPos)
		self.declPos += self.coSpawnObj.Len()

		self.doneIndent()
	}

	fn buildTraitHash(mut &self, mut t: &sema::Trait) {
		mut hash := &traitHash{
			traitDecl: t,
			methods: make([]&sema::Func, 0, len(t.Methods)),
		}
		obj::IterTraitMethods(t, fn|mut m| {
			// lookup and do not add already exist methods
			for _, em in hash.methods {
				if em == m {
					ret
				}
			}
			// m is not exist in hash.methods
			hash.methods = append(hash.methods, m)
		})
		self.traitMap = append(self.traitMap, hash)
	}

	fn buildTraitHashes(mut &self) {
		obj::IterPackages(self.ir, fn|mut pkg| {
			obj::IterFiles(pkg, fn|mut file| {
				for (_, mut t) in file.Traits {
					if t.Token != nil {
						self.buildTraitHash(t)
					}
				}
			})
		})
	}

	fn insertBuf(mut &self, mut &buf: *strings::Builder, pos: int) {
		if buf.Len() > 0 {
			mut ibuf := unsafe { self.Buf.Buf() }
			ibuf = slices::Insert(ibuf, pos, unsafe { buf.Buf()... })
			unsafe { self.Buf.SetBuf(ibuf) }
		}
	}

	// Implement RC functions of runtime.
	// Checks concurrency state of program and updates function implementations
	// to thread-safe variants if necessary.
	fn implementRC(mut &self) {
		if self.meta.concurrent {
			// enable thread-safety for safe concurrency
			self.funcIns(meta::Program.Runtime.RCAddAtomic, "__jule_RCAdd")
			self.funcIns(meta::Program.Runtime.RCLoadAtomic, "__jule_RCLoad")
			self.funcIns(meta::Program.Runtime.RCDropAtomic, "__jule_RCDrop")
		} else {
			// no thread-safety
			self.funcIns(meta::Program.Runtime.RCAdd, "")
			self.funcIns(meta::Program.Runtime.RCLoad, "")
			self.funcIns(meta::Program.Runtime.RCDrop, "")
		}
	}

	fn serializeHead(mut &self) {
		self.buildTraitHashes()
		self.prepareStructures()
		self.head()
		self.write("\n")
		self.decls()

		self.write("\n")
		self.structures()
		self.funcs()
		self.initCaller()
		self.write("\n\n")
	}

	fn Serialize(mut &self) {
		self.serializeHead()
		self.end()
	}
}

// Concatenate all strings into single string.
fn concatAllParts(parts: ...&token::Token): []byte {
	mut n := 0
	for _, part in parts {
		n += len(part.Kind)
	}
	if n == 0 {
		ret nil
	}
	mut s := strings::Builder{}
	s.Grow(n)
	for _, p in parts {
		s.WriteStr(p.Kind)!
	}
	ret unsafe { s.Buf() }
}

// Writes thread data type for Jule's runtime thread handling.
// See runtime::coSpawn function for documentation.
fn writeThreadType(mut &b: *strings::Builder) {
	match {
	| dist::IsWindows(build::OS):
		b.WriteStr("HANDLE")!
	| dist::IsUnix(build::OS):
		b.WriteStr("pthread_t")!
	|:
		panic("unreachable")
	}
}
// Copyright 2023-2025 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "env"
use "obj"
use "obj/meta"
use "opt"
use "std/conv"
use "std/jule/constant"
use "std/jule/sema"
use "std/jule/token"
use "std/strings"
use "std/unsafe"

const (
	closureCtxIdent  = "__jule_closure_ctx"
	matchExpr        = "_match_expr"
	resultName       = "__jule_func_result"
	assignResultName = "__jule_assign_result"
	resultArgName    = "__jule_result_arg"
	deferStackName   = "__jule_deferStack"
)

static assignArgName = "__jule_assign_arg"

// Common group of semantic analysis stmt types and optimizer specific types.
enum compStmt: type {
	sema::Stmt,
	&opt::PushToSliceExpr,
	&opt::MutSlicingExpr,
	&opt::SwapExpr,
	&opt::ExceptionalForwardingExpr,
	&opt::StrRuneIter,
}

// Channel and case hash for select.
struct chanCase {
	Case:  &sema::Case
	Value: &sema::Value
}

struct scopeCoder {
	oc: &ObjectCoder
}

impl scopeCoder {
	static fn new(mut &oc: &ObjectCoder): &scopeCoder {
		ret &scopeCoder{
			oc: oc,
		}
	}

	fn rangeChanIter(mut &self, mut it: &sema::RangeIter) {
		self.oc.write("{\n")
		self.oc.addIndent()
		self.oc.indent()
		self.oc.write("auto expr = ")
		mut ref := false
		if opt::Copy && isCopyOptimizable(it.Expr, true) {
			ref = true
			match type it.Expr.Model {
			| &sema::Var:
				v := it.Expr.Model.(&sema::Var)
				if v.Reference {
					self.oc.ec.model(it.Expr.Model)
					break
				}
				fall
			|:
				self.oc.write("&(")
				self.oc.ec.model(it.Expr.Model)
				self.oc.write(")")
			}
		} else {
			self.oc.ec.possibleRefExpr(it.Expr.Model)
		}
		self.oc.write(";\n")
		mut sb := strings::Builder{}
		sb.Grow(1 << 6)
		identCoder.iterNext(sb, uintptr(it))
		next := sb.Str()
		self.oc.write(next)
		self.oc.write(":;\n")
		self.oc.indent()
		self.oc.write(typeBool + " __ok = false;\n")
		self.oc.indent()
		writeExpr := fn() {
			// Write channel receive expression.
			// Use built-in expression for that.
			// sb should be cleared, make sure content is used already.
			sb.Clear()
			if ref {
				sb.WriteByte('*')!
			}
			sb.WriteStr("expr")!
			model := any(sb.Str())
			mut expr := new(sema::ChanRecv)
			expr.Token = it.ExprToken
			expr.Expr = new(sema::Value)
			expr.Expr.Type = it.Expr.Type
			expr.Expr.Model = unsafe { *(*sema::Expr)(&model) }
			self.oc.ec.chanRecv(expr, fn() { self.oc.write("&__ok") }, false)
		}
		if it.KeyA != nil {
			self.oc.varInitExpr(it.KeyA, writeExpr)
		} else {
			writeExpr()
			self.oc.write(";")
		}
		self.oc.write("\n")
		self.oc.indent()
		self.oc.write("if (__ok) {\n")
		self.oc.addIndent()
		self.oc.indent()
		self.scope(it.Scope)
		self.oc.write("\n")
		self.oc.indent()
		self.oc.write("goto ")
		self.oc.write(next)
		self.oc.write(";\n")
		self.oc.doneIndent()
		self.oc.indent()
		self.oc.write("}\n")

		// Close scope.
		self.oc.indent()
		identCoder.iterEnd(self.oc.Buf, uintptr(it))
		self.oc.write(":;\n")
		self.oc.doneIndent()
		self.oc.indent()
		self.oc.write("}")
	}

	// Common head object-code for iterations of all kind.
	fn iterHead(mut &self, mut &it: &sema::RangeIter, mut &ref: bool, begin: str) {
		self.oc.write("{\n")
		self.oc.addIndent()
		self.oc.indent()
		self.oc.write("auto expr = ")
		if opt::Copy && isCopyOptimizable(it.Expr, true) {
			ref = true
			match type it.Expr.Model {
			| &sema::Var:
				v := it.Expr.Model.(&sema::Var)
				if v.Reference {
					self.oc.ec.model(it.Expr.Model)
					break
				}
				fall
			|:
				self.oc.write("&(")
				self.oc.ec.model(it.Expr.Model)
				self.oc.write(")")
			}
		} else {
			self.oc.ec.possibleRefExpr(it.Expr.Model)
		}
		self.oc.write(";\n")
		self.oc.indent()
		self.oc.write("auto it = expr")
		if ref {
			self.oc.write("->")
		} else {
			self.oc.write(".")
		}
		self.oc.write("begin();\n")
		self.oc.indent()
		self.oc.write("auto expr_end = expr")
		if ref {
			self.oc.write("->")
		} else {
			self.oc.write(".")
		}
		self.oc.write("end();\n")
		self.oc.indent()
		self.oc.write(begin)
		self.oc.write(":;\n")
		self.oc.indent()
		self.oc.write("if (it != expr_end) {\n")
		self.oc.addIndent()
		self.oc.indent()
	}

	fn rangeIndexIter(mut &self, mut &it: &sema::RangeIter) {
		mut sb := strings::Builder{}
		sb.Grow(1 << 6)
		identCoder.iterBegin(sb, uintptr(it))
		begin := sb.Str()
		sb.Clear()
		identCoder.iterNext(sb, uintptr(it))
		next := sb.Str()

		mut ref := false
		self.iterHead(it, ref, begin)
		if it.KeyA != nil {
			self.oc.varInitExpr(it.KeyA, fn() {
				if ref {
					self.oc.write("it - expr->begin()")
				} else {
					self.oc.write("it - expr.begin()")
				}
			})
			self.oc.write("\n")
			self.oc.indent()
		}
		if it.KeyB != nil {
			it.KeyB.Reference = opt::Copy && isIterCopyOptimizable(it.Expr, it.KeyB)
			self.oc.varInitExpr(it.KeyB, fn() {
				unsafe {
					if it.KeyB.Reference {
						self.oc.write("it")
					} else {
						self.oc.write("*it")
					}
				}
			})
			self.oc.write("\n")
			self.oc.indent()
		}
		self.scope(it.Scope)
		self.oc.write("\n")
		self.oc.indent()
		self.oc.write(next)
		self.oc.write(":;\n")
		self.oc.indent()
		self.oc.write("++it;\n")
		self.oc.indent()
		if it.KeyA != nil {
			identCoder.var(self.oc.Buf, it.KeyA)
			self.oc.write("++;\n")
			self.oc.indent()
		}
		self.oc.write("goto ")
		self.oc.write(begin)
		self.oc.write(";\n")

		// Close if.
		self.oc.doneIndent()
		self.oc.indent()
		self.oc.write("}\n")

		self.oc.indent()
		identCoder.iterEnd(self.oc.Buf, uintptr(it))
		self.oc.write(":;\n")

		// Close scope.
		self.oc.doneIndent()
		self.oc.indent()
		self.oc.write("}")
	}

	fn rangeHashmapIter(mut &self, mut &it: &sema::RangeIter) {
		mut sb := strings::Builder{}
		sb.Grow(1 << 6)
		identCoder.iterBegin(sb, uintptr(it))
		begin := sb.Str()
		sb.Clear()
		identCoder.iterNext(sb, uintptr(it))
		next := sb.Str()

		mut _map := it.Expr.Type.Map()
		mut ins := obj::FindStructGenericInstance(meta::Program.Runtime.Map, _map.Key, _map.Val)
		const Static = false
		mut f := ins.FindMethod("iterator", Static).Instances[0]

		mut iterator := obj::FindStructGenericInstance(meta::Program.Runtime.MapIterator, _map.Key, _map.Val)
		mut nextCall := iterator.FindMethod("next", Static).Instances[0]

		const (
			resultName    = "__iterator_result"
			resultArgName = resultName + "." + resultArgName
			resultKey     = resultArgName + "0"
			resultVal     = resultArgName + "1"
		)

		self.oc.write("{\n")
		self.oc.addIndent()
		self.oc.indent()
		self.oc.tc.structureIns(self.oc.Buf, iterator)
		self.oc.write(" it = ")
		identCoder.funcIns(self.oc.Buf, f)
		self.oc.write("(")
		self.oc.ec.possibleRefExpr(it.Expr.Model)
		self.oc.write(");\n")
		self.oc.indent()
		self.oc.write(begin)
		self.oc.write(":;\n")
		self.oc.indent()
		self.oc.tc.funcInsResult(self.oc.Buf, nextCall)
		self.oc.write(" ")
		self.oc.write(resultName)
		self.oc.write(" = ")
		identCoder.funcIns(self.oc.Buf, nextCall)
		self.oc.write("(&it);\n")
		self.oc.indent()
		self.oc.write("if (")
		self.oc.write(resultKey)
		self.oc.write(" != nullptr) {\n")
		self.oc.addIndent()
		self.oc.indent()
		if it.KeyA != nil {
			self.oc.varInitExpr(it.KeyA, fn() { self.oc.write("*" + resultKey) })
			self.oc.write("\n")
			self.oc.indent()
		}
		if it.KeyB != nil {
			self.oc.varInitExpr(it.KeyB, fn() { self.oc.write("*" + resultVal) })
			self.oc.write("\n")
			self.oc.indent()
		}
		self.scope(it.Scope)
		self.oc.write("\n")
		self.oc.indent()
		self.oc.write(next)
		self.oc.write(":;\n")
		self.oc.indent()
		self.oc.write("goto ")
		self.oc.write(begin)
		self.oc.write(";\n")

		// Close if.
		self.oc.doneIndent()
		self.oc.indent()
		self.oc.write("}\n")

		self.oc.indent()
		identCoder.iterEnd(self.oc.Buf, uintptr(it))
		self.oc.write(":;\n")

		// Close scope.
		self.oc.doneIndent()
		self.oc.indent()
		self.oc.write("}")
	}

	fn strRuneIter(mut &self, mut &it: opt::StrRuneIter, utf8: bool) {
		mut sb := strings::Builder{}
		sb.Grow(1 << 6)
		identCoder.iterBegin(sb, uintptr(it.Base))
		begin := sb.Str()
		sb.Clear()
		identCoder.iterNext(sb, uintptr(it.Base))
		next := sb.Str()

		self.oc.write("{\n")
		self.oc.addIndent()
		self.oc.indent()

		mut ref := false
		self.oc.write("auto expr = ")
		if opt::Copy && isCopyOptimizable(it.Expr, true) {
			ref = true
			match type it.Expr.Model {
			| &sema::Var:
				v := it.Expr.Model.(&sema::Var)
				if v.Reference {
					self.oc.ec.model(it.Expr.Model)
					break
				}
				fall
			|:
				self.oc.write("&(")
				self.oc.ec.model(it.Expr.Model)
				self.oc.write(")")
			}
		} else {
			self.oc.ec.possibleRefExpr(it.Expr.Model)
		}
		self.oc.write(";\n")
		self.oc.indent()
		self.oc.write(typeU8)
		self.oc.write(" *it = expr")
		if ref {
			self.oc.write("->")
		} else {
			self.oc.write(".")
		}
		self.oc.write("begin();\n")
		self.oc.indent()
		self.oc.write("const ")
		self.oc.write(typeU8)
		self.oc.write(" *end = it + expr")
		if ref {
			self.oc.write("->")
		} else {
			self.oc.write(".")
		}
		self.oc.write("len();\n")
		self.oc.indent()

		// Variables.
		if it.Base.KeyA != nil {
			self.oc.varInitExpr(it.Base.KeyA, fn() { self.oc.write("0") })
			self.oc.write("\n")
			self.oc.indent()
		}
		self.oc.write(typeInt)
		self.oc.write(" len;\n")
		self.oc.indent()
		if it.Base.KeyB != nil {
			self.oc.varInitExpr(it.Base.KeyB, nil)
			self.oc.write("\n")
			self.oc.indent()
		}
		self.oc.write(begin)
		self.oc.write(":;\n")
		self.oc.indent()
		self.oc.write("__jule_runeStep(it, end - it, ")
		if it.Base.KeyB != nil {
			self.oc.write("&")
			identCoder.var(self.oc.Buf, it.Base.KeyB)
		} else {
			self.oc.write("nullptr")
		}
		self.oc.write(", &len);\n")
		self.oc.indent()

		self.oc.write("if (it < end) {\n")
		self.oc.addIndent()
		self.oc.indent()
		self.scope(it.Base.Scope)
		self.oc.write("\n")
		self.oc.indent()
		self.oc.write(next)
		self.oc.write(":;\n")
		self.oc.indent()
		self.oc.write("it += len;\n")
		self.oc.indent()
		if it.Base.KeyA != nil {
			identCoder.var(self.oc.Buf, it.Base.KeyA)
			if utf8 {
				self.oc.write(" += len;\n")
			} else {
				self.oc.write("++;\n")
			}
			self.oc.indent()
		}
		self.oc.write("goto ")
		self.oc.write(begin)
		self.oc.write(";\n")

		// Close if.
		self.oc.doneIndent()
		self.oc.indent()
		self.oc.write("}\n")

		self.oc.indent()
		identCoder.iterEnd(self.oc.Buf, uintptr(it.Base))
		self.oc.write(":;\n")

		// Close scope.
		self.oc.doneIndent()
		self.oc.indent()
		self.oc.write("}")
	}

	fn ifCase(mut &self, mut i: &sema::If) {
		if i.Expr != nil {
			self.oc.write("if (")
			self.oc.ec.possibleRefExpr(i.Expr)
			self.oc.write(") ")
		}
		self.scope(i.Scope)
	}

	fn conditional(mut &self, mut c: &sema::Conditional) {
		mut written := false
		for (_, mut elif) in c.Elifs {
			if elif == nil {
				continue
			}
			if written {
				self.oc.write(" else ")
			}
			written = true
			self.ifCase(elif)
		}
		if c.Default != nil {
			if written {
				self.oc.write(" else ")
			}
			self.scope(c.Default.Scope)
		}
	}

	fn infIter(mut &self, mut it: &sema::InfIter) {
		self.oc.write("for (;;) {\n")
		self.oc.addIndent() // Indent scope.
		self.oc.indent()
		self.scope(it.Scope)
		self.oc.doneIndent()
		self.oc.write("\n")
		self.oc.indent()
		identCoder.iterNext(self.oc.Buf, uintptr(it))
		self.oc.write(":;\n")
		self.oc.indent()
		self.oc.write("}\n")
		self.oc.indent()
		identCoder.iterEnd(self.oc.Buf, uintptr(it))
		self.oc.write(":;")
	}

	fn whileIter(mut &self, mut it: &sema::WhileIter) {
		if it.Expr != nil && it.Next == nil {
			self.oc.write("while (")
			self.oc.ec.possibleRefExpr(it.Expr)
			self.oc.write(") {")
		} else {
			self.oc.write("for (; ")
			if it.Expr != nil {
				self.oc.ec.possibleRefExpr(it.Expr)
			}
			self.oc.write("; ")
			if it.Next != nil {
				self.st(it.Next)
			}
			self.oc.write(") {")
		}

		if len(it.Scope.Stmts) == 0 {
			self.oc.write("}")
			ret
		}

		self.oc.write("\n")
		self.oc.addIndent()
		self.oc.indent()
		self.scope(it.Scope)
		self.oc.write("\n")
		self.oc.doneIndent()
		self.oc.indent()

		identCoder.iterNext(self.oc.Buf, uintptr(it))
		self.oc.write(":;\n")
		self.oc.indent()
		self.oc.write("}\n")
		self.oc.indent()
		identCoder.iterEnd(self.oc.Buf, uintptr(it))
		self.oc.write(":;")
	}

	fn rangeIter(mut &self, mut it: &sema::RangeIter) {
		match {
		| it.Expr.Type.Chan() != nil:
			self.rangeChanIter(it)
		| it.Expr.Type.Slice() != nil:
			self.rangeIndexIter(it)
		| it.Expr.Type.Array() != nil:
			self.rangeIndexIter(it)
		| it.Expr.Type.Map() != nil:
			self.rangeHashmapIter(it)
		|:
			mut sit := opt::StrRuneIter{Expr: it.Expr, Base: it}
			self.strRuneIter(sit, true) // Str
		}
	}

	fn continueStmt(mut &self, c: &sema::Continue) {
		self.oc.write("goto ")
		identCoder.iterNext(self.oc.Buf, c.It)
	}

	fn label(mut &self, l: &sema::Label) {
		identCoder.label(self.oc.Buf, uintptr(l))
		self.oc.write(":")
	}

	fn gotoStmt(mut &self, gt: &sema::Goto) {
		self.oc.write("goto ")
		identCoder.label(self.oc.Buf, uintptr(gt.Label))
	}

	fn tryMapSet(mut &self, mut m: sema::Expr): (ok: bool) {
		mut iem, ok := m.(&sema::IndexingExpr)
		if !ok {
			ret
		}
		_map := iem.Expr.Type.Map()
		if _map == nil {
			ret false
		}
		// Map indexing used for assignment.
		// Generate direct lookup unlike expression coder.
		mut ins := obj::FindStructGenericInstance(meta::Program.Runtime.Map, _map.Key, _map.Val)
		const Static = false
		mut f := ins.FindMethod("set", Static).Instances[0]
		self.oc.write("(*")
		identCoder.funcIns(self.oc.Buf, f)
		self.oc.write("((")
		self.oc.ec.possibleRefExpr(iem.Expr.Model)
		self.oc.write(").ptr(")
		if !env::Production {
			self.oc.write("\"")
			self.oc.locInfo(iem.Token)
			self.oc.write("\"")
		}
		self.oc.write("), ")
		self.oc.ec.possibleRefExpr(iem.Index.Model)
		self.oc.write("))")
		ret
	}

	fn postfix(mut &self, mut p: &sema::Postfix) {
		self.oc.write("(")
		ok := self.tryMapSet(p.Expr)
		if !ok {
			self.oc.ec.possibleRefExpr(p.Expr)
		}
		self.oc.write(")")
		self.oc.write(p.Op)
	}

	fn assignLeft(mut &self, mut &model: sema::Expr) {
		ok := self.tryMapSet(model)
		if !ok {
			self.oc.ec.possibleRefExpr(model)
		}
	}

	fn shl(mut &self, mut a: &sema::Assign) {
		self.assignLeft(a.Left.Model)
		self.oc.write(" = ")
		self.oc.ec.shl(a.Left, a.Right)
	}

	fn shr(mut &self, mut a: &sema::Assign) {
		self.assignLeft(a.Left.Model)
		self.oc.write(" = ")
		self.oc.ec.shr(a.Left, a.Right)
	}

	fn divByZeroAssign(mut &self, mut a: &sema::Assign) {
		self.assignLeft(a.Left.Model)
		self.oc.write(" = ")
		self.oc.ec.divByZeroBinary(a.Op, a.Left, a.Right)
	}

	fn assign(mut &self, mut a: &sema::Assign) {
		// optimize may optimize multi-assign statements
		// it uses common tokens of normalized statement
		// so it may be := assignment token, it is not a bug
		// handle it like the equal operator
		mut op := a.Op.Id
		mut kind := a.Op.Kind
		if a.Op.Id == token::ColonEq {
			op = token::Eq
			kind = "="
		}

		mut fc := isExceptionalResult(a.Right.Model)
		if fc != nil {
			self.oc.ec.handleExceptionalCallWithData(fc, useExprMemory{
				DestType: a.Left.Type,
				Model: a.Left.Model,
				Type: useExprAssignment,
				OpId: op,
				OpKind: kind,
			})
			ret
		}

		match a.Op.Id {
		| token::SolidusEq | token::PercentEq:
			if env::Safety {
				self.divByZeroAssign(a)
				ret
			}
		| token::ShlEq:
			self.shl(a)
			ret
		| token::ShrEq:
			self.shr(a)
			ret
		}

		self.assignLeft(a.Left.Model)
		self.oc.write(kind)
		self.oc.ec.possibleRefExpr(a.Right.Model)
	}

	fn mapLookupAssign(mut &self, mut &a: &sema::MultiAssign) {
		// map lookup right expression always should be indexing
		mut iem := a.Right.(&sema::IndexingExpr)
		mut _map := iem.Expr.Type.Map()

		mut ins := obj::FindStructGenericInstance(meta::Program.Runtime.Map, _map.Key, _map.Val)
		const Static = false
		mut f := ins.FindMethod("lookup", Static).Instances[0]

		identCoder.funcIns(self.oc.Buf, f)
		self.oc.write("(")
		self.assignLeft(iem.Expr.Model)
		self.oc.write(", ")
		self.oc.ec.possibleRefExpr(iem.Index.Model)
		self.oc.write(", ")
		if a.Left[0] != nil {
			self.oc.write("&(")
			self.oc.ec.possibleRefExpr(a.Left[0].Model)
			self.oc.write("), ")
		} else {
			self.oc.write("nullptr, ")
		}
		if a.Left[1] != nil {
			self.oc.write("&(")
			self.oc.ec.possibleRefExpr(a.Left[1].Model)
			self.oc.write(")")
		} else {
			self.oc.write("nullptr")
		}
		self.oc.write(")")
	}

	fn multiAssignTuple(mut &self, mut &a: &sema::MultiAssign) {
		self.oc.write("({\n")
		self.oc.addIndent()

		// tuple expressions may have reference for receiver memory
		// since receivers implemented as pointers they should take the pointer
		// to the actual expression of tuple
		// therefore do not generate temporary variable for references
		// they should take pointer from the tuple data

		mut tup := a.Right.(&sema::TupleExpr)

	Values:
		for (i, mut r) in tup.Values {
			self.oc.indent()
			mut l := a.Left[i]
			if l != nil {
				mut v, _ := l.Model.(&sema::Var)
				if v != nil && v.Reference {
					// left expression is a reference variable
					// lookup declared variables in this assignment
					// so we can detetermine reference variable is declared or assigned
					for _, dv in a.Decls {
						if v == dv {
							// variable is declaring now
							// takes pointer from the lvalue tuple data
							identCoder.var(self.oc.Buf, v)
							self.oc.write(" = &(")
							self.oc.ec.possibleRefExpr(r.Model)
							self.oc.write(");\n")
							a.Left[i] = nil // Ignore handling for following statements.
							continue Values
						}
					}
					// variable is not exist in declared variables
					// it can take temporary variable strategy
					// it just takes assignment to the pointing data
					// not takes pointer of the lvalue data
				}
				self.oc.tc.kind(self.oc.Buf, l.Type)
				self.oc.write(" ")
				identCoder.toOut(self.oc.Buf, assignArgName, uintptr(i))
				self.oc.write(" = ")
			}
			self.oc.ec.possibleRefExpr(r.Model)
			self.oc.write(";\n")
		}

		for (i, mut l) in a.Left {
			if l == nil {
				continue
			}
			self.oc.indent()
			self.assignLeft(l.Model)
			self.oc.write(" = ")
			identCoder.toOut(self.oc.Buf, assignArgName, uintptr(i))
			self.oc.write(";\n")
		}

		self.oc.doneIndent()
		self.oc.indent()
		self.oc.write("})")
	}

	fn assignWithPossibleCast(mut &self, mut l: sema::Expr, mut lt: &sema::Type, mut r: sema::Expr, mut rt: &sema::Type) {
		self.assignLeft(l)
		match {
		| rt.IsNil() || rt.Equal(lt):
			self.oc.write(" = ")
			self.oc.ec.possibleRefExpr(r)
		| obj::IsAny(lt):
			self.oc.write(" = " + typeAny + "(")
			self.oc.ec.possibleRefExpr(r)
			self.oc.write(", &" + anyTypeIdent)
			self.oc.write(conv::Itoa(self.oc.pushAnyType(rt)))
			self.oc.write(")")
		|:
			// It should be trait.
			if rt.Trait() != nil { // Different traits, cast.
				self.oc.write(" = ")
				mut t1 := lt.Trait()
				mut t2 := rt.Trait()
				self.oc.ec.possibleRefExpr(r)
				self.oc.write(".map(")
				self.oc.pushAndWriteMaskMapper(t1, t2)
				self.oc.write(")")
				break
			}
			t := lt.Trait()
			self.oc.write(" = " + typeTrait + "(")
			self.oc.ec.possibleRefExpr(r)
			self.oc.write(", (" + typeTrait + "::Type*)&")
			identCoder.traitDecl(self.oc.Buf, t)
			self.oc.write("_mptr_data")
			self.oc.write(conv::Itoa(obj::FindTraitTypeOffset(t, rt)))
			self.oc.write(")")
		}
		self.oc.write(";")
	}

	fn multiAssignFunc(mut &self, mut &a: &sema::MultiAssign) {
		self.oc.write("{\n")
		self.oc.addIndent()
		self.oc.indent()

		mut fc := a.Right.(&sema::FuncCallExpr)
		self.oc.tc.rc.codeMut1(self.oc.Buf, fc.Func.Result)
		if fc.Func.Decl != nil && fc.Func.Decl.Exceptional {
			static mut dest = useExprMemory{
				DestType: nil, // Should not be required in this case.
				Model: &sema::Var{
					Binded: true, // to use identifier directly
					Ident: assignResultName,
				},
				Type: useExprPlain,
				OpId: token::Eq,
				OpKind: "=",
			}
			self.oc.write(" " + assignResultName + ";\n")
			self.oc.indent()
			self.oc.ec.handleExceptionalCallWithData(fc, dest)
			self.oc.write("\n")
		} else {
			self.oc.write(" " + assignResultName + " = ")
			self.oc.ec.possibleRefExpr(a.Right)
			self.oc.write(";\n")
		}

		mut tup := fc.Func.Result.Tuple()
		mut r := &sema::Var{
			Binded: true, // to use identifier directly
		}
		for (i, mut l) in a.Left {
			if l == nil {
				continue
			}
			r.Ident = assignResultName + "." + resultArgName + conv::Itoa(i)
			self.oc.indent()
			self.assignWithPossibleCast(l.Model, l.Type, r, tup.Types[i])
			self.oc.write("\n")
		}

		self.oc.doneIndent()
		self.oc.indent()
		self.oc.write("}")
	}

	// Handles channel receive expression assignments like; data, ok := <-c
	fn chanRecvAssign(mut &self, mut a: &sema::MultiAssign) {
		if a.Left[0] == nil && a.Left[1] == nil {
			// Expression is like: _, _ = <-c
			// Handle as plain expression.
			self.oc.ec.chanRecv(a.Right.(&sema::ChanRecv), nil, false)
			ret
		}
		if a.Left[0] != nil {
			// Received data assigned to this.
			self.oc.ec.possibleRefExpr(a.Left[0].Model)
			self.oc.write(" = ")
		}
		let mut ok: fn() = nil
		if a.Left[1] != nil {
			// The |ok| parameter found.
			// Pass the memory of the lvalue to the receiver function.
			ok = fn() {
				self.oc.write("&(")
				self.oc.ec.possibleRefExpr(a.Left[1].Model)
				self.oc.write(")")
			}
		}
		self.oc.ec.chanRecv(a.Right.(&sema::ChanRecv), ok, false)
	}

	fn typeAssertionAssign(mut &self, mut a: &sema::MultiAssign) {
		mut ce := a.Right.(&sema::TypeAssertionExpr)
		mut f := obj::FindFuncGenericInstance(meta::Program.Runtime.DynAssertAssign, ce.Expr.Type, ce.Type)
		identCoder.funcIns(self.oc.Buf, f)
		self.oc.write("(")
		self.assignLeft(ce.Expr.Model)
		self.oc.write(", ")
		if a.Left[0] != nil {
			self.oc.write("&(")
			self.oc.ec.possibleRefExpr(a.Left[0].Model)
			self.oc.write("), ")
		} else {
			self.oc.write("nullptr, ")
		}
		if a.Left[1] != nil {
			self.oc.write("&(")
			self.oc.ec.possibleRefExpr(a.Left[1].Model)
			self.oc.write(")")
		} else {
			self.oc.write("nullptr")
		}
		self.oc.write(")")
	}

	fn typeAssertionAssignUnsafe(mut &self, mut a: &sema::MultiAssign, mut uc: &opt::UnsafeTypeAssertionExpr) {
		if a.Left[0] != nil {
			self.oc.ec.possibleRefExpr(a.Left[0].Model)
			self.oc.write(" = ")
		}
		self.oc.ec.unsafeTypeAssertion(uc)
		if a.Left[1] != nil {
			self.oc.write(";\n")
			self.oc.indent()
			self.oc.ec.possibleRefExpr(a.Left[1].Model)
			self.oc.write(" = true")
		}
	}

	fn multiAssign(mut &self, mut a: &sema::MultiAssign) {
		// Write declarations without no initialization.
		// It will initialize with assignments.
		for (_, mut d) in a.Decls {
			self.oc.varInitExpr(d, nil)
			self.oc.write("\n")
			self.oc.indent()
		}

		let mut r: compExpr = a.Right
		match type r {
		| &sema::IndexingExpr:
			self.mapLookupAssign(a)
			ret
		| &sema::TypeAssertionExpr:
			self.typeAssertionAssign(a)
			ret
		| &opt::UnsafeTypeAssertionExpr:
			// We avoiding misanalysis for assertion casting expressions here.
			// Since we know the casting result, assign directly with no analysis.
			mut uc := r.(&opt::UnsafeTypeAssertionExpr)
			self.typeAssertionAssignUnsafe(a, uc)
			ret
		| &sema::ChanRecv:
			self.chanRecvAssign(a)
			ret
		| &sema::TupleExpr:
			self.multiAssignTuple(a)
		| &sema::FuncCallExpr:
			self.multiAssignFunc(a)
		|:
			panic("cxx: this panic call should be unreachable")
		}
	}

	fn case(mut &self, mut m: &sema::Match, mut &l: sema::OperandExpr, mut c: &sema::Case) {
		if len(c.Exprs) != 0 && !m.Comptime {
			if len(m.Cases) > 0 && m.Cases[0] == c {
				self.oc.write("if (")
			} else {
				self.oc.write("else if (")
			}
			for (i, mut expr) in c.Exprs {
				match {
				| !m.TypeMatch:
					mut r := sema::OperandExpr{
						Model: expr.Model,
						Type: expr.Type,
					}
					self.oc.ec._unsafeBinary(self.oc.Buf, l, r, token::DblEq, "==")
				|:
					self.oc.write(matchExpr)
					mut tk := expr.Type
					if m.Expr.Type.Trait() != nil { // Trait type.
						t := m.Expr.Type.Trait()
						self.oc.write(".type == (" + typeTrait + "::Type*)&")
						identCoder.traitDecl(self.oc.Buf, t)
						self.oc.write("_mptr_data")
						self.oc.write(conv::Itoa(obj::FindTraitTypeOffset(m.Expr.Type.Trait(), expr.Type)))
					} else { // Any type.
						j := self.oc.pushAnyType(tk)
						self.oc.write(".type == &" + anyTypeIdent)
						self.oc.write(conv::Itoa(j))
					}
				}

				if len(c.Exprs)-i > 1 {
					self.oc.write(" || ")
				}
			}
			self.oc.write(") ")
		} else if m.Default == c && len(m.Cases) != 0 {
			self.oc.indent()
			self.oc.write("else ")
		}

		self.oc.addIndent()

		self.oc.write("{\n")
		self.oc.indent()
		identCoder.caseBegin(self.oc.Buf, uintptr(c))
		self.oc.write(":;\n")
		if len(c.Scope.Stmts) > 0 {
			self.oc.indent()
			self.scope(c.Scope)
			self.oc.write("\n")
		}

		self.oc.doneIndent()

		self.oc.indent()
		self.oc.write("}")
	}

	fn matchStmt(mut &self, mut m: &sema::Match) {
		if len(m.Cases) == 0 && m.Default == nil {
			ret
		}
		if m.Comptime && (m.Default == nil || len(m.Default.Scope.Stmts) == 0) {
			ret
		}
		self.oc.write("{\n")
		self.oc.addIndent()
		self.oc.indent()

		mut l := sema::OperandExpr{}

		// Constant expressions generated as literals in conditions.
		if !m.Comptime {
			l.Type = m.Expr.Type
			if m.Expr.IsConst() {
				matchExprS := writeAndReadFromBuf(self.oc.Buf, fn() {
					self.oc.ec.possibleRefExpr(m.Expr.Model)
				})
				mut matchExpr := compExpr(matchExprS)
				l.Model = unsafe { *(*sema::Expr)(&matchExpr) }
			} else {
				if opt::Copy && isCopyOptimizable(m.Expr, false) {
					self.oc.write("auto &_match_expr{ ")
				} else {
					self.oc.write("auto _match_expr{ ")
				}
				mut matchExpr := compExpr(matchExpr)
				l.Model = unsafe { *(*sema::Expr)(&matchExpr) }
				self.oc.ec.possibleRefExpr(m.Expr.Model)
				self.oc.write(" };\n")
				self.oc.indent()
			}
		}

		if len(m.Cases) > 0 {
			for (_, mut c) in m.Cases {
				if c == nil {
					continue
				}
				self.oc.write("\n")
				self.oc.indent()
				self.case(m, l, c)
			}
		}

		if m.Default != nil {
			self.oc.write("\n")
			self.case(m, l, m.Default)
		}

		self.oc.write("\n")
		self.oc.indent()
		identCoder.matchEnd(self.oc.Buf, uintptr(m))
		self.oc.write(":;")
		self.oc.write("\n")

		self.oc.doneIndent()

		self.oc.indent()
		self.oc.write("}")
	}

	fn selectStmt(mut &self, mut slct: &sema::Select) {
		if len(slct.Cases) == 0 {
			// Empty select.
			if slct.Default == nil {
				identCoder.funcIns(self.oc.Buf, meta::Program.Runtime.ChanSelect)
				self.oc.write("(nullptr, 0, 0, false);")
			} else {
				// Just the default case.
				self.scope(slct.Default.Scope)
			}
			ret
		}
		// Non-empty select.
		// Generate necessary data and call the select statement function.
		// See the [runtime::chanSelect] function for documentation.
		self.oc.write("{\n")
		self.oc.addIndent()
		self.oc.indent()

		// Whether it is a blocking select.
		block := slct.Default == nil

		// Generate code for [runtime::hchan] type.
		mut hchan := ""
		{
			mut sbuf := strings::Builder{}
			sbuf.Grow(40)
			self.oc.tc.structure(sbuf, meta::Program.Runtime.Hchan)
			hchan = sbuf.Str()
		}

		// NOTE:
		// Create array for channels. This implementation will not check
		// the channel count, but probably total count of channel will not
		// cause overflow by size.
		self.oc.tc.asSptr(self.oc.Buf, unsafe::StrBytes(hchan))
		self.oc.write(" __jule_chans[] = {")
		// Most common use case, assume 1 chan-recv/chan-send per case.
		// In the end, len(chans) equals to total count of chans.
		// All elements, matched by index which returned by the select algorithm.
		// So chans[i] always the matched case, if exist.
		mut chans := make([]chanCase, 0, len(slct.Cases))
		mut &_chans := chans // Used by closure, unsafely.
		obj::IterCaseExprs(slct.Cases, fn(mut &c: &sema::Case, mut &val: &sema::Value) {
			mut cr, _ := val.Model.(&sema::ChanRecv)
			if cr != nil {
				unsafe { _chans = append(_chans, chanCase{c, val}) }
				self.oc.ec.possibleRefExpr(cr.Expr.Model)
				self.oc.write(".as<")
				self.oc.write(hchan)
				self.oc.write(">(), ")
			}
		})
		recvChans := len(chans) // Total count of chan-recv cases.
		obj::IterCaseExprs(slct.Cases, fn(mut &c: &sema::Case, mut &val: &sema::Value) {
			mut cs, _ := val.Model.(&sema::ChanSend)
			if cs != nil {
				unsafe { _chans = append(_chans, chanCase{c, val}) }
				self.oc.ec.possibleRefExpr(cs.Chan.Model)
				self.oc.write(".as<")
				self.oc.write(hchan)
				self.oc.write(">(), ")
			}
		})
		self.oc.write("};\n")
		self.oc.indent()
		self.oc.write(typeInt)
		self.oc.write(" __offset = ")
		identCoder.funcIns(self.oc.Buf, meta::Program.Runtime.ChanSelect)
		self.oc.write("(__jule_chans, ")
		self.oc.write(conv::Itoa(len(chans)))
		self.oc.write(", ")
		self.oc.write(conv::Itoa(recvChans))
		self.oc.write(", ")
		self.oc.write(conv::FormatBool(block))
		self.oc.write(");\n")
		self.oc.indent()
		if !block {
			// This if condition is unnecessart for blocking select statements.
			self.oc.write("if (__offset >= 0) {\n")
			self.oc.addIndent()
		}
		self.oc.indent()
		self.oc.write("switch (__offset) {\n")

		// Generate cases, match them, and execute.
		genCase := fn(i: int, mut &c: chanCase) {
			// We have to convert hchan to pchan.
			// So use custom built-in expression for that.
			mut sb := strings::Builder{}
			sb.Grow(40)
			sb.WriteStr("__jule_chans[")!
			sb.WriteStr(conv::Itoa(i))!
			sb.WriteStr("].as<")!
			match type c.Value.Model {
			| &sema::ChanRecv:
				mut cr := c.Value.Model.(&sema::ChanRecv)
				mut pchan := obj::FindStructGenericInstance(meta::Program.Runtime.Pchan, cr.Expr.Type.Chan().Elem)
				self.oc.tc.structureIns(sb, pchan)
				sb.WriteStr(">()")!
				model := any(sb.Str())
				cr.Expr.Model = unsafe { *(*sema::Expr)(&model) }
				self.oc.ec.chanRecv(cr, nil, true)
			| &sema::ChanSend:
				mut cs := c.Value.Model.(&sema::ChanSend)
				mut pchan := obj::FindStructGenericInstance(meta::Program.Runtime.Pchan, cs.Chan.Type.Chan().Elem)
				self.oc.tc.structureIns(sb, pchan)
				sb.WriteStr(">()")!
				model := any(sb.Str())
				cs.Chan.Model = unsafe { *(*sema::Expr)(&model) }
				self.oc.ec.chanSend(cs, true)
			|:
				panic("unreachable")
			}
			self.oc.write(";\n")
			self.oc.indent()
			self.scope(c.Case.Scope)
			self.oc.write("\n")
		}
		for (i, mut c) in chans {
			self.oc.indent()
			self.oc.write("case ")
			self.oc.write(conv::Itoa(i))
			self.oc.write(":\n")
			self.oc.addIndent()
			self.oc.indent()
			genCase(i, c)
			self.oc.indent()
			self.oc.write("break;\n")
			self.oc.doneIndent()
		}
		// Closing switch.
		self.oc.indent()
		self.oc.write("}\n")
		self.oc.doneIndent()

		// Closing if.
		if !block {
			self.oc.indent()
			self.oc.write("} else ")
			self.scope(slct.Default.Scope) // Default scope is should not be nil.
			self.oc.write("\n")
			self.oc.doneIndent()
		}

		self.oc.indent()
		identCoder.matchEnd(self.oc.Buf, uintptr(slct))
		self.oc.write(":;\n")

		// Closing inner.
		self.oc.indent()
		self.oc.write("}")
	}

	fn fallStmt(mut &self, f: &sema::Fall) {
		self.oc.write("goto ")
		identCoder.caseBegin(self.oc.Buf, f.DestCase)
	}

	fn breakStmt(mut &self, b: &sema::Break) {
		self.oc.write("goto ")
		match {
		| b.It != 0:
			identCoder.iterEnd(self.oc.Buf, b.It)
		| b.Match != 0:
			identCoder.matchEnd(self.oc.Buf, b.Match)
		| b.Select != 0:
			identCoder.matchEnd(self.oc.Buf, b.Select)
		|:
			panic("unreachable")
		}
	}

	fn setResult(mut &self, mut r: &sema::Ret) {
		mut fc := isExceptionalResult(r.Expr)
		if fc != nil {
			// If result types are not equal, must be handled like an assign.
			// See the documentation of the &FuncCallExpr case below.
			if !r.Func.Result.Equal(fc.Func.Result) {
				goto assignFC
			}
			static mut dest = useExprMemory{
				DestType: nil, // Should not be required in this case.
				Model: &sema::Var{
					Binded: true, // to use identifier directly
					Ident: resultName,
				},
				Type: useExprPlain,
				OpId: token::Eq,
				OpKind: "=",
			}
			self.oc.ec.handleExceptionalCallWithData(fc, dest)
			self.oc.write("\n")
			self.oc.indent()
			ret
		}

		if len(r.Func.Decl.Result.Idents) == 1 {
			self.oc.write(resultName + " = ")
			self.oc.ec.possibleRefExpr(r.Expr)
			self.oc.write(";\n")
			self.oc.indent()
			ret
		}
		match type r.Expr {
		| &sema::TupleExpr:
			mut values := r.Expr.(&sema::TupleExpr).Values
			for (i, mut v) in values {
				self.oc.write(resultName + "." + resultArgName)
				self.oc.write(conv::Itoa(i))
				self.oc.write(" = ")
				self.oc.ec.possibleRefExpr(v.Model)
				self.oc.write(";\n")
				self.oc.indent()
			}
			ret
		| &sema::FuncCallExpr:
			// If function call could not returned by isExceptionalResult,
			// the use the pure function call.
			if fc == nil {
				fc = r.Expr.(&sema::FuncCallExpr)
			}
			// If result types are equal, assign directly.
			// Otherwise, we probably need casting due to dynamic types.
			if r.Func.Result.Equal(fc.Func.Result) {
				self.oc.write(resultName + " = std::move(")
				self.oc.ec.model(r.Expr)
				self.oc.write(");\n")
				self.oc.indent()
				ret
			}
			goto assignFC
		|:
			panic("cxx: implementation mistake, this panic call should be unreachable")
		}
	assignFC:
		// Handle like an assignment.
		// The assignment handler will do the task.
		mut tup := r.Func.Result.Tuple()
		if tup == nil {
			// Single type, handle like an single assignment.
			static mut rv = &sema::Var{
				Binded: true, // to use identifier directly
				Ident: resultName,
			}
			mut dest := useExprMemory{
				DestType: r.Func.Result,
				Model: rv,
				Type: useExprPlain,
				OpId: token::Eq,
				OpKind: "=",
			}
			self.oc.ec.handleExceptionalCallWithData(fc, dest)
		} else {
			mut a := new(sema::MultiAssign)
			a.Decls = nil // not needed
			a.Op = nil    // not needed
			a.Right = r.Expr
			a.Left = make([]&sema::Value, len(tup.Types))
			for i in a.Left {
				mut ident := resultName + "." + resultArgName
				ident += conv::Itoa(i)
				a.Left[i] = &sema::Value{
					Type: tup.Types[i],
					Model: &sema::Var{
						Binded: true, // to use identifier directly
						Ident: ident,
					},
				}
			}
			self.multiAssign(a)
		}
		self.oc.write("\n")
		self.oc.indent()
	}

	fn retStmt(mut &self, mut r: &sema::Ret) {
		hasDefer := r.Func.Decl != nil && r.Func.Decl.HasDefer
		mut fc := isExceptionalResult(r.Expr) // Exceptional functions should be handled with setResult.
		if r.Func.Decl.IsVoid() {
			if hasDefer {
				self.oc.write(deferStackName + ".call();\n")
				self.oc.indent()
			}
			if r.Func.Decl.Exceptional {
				self.oc.write("return jule::VoidExceptional{};")
				ret
			}
			self.oc.write("return;")
			ret
		} else if len(r.Func.Decl.Result.Idents) == 0 && fc == nil {
			if r.Func.Decl.Exceptional {
				// Use scope to prevent "goto" errors about declarations.
				self.oc.write("{\n")
				self.oc.addIndent()
				self.oc.indent()
				self.oc.write("jule::Exceptional<")
				self.oc.tc.kind(self.oc.Buf, r.Func.Result)
				self.oc.write("> result;\n")
				self.oc.indent()
				self.oc.write("result.result = ")
				self.oc.ec.possibleRefExpr(r.Expr)
				self.oc.write(";\n")
				self.oc.indent()
				if hasDefer {
					self.oc.write(deferStackName + ".call();\n")
					self.oc.indent()
				}
				self.oc.write("return result;\n")
				self.oc.doneIndent()
				self.oc.indent()
				self.oc.write("}")
			} else {
				self.oc.write("{\n")
				self.oc.addIndent()
				self.oc.indent()
				if hasDefer {
					self.oc.tc.kind(self.oc.Buf, r.Func.Result)
					self.oc.write(" __result = ")
				} else {
					self.oc.write("return ")
				}
				self.oc.ec.possibleRefExpr(r.Expr)
				if hasDefer {
					self.oc.write(";\n")
					self.oc.indent()
					self.oc.write(deferStackName + ".call();\n")
					self.oc.indent()
					self.oc.write("return __result;\n")
				} else {
					self.oc.write(";\n")
				}
				self.oc.doneIndent()
				self.oc.indent()
				self.oc.write("}")
			}
			ret
		}

		// If function have not explicit result variables, push to stack temporarily.
		// We need to allocate just one variable, because this is the only possible case.
		// Probably needed for implicit casting.
		needResultVar := len(r.Func.Decl.Result.Idents) != 1 && r.Func.Result.Tuple() == nil
		if needResultVar {
			self.oc.write("{\n")
			self.oc.addIndent()
			self.oc.indent()

			self.oc.tc.kind(self.oc.Buf, r.Func.Result)
			self.oc.write(" " + resultName)
			if shouldInitialized(r.Func.Result) {
				self.oc.write(" = ")
				self.oc.ec.initExpr(r.Func.Result)
			}
			self.oc.write(";\n")
			self.oc.indent()
		}

		if r.Expr != nil {
			self.setResult(r)
		}
		// We can call defer stack here if exist.
		// All result arguments evaluated and stored.
		if hasDefer {
			self.oc.write(deferStackName + ".call();\n")
			self.oc.indent()
		}
		if r.Func.Decl.Exceptional {
			self.oc.write("return jule::Exceptional<")
			self.oc.tc.rc.codeMut1(self.oc.Buf, r.Func.Result)
			self.oc.write(">{.result=" + resultName + "};")
		} else {
			self.oc.write("return " + resultName + ";")
		}

		// Close the result variable scope.
		if needResultVar {
			self.oc.write("\n")
			self.oc.doneIndent()
			self.oc.indent()
			self.oc.write("}")
		}
	}

	fn var(mut &self, mut v: &sema::Var) {
		if !v.Constant {
			self.oc.var(v)
		}
	}

	fn mutSlicing(mut &self, mut m: &opt::MutSlicingExpr) {
		self.oc.write("(")
		self.oc.ec.possibleRefExpr(m.Expr)
		self.oc.write(").mut_slice(")
		if !env::Production {
			self.oc.write("\"")
			self.oc.locInfo(m.Token)
			self.oc.write("\", ")
		}
		self.oc.ec.possibleRefExpr(m.Left)
		if m.Right != nil {
			self.oc.write(", ")
			self.oc.ec.possibleRefExpr(m.Right)
		}
		if m.Cap != nil {
			self.oc.write(", ")
			self.oc.ec.possibleRefExpr(m.Cap)
		}
		self.oc.write(");")
	}

	fn swap(mut &self, mut m: &opt::SwapExpr) {
		self.oc.write("std::swap(")
		self.oc.ec.possibleRefExpr(m.Left.Model)
		self.oc.write(", ")
		self.oc.ec.possibleRefExpr(m.Right.Model)
		self.oc.write(")")
	}

	fn exceptionalForwarding(mut &self, mut m: &opt::ExceptionalForwardingExpr) {
		self.oc.write("return ")
		self.oc.ec.pureFuncCall(m.Expr)
	}

	// Generates C++ code of statement.
	fn st(mut &self, mut st: compStmt) {
		if st == nil {
			ret
		}
		match type st {
		| &sema::Scope:
			self.scope(st.(&sema::Scope))
		| &sema::Var:
			self.var(st.(&sema::Var))
		| &sema::Value:
			mut v := st.(&sema::Value)
			// Catch anonymous functions created by defer scope.
			// Push them to defer stack.
			f, _ := v.Model.(&sema::AnonFuncExpr)
			if f != nil && f.Func.Scope != nil && f.Func.Scope.Deferred {
				self.oc.write(deferStackName + ".push(")
				self.oc.ec.model(v.Model)
				self.oc.write(")")
			} else {
				self.oc.ec.model(v.Model)
			}
		| &sema::Conditional:
			self.conditional(st.(&sema::Conditional))
		| &sema::InfIter:
			self.infIter(st.(&sema::InfIter))
		| &sema::WhileIter:
			self.whileIter(st.(&sema::WhileIter))
		| &sema::RangeIter:
			self.rangeIter(st.(&sema::RangeIter))
		| &sema::Continue:
			self.continueStmt(st.(&sema::Continue))
		| &sema::Label:
			self.label(st.(&sema::Label))
		| &sema::Goto:
			self.gotoStmt(st.(&sema::Goto))
		| &sema::Postfix:
			self.postfix(st.(&sema::Postfix))
		| &sema::Assign:
			self.assign(st.(&sema::Assign))
		| &sema::MultiAssign:
			self.multiAssign(st.(&sema::MultiAssign))
		| &sema::Match:
			self.matchStmt(st.(&sema::Match))
		| &sema::Select:
			self.selectStmt(st.(&sema::Select))
		| &sema::Fall:
			self.fallStmt(st.(&sema::Fall))
		| &sema::Break:
			self.breakStmt(st.(&sema::Break))
		| &sema::Ret:
			self.retStmt(st.(&sema::Ret))
		| &opt::PushToSliceExpr:
			self.oc.ec.pushToSlice(st.(&opt::PushToSliceExpr))
		| &opt::MutSlicingExpr:
			self.mutSlicing(st.(&opt::MutSlicingExpr))
		| &opt::SwapExpr:
			self.swap(st.(&opt::SwapExpr))
		| &opt::ExceptionalForwardingExpr:
			self.exceptionalForwarding(st.(&opt::ExceptionalForwardingExpr))
		| &opt::StrRuneIter:
			mut sit := st.(&opt::StrRuneIter)
			self.strRuneIter(*sit, false)
		| &sema::Use:
			// no-op
		}
	}

	fn scopeStmts(mut &self, mut &s: &sema::Scope) {
		for (_, mut st) in s.Stmts {
			self.oc.indent()
			self.st(st)
			self.oc.write(";\n")
		}
	}

	// Generates C++ code of scope.
	fn scope(mut &self, mut s: &sema::Scope) {
		self.oc.addIndent()
		self.oc.write("{\n")
		self.scopeStmts(s)
		self.oc.doneIndent()
		self.oc.indent()
		self.oc.write("}")
	}

	fn commonFuncScope(mut &self, mut &f: &sema::FuncIns) {
		if !f.Decl.IsVoid() {
			mut tup := f.Result.Tuple()
			if tup != nil {
				self.oc.indent()
				self.oc.tc.rc.tuple(self.oc.Buf, tup)
				self.oc.write(" " + resultName + ";\n")
				for (i, mut t) in tup.Types {
					if shouldInitialized(t) {
						self.oc.indent()
						self.oc.write(resultName + "." + resultArgName)
						self.oc.write(conv::Itoa(i))
						self.oc.write(" = ")
						self.oc.ec.initExpr(t)
						self.oc.write(";\n")
					}
				}
			} else if len(f.Decl.Result.Idents) == 1 {
				// Non-tuple single return type with identifier.
				// Use [resultName] as identifier.
				self.oc.indent()
				self.oc.tc.kind(self.oc.Buf, f.Result)
				self.oc.write(" " + resultName)
				if shouldInitialized(f.Result) {
					self.oc.write(" = ")
					self.oc.ec.initExpr(f.Result)
				}
				self.oc.write(";\n")
			}
		}
		if f.Decl.HasDefer {
			self.oc.indent()
			self.oc.write("jule::DeferStack " + deferStackName + ";\n")
		}
		self.scopeStmts(f.Scope)

		// Before executing final steps, checks whether the scope has final statement
		// already such as return statement or error call.
		if len(f.Scope.Stmts) > 0 {
			stmt := f.Scope.Stmts[len(f.Scope.Stmts)-1]
			match type stmt {
			| &sema::Ret:
				ret
			| &sema::Value:
				v := stmt.(&sema::Value)
				match type v.Model {
				| &sema::BuiltinErrorCallExpr
				| &sema::BuiltinPanicCallExpr:
					ret
				|:
					// no-op
				}
			|:
				// no-op
			}
		}

		if f.Decl.HasDefer {
			self.oc.indent()
			self.oc.write(deferStackName + ".call();\n")
		}
		if f.Decl.Exceptional && f.Decl.IsVoid() {
			// Just for void exceptionals.
			// Other cases checked by semantic analsis and disallowed
			// if they are not returns.
			self.oc.indent()
			self.oc.write("return jule::VoidExceptional{};\n")
		}
	}

	fn anonFuncScope(mut &self, mut m: &sema::AnonFuncExpr, ident: str) {
		if m.Func.Scope == nil {
			ret
		}
		closure := obj::IsClosure(m)
		if closure {
			self.oc.ec.varPrefixes = append(self.oc.ec.varPrefixes, fn(mut v: &sema::Var): bool {
				ret captureVarHandling(self.oc, m, v)
			})
		}
		self.oc.write("{\n")
		self.oc.addIndent()

		if closure {
			// Get ctx.
			self.oc.indent()
			self.oc.write(typePtr + "<")
			self.oc.write(ident)
			self.oc.write(anonFuncCtxSuffix + "> " + closureCtxIdent + " = " + ctxParamIdent + ".as<")
			self.oc.write(ident)
			self.oc.write(anonFuncCtxSuffix + ">();\n")
		}

		self.commonFuncScope(m.Func)

		self.oc.doneIndent()
		self.oc.indent()
		self.oc.write("}")
		if closure {
			self.oc.ec.varPrefixes = self.oc.ec.varPrefixes[:len(self.oc.ec.varPrefixes)-1]
		}
	}

	// Generates C++ code of function's scope.
	fn funcScope(mut &self, mut f: &sema::FuncIns) {
		if f.Scope == nil {
			ret
		}
		self.oc.write("{\n")
		self.oc.addIndent()
		self.commonFuncScope(f)
		self.oc.doneIndent()
		self.oc.indent()
		self.oc.write("}")
	}
}

fn isCopyOptimizable(&v: &sema::Value, iter: bool): bool {
	// Return false if value is not lvalue or iter && mutable.
	// If the value is not lvalue, we have to copy it.
	// If the value is mutable and optimized for iteration, we cannot optimize it.
	// Because the value may be mutated in the iteration.
	// Compiler will not analysis such cases yet, so we cannot know.
	if !v.Lvalue || (iter && v.Mutable) {
		ret false
	}
	_, slicing := v.Model.(&sema::SlicingExpr)
	ret !slicing
}

fn isIterCopyOptimizable(&val: &sema::Value, &v: &sema::Var): bool {
	if !val.Lvalue && !val.Type.Mutable() {
		ret true
	}
	ret !v.Mutable && !val.Mutable
}

fn captureVarHandling(mut &oc: &ObjectCoder, mut &m: &sema::AnonFuncExpr, mut &v: &sema::Var): bool {
	for _, cv in m.Captured {
		if cv == v {
			oc.write(closureCtxIdent + ".alloc->")
			identCoder.anonFuncVar(oc.Buf, v)
			ret true
		}
	}
	ret false
}
// Copyright 2023-2025 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "env"
use "obj"
use "obj/meta"
use "opt"
use "std/conv"
use "std/jule/constant"
use "std/jule/sema"
use "std/jule/token"
use "std/strings"
use "std/unsafe"

const closureCtxIdent = "__jule_closure_ctx"
const matchExpr = "_match_expr"
const resultName = "__jule_func_result"
const assignResultName = "__jule_assign_result"
const resultArgName = "__jule_result_arg"
const deferStackName = "__jule_deferStack"

static assignArgName = "__jule_assign_arg"

// Common group of semantic analysis stmt types and optimizer specific types.
enum compStmt: type {
	Stmt: sema::Stmt,
	&opt::PushToSliceExpr,
	&opt::AppendToSliceExpr,
	&opt::MutSlicingExpr,
	&opt::SwapExpr,
	&opt::ExceptionalForwardingExpr,
	&opt::StrRuneIter,
}

// Channel and case hash for select.
struct chanCase {
	Case:  &sema::Case
	Value: &sema::Value
}

struct scopeCoder {
	oc: &ObjectCoder
}

impl scopeCoder {
	static fn new(mut &oc: &ObjectCoder): &scopeCoder {
		ret &scopeCoder{
			oc: oc,
		}
	}

	fn rangeChanIter(mut &self, mut it: &sema::RangeIter) {
		self.oc.write("{\n")
		self.oc.addIndent()
		self.oc.indent()
		self.oc.write("auto expr = ")
		mut ref := false
		if opt::Copy && isCopyOptimizable(it.Expr) {
			ref = true
			match type it.Expr.Model {
			| &sema::Var:
				v := (&sema::Var)(it.Expr.Model)
				if v.Reference {
					self.oc.ec.model(it.Expr.Model)
					break
				}
				fall
			|:
				self.oc.write("&(")
				self.oc.ec.model(it.Expr.Model)
				self.oc.write(")")
			}
		} else {
			self.oc.ec.possibleRefExpr(it.Expr.Model)
		}
		self.oc.write(";\n")
		mut sb := strings::Builder{}
		sb.Grow(1 << 6)
		identCoder.iterNext(sb, uintptr(it))
		next := sb.Str()
		self.oc.write(next)
		self.oc.write(":;\n")
		self.oc.indent()
		self.oc.write(typeBool + " __ok = false;\n")
		self.oc.indent()
		writeExpr := fn() {
			// Write channel receive expression.
			// Use built-in expression for that.
			// sb should be cleared, make sure content is used already.
			sb.Clear()
			if ref {
				sb.WriteByte('*')!
			}
			sb.WriteStr("expr")!
			model := any(sb.Str())
			mut expr := new(sema::ChanRecv)
			expr.Token = it.ExprToken
			expr.Expr = new(sema::Value)
			expr.Expr.Type = it.Expr.Type
			expr.Expr.Model = unsafe { *(*sema::Expr)(&model) }
			self.oc.ec.chanRecv(expr, fn() { self.oc.write("&__ok") }, false)
		}
		if it.KeyA != nil {
			self.oc.varInitExpr(it.KeyA, writeExpr)
		} else {
			writeExpr()
			self.oc.write(";")
		}
		self.oc.write("\n")
		self.oc.indent()
		self.oc.write("if (__ok) {\n")
		self.oc.addIndent()
		self.oc.indent()
		self.scope(it.Scope)
		self.oc.write("\n")
		self.oc.indent()
		self.oc.write("goto ")
		self.oc.write(next)
		self.oc.write(";\n")
		self.oc.doneIndent()
		self.oc.indent()
		self.oc.write("}\n")

		// Close scope.
		self.oc.indent()
		identCoder.iterEnd(self.oc.Buf, uintptr(it))
		self.oc.write(":;\n")
		self.oc.doneIndent()
		self.oc.indent()
		self.oc.write("}")
	}

	// Common head object-code for iterations of all kind.
	fn iterHead[T](mut &self, &it: T, mut &ref: bool, begin: str) {
		self.oc.write("{\n")
		self.oc.addIndent()
		self.oc.indent()
		self.oc.write("auto expr = ")
		if opt::Copy && isCopyOptimizable(it.Expr) {
			ref = true
			match type it.Expr.Model {
			| &sema::Var:
				v := (&sema::Var)(it.Expr.Model)
				if v.Reference {
					self.oc.ec.model(it.Expr.Model)
					break
				}
				fall
			|:
				self.oc.write("&(")
				self.oc.ec.model(it.Expr.Model)
				self.oc.write(")")
			}
		} else {
			self.oc.ec.possibleRefExpr(it.Expr.Model)
		}
		self.oc.write(";\n")
		self.oc.indent()
		self.oc.write("auto it = expr")
		if ref {
			self.oc.write("->")
		} else {
			self.oc.write(".")
		}
		self.oc.write("begin();\n")
		self.oc.indent()
		self.oc.write("auto expr_end = expr")
		if ref {
			self.oc.write("->")
		} else {
			self.oc.write(".")
		}
		self.oc.write("end();\n")
		self.oc.indent()
		self.oc.write(begin)
		self.oc.write(":;\n")
		self.oc.indent()
		self.oc.write("if (it != expr_end) {\n")
		self.oc.addIndent()
		self.oc.indent()
	}

	fn rangeIndexIter(mut &self, mut &it: &sema::RangeIter) {
		mut sb := strings::Builder{}
		sb.Grow(1 << 6)
		identCoder.iterBegin(sb, uintptr(it))
		begin := sb.Str()
		sb.Clear()
		identCoder.iterNext(sb, uintptr(it))
		next := sb.Str()

		mut ref := false
		self.iterHead(it, ref, begin)
		if it.KeyA != nil {
			self.oc.varInitExpr(it.KeyA, fn() {
				if ref {
					self.oc.write("it - expr->begin()")
				} else {
					self.oc.write("it - expr.begin()")
				}
			})
			self.oc.write("\n")
			self.oc.indent()
		}
		if it.KeyB != nil {
			it.KeyB.Reference = opt::Copy && isIterCopyOptimizable(it.Expr, it.KeyB)
			self.oc.varInitExpr(it.KeyB, fn() {
				unsafe {
					if it.KeyB.Reference {
						self.oc.write("it")
					} else {
						self.oc.write("*it")
					}
				}
			})
			self.oc.write("\n")
			self.oc.indent()
		}
		self.scope(it.Scope)
		self.oc.write("\n")
		self.oc.indent()
		self.oc.write(next)
		self.oc.write(":;\n")
		self.oc.indent()
		self.oc.write("++it;\n")
		self.oc.indent()
		if it.KeyA != nil {
			identCoder.var(self.oc.Buf, it.KeyA)
			self.oc.write("++;\n")
			self.oc.indent()
		}
		self.oc.write("goto ")
		self.oc.write(begin)
		self.oc.write(";\n")

		// Close if.
		self.oc.doneIndent()
		self.oc.indent()
		self.oc.write("}\n")

		self.oc.indent()
		identCoder.iterEnd(self.oc.Buf, uintptr(it))
		self.oc.write(":;\n")

		// Close scope.
		self.oc.doneIndent()
		self.oc.indent()
		self.oc.write("}")
	}

	fn rangeHashmapIter(mut &self, mut &it: &sema::RangeIter) {
		mut sb := strings::Builder{}
		sb.Grow(1 << 6)
		identCoder.iterBegin(sb, uintptr(it))
		begin := sb.Str()
		sb.Clear()
		identCoder.iterNext(sb, uintptr(it))
		next := sb.Str()

		mut _map := it.Expr.Type.Map()
		mut ins := obj::FindStructGenericInstance(meta::Program.Runtime.Map, _map.Key, _map.Val)
		const Static = false
		mut f := ins.FindMethod("iterator", Static).Instances[0]

		mut iterator := obj::FindStructGenericInstance(meta::Program.Runtime.MapIterator, _map.Key, _map.Val)
		mut nextCall := iterator.FindMethod("next", Static).Instances[0]

		const resultName = "__iterator_result"
		const resultArgName = resultName + "." + resultArgName
		const resultKey = resultArgName + "0"
		const resultVal = resultArgName + "1"

		self.oc.write("{\n")
		self.oc.addIndent()
		self.oc.indent()
		self.oc.tc.structureIns(self.oc.Buf, iterator)
		self.oc.write(" it = ")
		identCoder.funcIns(self.oc.Buf, f)
		self.oc.write("(")
		self.oc.ec.possibleRefExpr(it.Expr.Model)
		self.oc.write(");\n")
		self.oc.indent()
		self.oc.write(begin)
		self.oc.write(":;\n")
		self.oc.indent()
		self.oc.tc.funcInsResult(self.oc.Buf, nextCall)
		self.oc.write(" ")
		self.oc.write(resultName)
		self.oc.write(" = ")
		identCoder.funcIns(self.oc.Buf, nextCall)
		self.oc.write("(&it);\n")
		self.oc.indent()
		self.oc.write("if (")
		self.oc.write(resultKey)
		self.oc.write(" != nullptr) {\n")
		self.oc.addIndent()
		self.oc.indent()
		if it.KeyA != nil {
			self.oc.varInitExpr(it.KeyA, fn() { self.oc.write("*" + resultKey) })
			self.oc.write("\n")
			self.oc.indent()
		}
		if it.KeyB != nil {
			self.oc.varInitExpr(it.KeyB, fn() { self.oc.write("*" + resultVal) })
			self.oc.write("\n")
			self.oc.indent()
		}
		self.scope(it.Scope)
		self.oc.write("\n")
		self.oc.indent()
		self.oc.write(next)
		self.oc.write(":;\n")
		self.oc.indent()
		self.oc.write("goto ")
		self.oc.write(begin)
		self.oc.write(";\n")

		// Close if.
		self.oc.doneIndent()
		self.oc.indent()
		self.oc.write("}\n")

		self.oc.indent()
		identCoder.iterEnd(self.oc.Buf, uintptr(it))
		self.oc.write(":;\n")

		// Close scope.
		self.oc.doneIndent()
		self.oc.indent()
		self.oc.write("}")
	}

	fn strRuneIter(mut &self, mut it: &opt::StrRuneIter) {
		mut sb := strings::Builder{}
		sb.Grow(1 << 6)
		identCoder.iterBegin(sb, uintptr(it.Base))
		begin := sb.Str()
		sb.Clear()
		identCoder.iterNext(sb, uintptr(it.Base))
		next := sb.Str()

		self.oc.write("{\n")
		self.oc.addIndent()
		self.oc.indent()

		mut ref := false
		self.oc.write("auto expr = ")
		if opt::Copy && isCopyOptimizable(it.Expr) {
			ref = true
			match type it.Expr.Model {
			| &sema::Var:
				v := (&sema::Var)(it.Expr.Model)
				if v.Reference {
					self.oc.ec.model(it.Expr.Model)
					break
				}
				fall
			|:
				self.oc.write("&(")
				self.oc.ec.model(it.Expr.Model)
				self.oc.write(")")
			}
		} else {
			self.oc.ec.possibleRefExpr(it.Expr.Model)
		}
		self.oc.write(";\n")
		self.oc.indent()
		self.oc.write(typeU8)
		self.oc.write(" *it = expr")
		if ref {
			self.oc.write("->")
		} else {
			self.oc.write(".")
		}
		self.oc.write("begin();\n")
		self.oc.indent()
		self.oc.write("const ")
		self.oc.write(typeU8)
		self.oc.write(" *end = it + expr")
		if ref {
			self.oc.write("->")
		} else {
			self.oc.write(".")
		}
		self.oc.write("len();\n")
		self.oc.indent()

		// Variables.
		if it.Base.KeyA != nil {
			self.oc.varInitExpr(it.Base.KeyA, fn() { self.oc.write("0") })
			self.oc.write("\n")
			self.oc.indent()
		}
		self.oc.write(typeInt)
		self.oc.write(" len;\n")
		self.oc.indent()
		if it.Base.KeyB != nil {
			self.oc.varInitExpr(it.Base.KeyB, nil)
			self.oc.write("\n")
			self.oc.indent()
		}
		self.oc.write(begin)
		self.oc.write(":;\n")
		self.oc.indent()
		self.oc.write("__jule_runeStep(it, end - it, ")
		if it.Base.KeyB != nil {
			self.oc.write("&")
			identCoder.var(self.oc.Buf, it.Base.KeyB)
		} else {
			self.oc.write("nullptr")
		}
		self.oc.write(", &len);\n")
		self.oc.indent()

		self.oc.write("if (it < end) {\n")
		self.oc.addIndent()
		self.oc.indent()
		self.scope(it.Base.Scope)
		self.oc.write("\n")
		self.oc.indent()
		self.oc.write(next)
		self.oc.write(":;\n")
		self.oc.indent()
		self.oc.write("it += len;\n")
		self.oc.indent()
		if it.Base.KeyA != nil {
			identCoder.var(self.oc.Buf, it.Base.KeyA)
			self.oc.write("++;\n")
			self.oc.indent()
		}
		self.oc.write("goto ")
		self.oc.write(begin)
		self.oc.write(";\n")

		// Close if.
		self.oc.doneIndent()
		self.oc.indent()
		self.oc.write("}\n")

		// Close scope.
		self.oc.doneIndent()
		self.oc.indent()
		self.oc.write("}")
	}

	fn ifCase(mut &self, mut i: &sema::If) {
		if i.Expr != nil {
			self.oc.write("if (")
			self.oc.ec.possibleRefExpr(i.Expr)
			self.oc.write(") ")
		}
		self.scope(i.Scope)
	}

	fn conditional(mut &self, mut c: &sema::Conditional) {
		mut written := false
		for (_, mut elif) in c.Elifs {
			if elif == nil {
				continue
			}
			if written {
				self.oc.write(" else ")
			}
			written = true
			self.ifCase(elif)
		}
		if c.Default != nil {
			if written {
				self.oc.write(" else ")
			}
			self.scope(c.Default.Scope)
		}
	}

	fn infIter(mut &self, mut it: &sema::InfIter) {
		self.oc.write("for (;;) {\n")
		self.oc.addIndent() // Indent scope.
		self.oc.indent()
		self.scope(it.Scope)
		self.oc.doneIndent()
		self.oc.write("\n")
		self.oc.indent()
		identCoder.iterNext(self.oc.Buf, uintptr(it))
		self.oc.write(":;\n")
		self.oc.indent()
		self.oc.write("}\n")
		self.oc.indent()
		identCoder.iterEnd(self.oc.Buf, uintptr(it))
		self.oc.write(":;")
	}

	fn whileIter(mut &self, mut it: &sema::WhileIter) {
		if it.Expr != nil && it.Next == nil {
			self.oc.write("while (")
			self.oc.ec.possibleRefExpr(it.Expr)
			self.oc.write(") {")
		} else {
			self.oc.write("for (; ")
			if it.Expr != nil {
				self.oc.ec.possibleRefExpr(it.Expr)
			}
			self.oc.write("; ")
			if it.Next != nil {
				self.st(it.Next)
			}
			self.oc.write(") {")
		}

		if len(it.Scope.Stmts) == 0 {
			self.oc.write("}")
			ret
		}

		self.oc.write("\n")
		self.oc.addIndent()
		self.oc.indent()
		self.scope(it.Scope)
		self.oc.write("\n")
		self.oc.doneIndent()
		self.oc.indent()

		identCoder.iterNext(self.oc.Buf, uintptr(it))
		self.oc.write(":;\n")
		self.oc.indent()
		self.oc.write("}\n")
		self.oc.indent()
		identCoder.iterEnd(self.oc.Buf, uintptr(it))
		self.oc.write(":;")
	}

	fn rangeIter(mut &self, mut it: &sema::RangeIter) {
		match {
		| it.Expr.Type.Chan() != nil:
			self.rangeChanIter(it)
		| it.Expr.Type.Slice() != nil:
			self.rangeIndexIter(it)
		| it.Expr.Type.Array() != nil:
			self.rangeIndexIter(it)
		| it.Expr.Type.Map() != nil:
			self.rangeHashmapIter(it)
		|:
			self.rangeIndexIter(it) // Str
		}
	}

	fn continueStmt(mut &self, c: &sema::Continue) {
		self.oc.write("goto ")
		identCoder.iterNext(self.oc.Buf, c.It)
	}

	fn label(mut &self, l: &sema::Label) {
		identCoder.label(self.oc.Buf, uintptr(l))
		self.oc.write(":")
	}

	fn gotoStmt(mut &self, gt: &sema::Goto) {
		self.oc.write("goto ")
		identCoder.label(self.oc.Buf, uintptr(gt.Label))
	}

	fn tryMapSet(mut &self, m: sema::Expr): (ok: bool) {
		match type m {
		| &sema::IndexingExpr:
			mut iem := (&sema::IndexingExpr)(m)
			_map := iem.Expr.Type.Map()
			if _map == nil {
				break
			}
			// Map indexing used for assignment.
			// Generate direct lookup unlike expression coder.
			mut ins := obj::FindStructGenericInstance(meta::Program.Runtime.Map, _map.Key, _map.Val)
			const Static = false
			mut f := ins.FindMethod("set", Static).Instances[0]
			self.oc.write("(*")
			identCoder.funcIns(self.oc.Buf, f)
			self.oc.write("((")
			self.oc.ec.possibleRefExpr(iem.Expr.Model)
			self.oc.write(").ptr(")
			if !env::Production {
				self.oc.write("\"")
				self.oc.locInfo(iem.Token)
				self.oc.write("\"")
			}
			self.oc.write("), ")
			self.oc.ec.possibleRefExpr(iem.Index.Model)
			self.oc.write("))")
			ok = true
		}
		ret
	}

	fn postfix(mut &self, mut p: &sema::Postfix) {
		self.oc.write("(")
		ok := self.tryMapSet(p.Expr)
		if !ok {
			self.oc.ec.possibleRefExpr(p.Expr)
		}
		self.oc.write(")")
		self.oc.write(p.Op)
	}

	fn assignLeft(mut &self, mut &model: sema::Expr) {
		ok := self.tryMapSet(model)
		if !ok {
			self.oc.ec.possibleRefExpr(model)
		}
	}

	fn shl(mut &self, mut a: &sema::Assign) {
		self.assignLeft(a.Left.Model)
		self.oc.write(" = ")
		self.oc.ec.shl(a.Left, a.Right)
	}

	fn shr(mut &self, mut a: &sema::Assign) {
		self.assignLeft(a.Left.Model)
		self.oc.write(" = ")
		self.oc.ec.shr(a.Left, a.Right)
	}

	fn divByZeroAssign(mut &self, mut a: &sema::Assign) {
		self.assignLeft(a.Left.Model)
		self.oc.write(" = ")
		self.oc.ec.divByZeroBinary(a.Op, a.Left, a.Right)
	}

	fn assign(mut &self, mut a: &sema::Assign) {
		match a.Op.Id {
		| token::Id.SolidusEq | token::Id.PercentEq:
			if env::Safety {
				self.divByZeroAssign(a)
				ret
			}
		| token::Id.ShlEq:
			self.shl(a)
			ret
		| token::Id.ShrEq:
			self.shr(a)
			ret
		}

		// optimize may optimize multi-assign statements
		// it uses common tokens of normalized statement
		// so it may be := assignment token, it is not a bug
		// handle it like the equal operator
		mut op := a.Op.Id
		mut kind := a.Op.Kind
		if a.Op.Id == token::Id.ColonEq {
			op = token::Id.Eq
			kind = token::Kind.Eq
		}

		self.assignLeft(a.Left.Model)
		self.oc.write(kind)
		self.oc.ec.possibleRefExpr(a.Right.Model)
	}

	fn mapLookupAssign(mut &self, mut &a: &sema::MultiAssign) {
		// map lookup right expression always should be indexing
		mut iem := (&sema::IndexingExpr)(a.Right)
		mut _map := iem.Expr.Type.Map()

		mut ins := obj::FindStructGenericInstance(meta::Program.Runtime.Map, _map.Key, _map.Val)
		const Static = false
		mut f := ins.FindMethod("lookup", Static).Instances[0]

		identCoder.funcIns(self.oc.Buf, f)
		self.oc.write("(")
		self.assignLeft(iem.Expr.Model)
		self.oc.write(", ")
		self.oc.ec.possibleRefExpr(iem.Index.Model)
		self.oc.write(", ")
		if a.Left[0] != nil {
			self.oc.write("&(")
			self.oc.ec.possibleRefExpr(a.Left[0].Model)
			self.oc.write("), ")
		} else {
			self.oc.write("nullptr, ")
		}
		if a.Left[1] != nil {
			self.oc.write("&(")
			self.oc.ec.possibleRefExpr(a.Left[1].Model)
			self.oc.write(")")
		} else {
			self.oc.write("nullptr")
		}
		self.oc.write(")")
	}

	fn multiAssignTuple(mut &self, mut &a: &sema::MultiAssign) {
		self.oc.write("({\n")
		self.oc.addIndent()

		// tuple expressions may have reference for receiver memory
		// since receivers implemented as pointers they should take the pointer
		// to the actual expression of tuple
		// therefore do not generate temporary variable for references
		// they should take pointer from the tuple data

		mut tup := (&sema::TupleExpr)(a.Right)

		for (i, mut r) in tup.Values {
			self.oc.indent()
			mut l := a.Left[i]
			if l != nil {
				match type l.Model {
				| &sema::Var:
					mut v := (&sema::Var)(l.Model)
					if !v.Reference {
						break
					}
					// left expression is a reference variable
					// lookup declared variables in this assignment
					// so we can detetermine reference variable is declared or assigned
					for _, dv in a.Decls {
						if v == dv {
							goto found
						}
					}
					// variable is not exist in declared variables
					// it can take temporary variable strategy
					// it just takes assignment to the pointing data
					// not takes pointer of the lvalue data
					break
				found:
					// variable is declaring now
					// takes pointer from the lvalue tuple data
					identCoder.var(self.oc.Buf, v)
					self.oc.write(" = &(")
					self.oc.ec.possibleRefExpr(r.Model)
					self.oc.write(");\n")
					a.Left[i] = nil // Ignore handling for following statements.
					continue
				}
				self.oc.tc.kind(self.oc.Buf, l.Type)
				self.oc.write(" ")
				identCoder.toOut(self.oc.Buf, assignArgName, uintptr(i))
				self.oc.write(" = ")
			}
			self.oc.ec.possibleRefExpr(r.Model)
			self.oc.write(";\n")
		}

		for (i, mut l) in a.Left {
			if l == nil {
				continue
			}
			self.oc.indent()
			self.assignLeft(l.Model)
			self.oc.write(" = ")
			identCoder.toOut(self.oc.Buf, assignArgName, uintptr(i))
			self.oc.write(";\n")
		}

		self.oc.doneIndent()
		self.oc.indent()
		self.oc.write("})")
	}

	fn multiAssignFunc(mut &self, mut &a: &sema::MultiAssign) {
		self.oc.write("({\n")
		self.oc.addIndent()
		self.oc.indent()

		mut f := (&sema::FuncCallExpr)(a.Right)
		self.oc.tc.rc.codeMut1(self.oc.Buf, f.Func.Result)
		self.oc.write(" " + assignResultName + " = ")
		self.oc.ec.possibleRefExpr(a.Right)
		self.oc.write(";\n")

		mut tup := f.Func.Result.Tuple()
		for (i, mut l) in a.Left {
			if l == nil {
				continue
			}
			const r = assignResultName + "." + resultArgName
			self.oc.indent()
			self.assignLeft(l.Model)
			match {
			| tup.Types[i].Equal(l.Type):
				self.oc.write(" = " + r)
				self.oc.write(conv::Itoa(i))
			| obj::IsAny(l.Type):
				self.oc.write(" = " + typeAny + "(" + r)
				self.oc.write(conv::Itoa(i))
				self.oc.write(", &" + anyTypeIdent)
				self.oc.write(conv::Itoa(self.oc.pushAnyType(tup.Types[i])))
				self.oc.write(")")
			|:
				// It should be trait.
				if tup.Types[i].Trait() != nil { // Different traits, cast.
					self.oc.write(" = ")
					mut t1 := l.Type.Trait()
					mut t2 := tup.Types[i].Trait()
					self.oc.write(r)
					self.oc.write(conv::Itoa(i))
					self.oc.write(".map(")
					self.oc.pushAndWriteMaskMapper(t1, t2)
					self.oc.write(")")
					break
				}
				t := l.Type.Trait()
				self.oc.write(" = " + typeTrait + "(" + r)
				self.oc.write(conv::Itoa(i))
				self.oc.write(", (" + typeTrait + "::Type*)&")
				identCoder.traitDecl(self.oc.Buf, t)
				self.oc.write("_mptr_data")
				self.oc.write(conv::Itoa(obj::FindTraitTypeOffset(t, tup.Types[i])))
				self.oc.write(")")
			}
			self.oc.write(";\n")
		}

		self.oc.doneIndent()
		self.oc.indent()
		self.oc.write("})")
	}

	// Handles channel receive expression assignments like; data, ok := <-c
	fn chanRecvAssign(mut &self, mut a: &sema::MultiAssign) {
		if a.Left[0] == nil && a.Left[1] == nil {
			// Expression is like: _, _ = <-c
			// Handle as plain expression.
			self.oc.ec.chanRecv((&sema::ChanRecv)(a.Right), nil, false)
			ret
		}
		if a.Left[0] != nil {
			// Received data assigned to this.
			self.oc.ec.possibleRefExpr(a.Left[0].Model)
			self.oc.write(" = ")
		}
		let mut ok: fn() = nil
		if a.Left[1] != nil {
			// The |ok| parameter found.
			// Pass the memory of the lvalue to the receiver function.
			ok = fn() {
				self.oc.write("&(")
				self.oc.ec.possibleRefExpr(a.Left[1].Model)
				self.oc.write(")")
			}
		}
		self.oc.ec.chanRecv((&sema::ChanRecv)(a.Right), ok, false)
	}

	fn castingAssertionAssign(mut &self, mut a: &sema::MultiAssign) {
		mut ce := (&sema::CastingExpr)(a.Right)
		mut f := obj::FindFuncGenericInstance(meta::Program.Runtime.DynAssertAssign, ce.Expr.Type, ce.Type)
		identCoder.funcIns(self.oc.Buf, f)
		self.oc.write("(")
		self.assignLeft(ce.Expr.Model)
		self.oc.write(", ")
		if a.Left[0] != nil {
			self.oc.write("&(")
			self.oc.ec.possibleRefExpr(a.Left[0].Model)
			self.oc.write("), ")
		} else {
			self.oc.write("nullptr, ")
		}
		if a.Left[1] != nil {
			self.oc.write("&(")
			self.oc.ec.possibleRefExpr(a.Left[1].Model)
			self.oc.write(")")
		} else {
			self.oc.write("nullptr")
		}
		self.oc.write(")")
	}

	fn multiAssign(mut &self, mut a: &sema::MultiAssign) {
		// Write declarations without no initialization.
		// It will initialize with assignments.
		for (_, mut d) in a.Decls {
			self.oc.varInitExpr(d, nil)
			self.oc.write("\n")
			self.oc.indent()
		}

		// Special cases.
		match type a.Right {
		| &sema::IndexingExpr:
			self.mapLookupAssign(a)
			ret
		| &sema::CastingExpr:
			self.castingAssertionAssign(a)
			ret
		| &sema::ChanRecv:
			self.chanRecvAssign(a)
			ret
		}

		match type a.Right {
		| &sema::TupleExpr:
			self.multiAssignTuple(a)
		| &sema::FuncCallExpr:
			self.multiAssignFunc(a)
		|:
			panic("cxx: this panic call should be unreachable")
		}
	}

	fn matchExpr(mut &self, mut m: &sema::Match): fn() {
		if !m.Expr.IsConst() {
			ret fn() { self.oc.write(matchExpr) }
		}
		if !m.Expr.Constant.IsBool() || !m.Expr.Constant.ReadBool() {
			ret fn() { self.oc.ec.possibleRefExpr(m.Expr.Model) }
		}
		ret nil
	}

	fn case(mut &self, mut m: &sema::Match, mut c: &sema::Case) {
		if len(c.Exprs) != 0 && !m.Comptime {
			if len(m.Cases) > 0 && m.Cases[0] == c {
				self.oc.write("if (")
			} else {
				self.oc.write("else if (")
			}
			for (i, mut expr) in c.Exprs {
				match {
				| !m.TypeMatch:
					caseExpr := self.matchExpr(m)
					if m.Expr.GoodOperand(expr) {
						if caseExpr != nil {
							caseExpr()
							self.oc.write(" == ")
						}
						self.oc.ec.possibleRefExpr(expr.Model)
					} else {
						self.oc.ec.possibleRefExpr(expr.Model)
						if caseExpr != nil {
							self.oc.write(" == ")
							caseExpr()
						}
					}
				|:
					self.oc.write(matchExpr)
					mut tk := (&sema::Type)(expr.Model)
					if m.Expr.Type.Trait() != nil { // Trait type.
						t := m.Expr.Type.Trait()
						self.oc.write(".type == (" + typeTrait + "::Type*)&")
						identCoder.traitDecl(self.oc.Buf, t)
						self.oc.write("_mptr_data")
						self.oc.write(conv::Itoa(obj::FindTraitTypeOffset(m.Expr.Type.Trait(), expr.Type)))
					} else { // Any type.
						j := self.oc.pushAnyType(tk)
						self.oc.write(".type == &" + anyTypeIdent)
						self.oc.write(conv::Itoa(j))
					}
				}

				if len(c.Exprs)-i > 1 {
					self.oc.write(" || ")
				}
			}
			self.oc.write(") ")
		} else if m.Default == c && len(m.Cases) != 0 {
			self.oc.indent()
			self.oc.write("else ")
		}

		self.oc.addIndent()

		self.oc.write("{\n")
		self.oc.indent()
		identCoder.caseBegin(self.oc.Buf, uintptr(c))
		self.oc.write(":;\n")
		if len(c.Scope.Stmts) > 0 {
			self.oc.indent()
			self.scope(c.Scope)
			self.oc.write("\n")
		}

		self.oc.doneIndent()

		self.oc.indent()
		self.oc.write("}")
	}

	fn matchStmt(mut &self, mut m: &sema::Match) {
		if len(m.Cases) == 0 && m.Default == nil {
			ret
		}

		if m.Comptime && (m.Default == nil || len(m.Default.Scope.Stmts) == 0) {
			ret
		}

		self.oc.write("{\n")

		self.oc.addIndent()

		self.oc.indent()

		// Constant expressions generated as literals in conditions.
		if !m.Comptime && !m.Expr.IsConst() {
			if opt::Copy && isCopyOptimizable(m.Expr) {
				self.oc.write("auto &_match_expr{ ")
			} else {
				self.oc.write("auto _match_expr{ ")
			}
			self.oc.ec.possibleRefExpr(m.Expr.Model)
			self.oc.write(" };\n")
			self.oc.indent()
		}

		if len(m.Cases) > 0 {
			for (_, mut c) in m.Cases {
				if c == nil {
					continue
				}
				self.oc.write("\n")
				self.oc.indent()
				self.case(m, c)
			}
		}

		if m.Default != nil {
			self.oc.write("\n")
			self.case(m, m.Default)
		}

		self.oc.write("\n")
		self.oc.indent()
		identCoder.matchEnd(self.oc.Buf, uintptr(m))
		self.oc.write(":;")
		self.oc.write("\n")

		self.oc.doneIndent()

		self.oc.indent()
		self.oc.write("}")
	}

	fn selectStmt(mut &self, mut slct: &sema::Select) {
		if len(slct.Cases) == 0 {
			// Empty select.
			if slct.Default == nil {
				identCoder.funcIns(self.oc.Buf, meta::Program.Runtime.ChanSelect)
				self.oc.write("(nullptr, 0, 0, false);")
			} else {
				// Just the default case.
				self.scope(slct.Default.Scope)
			}
			ret
		}
		// Non-empty select.
		// Generate necessary data and call the select statement function.
		// See the [runtime::chanSelect] function for documentation.
		self.oc.write("{\n")
		self.oc.addIndent()
		self.oc.indent()

		// Whether it is a blocking select.
		block := slct.Default == nil

		// Generate code for [runtime::hchan] type.
		mut hchan := ""
		{
			mut sbuf := strings::Builder{}
			sbuf.Grow(40)
			self.oc.tc.structure(sbuf, meta::Program.Runtime.Hchan)
			hchan = sbuf.Str()
		}

		// NOTE:
		// Create array for channels. This implementation will not check
		// the channel count, but probably total count of channel will not
		// cause overflow by size.
		self.oc.tc.asSptr(self.oc.Buf, unsafe::StrBytes(hchan))
		self.oc.write(" __jule_chans[] = {")
		// Most common use case, assume 1 chan-recv/chan-send per case.
		// In the end, len(chans) equals to total count of chans.
		// All elements, matched by index which returned by the select algorithm.
		// So chans[i] always the matched case, if exist.
		mut chans := make([]chanCase, 0, len(slct.Cases))
		mut &_chans := chans // Used by closure, unsafely.
		obj::IterCaseExprs(slct.Cases, fn(mut &c: &sema::Case, mut &val: &sema::Value) {
			match type val.Model {
			| &sema::ChanRecv:
				unsafe { _chans = append(_chans, chanCase{c, val}) }
				mut cr := (&sema::ChanRecv)(val.Model)
				self.oc.ec.possibleRefExpr(cr.Expr.Model)
				self.oc.write(".as<")
				self.oc.write(hchan)
				self.oc.write(">(), ")
			}
		})
		recvChans := len(chans) // Total count of chan-recv cases.
		obj::IterCaseExprs(slct.Cases, fn(mut &c: &sema::Case, mut &val: &sema::Value) {
			match type val.Model {
			| &sema::ChanSend:
				unsafe { _chans = append(_chans, chanCase{c, val}) }
				mut cr := (&sema::ChanSend)(val.Model)
				self.oc.ec.possibleRefExpr(cr.Chan.Model)
				self.oc.write(".as<")
				self.oc.write(hchan)
				self.oc.write(">(), ")
			}
		})
		self.oc.write("};\n")
		self.oc.indent()
		self.oc.write(typeInt)
		self.oc.write(" __offset = ")
		identCoder.funcIns(self.oc.Buf, meta::Program.Runtime.ChanSelect)
		self.oc.write("(__jule_chans, ")
		self.oc.write(conv::Itoa(len(chans)))
		self.oc.write(", ")
		self.oc.write(conv::Itoa(recvChans))
		self.oc.write(", ")
		self.oc.write(conv::FmtBool(block))
		self.oc.write(");\n")
		self.oc.indent()
		if !block {
			// This if condition is unnecessart for blocking select statements.
			self.oc.write("if (__offset >= 0) {\n")
			self.oc.addIndent()
		}
		self.oc.indent()
		self.oc.write("switch (__offset) {\n")

		// Generate cases, match them, and execute.
		genCase := fn(i: int, mut &c: chanCase) {
			// We have to convert hchan to pchan.
			// So use custom built-in expression for that.
			mut sb := strings::Builder{}
			sb.Grow(40)
			sb.WriteStr("__jule_chans[")!
			sb.WriteStr(conv::Itoa(i))!
			sb.WriteStr("].as<")!
			match type c.Value.Model {
			| &sema::ChanRecv:
				mut cr := (&sema::ChanRecv)(c.Value.Model)
				mut pchan := obj::FindStructGenericInstance(meta::Program.Runtime.Pchan, cr.Expr.Type.Chan().Elem)
				self.oc.tc.structureIns(sb, pchan)
				sb.WriteStr(">()")!
				model := any(sb.Str())
				cr.Expr.Model = unsafe { *(*sema::Expr)(&model) }
				self.oc.ec.chanRecv(cr, nil, true)
			| &sema::ChanSend:
				mut cs := (&sema::ChanSend)(c.Value.Model)
				mut pchan := obj::FindStructGenericInstance(meta::Program.Runtime.Pchan, cs.Chan.Type.Chan().Elem)
				self.oc.tc.structureIns(sb, pchan)
				sb.WriteStr(">()")!
				model := any(sb.Str())
				cs.Chan.Model = unsafe { *(*sema::Expr)(&model) }
				self.oc.ec.chanSend(cs, true)
			|:
				panic("unreachable")
			}
			self.oc.write(";\n")
			self.oc.indent()
			self.scope(c.Case.Scope)
			self.oc.write("\n")
		}
		for (i, mut c) in chans {
			self.oc.indent()
			self.oc.write("case ")
			self.oc.write(conv::Itoa(i))
			self.oc.write(":\n")
			self.oc.addIndent()
			self.oc.indent()
			genCase(i, c)
			self.oc.indent()
			self.oc.write("break;\n")
			self.oc.doneIndent()
		}
		// Closing switch.
		self.oc.indent()
		self.oc.write("}\n")
		self.oc.doneIndent()

		// Closing if.
		if !block {
			self.oc.indent()
			self.oc.write("} else ")
			self.scope(slct.Default.Scope) // Default scope is should not be nil.
			self.oc.write("\n")
			self.oc.doneIndent()
		}

		self.oc.indent()
		identCoder.matchEnd(self.oc.Buf, uintptr(slct))
		self.oc.write(":;\n")

		// Closing inner.
		self.oc.indent()
		self.oc.write("}")
	}

	fn fallStmt(mut &self, f: &sema::Fall) {
		self.oc.write("goto ")
		identCoder.caseBegin(self.oc.Buf, f.DestCase)
	}

	fn breakStmt(mut &self, b: &sema::Break) {
		self.oc.write("goto ")
		match {
		| b.It != 0:
			identCoder.iterEnd(self.oc.Buf, b.It)
		| b.Match != 0:
			identCoder.matchEnd(self.oc.Buf, b.Match)
		| b.Select != 0:
			identCoder.matchEnd(self.oc.Buf, b.Select)
		|:
			panic("unreachable")
		}
	}

	fn setResult(mut &self, mut r: &sema::Ret) {
		if len(r.Func.Decl.Result.Idents) == 1 {
			self.oc.write(resultName + " = ")
			self.oc.ec.possibleRefExpr(r.Expr)
			self.oc.write(";\n")
			self.oc.indent()
			ret
		}
		match type r.Expr {
		| &sema::TupleExpr:
			mut values := (&sema::TupleExpr)(r.Expr).Values
			for i, v in values {
				self.oc.write(resultName + "." + resultArgName)
				self.oc.write(conv::Itoa(i))
				self.oc.write(" = ")
				self.oc.ec.possibleRefExpr(v.Model)
				self.oc.write(";\n")
				self.oc.indent()
			}
		| &sema::FuncCallExpr:
			self.oc.write(resultName + " = std::move(")
			self.oc.ec.model(r.Expr)
			self.oc.write(");\n")
		|:
			panic("cxx: implementation mistake, this panic call should be unreachable")
		}
	}

	fn retStmt(mut &self, mut r: &sema::Ret) {
		hasDefer := r.Func.Decl != nil && r.Func.Decl.HasDefer
		if r.Func.Decl.IsVoid() {
			if hasDefer {
				self.oc.write(deferStackName + ".call();\n")
				self.oc.indent()
			}
			if r.Func.Decl.Exceptional {
				self.oc.write("return jule::VoidExceptional{};")
				ret
			}
			self.oc.write("return;")
			ret
		} else if len(r.Func.Decl.Result.Idents) == 0 {
			if r.Func.Decl.Exceptional {
				self.oc.write("return jule::Exceptional<")
				self.oc.tc.kind(self.oc.Buf, r.Func.Result)
				self.oc.write(">{.result=")
				if hasDefer {
					self.oc.write("({ ")
					self.oc.tc.kind(self.oc.Buf, r.Func.Result)
					self.oc.write(" __result = ")
				}
				self.oc.ec.possibleRefExpr(r.Expr)
				if hasDefer {
					self.oc.write("; " + deferStackName + ".call(); __result; })")
				}
				self.oc.write("};")
			} else {
				self.oc.write("return ")
				if hasDefer {
					self.oc.write("({ ")
					self.oc.tc.kind(self.oc.Buf, r.Func.Result)
					self.oc.write(" __result = ")
				}
				self.oc.ec.possibleRefExpr(r.Expr)
				if hasDefer {
					self.oc.write(";" + deferStackName + ".call(); __result; })")
				}
				self.oc.write(";")
			}
			ret
		}

		if r.Expr != nil {
			self.setResult(r)
		}
		// We can call defer stack here if exist.
		// All result arguments evaluated and stored.
		if hasDefer {
			self.oc.write(deferStackName + ".call();\n")
			self.oc.indent()
		}
		if r.Func.Decl.Exceptional {
			self.oc.write("return jule::Exceptional<")
			self.oc.tc.rc.codeMut1(self.oc.Buf, r.Func.Result)
			self.oc.write(">{.result=" + resultName + "};")
		} else {
			self.oc.write("return " + resultName + ";")
		}
	}

	fn var(mut &self, mut v: &sema::Var) {
		if !v.Constant {
			self.oc.var(v)
		}
	}

	fn mutSlicing(mut &self, mut m: &opt::MutSlicingExpr) {
		self.oc.write("(")
		self.oc.ec.possibleRefExpr(m.Expr)
		self.oc.write(").mut_slice(")
		if !env::Production {
			self.oc.write("\"")
			self.oc.locInfo(m.Token)
			self.oc.write("\", ")
		}
		self.oc.ec.possibleRefExpr(m.Left)
		if m.Right != nil {
			self.oc.write(", ")
			self.oc.ec.possibleRefExpr(m.Right)
		}
		self.oc.write(");")
	}

	fn swap(mut &self, mut m: &opt::SwapExpr) {
		self.oc.write("std::swap(")
		self.oc.ec.possibleRefExpr(m.Left.Model)
		self.oc.write(", ")
		self.oc.ec.possibleRefExpr(m.Right.Model)
		self.oc.write(")")
	}

	fn exceptionalForwarding(mut &self, mut m: &opt::ExceptionalForwardingExpr) {
		self.oc.write("return ")
		self.oc.ec.pureFuncCall(m.Expr)
	}

	// Generates C++ code of statement.
	fn st(mut &self, mut st: compStmt) {
		if st == nil {
			ret
		}
		match type st {
		| &sema::Scope:
			self.scope((&sema::Scope)(st))
		| &sema::Var:
			self.var((&sema::Var)(st))
		| &sema::Value:
			v := (&sema::Value)(st)
			// Catch anonymous functions created by defer scope.
			// Push them to defer stack.
			match type v.Model {
			| &sema::AnonFuncExpr:
				f := (&sema::AnonFuncExpr)(v.Model)
				if f.Func.Scope != nil && f.Func.Scope.Deferred {
					self.oc.write(deferStackName + ".push(")
					self.oc.ec.model(v.Model)
					self.oc.write(")")
					ret
				}
			}
			self.oc.ec.model(v.Model)
		| &sema::Conditional:
			self.conditional((&sema::Conditional)(st))
		| &sema::InfIter:
			self.infIter((&sema::InfIter)(st))
		| &sema::WhileIter:
			self.whileIter((&sema::WhileIter)(st))
		| &sema::RangeIter:
			self.rangeIter((&sema::RangeIter)(st))
		| &sema::Continue:
			self.continueStmt((&sema::Continue)(st))
		| &sema::Label:
			self.label((&sema::Label)(st))
		| &sema::Goto:
			self.gotoStmt((&sema::Goto)(st))
		| &sema::Postfix:
			self.postfix((&sema::Postfix)(st))
		| &sema::Assign:
			self.assign((&sema::Assign)(st))
		| &sema::MultiAssign:
			self.multiAssign((&sema::MultiAssign)(st))
		| &sema::Match:
			self.matchStmt((&sema::Match)(st))
		| &sema::Select:
			self.selectStmt((&sema::Select)(st))
		| &sema::Fall:
			self.fallStmt((&sema::Fall)(st))
		| &sema::Break:
			self.breakStmt((&sema::Break)(st))
		| &sema::Ret:
			self.retStmt((&sema::Ret)(st))
		| &opt::PushToSliceExpr:
			self.oc.ec.pushToSlice((&opt::PushToSliceExpr)(st))
		| &opt::AppendToSliceExpr:
			self.oc.ec.appendToSlice((&opt::AppendToSliceExpr)(st))
		| &opt::MutSlicingExpr:
			self.mutSlicing((&opt::MutSlicingExpr)(st))
		| &opt::SwapExpr:
			self.swap((&opt::SwapExpr)(st))
		| &opt::ExceptionalForwardingExpr:
			self.exceptionalForwarding((&opt::ExceptionalForwardingExpr)(st))
		| &opt::StrRuneIter:
			self.strRuneIter((&opt::StrRuneIter)(st))
		|:
			self.oc.write("<unimplemented_stmt>")
		}
	}

	fn scopeStmts(mut &self, mut &s: &sema::Scope) {
		for (_, mut st) in s.Stmts {
			self.oc.indent()
			self.st(st)
			self.oc.write(";\n")
		}
	}

	// Generates C++ code of scope.
	fn scope(mut &self, mut s: &sema::Scope) {
		self.oc.addIndent()
		self.oc.write("{\n")
		self.scopeStmts(s)
		self.oc.doneIndent()
		self.oc.indent()
		self.oc.write("}")
	}

	fn commonFuncScope(mut &self, mut &f: &sema::FuncIns) {
		if !f.Decl.IsVoid() {
			mut tup := f.Result.Tuple()
			if tup != nil {
				self.oc.indent()
				self.oc.tc.rc.tuple(self.oc.Buf, tup)
				self.oc.write(" " + resultName + ";\n")
				for (i, mut t) in tup.Types {
					if shouldInitialized(t) {
						self.oc.indent()
						self.oc.write(resultName + "." + resultArgName)
						self.oc.write(conv::Itoa(i))
						self.oc.write(" = ")
						self.oc.ec.initExpr(t)
						self.oc.write(";\n")
					}
				}
			} else if len(f.Decl.Result.Idents) == 1 {
				// Non-tuple single return type with identifier.
				// Use [resultName] as identifier.
				self.oc.indent()
				self.oc.tc.kind(self.oc.Buf, f.Result)
				self.oc.write(" " + resultName)
				if shouldInitialized(f.Result) {
					self.oc.write(" = ")
					self.oc.ec.initExpr(f.Result)
				}
				self.oc.write(";\n")
			}
		}
		if f.Decl.HasDefer {
			self.oc.indent()
			self.oc.write("jule::DeferStack " + deferStackName + ";\n")
		}
		self.scopeStmts(f.Scope)

		// Before executing final steps, checks whether the scope has final statement
		// already such as return statement or error call.
		if len(f.Scope.Stmts) > 0 {
			stmt := f.Scope.Stmts[len(f.Scope.Stmts)-1]
			match type stmt {
			| &sema::Ret:
				ret
			| &sema::Value:
				v := (&sema::Value)(stmt)
				match type v.Model {
				| &sema::BuiltinErrorCallExpr
				| &sema::BuiltinPanicCallExpr:
					ret
				}
			}
		}

		if f.Decl.HasDefer {
			self.oc.indent()
			self.oc.write(deferStackName + ".call();\n")
		}
		if f.Decl.Exceptional && f.Decl.IsVoid() {
			// Just for void exceptionals.
			// Other cases checked by semantic analsis and disallowed
			// if they are not returns.
			self.oc.indent()
			self.oc.write("return jule::VoidExceptional{};\n")
		}
	}

	fn anonFuncScope(mut &self, mut m: &sema::AnonFuncExpr, ident: str) {
		if m.Func.Scope == nil {
			ret
		}
		closure := obj::IsClosure(m)
		if closure {
			self.oc.ec.varPrefixes = append(self.oc.ec.varPrefixes, fn(mut v: &sema::Var): bool { ret captureVarHandling(self.oc, m, v) })
		}
		self.oc.write("{\n")
		self.oc.addIndent()

		if closure {
			// Get ctx.
			self.oc.indent()
			self.oc.write(typePtr + "<")
			self.oc.write(ident)
			self.oc.write(anonFuncCtxSuffix + "> " + closureCtxIdent + " = " + ctxParamIdent + ".as<")
			self.oc.write(ident)
			self.oc.write(anonFuncCtxSuffix + ">();\n")
		}

		self.commonFuncScope(m.Func)

		self.oc.doneIndent()
		self.oc.indent()
		self.oc.write("}")
		if closure {
			self.oc.ec.varPrefixes = self.oc.ec.varPrefixes[:len(self.oc.ec.varPrefixes)-1]
		}
	}

	// Generates C++ code of function's scope.
	fn funcScope(mut &self, mut f: &sema::FuncIns) {
		if f.Scope == nil {
			ret
		}
		self.oc.write("{\n")
		self.oc.addIndent()
		self.commonFuncScope(f)
		self.oc.doneIndent()
		self.oc.indent()
		self.oc.write("}")
	}
}

fn isCopyOptimizable(&v: &sema::Value): bool {
	if !v.Lvalue {
		ret false
	}
	match type v.Model {
	| &sema::SlicingExpr:
		ret false
	}
	ret true
}

fn isIterCopyOptimizable(&val: &sema::Value, &v: &sema::Var): bool {
	if !val.Lvalue && !val.Type.Mutable() {
		ret true
	}
	ret !v.Mutable && !val.Mutable
}

fn captureVarHandling(mut &oc: &ObjectCoder, mut &m: &sema::AnonFuncExpr, mut &v: &sema::Var): bool {
	for _, cv in m.Captured {
		if cv == v {
			oc.write(closureCtxIdent + ".alloc->")
			identCoder.var(oc.Buf, v)
			ret true
		}
	}
	ret false
}
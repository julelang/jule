// Copyright 2025 The Jule Project Contributors. All rights reserved.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/jule/sema"

// Cache for the FastMemcpy function to avoid repetitive computations.
let mut memcpyCache = map[&sema::StructIns]bool{}

// Reports whether type supports fast memcpy implementation.
fn FastMemcpy(mut t: &sema::Type): (r: bool) {
	// Report false for external types.
	// Because they might be have constructor or etc.
	// The memcpy implementation is a kind of the memcpy function of C.
	// There is no support for constructors, destructors, and other high level things.
	if t.Extern() {
		ret false
	}

	mut arr := t.Array()
	if arr != nil {
		ret FastMemcpy(arr.Value)
	}
	mut s := t.Struct()
	if s != nil {
		ret fastMemcpyStruct(s)
	}

	ret t.Prim() != nil
}

fn fastMemcpyStruct(mut s: &sema::StructIns): (r: bool) {
	// If struct type is empty (no fields), report true.
	// No caching needed.
	if len(s.Fields) == 0 {
		ret true
	}

	// Look to cache before analysis.
	r, ok := memcpyCache[s]
	if ok {
		ret r
	}

	for (_, mut field) in s.Fields {
		if !FastMemcpy(field.Type) {
			r = false
			goto Cache
		}
	}
	r = true

Cache:
	memcpyCache[s] = r

	ret
}
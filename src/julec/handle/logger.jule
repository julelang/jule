// Copyright 2023-2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/conv"
use "std/jule/build"
use "std/strings"

// Logger for compiler logs.
struct Logger{}

impl Logger {
	// Prints flag log.
	static fn LogFlat(&l: build::Log) {
		println(l.Text)
	}

	// Prints error log.
	static fn LogError(&l: build::Log) {
		print(AnsiEscape.RedSeq)
		print("error: ")
		print(l.Text)
		AnsiEscape.Reset()

		if len(l.Path) != 0 {
			print("\n  --> ")
			print(l.Path)
		}
		if l.Row != 0 && l.Column != 0 {
			print(":")
			print(conv::Itoa(l.Row))
			print(":")
			print(conv::Itoa(l.Column))
		}
		if len(l.Line) != 0 {
			// For correct handling, trim leading and trailing space bytes.
			// Also replace tabs with spaces for deterministic size.
			mut line := strings::Trim(l.Line, "\r\n\v\b\t ")
			line = strings::ReplaceAll(line, "\t", " ")

			mut offset := len(l.Line) - len(line) + 1
			print("\n  ")
			row := conv::Itoa(l.Row)
			print(row)
			print(" | ")
			print(line)
			print("\n  ")
			print(strings::Repeat(" ", len(row)))
			print(" | ")
			print(strings::Repeat(" ", l.Column-offset))
			print("^")
			if len(l.Suggestion) != 0 {
				print("\n  ")
				print(strings::Repeat(" ", len(row)))
				print(" | ")
				AnsiEscape.Print(AnsiEscape.BrightMagentaSeq, "suggestion: ")
				print(l.Suggestion)
			}
		}
		println("\n")
	}

	// Log.
	static fn Log(&l: build::Log) {
		match l.Kind {
		| build::LogKind.Flat:
			Logger.LogFlat(l)
		| build::LogKind.Error:
			Logger.LogError(l)
		}
	}

	// Prints all logs.
	static fn PrintLogs(&logs: []build::Log) {
		for _, l in logs {
			Logger.Log(l)
		}
		print("=== ")
		print(conv::Itoa(len(logs)))
		println(" error generated ===")
	}
}